// Data Structures in Blood
// A comprehensive example demonstrating structs, functions,
// and complex program logic - 400+ lines

// ===========================================================================
// Point and Vector Operations
// ===========================================================================

// 2D Point struct
struct Point {
    x: i32,
    y: i32,
}

// Create a point at origin
fn point_origin() -> Point {
    Point { x: 0, y: 0 }
}

// Create a point at specific coordinates
fn point_new(x: i32, y: i32) -> Point {
    Point { x: x, y: y }
}

// Add two points (vector addition)
fn point_add(p1: Point, p2: Point) -> Point {
    Point { x: p1.x + p2.x, y: p1.y + p2.y }
}

// Subtract two points
fn point_sub(p1: Point, p2: Point) -> Point {
    Point { x: p1.x - p2.x, y: p1.y - p2.y }
}

// Scale a point by a factor
fn point_scale(p: Point, factor: i32) -> Point {
    Point { x: p.x * factor, y: p.y * factor }
}

// Manhattan distance from origin
fn point_manhattan(p: Point) -> i32 {
    let mut dx: i32 = p.x;
    let mut dy: i32 = p.y;
    if dx < 0 { dx = 0 - dx; }
    if dy < 0 { dy = 0 - dy; }
    dx + dy
}

// Dot product of two vectors
fn point_dot(p1: Point, p2: Point) -> i32 {
    p1.x * p2.x + p1.y * p2.y
}

// Cross product (2D - returns scalar)
fn point_cross(p1: Point, p2: Point) -> i32 {
    p1.x * p2.y - p1.y * p2.x
}

// Check if two points are equal
fn point_eq(p1: Point, p2: Point) -> bool {
    p1.x == p2.x && p1.y == p2.y
}

// Squared distance between two points
fn point_dist_squared(p1: Point, p2: Point) -> i32 {
    let dx: i32 = p2.x - p1.x;
    let dy: i32 = p2.y - p1.y;
    dx * dx + dy * dy
}

// ===========================================================================
// Complex Number Operations
// ===========================================================================

struct Complex {
    real: i32,
    imag: i32,
}

fn complex_new(real: i32, imag: i32) -> Complex {
    Complex { real: real, imag: imag }
}

fn complex_add(a: Complex, b: Complex) -> Complex {
    Complex { real: a.real + b.real, imag: a.imag + b.imag }
}

fn complex_sub(a: Complex, b: Complex) -> Complex {
    Complex { real: a.real - b.real, imag: a.imag - b.imag }
}

fn complex_mul(a: Complex, b: Complex) -> Complex {
    // (a + bi)(c + di) = (ac - bd) + (ad + bc)i
    Complex {
        real: a.real * b.real - a.imag * b.imag,
        imag: a.real * b.imag + a.imag * b.real,
    }
}

fn complex_magnitude_squared(c: Complex) -> i32 {
    c.real * c.real + c.imag * c.imag
}

fn complex_conjugate(c: Complex) -> Complex {
    Complex { real: c.real, imag: 0 - c.imag }
}

fn complex_eq(a: Complex, b: Complex) -> bool {
    a.real == b.real && a.imag == b.imag
}

// ===========================================================================
// Rectangle Operations
// ===========================================================================

struct Rectangle {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

fn rect_new(x: i32, y: i32, w: i32, h: i32) -> Rectangle {
    Rectangle { x: x, y: y, width: w, height: h }
}

fn rect_area(r: Rectangle) -> i32 {
    r.width * r.height
}

fn rect_perimeter(r: Rectangle) -> i32 {
    2 * (r.width + r.height)
}

fn rect_contains_point(r: Rectangle, px: i32, py: i32) -> bool {
    px >= r.x && px < r.x + r.width &&
    py >= r.y && py < r.y + r.height
}

fn rect_intersects(r1: Rectangle, r2: Rectangle) -> bool {
    r1.x < r2.x + r2.width &&
    r1.x + r1.width > r2.x &&
    r1.y < r2.y + r2.height &&
    r1.y + r1.height > r2.y
}

fn rect_center_x(r: Rectangle) -> i32 {
    r.x + r.width / 2
}

fn rect_center_y(r: Rectangle) -> i32 {
    r.y + r.height / 2
}

// ===========================================================================
// Binary Tree Simulation (using indices as pointers)
// ===========================================================================

// Simulated binary search tree with fixed nodes:
// Tree structure:
//           50 (0)
//          /    \
//        30 (1)  70 (2)
//       /  \    /   \
//     20(3) 40(4) 60(5) 80(6)

fn tree_value(node: i32) -> i32 {
    if node == 0 { 50 }
    else if node == 1 { 30 }
    else if node == 2 { 70 }
    else if node == 3 { 20 }
    else if node == 4 { 40 }
    else if node == 5 { 60 }
    else if node == 6 { 80 }
    else { 0 }
}

fn tree_left(node: i32) -> i32 {
    if node == 0 { 1 }
    else if node == 1 { 3 }
    else if node == 2 { 5 }
    else { -1 }
}

fn tree_right(node: i32) -> i32 {
    if node == 0 { 2 }
    else if node == 1 { 4 }
    else if node == 2 { 6 }
    else { -1 }
}

// Search for a value in BST
fn tree_search(target: i32) -> bool {
    let mut current: i32 = 0;  // Start at root
    let mut found: bool = false;

    while current >= 0 && !found {
        let val: i32 = tree_value(current);
        if target == val {
            found = true;
        } else if target < val {
            current = tree_left(current);
        } else {
            current = tree_right(current);
        }
    }
    found
}

// Count nodes (we have 7 nodes)
fn tree_count_nodes() -> i32 {
    7
}

// Sum all values
fn tree_sum_values() -> i32 {
    tree_value(0) + tree_value(1) + tree_value(2) +
    tree_value(3) + tree_value(4) + tree_value(5) + tree_value(6)
}

// Find minimum (leftmost)
fn tree_min() -> i32 {
    let mut current: i32 = 0;
    while tree_left(current) >= 0 {
        current = tree_left(current);
    }
    tree_value(current)
}

// Find maximum (rightmost)
fn tree_max() -> i32 {
    let mut current: i32 = 0;
    while tree_right(current) >= 0 {
        current = tree_right(current);
    }
    tree_value(current)
}

// Count nodes in left subtree
fn tree_count_left() -> i32 {
    // Nodes 1, 3, 4 are in left subtree
    3
}

// Count nodes in right subtree
fn tree_count_right() -> i32 {
    // Nodes 2, 5, 6 are in right subtree
    3
}

// ===========================================================================
// Matrix Operations (2x2 for simplicity)
// ===========================================================================

struct Matrix2x2 {
    a11: i32, a12: i32,
    a21: i32, a22: i32,
}

fn matrix_identity() -> Matrix2x2 {
    Matrix2x2 { a11: 1, a12: 0, a21: 0, a22: 1 }
}

fn matrix_new(a11: i32, a12: i32, a21: i32, a22: i32) -> Matrix2x2 {
    Matrix2x2 { a11: a11, a12: a12, a21: a21, a22: a22 }
}

fn matrix_add(m1: Matrix2x2, m2: Matrix2x2) -> Matrix2x2 {
    Matrix2x2 {
        a11: m1.a11 + m2.a11, a12: m1.a12 + m2.a12,
        a21: m1.a21 + m2.a21, a22: m1.a22 + m2.a22,
    }
}

fn matrix_mul(m1: Matrix2x2, m2: Matrix2x2) -> Matrix2x2 {
    Matrix2x2 {
        a11: m1.a11 * m2.a11 + m1.a12 * m2.a21,
        a12: m1.a11 * m2.a12 + m1.a12 * m2.a22,
        a21: m1.a21 * m2.a11 + m1.a22 * m2.a21,
        a22: m1.a21 * m2.a12 + m1.a22 * m2.a22,
    }
}

fn matrix_determinant(m: Matrix2x2) -> i32 {
    m.a11 * m.a22 - m.a12 * m.a21
}

fn matrix_trace(m: Matrix2x2) -> i32 {
    m.a11 + m.a22
}

fn matrix_scale(m: Matrix2x2, k: i32) -> Matrix2x2 {
    Matrix2x2 {
        a11: m.a11 * k, a12: m.a12 * k,
        a21: m.a21 * k, a22: m.a22 * k,
    }
}

fn matrix_transpose(m: Matrix2x2) -> Matrix2x2 {
    Matrix2x2 { a11: m.a11, a12: m.a21, a21: m.a12, a22: m.a22 }
}

// ===========================================================================
// Rational Number Operations
// ===========================================================================

struct Rational {
    num: i32,
    den: i32,
}

fn gcd(a: i32, b: i32) -> i32 {
    let mut x: i32 = a;
    let mut y: i32 = b;
    if x < 0 { x = 0 - x; }
    if y < 0 { y = 0 - y; }
    while y != 0 {
        let temp: i32 = y;
        y = x % y;
        x = temp;
    }
    x
}

fn rational_new(num: i32, den: i32) -> Rational {
    let g: i32 = gcd(num, den);
    let mut n: i32 = num / g;
    let mut d: i32 = den / g;
    // Normalize sign
    if d < 0 {
        n = 0 - n;
        d = 0 - d;
    }
    Rational { num: n, den: d }
}

fn rational_add(a: Rational, b: Rational) -> Rational {
    let num: i32 = a.num * b.den + b.num * a.den;
    let den: i32 = a.den * b.den;
    rational_new(num, den)
}

fn rational_sub(a: Rational, b: Rational) -> Rational {
    let num: i32 = a.num * b.den - b.num * a.den;
    let den: i32 = a.den * b.den;
    rational_new(num, den)
}

fn rational_mul(a: Rational, b: Rational) -> Rational {
    rational_new(a.num * b.num, a.den * b.den)
}

fn rational_div(a: Rational, b: Rational) -> Rational {
    rational_new(a.num * b.den, a.den * b.num)
}

fn rational_eq(a: Rational, b: Rational) -> bool {
    a.num == b.num && a.den == b.den
}

// ===========================================================================
// Statistics Functions (simulated arrays)
// ===========================================================================

// Sum of first n natural numbers
fn sum_natural(n: i32) -> i32 {
    n * (n + 1) / 2
}

// Sum of squares of first n natural numbers
fn sum_squares(n: i32) -> i32 {
    n * (n + 1) * (2 * n + 1) / 6
}

// Triangular number
fn triangular(n: i32) -> i32 {
    n * (n + 1) / 2
}

// Compute average of fixed values
fn average_5() -> i32 {
    // Values: 10, 20, 30, 40, 50
    let sum: i32 = 10 + 20 + 30 + 40 + 50;
    sum / 5
}

// Compute variance * 5 (to avoid fractions)
fn variance_5() -> i32 {
    // Values: 10, 20, 30, 40, 50
    // Mean: 30
    // Deviations squared: 400, 100, 0, 100, 400
    // Sum: 1000
    1000
}

// ===========================================================================
// Test Functions
// ===========================================================================

fn test_points() {
    println_str("=== Point Operations ===");

    let p1: Point = point_new(3, 4);
    let p2: Point = point_new(1, 2);
    let sum: Point = point_add(p1, p2);

    print_str("P1: (3, 4), P2: (1, 2)");
    println_str("");
    print_str("Sum: (");
    print_int(sum.x);
    print_str(", ");
    print_int(sum.y);
    println_str(")");

    let p3: Point = point_new(3, 4);
    let manhattan: i32 = point_manhattan(p3);
    print_str("Manhattan distance of (3, 4): ");
    println_int(manhattan);

    let p4: Point = point_new(3, 4);
    let p5: Point = point_new(1, 2);
    let dot: i32 = point_dot(p4, p5);
    print_str("Dot product: ");
    println_int(dot);

    let p6: Point = point_new(3, 4);
    let p7: Point = point_new(1, 2);
    let cross: i32 = point_cross(p6, p7);
    print_str("Cross product: ");
    println_int(cross);

    let p8: Point = point_new(0, 0);
    let p9: Point = point_new(3, 4);
    let dist: i32 = point_dist_squared(p8, p9);
    print_str("Distance squared from origin to (3,4): ");
    println_int(dist);

    println_str("");
}

fn test_complex() {
    println_str("=== Complex Number Operations ===");

    let c1: Complex = complex_new(3, 4);
    let c2: Complex = complex_new(1, 2);

    let sum: Complex = complex_add(c1, c2);
    print_str("(3+4i) + (1+2i) = ");
    print_int(sum.real);
    print_str("+");
    print_int(sum.imag);
    println_str("i");

    let c3: Complex = complex_new(3, 4);
    let c4: Complex = complex_new(1, 2);
    let prod: Complex = complex_mul(c3, c4);
    print_str("(3+4i) * (1+2i) = ");
    print_int(prod.real);
    print_str("+");
    print_int(prod.imag);
    println_str("i");
    println_str("(Expected: -5+10i)");

    let c5: Complex = complex_new(3, 4);
    let mag: i32 = complex_magnitude_squared(c5);
    print_str("|3+4i|^2 = ");
    println_int(mag);
    println_str("(Expected: 25)");

    let c6: Complex = complex_new(3, 4);
    let conj: Complex = complex_conjugate(c6);
    print_str("Conjugate of 3+4i: ");
    print_int(conj.real);
    print_str("+");
    print_int(conj.imag);
    println_str("i");

    println_str("");
}

fn test_rectangles() {
    println_str("=== Rectangle Operations ===");

    let r1: Rectangle = rect_new(0, 0, 10, 5);
    print_str("Rectangle (0,0) 10x5:");
    println_str("");

    let r2: Rectangle = rect_new(0, 0, 10, 5);
    print_str("  Area: ");
    println_int(rect_area(r2));

    let r3: Rectangle = rect_new(0, 0, 10, 5);
    print_str("  Perimeter: ");
    println_int(rect_perimeter(r3));

    let r4: Rectangle = rect_new(0, 0, 10, 5);
    print_str("  Contains (5, 2): ");
    if rect_contains_point(r4, 5, 2) {
        println_str("yes");
    } else {
        println_str("no");
    }

    let r5: Rectangle = rect_new(0, 0, 10, 5);
    print_str("  Contains (15, 2): ");
    if rect_contains_point(r5, 15, 2) {
        println_str("yes");
    } else {
        println_str("no");
    }

    let r6: Rectangle = rect_new(0, 0, 10, 5);
    let r7: Rectangle = rect_new(5, 2, 10, 10);
    print_str("  Intersects (5,2) 10x10: ");
    if rect_intersects(r6, r7) {
        println_str("yes");
    } else {
        println_str("no");
    }

    println_str("");
}

fn test_tree() {
    println_str("=== Binary Search Tree ===");

    print_str("Tree structure: 50 -> (30, 70) -> (20, 40, 60, 80)");
    println_str("");

    print_str("Node count: ");
    println_int(tree_count_nodes());

    print_str("Sum of all values: ");
    println_int(tree_sum_values());
    println_str("(Expected: 350)");

    print_str("Minimum value: ");
    println_int(tree_min());
    println_str("(Expected: 20)");

    print_str("Maximum value: ");
    println_int(tree_max());
    println_str("(Expected: 80)");

    print_str("Search for 40: ");
    if tree_search(40) { println_str("FOUND"); } else { println_str("NOT FOUND"); }

    print_str("Search for 45: ");
    if tree_search(45) { println_str("FOUND"); } else { println_str("NOT FOUND"); }

    print_str("Search for 80: ");
    if tree_search(80) { println_str("FOUND"); } else { println_str("NOT FOUND"); }

    print_str("Search for 25: ");
    if tree_search(25) { println_str("FOUND"); } else { println_str("NOT FOUND"); }

    println_str("");
}

fn test_matrices() {
    println_str("=== Matrix Operations ===");

    let m1: Matrix2x2 = matrix_new(1, 2, 3, 4);
    print_str("Matrix M1: [[1,2],[3,4]]");
    println_str("");

    let m2: Matrix2x2 = matrix_new(1, 2, 3, 4);
    print_str("Determinant: ");
    println_int(matrix_determinant(m2));
    println_str("(Expected: -2)");

    let m3: Matrix2x2 = matrix_new(1, 2, 3, 4);
    print_str("Trace: ");
    println_int(matrix_trace(m3));
    println_str("(Expected: 5)");

    let m4: Matrix2x2 = matrix_new(1, 2, 3, 4);
    let m5: Matrix2x2 = matrix_new(5, 6, 7, 8);
    let sum: Matrix2x2 = matrix_add(m4, m5);
    print_str("M1 + [[5,6],[7,8]] = [[");
    print_int(sum.a11);
    print_str(",");
    print_int(sum.a12);
    print_str("],[");
    print_int(sum.a21);
    print_str(",");
    print_int(sum.a22);
    println_str("]]");

    let m6: Matrix2x2 = matrix_new(1, 2, 3, 4);
    let m7: Matrix2x2 = matrix_new(5, 6, 7, 8);
    let prod: Matrix2x2 = matrix_mul(m6, m7);
    print_str("M1 * [[5,6],[7,8]] = [[");
    print_int(prod.a11);
    print_str(",");
    print_int(prod.a12);
    print_str("],[");
    print_int(prod.a21);
    print_str(",");
    print_int(prod.a22);
    println_str("]]");
    println_str("(Expected: [[19,22],[43,50]])");

    println_str("");
}

fn test_rationals() {
    println_str("=== Rational Number Operations ===");

    let r1: Rational = rational_new(1, 2);
    let r2: Rational = rational_new(1, 3);

    print_str("1/2 + 1/3 = ");
    let sum: Rational = rational_add(r1, r2);
    print_int(sum.num);
    print_str("/");
    println_int(sum.den);
    println_str("(Expected: 5/6)");

    let r3: Rational = rational_new(3, 4);
    let r4: Rational = rational_new(2, 3);
    let prod: Rational = rational_mul(r3, r4);
    print_str("3/4 * 2/3 = ");
    print_int(prod.num);
    print_str("/");
    println_int(prod.den);
    println_str("(Expected: 1/2)");

    let r5: Rational = rational_new(6, 8);
    print_str("6/8 simplified = ");
    print_int(r5.num);
    print_str("/");
    println_int(r5.den);
    println_str("(Expected: 3/4)");

    println_str("");
}

fn test_statistics() {
    println_str("=== Statistics Operations ===");

    print_str("Sum of 1 to 10: ");
    println_int(sum_natural(10));
    println_str("(Expected: 55)");

    print_str("Sum of squares 1 to 5: ");
    println_int(sum_squares(5));
    println_str("(Expected: 55)");

    print_str("10th triangular number: ");
    println_int(triangular(10));
    println_str("(Expected: 55)");

    print_str("Average of [10,20,30,40,50]: ");
    println_int(average_5());
    println_str("(Expected: 30)");

    println_str("");
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("======================================================");
    println_str("  Blood Data Structures Demonstration");
    println_str("  Points, Complex Numbers, Rectangles, Trees, Matrices");
    println_str("======================================================");
    println_str("");

    test_points();
    test_complex();
    test_rectangles();
    test_tree();
    test_matrices();
    test_rationals();
    test_statistics();

    println_str("=== All tests completed successfully! ===");
}
