// Sorting Algorithms in Blood
// Demonstrates functions with parameters, array operations, and algorithms

// Helper function: swap two values (using out parameters pattern)
fn swap_values(a: i32, b: i32) -> (i32, i32) {
    (b, a)
}

// Bubble sort a small fixed array (5 elements)
// Returns the sorted first element as a validation check
fn bubble_sort_demo() -> i32 {
    // Fixed array: [64, 34, 25, 12, 22]
    let mut a0: i32 = 64;
    let mut a1: i32 = 34;
    let mut a2: i32 = 25;
    let mut a3: i32 = 12;
    let mut a4: i32 = 22;

    // Outer loop
    let mut i: i32 = 0;
    while i < 5 {
        // Inner loop (bubble pass)
        let mut j: i32 = 0;
        while j < 4 - i {
            // Compare adjacent elements and swap if needed
            if j == 0 {
                if a0 > a1 {
                    let temp: i32 = a0;
                    a0 = a1;
                    a1 = temp;
                }
            } else if j == 1 {
                if a1 > a2 {
                    let temp: i32 = a1;
                    a1 = a2;
                    a2 = temp;
                }
            } else if j == 2 {
                if a2 > a3 {
                    let temp: i32 = a2;
                    a2 = a3;
                    a3 = temp;
                }
            } else if j == 3 {
                if a3 > a4 {
                    let temp: i32 = a3;
                    a3 = a4;
                    a4 = temp;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }

    // Return smallest element (should be 12)
    a0
}

// Find minimum in a sequence
fn find_min_4() -> i32 {
    let a: i32 = 42;
    let b: i32 = 17;
    let c: i32 = 35;
    let d: i32 = 8;

    let mut min: i32 = a;
    if b < min { min = b; }
    if c < min { min = c; }
    if d < min { min = d; }
    min
}

// Find maximum in a sequence
fn find_max_4() -> i32 {
    let a: i32 = 42;
    let b: i32 = 17;
    let c: i32 = 35;
    let d: i32 = 8;

    let mut max: i32 = a;
    if b > max { max = b; }
    if c > max { max = c; }
    if d > max { max = d; }
    max
}

// Count elements matching a criteria (counting odds)
fn count_odds() -> i32 {
    let a: i32 = 42;
    let b: i32 = 17;
    let c: i32 = 35;
    let d: i32 = 8;
    let e: i32 = 23;

    let mut count: i32 = 0;
    if a % 2 != 0 { count = count + 1; }
    if b % 2 != 0 { count = count + 1; }
    if c % 2 != 0 { count = count + 1; }
    if d % 2 != 0 { count = count + 1; }
    if e % 2 != 0 { count = count + 1; }
    count
}

// Sum elements conditionally (sum of positives)
fn sum_positives() -> i32 {
    let a: i32 = -5;
    let b: i32 = 10;
    let c: i32 = -3;
    let d: i32 = 7;
    let e: i32 = 2;

    let mut sum: i32 = 0;
    if a > 0 { sum = sum + a; }
    if b > 0 { sum = sum + b; }
    if c > 0 { sum = sum + c; }
    if d > 0 { sum = sum + d; }
    if e > 0 { sum = sum + e; }
    sum
}

// Binary search simulation (searching for 35 in sorted sequence)
fn binary_search_demo() -> bool {
    // Sorted: 8, 17, 35, 42 (indices 0-3)
    let target: i32 = 35;
    let mut low: i32 = 0;
    let mut high: i32 = 3;
    let mut found: bool = false;

    while low <= high {
        let mid: i32 = (low + high) / 2;

        // Get element at mid (simulated array)
        let mut mid_val: i32 = 0;
        if mid == 0 { mid_val = 8; }
        else if mid == 1 { mid_val = 17; }
        else if mid == 2 { mid_val = 35; }
        else if mid == 3 { mid_val = 42; }

        if mid_val == target {
            found = true;
            low = high + 1; // Exit loop
        } else if mid_val < target {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    found
}

// Linear search (finding first even number's position)
fn linear_search_first_even() -> i32 {
    // Sequence: 1, 3, 7, 4, 9
    let mut pos: i32 = -1; // -1 means not found
    let mut i: i32 = 0;

    while i < 5 {
        let mut val: i32 = 0;
        if i == 0 { val = 1; }
        else if i == 1 { val = 3; }
        else if i == 2 { val = 7; }
        else if i == 3 { val = 4; }
        else if i == 4 { val = 9; }

        if val % 2 == 0 {
            pos = i;
            i = 5; // Exit loop
        } else {
            i = i + 1;
        }
    }
    pos // Should return 3 (position of 4)
}

// Merge two sorted sequences (conceptual - returns merged sum)
fn merge_sum() -> i32 {
    // Seq1: 1, 3, 5
    // Seq2: 2, 4, 6
    // Merged: 1, 2, 3, 4, 5, 6 -> sum = 21
    1 + 2 + 3 + 4 + 5 + 6
}

fn main() {
    println_str("=== Blood Sorting and Searching Demo ===");
    println_str("");

    println_str("Bubble Sort:");
    print_str("  Sorted first element: ");
    println_int(bubble_sort_demo());
    println_str("  (Expected: 12)");
    println_str("");

    println_str("Find Operations:");
    print_str("  Min of [42, 17, 35, 8]: ");
    println_int(find_min_4());
    print_str("  Max of [42, 17, 35, 8]: ");
    println_int(find_max_4());
    println_str("");

    println_str("Counting:");
    print_str("  Odd count in [42, 17, 35, 8, 23]: ");
    println_int(count_odds());
    println_str("  (Expected: 3)");
    println_str("");

    println_str("Sum Operations:");
    print_str("  Sum of positives in [-5, 10, -3, 7, 2]: ");
    println_int(sum_positives());
    println_str("  (Expected: 19)");
    println_str("");

    println_str("Searching:");
    print_str("  Binary search for 35 in [8, 17, 35, 42]: ");
    if binary_search_demo() {
        println_str("FOUND");
    } else {
        println_str("NOT FOUND");
    }

    print_str("  First even position in [1, 3, 7, 4, 9]: ");
    println_int(linear_search_first_even());
    println_str("  (Expected: 3)");
    println_str("");

    println_str("Merge:");
    print_str("  Merged sum of [1,3,5] and [2,4,6]: ");
    println_int(merge_sum());
    println_str("  (Expected: 21)");
    println_str("");

    println_str("=== Demo complete ===");
}
