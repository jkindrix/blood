---
source: bloodc/tests/codegen_regression.rs
expression: ir
---
; ModuleID = 'blood_program'

declare double @parse_f64({ ptr, i64 })

declare double @ptr_read_f64(i64)

declare i1 @file_append_string({ ptr, i64 }, { ptr, i64 })

declare i1 @file_delete({ ptr, i64 })

declare i1 @file_exists({ ptr, i64 })

declare i1 @file_write_string({ ptr, i64 }, { ptr, i64 })

declare i1 @str_eq({ ptr, i64 }, { ptr, i64 })

declare i32 @args_count()

declare i32 @blood_alloc(i64, ptr, ptr)

declare i32 @blood_check_generation(i32, i32)

declare i32 @blood_get_generation(i64)

declare i32 @blood_region_exit_scope(i64)

declare i32 @blood_region_is_pending_deallocation(i64)

declare i32 @blood_region_is_suspended(i64)

declare i32 @blood_region_resume(i64)

declare i32 @blood_region_suspend(i64)

declare i32 @blood_register_allocation(i64, i64)

declare i32 @blood_runtime_init()

declare i32 @blood_scheduler_init(i64)

declare i32 @blood_scheduler_is_running()

declare i32 @blood_scheduler_run_background()

declare i32 @blood_validate_generation(i64, i32)

declare i32 @char_from_u32(i32)

declare i32 @i64_to_i32(i64)

declare i32 @option_is_none(ptr)

declare i32 @option_is_some(ptr)

declare i32 @option_try(ptr, i64, ptr)

declare i32 @ptr_read_i32(i64)

declare i32 @read_int()

declare i32 @result_is_err(ptr)

declare i32 @result_is_ok(ptr)

declare i32 @result_try(ptr, i64, ptr)

declare i32 @string_contains(ptr, ptr)

declare i32 @string_ends_with(ptr, ptr)

declare i32 @string_is_empty(ptr)

declare i32 @string_starts_with(ptr, ptr)

declare i32 @system({ ptr, i64 })

declare i32 @vec_contains(ptr, ptr, i64)

declare i32 @vec_get(ptr, i64, i64, ptr)

declare i32 @vec_is_empty(ptr)

declare i32 @vec_pop(ptr, i64, ptr)

declare i64 @blood_alloc_or_abort(i64, ptr)

declare i64 @blood_alloc_simple(i64)

declare i64 @blood_continuation_resume_with_regions(i64, i64)

declare i64 @blood_continuation_take_suspended_regions(i64, ptr, i64)

declare i64 @blood_effect_context_get_snapshot()

declare i64 @blood_effect_context_take_snapshot()

declare i64 @blood_evidence_get(ptr, i64)

declare i64 @blood_evidence_pop(ptr)

declare i64 @blood_fiber_create()

declare i64 @blood_fiber_suspend()

declare i64 @blood_get_type_tag(ptr)

declare i64 @blood_handler_depth(i64)

declare i64 @blood_memcpy(i64, i64, i64)

declare i64 @blood_perform(i64, i32, ptr, i64, i64)

declare i64 @blood_realloc(i64, i64)

declare i64 @blood_region_alloc(i64, i64, i64)

declare i64 @blood_region_create(i64, i64)

declare i64 @blood_region_used(i64)

declare i64 @blood_scheduler_active_fibers()

declare i64 @blood_scheduler_runnable_fibers()

declare i64 @blood_scheduler_spawn(ptr, ptr)

declare i64 @blood_scheduler_spawn_simple(ptr)

declare i64 @blood_snapshot_create()

declare i64 @blood_snapshot_len(i64)

declare i64 @blood_snapshot_validate(i64)

declare i64 @blood_thread_join(i64)

declare i64 @blood_thread_spawn(i64, i64)

declare i64 @i32_to_i64(i32)

declare i64 @parse_i64_radix({ ptr, i64 }, i32)

declare i64 @ptr_read_i64(i64)

declare i64 @ptr_read_u64(i64)

declare i64 @size_of_bool()

declare i64 @size_of_i32()

declare i64 @size_of_i64()

declare i64 @str_len({ ptr, i64 })

declare i64 @str_len_chars(ptr)

declare i64 @str_len_usize(ptr)

declare i64 @string_len(ptr)

declare i64 @string_len_chars(ptr)

declare i64 @vec_capacity(ptr)

declare i64 @vec_len(ptr)

declare i8 @ptr_read_u8(i64)

declare ptr @blood_dispatch_lookup(i64, i64)

declare ptr @blood_evidence_create()

declare ptr @blood_evidence_current()

declare ptr @blood_evidence_get_state(ptr, i64)

declare ptr @box_as_mut(ptr)

declare ptr @box_as_ref(ptr)

declare ptr @box_from_raw(ptr)

declare ptr @box_into_raw(ptr)

declare ptr @box_leak(ptr)

declare ptr @box_new(ptr, i64)

declare ptr @vec_get_ptr(ptr, i64, i64)

declare void @blood_assert(i32)

declare void @blood_assert_eq_bool(i1, i1)

declare void @blood_assert_eq_int(i32, i32)

declare void @blood_continuation_add_suspended_region(i64, i64)

declare void @blood_dispatch_register(i64, i64, ptr)

declare void @blood_effect_context_set_snapshot(i64)

declare void @blood_evidence_destroy(ptr)

declare void @blood_evidence_push(ptr, i64)

declare void @blood_evidence_register(ptr, i64, ptr, i64)

declare void @blood_evidence_set_state(ptr, ptr)

declare void @blood_fiber_resume(i64, i64)

declare void @blood_free(i64, i64)

declare void @blood_free_simple(i64)

declare void @blood_increment_generation(ptr)

declare void @blood_panic(ptr)

declare void @blood_region_activate(i64)

declare void @blood_region_deactivate()

declare void @blood_region_destroy(i64)

declare void @blood_runtime_shutdown()

declare void @blood_scheduler_run()

declare void @blood_scheduler_shutdown()

declare void @blood_scheduler_wait()

declare void @blood_scheduler_yield()

declare void @blood_snapshot_add_entry(i64, i64, i32)

declare void @blood_snapshot_destroy(i64)

declare void @blood_snapshot_stale_panic(i64, i64)

declare void @blood_stale_reference_panic(i32, i32)

declare void @blood_unregister_allocation(i64)

declare void @box_free(ptr, i64)

declare void @box_into_inner(ptr, i64, ptr)

declare void @debug_read_enum_at(ptr)

declare void @debug_vec_index(i64, i64)

declare void @debug_vec_ptrs(ptr, ptr)

declare void @eprint_str({ ptr, i64 })

declare void @eprintln_str({ ptr, i64 })

declare void @option_and(ptr, ptr, i64, ptr)

declare void @option_as_mut(ptr, i64, ptr)

declare void @option_as_ref(ptr, i64, ptr)

declare void @option_expect(ptr, i64, ptr, i64, ptr)

declare void @option_ok_or(ptr, i64, ptr, i64, ptr)

declare void @option_or(ptr, ptr, i64, ptr)

declare void @option_replace(ptr, ptr, i64, ptr)

declare void @option_take(ptr, i64, ptr)

declare void @option_unwrap(ptr, i64, ptr)

declare void @option_unwrap_or(ptr, i64, ptr, ptr)

declare void @option_xor(ptr, ptr, i64, ptr)

declare void @panic({ ptr, i64 })

declare void @print_bool(i1)

declare void @print_char(i32)

declare void @print_f32(float)

declare void @print_f32_prec(float, i32)

declare void @print_f64(double)

declare void @print_f64_prec(double, i32)

declare void @print_i64(i64)

declare void @print_int(i32)

declare void @print_newline()

declare void @print_str({ ptr, i64 })

declare void @print_u64(i64)

declare void @println()

declare void @println_bool(i1)

declare void @println_char(i32)

declare void @println_f32(float)

declare void @println_f32_prec(float, i32)

declare void @println_f64(double)

declare void @println_f64_prec(double, i32)

declare void @println_i64(i64)

declare void @println_int(i32)

declare void @println_str({ ptr, i64 })

declare void @println_u64(i64)

declare void @ptr_write_f64(i64, double)

declare void @ptr_write_i32(i64, i32)

declare void @ptr_write_i64(i64, i64)

declare void @ptr_write_u64(i64, i64)

declare void @ptr_write_u8(i64, i8)

declare void @result_and(ptr, ptr, i64, i64, ptr)

declare void @result_as_mut(ptr, i64, i64, ptr)

declare void @result_as_ref(ptr, i64, i64, ptr)

declare void @result_err(ptr, i64, ptr)

declare void @result_expect(ptr, i64, ptr, i64, ptr)

declare void @result_expect_err(ptr, i64, ptr, i64, ptr)

declare void @result_ok(ptr, i64, ptr)

declare void @result_or(ptr, ptr, i64, i64, ptr)

declare void @result_unwrap(ptr, i64, ptr)

declare void @result_unwrap_err(ptr, i64, ptr)

declare void @result_unwrap_or(ptr, i64, ptr, ptr)

declare void @str_to_string(ptr, ptr)

declare void @string_clear(ptr)

declare void @string_find(ptr, ptr, ptr)

declare void @string_new(ptr)

declare void @string_push(ptr, i32)

declare void @string_push_str(ptr, ptr)

declare void @string_rfind(ptr, ptr, ptr)

declare void @string_substring(ptr, i64, i64, ptr)

declare void @vec_clear(ptr)

declare void @vec_first(ptr, i64, ptr)

declare void @vec_free(ptr, i64)

declare void @vec_last(ptr, i64, ptr)

declare void @vec_new(i64, ptr)

declare void @vec_push(ptr, ptr, i64)

declare void @vec_reverse(ptr, i64)

declare void @vec_with_capacity(i64, i64, ptr)

declare { i32, i32 } @str_char_at(ptr, i64)

declare { i32, i32 } @str_char_at_index(ptr, i64)

declare { i32, i32 } @string_char_at(ptr, i64)

declare { ptr, i64 } @args_get(i32)

declare { ptr, i64 } @blood_str_concat({ ptr, i64 }, { ptr, i64 })

declare { ptr, i64 } @bool_to_string(i1)

declare { ptr, i64 } @char_to_string(i32)

declare { ptr, i64 } @f32_to_string(float)

declare { ptr, i64 } @f64_to_string(double)

declare { ptr, i64 } @file_read_to_string({ ptr, i64 })

declare { ptr, i64 } @i128_to_string(i128)

declare { ptr, i64 } @i16_to_string(i16)

declare { ptr, i64 } @i64_to_string(i64)

declare { ptr, i64 } @i8_to_string(i8)

declare { ptr, i64 } @int_to_string(i32)

declare { ptr, i64 } @read_line()

declare { ptr, i64 } @str_as_bytes(ptr)

declare { ptr, i64 } @string_as_bytes(ptr)

declare { ptr, i64 } @string_as_str(ptr)

declare { ptr, i64 } @string_trim(ptr)

declare { ptr, i64 } @string_trim_end(ptr)

declare { ptr, i64 } @string_trim_start(ptr)

declare { ptr, i64 } @u128_to_string(i128)

declare { ptr, i64 } @u16_to_string(i16)

declare { ptr, i64 } @u32_to_string(i32)

declare { ptr, i64 } @u64_to_string(i64)

declare { ptr, i64 } @u8_to_string(i8)

define i32 @blood_main() {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_gen = alloca i32, align 4
  store i32 0, ptr %_1_gen, align 4
  %_1_addr = call i64 @blood_alloc_or_abort(i64 8, ptr %_1_gen)
  %_1_ptr = inttoptr i64 %_1_addr to ptr
  %_2_gen = alloca i32, align 4
  store i32 0, ptr %_2_gen, align 4
  %_2_addr = call i64 @blood_alloc_or_abort(i64 8, ptr %_2_gen)
  %_2_ptr = inttoptr i64 %_2_addr to ptr
  %_3_stack = alloca i32, align 4
  store { i32, i32 } { i32 3, i32 4 }, ptr %_2_ptr, align 4
  %load = load { i32, i32 }, ptr %_2_ptr, align 4
  store { i32, i32 } %load, ptr %_1_ptr, align 4
  %load1 = load { i32, i32 }, ptr %_1_ptr, align 4
  %call_result = call i32 @"blood$manhattan$D_Point"({ i32, i32 } %load1)
  store i32 %call_result, ptr %_3_stack, align 4
  br label %bb1

bb1:                                              ; preds = %bb0
  %load2 = load i32, ptr %_3_stack, align 4
  store i32 %load2, ptr %_0_stack, align 4
  %ret_val = load i32, ptr %_0_stack, align 4
  ret i32 %ret_val
}

define weak_odr i32 @"blood$manhattan$D_Point"({ i32, i32 } %0) {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_gen = alloca i32, align 4
  store i32 0, ptr %_1_gen, align 4
  %_1_addr = call i64 @blood_alloc_or_abort(i64 8, ptr %_1_gen)
  %_1_ptr = inttoptr i64 %_1_addr to ptr
  %_2_stack = alloca i32, align 4
  %_3_stack = alloca i32, align 4
  %_4_stack = alloca i32, align 4
  store { i32, i32 } %0, ptr %_1_ptr, align 4
  %field_0 = getelementptr inbounds { i32, i32 }, ptr %_1_ptr, i32 0, i32 0
  %load = load i32, ptr %field_0, align 4
  store i32 %load, ptr %_2_stack, align 4
  %field_1 = getelementptr inbounds { i32, i32 }, ptr %_1_ptr, i32 0, i32 1
  %load1 = load i32, ptr %field_1, align 4
  store i32 %load1, ptr %_3_stack, align 4
  %load2 = load i32, ptr %_2_stack, align 4
  %load3 = load i32, ptr %_3_stack, align 4
  %add = add i32 %load2, %load3
  store i32 %add, ptr %_4_stack, align 4
  %load4 = load i32, ptr %_4_stack, align 4
  store i32 %load4, ptr %_0_stack, align 4
  %ret_val = load i32, ptr %_0_stack, align 4
  ret i32 %ret_val
}
