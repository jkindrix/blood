---
source: bloodc/tests/codegen_regression.rs
expression: ir
---
; ModuleID = 'blood_program'

@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__blood_register_handlers, ptr null }]

declare double @parse_f64({ ptr, i64 })

declare double @ptr_read_f64(i64)

declare i1 @file_append_string({ ptr, i64 }, { ptr, i64 })

declare i1 @file_delete({ ptr, i64 })

declare i1 @file_exists({ ptr, i64 })

declare i1 @file_write_string({ ptr, i64 }, { ptr, i64 })

declare i1 @str_eq({ ptr, i64 }, { ptr, i64 })

declare i32 @args_count()

declare i32 @blood_alloc(i64, ptr, ptr)

declare i32 @blood_check_generation(i32, i32)

declare i32 @blood_get_generation(i64)

declare i32 @blood_region_exit_scope(i64)

declare i32 @blood_region_is_pending_deallocation(i64)

declare i32 @blood_region_is_suspended(i64)

declare i32 @blood_region_resume(i64)

declare i32 @blood_region_suspend(i64)

declare i32 @blood_register_allocation(i64, i64)

declare i32 @blood_runtime_init()

declare i32 @blood_scheduler_init(i64)

declare i32 @blood_scheduler_is_running()

declare i32 @blood_scheduler_run_background()

declare i32 @blood_validate_generation(i64, i32)

declare i32 @char_from_u32(i32)

declare i32 @i64_to_i32(i64)

declare i32 @option_is_none(ptr)

declare i32 @option_is_some(ptr)

declare i32 @option_try(ptr, i64, ptr)

declare i32 @ptr_read_i32(i64)

declare i32 @read_int()

declare i32 @result_is_err(ptr)

declare i32 @result_is_ok(ptr)

declare i32 @result_try(ptr, i64, ptr)

declare i32 @string_contains(ptr, ptr)

declare i32 @string_ends_with(ptr, ptr)

declare i32 @string_is_empty(ptr)

declare i32 @string_starts_with(ptr, ptr)

declare i32 @system({ ptr, i64 })

declare i32 @vec_contains(ptr, ptr, i64)

declare i32 @vec_get(ptr, i64, i64, ptr)

declare i32 @vec_is_empty(ptr)

declare i32 @vec_pop(ptr, i64, ptr)

declare i64 @blood_alloc_or_abort(i64, ptr)

declare i64 @blood_alloc_simple(i64)

declare i64 @blood_clock_millis()

declare i64 @blood_clock_nanos()

declare i64 @blood_continuation_create_multishot(ptr, ptr)

declare i64 @blood_continuation_resume(i64, i64)

declare i64 @blood_continuation_resume_with_regions(i64, i64)

declare i64 @blood_continuation_take_suspended_regions(i64, ptr, i64)

declare i64 @blood_effect_context_get_snapshot()

declare i64 @blood_effect_context_take_snapshot()

declare i64 @blood_evidence_get(ptr, i64)

declare i64 @blood_evidence_pop(ptr)

declare i64 @blood_fiber_create()

declare i64 @blood_fiber_suspend()

declare i64 @blood_get_type_tag(ptr)

declare i64 @blood_handler_depth(i64)

declare i64 @blood_memcpy(i64, i64, i64)

declare i64 @blood_perform(i64, i32, ptr, i64, i64)

declare i64 @blood_realloc(i64, i64)

declare i64 @blood_region_alloc(i64, i64, i64)

declare i64 @blood_region_create(i64, i64)

declare i64 @blood_region_used(i64)

declare i64 @blood_scheduler_active_fibers()

declare i64 @blood_scheduler_runnable_fibers()

declare i64 @blood_scheduler_spawn(ptr, ptr)

declare i64 @blood_scheduler_spawn_simple(ptr)

declare i64 @blood_snapshot_create()

declare i64 @blood_snapshot_len(i64)

declare i64 @blood_snapshot_validate(i64)

declare i64 @blood_thread_join(i64)

declare i64 @blood_thread_spawn(i64, i64)

declare i64 @i32_to_i64(i32)

declare i64 @parse_i64_radix({ ptr, i64 }, i32)

declare i64 @ptr_read_i64(i64)

declare i64 @ptr_read_u64(i64)

declare i64 @size_of_bool()

declare i64 @size_of_i32()

declare i64 @size_of_i64()

declare i64 @str_len({ ptr, i64 })

declare i64 @str_len_chars(ptr)

declare i64 @str_len_usize(ptr)

declare i64 @string_len(ptr)

declare i64 @string_len_chars(ptr)

declare i64 @vec_capacity(ptr)

declare i64 @vec_len(ptr)

declare i8 @ptr_read_u8(i64)

declare ptr @blood_dispatch_lookup(i64, i64)

declare ptr @blood_evidence_create()

declare ptr @blood_evidence_current()

declare ptr @blood_evidence_get_state(ptr, i64)

declare ptr @box_as_mut(ptr)

declare ptr @box_as_ref(ptr)

declare ptr @box_from_raw(ptr)

declare ptr @box_into_raw(ptr)

declare ptr @box_leak(ptr)

declare ptr @box_new(ptr, i64)

declare ptr @vec_get_ptr(ptr, i64, i64)

declare void @blood_assert(i32)

declare void @blood_assert_eq_bool(i1, i1)

declare void @blood_assert_eq_int(i32, i32)

declare void @blood_continuation_add_suspended_region(i64, i64)

declare void @blood_dispatch_register(i64, i64, ptr)

declare void @blood_effect_context_set_snapshot(i64)

declare void @blood_evidence_clear_inline()

declare void @blood_evidence_destroy(ptr)

declare void @blood_evidence_push(ptr, i64)

declare void @blood_evidence_push_with_state(ptr, i64, ptr)

declare void @blood_evidence_register(ptr, i64, ptr, i64)

declare void @blood_evidence_set_current(ptr)

declare void @blood_evidence_set_state(ptr, ptr)

declare void @blood_fiber_resume(i64, i64)

declare void @blood_free(i64, i64)

declare void @blood_free_simple(i64)

declare void @blood_increment_generation(ptr)

declare void @blood_panic(ptr)

declare void @blood_region_activate(i64)

declare void @blood_region_deactivate()

declare void @blood_region_destroy(i64)

declare void @blood_runtime_shutdown()

declare void @blood_scheduler_run()

declare void @blood_scheduler_shutdown()

declare void @blood_scheduler_wait()

declare void @blood_scheduler_yield()

declare void @blood_snapshot_add_entry(i64, i64, i32)

declare void @blood_snapshot_destroy(i64)

declare void @blood_snapshot_stale_panic(i64, i64)

declare void @blood_stale_reference_panic(i32, i32)

declare void @blood_unregister_allocation(i64)

declare void @box_free(ptr, i64)

declare void @box_into_inner(ptr, i64, ptr)

declare void @debug_read_enum_at(ptr)

declare void @debug_vec_index(i64, i64)

declare void @debug_vec_ptrs(ptr, ptr)

declare void @eprint_str({ ptr, i64 })

declare void @eprintln_str({ ptr, i64 })

declare void @option_and(ptr, ptr, i64, ptr)

declare void @option_as_mut(ptr, i64, ptr)

declare void @option_as_ref(ptr, i64, ptr)

declare void @option_expect(ptr, i64, ptr, i64, ptr)

declare void @option_ok_or(ptr, i64, ptr, i64, ptr)

declare void @option_or(ptr, ptr, i64, ptr)

declare void @option_replace(ptr, ptr, i64, ptr)

declare void @option_take(ptr, i64, ptr)

declare void @option_unwrap(ptr, i64, ptr)

declare void @option_unwrap_or(ptr, i64, ptr, ptr)

declare void @option_xor(ptr, ptr, i64, ptr)

declare void @panic({ ptr, i64 })

declare void @print_bool(i1)

declare void @print_char(i32)

declare void @print_f32(float)

declare void @print_f32_prec(float, i32)

declare void @print_f64(double)

declare void @print_f64_prec(double, i32)

declare void @print_i64(i64)

declare void @print_int(i32)

declare void @print_newline()

declare void @print_str({ ptr, i64 })

declare void @print_u64(i64)

declare void @println()

declare void @println_bool(i1)

declare void @println_char(i32)

declare void @println_f32(float)

declare void @println_f32_prec(float, i32)

declare void @println_f64(double)

declare void @println_f64_prec(double, i32)

declare void @println_i64(i64)

declare void @println_int(i32)

declare void @println_str({ ptr, i64 })

declare void @println_u64(i64)

declare void @ptr_write_f64(i64, double)

declare void @ptr_write_i32(i64, i32)

declare void @ptr_write_i64(i64, i64)

declare void @ptr_write_u64(i64, i64)

declare void @ptr_write_u8(i64, i8)

declare void @result_and(ptr, ptr, i64, i64, ptr)

declare void @result_as_mut(ptr, i64, i64, ptr)

declare void @result_as_ref(ptr, i64, i64, ptr)

declare void @result_err(ptr, i64, ptr)

declare void @result_expect(ptr, i64, ptr, i64, ptr)

declare void @result_expect_err(ptr, i64, ptr, i64, ptr)

declare void @result_ok(ptr, i64, ptr)

declare void @result_or(ptr, ptr, i64, i64, ptr)

declare void @result_unwrap(ptr, i64, ptr)

declare void @result_unwrap_err(ptr, i64, ptr)

declare void @result_unwrap_or(ptr, i64, ptr, ptr)

declare void @str_to_string(ptr, ptr)

declare void @string_clear(ptr)

declare void @string_find(ptr, ptr, ptr)

declare void @string_new(ptr)

declare void @string_push(ptr, i32)

declare void @string_push_str(ptr, ptr)

declare void @string_rfind(ptr, ptr, ptr)

declare void @string_substring(ptr, i64, i64, ptr)

declare void @vec_clear(ptr)

declare void @vec_first(ptr, i64, ptr)

declare void @vec_free(ptr, i64)

declare void @vec_last(ptr, i64, ptr)

declare void @vec_new(i64, ptr)

declare void @vec_push(ptr, ptr, i64)

declare void @vec_reverse(ptr, i64)

declare void @vec_with_capacity(i64, i64, ptr)

declare { i32, i32 } @str_char_at(ptr, i64)

declare { i32, i32 } @str_char_at_index(ptr, i64)

declare { i32, i32 } @string_char_at(ptr, i64)

declare { ptr, i64 } @args_get(i32)

declare { ptr, i64 } @blood_str_concat({ ptr, i64 }, { ptr, i64 })

declare { ptr, i64 } @bool_to_string(i1)

declare { ptr, i64 } @char_to_string(i32)

declare { ptr, i64 } @env_get({ ptr, i64 })

declare { ptr, i64 } @f32_to_string(float)

declare { ptr, i64 } @f64_to_string(double)

declare { ptr, i64 } @file_read_to_string({ ptr, i64 })

declare { ptr, i64 } @i128_to_string(i128)

declare { ptr, i64 } @i16_to_string(i16)

declare { ptr, i64 } @i64_to_string(i64)

declare { ptr, i64 } @i8_to_string(i8)

declare { ptr, i64 } @int_to_string(i32)

declare { ptr, i64 } @read_line()

declare { ptr, i64 } @str_as_bytes(ptr)

declare { ptr, i64 } @string_as_bytes(ptr)

declare { ptr, i64 } @string_as_str(ptr)

declare { ptr, i64 } @string_trim(ptr)

declare { ptr, i64 } @string_trim_end(ptr)

declare { ptr, i64 } @string_trim_start(ptr)

declare { ptr, i64 } @u128_to_string(i128)

declare { ptr, i64 } @u16_to_string(i16)

declare { ptr, i64 } @u32_to_string(i32)

declare { ptr, i64 } @u64_to_string(i64)

declare { ptr, i64 } @u8_to_string(i8)

define i32 @blood_main() {
bb0:
  %_0_stack = alloca i32, align 4
  %_1_stack = alloca i32, align 4
  %_2_stack = alloca { i32 }, align 4
  %_3_stack = alloca { i32 }, align 4
  %_4_stack = alloca i8, align 1
  %_5_stack = alloca i8, align 1
  %_6_stack = alloca i8, align 1
  %_7_stack = alloca i32, align 4
  %_8_stack = alloca i32, align 4
  %_9_stack = alloca i1, align 1
  %_10_stack = alloca i8, align 1
  %_11_stack = alloca i8, align 1
  store { i32 } zeroinitializer, ptr %_2_stack, align 4
  %load = load { i32 }, ptr %_2_stack, align 4
  store { i32 } %load, ptr %_3_stack, align 4
  %current_ev = call ptr @blood_evidence_current()
  %ev_is_null = icmp eq ptr %current_ev, null
  br i1 %ev_is_null, label %region_create_ev, label %region_clone_ev

bb1:                                              ; preds = %region_merge_ev
  call void @"blood$increment"()
  br label %bb2

bb2:                                              ; preds = %bb1
  call void @"blood$increment"()
  br label %bb3

bb3:                                              ; preds = %bb2
  %snapshot = call i64 @blood_snapshot_create()
  %continuation = call i64 @blood_continuation_create_multishot(ptr @__blood_identity_continuation, ptr null)
  %perform_result = call i64 @blood_perform(i64 337, i32 0, ptr null, i64 0, i64 %continuation)
  %perform_trunc = trunc i64 %perform_result to i32
  store i32 %perform_trunc, ptr %_7_stack, align 4
  %validation = call i64 @blood_snapshot_validate(i64 %snapshot)
  call void @blood_snapshot_destroy(i64 %snapshot)
  %is_valid = icmp eq i64 %validation, 0
  br i1 %is_valid, label %snapshot_valid, label %snapshot_stale

bb4:                                              ; preds = %snapshot_valid
  %current_ev1 = call ptr @blood_evidence_current()
  %0 = call i64 @blood_evidence_pop(ptr %current_ev1)
  call void @blood_evidence_clear_inline()
  %load2 = load i32, ptr %_7_stack, align 4
  %result_ext = sext i32 %load2 to i64
  %return_clause_result = call i64 @LocalState_return(i64 %result_ext, ptr %state_shadow)
  %ret_trunc = trunc i64 %return_clause_result to i32
  store i32 %ret_trunc, ptr %_8_stack, align 4
  %load3 = load i32, ptr %_8_stack, align 4
  store i32 %load3, ptr %_1_stack, align 4
  %load4 = load i32, ptr %_1_stack, align 4
  %ne = icmp ne i32 %load4, 3
  store i1 %ne, ptr %_9_stack, align 1
  %load5 = load i1, ptr %_9_stack, align 1
  switch i1 %load5, label %bb6 [
    i1 true, label %bb5
  ]

bb5:                                              ; preds = %bb4
  store i32 1, ptr %_0_stack, align 4
  %ret_val = load i32, ptr %_0_stack, align 4
  ret i32 %ret_val

bb6:                                              ; preds = %bb4
  store i8 0, ptr %_10_stack, align 1
  br label %bb7

bb7:                                              ; preds = %bb8, %bb6
  store i32 0, ptr %_0_stack, align 4
  %ret_val6 = load i32, ptr %_0_stack, align 4
  ret i32 %ret_val6

bb8:                                              ; No predecessors!
  store i8 0, ptr %_11_stack, align 1
  br label %bb7

region_create_ev:                                 ; preds = %bb0
  %new_evidence = call ptr @blood_evidence_create()
  br label %region_merge_ev

region_clone_ev:                                  ; preds = %bb0
  %cloned_evidence = call ptr @blood_evidence_create()
  br label %region_merge_ev

region_merge_ev:                                  ; preds = %region_clone_ev, %region_create_ev
  %evidence = phi ptr [ %new_evidence, %region_create_ev ], [ %cloned_evidence, %region_clone_ev ]
  call void @blood_evidence_set_current(ptr %evidence)
  %state_shadow = alloca { i64 }, align 8
  %state_field_0_ptr = getelementptr inbounds { ptr }, ptr %_3_stack, i32 0, i32 0
  %state_field_0 = load ptr, ptr %state_field_0_ptr, align 8
  %shadow_0_ptr = getelementptr inbounds { i64 }, ptr %state_shadow, i32 0, i32 0
  %state_field_0_ptoi = ptrtoint ptr %state_field_0 to i64
  store i64 %state_field_0_ptoi, ptr %shadow_0_ptr, align 8
  call void @blood_evidence_push_with_state(ptr %evidence, i64 337, ptr %state_shadow)
  call void @"blood$increment"()
  br label %bb1

snapshot_valid:                                   ; preds = %bb3
  br label %bb4

snapshot_stale:                                   ; preds = %bb3
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable
}

define internal i64 @__blood_identity_continuation(i64 %0, ptr %1) {
entry:
  ret i64 %0
}

define linkonce_odr void @__blood_register_handlers() {
entry:
  %handler_ops = alloca [2 x ptr], align 8
  %op_ptr = getelementptr [2 x ptr], ptr %handler_ops, i32 0, i32 0
  store ptr @LocalState_get, ptr %op_ptr, align 8
  %op_ptr1 = getelementptr [2 x ptr], ptr %handler_ops, i32 0, i32 1
  store ptr @LocalState_put, ptr %op_ptr1, align 8
  %ops_ptr = getelementptr [2 x ptr], ptr %handler_ops, i32 0, i32 0
  call void @blood_evidence_register(ptr null, i64 337, ptr %ops_ptr, i64 2)
  ret void
}

define weak_odr i64 @LocalState_get(ptr %0, ptr %1, i64 %2, i64 %3) {
entry:
  %continuation = alloca i64, align 8
  store i64 %3, ptr %continuation, align 8
  %state_ptr = getelementptr inbounds { i64 }, ptr %0, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, ptr %state_ptr, align 8
  store i64 %state_val, ptr %state, align 8
  %resume_placeholder = alloca i64, align 8
  %load = load i64, ptr %state, align 8
  %cont_handle = load i64, ptr %continuation, align 8
  %is_tail = icmp eq i64 %cont_handle, 0
  br i1 %is_tail, label %resume_tail, label %resume_cont

resume_tail:                                      ; preds = %entry
  ret i64 %load

resume_cont:                                      ; preds = %entry
  %cont_result = call i64 @blood_continuation_resume(i64 %cont_handle, i64 %load)
  br label %resume_merge

resume_merge:                                     ; preds = %resume_cont
  %resume_result = phi i64 [ %cont_result, %resume_cont ]
  %resume_trunc = trunc i64 %resume_result to i32
  %state_writeback_ptr = getelementptr inbounds { i64 }, ptr %0, i32 0, i32 0
  %state_writeback_val = load i64, ptr %state, align 8
  store i64 %state_writeback_val, ptr %state_writeback_ptr, align 8
  %ret_ext = sext i32 %resume_trunc to i64
  ret i64 %ret_ext
}

define weak_odr i64 @LocalState_put(ptr %0, ptr %1, i64 %2, i64 %3) {
entry:
  %continuation = alloca i64, align 8
  store i64 %3, ptr %continuation, align 8
  %state_ptr = getelementptr inbounds { i64 }, ptr %0, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, ptr %state_ptr, align 8
  store i64 %state_val, ptr %state, align 8
  %s = alloca i64, align 8
  store i64 0, ptr %s, align 8
  %resume_placeholder = alloca i64, align 8
  %arg_0_ptr = getelementptr i64, ptr %1, i64 0
  %arg_0 = load i64, ptr %arg_0_ptr, align 8
  store i64 %arg_0, ptr %s, align 8
  %load = load i64, ptr %s, align 8
  store i64 %load, ptr %state, align 8
  %cont_handle = load i64, ptr %continuation, align 8
  %is_tail = icmp eq i64 %cont_handle, 0
  br i1 %is_tail, label %resume_tail, label %resume_cont

resume_tail:                                      ; preds = %entry
  ret i64 0

resume_cont:                                      ; preds = %entry
  %cont_result = call i64 @blood_continuation_resume(i64 %cont_handle, i64 0)
  br label %resume_merge

resume_merge:                                     ; preds = %resume_cont
  %resume_result = phi i64 [ %cont_result, %resume_cont ]
  %resume_trunc = trunc i64 %resume_result to i32
  %state_writeback_ptr = getelementptr inbounds { i64 }, ptr %0, i32 0, i32 0
  %state_writeback_val = load i64, ptr %state, align 8
  store i64 %state_writeback_val, ptr %state_writeback_ptr, align 8
  %ret_ext = sext i32 %resume_trunc to i64
  ret i64 %ret_ext
}

define weak_odr i64 @LocalState_return(i64 %0, ptr %1) {
entry:
  %x = alloca i32, align 4
  %ret_trunc = trunc i64 %0 to i32
  store i32 %ret_trunc, ptr %x, align 4
  %state_ptr = getelementptr inbounds { i64 }, ptr %1, i32 0, i32 0
  %state = alloca i64, align 8
  %state_val = load i64, ptr %state_ptr, align 8
  store i64 %state_val, ptr %state, align 8
  %load = load i32, ptr %x, align 4
  %ret_ext = sext i32 %load to i64
  ret i64 %ret_ext
}

define weak_odr void @"blood$increment"() {
bb0:
  %_0_stack = alloca i8, align 1
  %_1_stack = alloca i32, align 4
  %_2_stack = alloca i32, align 4
  %_3_stack = alloca i32, align 4
  %_4_stack = alloca i8, align 1
  %_5_stack = alloca i8, align 1
  %snapshot = call i64 @blood_snapshot_create()
  %continuation = call i64 @blood_continuation_create_multishot(ptr @__blood_identity_continuation, ptr null)
  %perform_result = call i64 @blood_perform(i64 337, i32 0, ptr null, i64 0, i64 %continuation)
  %perform_trunc = trunc i64 %perform_result to i32
  store i32 %perform_trunc, ptr %_2_stack, align 4
  %validation = call i64 @blood_snapshot_validate(i64 %snapshot)
  call void @blood_snapshot_destroy(i64 %snapshot)
  %is_valid = icmp eq i64 %validation, 0
  br i1 %is_valid, label %snapshot_valid, label %snapshot_stale

bb1:                                              ; preds = %snapshot_valid
  %load = load i32, ptr %_2_stack, align 4
  store i32 %load, ptr %_1_stack, align 4
  %load1 = load i32, ptr %_1_stack, align 4
  %add = add i32 %load1, 1
  store i32 %add, ptr %_3_stack, align 4
  %load2 = load i32, ptr %_3_stack, align 4
  %snapshot3 = call i64 @blood_snapshot_create()
  %perform_args = alloca [1 x i64], align 8
  %arg_0 = getelementptr [1 x i64], ptr %perform_args, i64 0, i64 0
  %arg_i64 = zext i32 %load2 to i64
  store i64 %arg_i64, ptr %arg_0, align 8
  %continuation4 = call i64 @blood_continuation_create_multishot(ptr @__blood_identity_continuation, ptr null)
  %perform_result5 = call i64 @blood_perform(i64 337, i32 1, ptr %perform_args, i64 1, i64 %continuation4)
  %validation6 = call i64 @blood_snapshot_validate(i64 %snapshot3)
  call void @blood_snapshot_destroy(i64 %snapshot3)
  %is_valid9 = icmp eq i64 %validation6, 0
  br i1 %is_valid9, label %snapshot_valid7, label %snapshot_stale8

bb2:                                              ; preds = %snapshot_valid7
  store i8 0, ptr %_5_stack, align 1
  %load10 = load i8, ptr %_5_stack, align 1
  store i8 %load10, ptr %_0_stack, align 1
  ret void

snapshot_valid:                                   ; preds = %bb0
  br label %bb1

snapshot_stale:                                   ; preds = %bb0
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable

snapshot_valid7:                                  ; preds = %bb1
  br label %bb2

snapshot_stale8:                                  ; preds = %bb1
  call void @blood_stale_reference_panic(i32 0, i32 0)
  unreachable
}
