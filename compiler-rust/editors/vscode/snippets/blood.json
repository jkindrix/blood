{
  "Function": {
    "prefix": "fn",
    "body": [
      "fn ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "    $0",
      "}"
    ],
    "description": "Function definition"
  },
  "Function with Effects": {
    "prefix": "fneff",
    "body": [
      "fn ${1:name}(${2:params}) -> ${3:ReturnType} with ${4:Effect} {",
      "    $0",
      "}"
    ],
    "description": "Function with effects"
  },
  "Main Function": {
    "prefix": "main",
    "body": [
      "fn main() with IO {",
      "    $0",
      "}"
    ],
    "description": "Main function"
  },
  "Struct": {
    "prefix": "struct",
    "body": [
      "struct ${1:Name} {",
      "    ${2:field}: ${3:Type},",
      "}"
    ],
    "description": "Struct definition"
  },
  "Enum": {
    "prefix": "enum",
    "body": [
      "enum ${1:Name} {",
      "    ${2:Variant},",
      "}"
    ],
    "description": "Enum definition"
  },
  "Trait": {
    "prefix": "trait",
    "body": [
      "trait ${1:Name} {",
      "    fn ${2:method}(&self)${3: -> ReturnType};",
      "}"
    ],
    "description": "Trait definition"
  },
  "Impl": {
    "prefix": "impl",
    "body": [
      "impl ${1:Type} {",
      "    $0",
      "}"
    ],
    "description": "Impl block"
  },
  "Impl Trait": {
    "prefix": "impltrait",
    "body": [
      "impl ${1:Trait} for ${2:Type} {",
      "    $0",
      "}"
    ],
    "description": "Trait implementation"
  },
  "Effect": {
    "prefix": "effect",
    "body": [
      "effect ${1:Name} {",
      "    fn ${2:operation}(${3:params})${4: -> ReturnType};",
      "}"
    ],
    "description": "Effect definition"
  },
  "Handler": {
    "prefix": "handler",
    "body": [
      "handler ${1:Name}: ${2:Effect} {",
      "    fn ${3:operation}(${4:params})${5: -> ReturnType} {",
      "        $0",
      "        resume(())",
      "    }",
      "}"
    ],
    "description": "Handler definition"
  },
  "With Handler": {
    "prefix": "with",
    "body": [
      "with handler ${1:Handler}::new() {",
      "    $0",
      "}"
    ],
    "description": "Handler scope"
  },
  "Do Effect": {
    "prefix": "do",
    "body": "do ${1:Effect}.${2:operation}(${3:args})",
    "description": "Perform effect operation"
  },
  "Match": {
    "prefix": "match",
    "body": [
      "match ${1:value} {",
      "    ${2:Pattern} => ${3:expr},",
      "    _ => ${0:default},",
      "}"
    ],
    "description": "Match expression"
  },
  "If Let": {
    "prefix": "iflet",
    "body": [
      "if let ${1:Pattern} = ${2:expr} {",
      "    $0",
      "}"
    ],
    "description": "If let expression"
  },
  "While Let": {
    "prefix": "whilelet",
    "body": [
      "while let ${1:Pattern} = ${2:expr} {",
      "    $0",
      "}"
    ],
    "description": "While let loop"
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "for ${1:item} in ${2:iter} {",
      "    $0",
      "}"
    ],
    "description": "For loop"
  },
  "Loop": {
    "prefix": "loop",
    "body": [
      "loop {",
      "    $0",
      "}"
    ],
    "description": "Infinite loop"
  },
  "Test Function": {
    "prefix": "test",
    "body": [
      "#[test]",
      "fn test_${1:name}() {",
      "    $0",
      "}"
    ],
    "description": "Test function"
  },
  "Derive": {
    "prefix": "derive",
    "body": "#[derive(${1:Debug, Clone})]",
    "description": "Derive attribute"
  },
  "Doc Comment": {
    "prefix": "///",
    "body": [
      "/// ${1:Description}",
      "///",
      "/// # Examples",
      "///",
      "/// ```",
      "/// $0",
      "/// ```"
    ],
    "description": "Documentation comment"
  },
  "Result Ok": {
    "prefix": "ok",
    "body": "Ok(${1:value})",
    "description": "Ok variant"
  },
  "Result Err": {
    "prefix": "err",
    "body": "Err(${1:error})",
    "description": "Err variant"
  },
  "Option Some": {
    "prefix": "some",
    "body": "Some(${1:value})",
    "description": "Some variant"
  },
  "Option None": {
    "prefix": "none",
    "body": "None",
    "description": "None variant"
  },
  "Println": {
    "prefix": "println",
    "body": "println!(\"${1:{}}\", ${2:value});",
    "description": "Print line"
  },
  "Debug Print": {
    "prefix": "dbg",
    "body": "dbg!(${1:value});",
    "description": "Debug print"
  },
  "Assert Eq": {
    "prefix": "aseq",
    "body": "assert_eq!(${1:left}, ${2:right});",
    "description": "Assert equals"
  },
  "Assert": {
    "prefix": "assert",
    "body": "assert!(${1:condition});",
    "description": "Assert condition"
  },
  "Vec New": {
    "prefix": "vecnew",
    "body": "let ${1:name}: Vec<${2:Type}> = Vec::new();",
    "description": "New vector"
  },
  "Vec Macro": {
    "prefix": "vec",
    "body": "vec![${1:elements}]",
    "description": "Vector macro"
  },
  "HashMap New": {
    "prefix": "hashnew",
    "body": "let ${1:name}: HashMap<${2:K}, ${3:V}> = HashMap::new();",
    "description": "New HashMap"
  },
  "Closure": {
    "prefix": "closure",
    "body": "|${1:params}| ${2:expr}",
    "description": "Closure"
  },
  "Module": {
    "prefix": "mod",
    "body": [
      "mod ${1:name} {",
      "    $0",
      "}"
    ],
    "description": "Module definition"
  },
  "Use": {
    "prefix": "use",
    "body": "use ${1:path};",
    "description": "Use statement"
  },
  "Pub Use": {
    "prefix": "pubuse",
    "body": "pub use ${1:path};",
    "description": "Public re-export"
  }
}
