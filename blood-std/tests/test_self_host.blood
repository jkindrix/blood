// Blood Self-Hosting Integration Tests
//
// These tests verify that the Blood compiler infrastructure can process
// itself, which is a prerequisite for full self-hosting.

use std::compiler::lexer::{tokenize, Token, TokenKind};
use std::compiler::parser::{parse, ParseError};
use std::compiler::ast::{Program, Declaration};

// =============================================================================
// Lexer Self-Tokenization Tests
// =============================================================================

/// Test that the lexer can tokenize a simple Blood function
fn test_lexer_simple_function() {
    let source = "fn main() { let x = 42; }";
    let tokens = tokenize(source.to_string());

    // Should produce tokens for: fn, main, (, ), {, let, x, =, 42, ;, }
    assert(tokens.len() > 0, "lexer should produce tokens");

    // First token should be 'fn' keyword
    assert(tokens[0].kind == TokenKind::Fn, "first token should be fn keyword");
}

/// Test lexer handles module declaration
fn test_lexer_module_declaration() {
    let source = "module std.compiler.lexer";
    let tokens = tokenize(source.to_string());

    assert(tokens.len() > 0, "lexer should tokenize module declaration");
    assert(tokens[0].kind == TokenKind::Module, "first token should be module keyword");
}

/// Test lexer handles use statements
fn test_lexer_use_statement() {
    let source = "use std.collections.Vec";
    let tokens = tokenize(source.to_string());

    assert(tokens.len() > 0, "lexer should tokenize use statement");
    assert(tokens[0].kind == TokenKind::Use, "first token should be use keyword");
}

/// Test lexer handles struct declarations
fn test_lexer_struct_declaration() {
    let source = "pub struct Token { kind: TokenKind, span: Span }";
    let tokens = tokenize(source.to_string());

    assert(tokens.len() > 0, "lexer should tokenize struct");
    assert(tokens[0].kind == TokenKind::Pub, "first token should be pub keyword");
}

// =============================================================================
// Parser Self-Parsing Tests
// =============================================================================

/// Test parser can parse a simple function
fn test_parser_simple_function() {
    let source = "fn main() { let x = 42; }";
    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            assert(program.declarations.len() == 1, "should have one declaration");
            match &program.declarations[0] {
                Declaration::Function(f) => {
                    assert(f.name.name == "main", "function should be named main");
                }
                _ => {
                    assert(false, "declaration should be a function");
                }
            }
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on simple function");
        }
    }
}

/// Test parser can parse struct definition
fn test_parser_struct_definition() {
    let source = "pub struct Point { x: i32, y: i32 }";
    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            assert(program.declarations.len() == 1, "should have one declaration");
            match &program.declarations[0] {
                Declaration::Struct(s) => {
                    assert(s.name.name == "Point", "struct should be named Point");
                }
                _ => {
                    assert(false, "declaration should be a struct");
                }
            }
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on struct definition");
        }
    }
}

/// Test parser can parse enum definition
fn test_parser_enum_definition() {
    let source = "pub enum Option[T] { Some(T), None }";
    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            assert(program.declarations.len() == 1, "should have one declaration");
            match &program.declarations[0] {
                Declaration::Enum(e) => {
                    assert(e.name.name == "Option", "enum should be named Option");
                    assert(e.variants.len() == 2, "Option should have two variants");
                }
                _ => {
                    assert(false, "declaration should be an enum");
                }
            }
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on enum definition");
        }
    }
}

/// Test parser can parse trait definition
fn test_parser_trait_definition() {
    let source = "pub trait Clone { fn clone(self) -> Self; }";
    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            assert(program.declarations.len() == 1, "should have one declaration");
            match &program.declarations[0] {
                Declaration::Trait(t) => {
                    assert(t.name.name == "Clone", "trait should be named Clone");
                }
                _ => {
                    assert(false, "declaration should be a trait");
                }
            }
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on trait definition");
        }
    }
}

/// Test parser can parse impl block
fn test_parser_impl_block() {
    let source = "impl Clone for Point { fn clone(self) -> Self { Point { x: self.x, y: self.y } } }";
    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            assert(program.declarations.len() == 1, "should have one declaration");
            match &program.declarations[0] {
                Declaration::Impl(i) => {
                    // Impl parsed successfully
                }
                _ => {
                    assert(false, "declaration should be an impl");
                }
            }
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on impl block");
        }
    }
}

// =============================================================================
// Combined Pipeline Tests
// =============================================================================

/// Test a complete small program can be parsed
fn test_complete_program() {
    let source = "
        module test

        pub struct Counter {
            value: i32,
        }

        impl Counter {
            pub fn new() -> Counter {
                Counter { value: 0 }
            }

            pub fn increment(mut self) {
                self.value = self.value + 1;
            }

            pub fn get(self) -> i32 {
                self.value
            }
        }

        fn main() {
            let mut c = Counter::new();
            c.increment();
            let v = c.get();
            assert(v == 1, \"counter should be 1\");
        }
    ";

    let result = parse(source.to_string());

    match result {
        Result::Ok(program) => {
            // Module, struct, impl, main function = at least 3 declarations
            assert(program.declarations.len() >= 3, "should have multiple declarations");
            // Note: can't check program.module as 'module' is a reserved keyword
        }
        Result::Err(errors) => {
            assert(false, "parser should succeed on complete program");
        }
    }
}

// =============================================================================
// Test Entry Point
// =============================================================================

/// Run all self-hosting integration tests
pub fn run_tests() {
    // Lexer tests
    test_lexer_simple_function();
    test_lexer_module_declaration();
    test_lexer_use_statement();
    test_lexer_struct_declaration();

    // Parser tests
    test_parser_simple_function();
    test_parser_struct_definition();
    test_parser_enum_definition();
    test_parser_trait_definition();
    test_parser_impl_block();

    // Pipeline tests
    test_complete_program();

    println!("All self-hosting integration tests passed!");
}
