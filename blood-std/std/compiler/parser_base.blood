// Blood Self-Hosted Compiler - Parser Base
//
// This module defines the core Parser struct and fundamental methods.
// Other parser modules use free functions that take &mut Parser.

mod common;
mod token;
mod lexer;
mod ast;

// ============================================================
// Parser Error
// ============================================================

/// Error code for parser diagnostics.
pub enum ErrorCode {
    UnexpectedToken,
    UnexpectedEof,
    UnexpectedCharacter,
    InvalidInteger,
    InvalidFloat,
    ExpectedExpression,
    ExpectedType,
    ExpectedPattern,
    ExpectedIdentifier,
    ExpectedDeclaration,
}

/// A parser diagnostic/error.
pub struct Diagnostic {
    pub message: String,
    pub span: common::Span,
    pub code: ErrorCode,
}

/// Creates a new diagnostic.
pub fn make_diagnostic(message: String, span: common::Span, code: ErrorCode) -> Diagnostic {
    Diagnostic { message: message, span: span, code: code }
}

// ============================================================
// Intern Entry
// ============================================================

/// Interned symbol entry (stores span info for deduplication).
pub struct InternEntry {
    pub start: u32,
    pub end: u32,
}

// ============================================================
// Parser
// ============================================================

/// The Blood parser.
///
/// Fields are public so parsing functions in other modules can access them.
pub struct Parser<'src> {
    /// The lexer producing tokens.
    pub lexer: lexer::Lexer<'src>,
    /// The source text.
    pub source: &'src str,
    /// Current token.
    pub current: token::Token,
    /// Next token (for one-token lookahead).
    pub next: token::Token,
    /// Previous token.
    pub previous: token::Token,
    /// Accumulated errors.
    pub errors: Vec<Diagnostic>,
    /// Whether we're in panic mode (error recovery).
    pub panic_mode: bool,
    /// Interned symbols (stores span info for deduplication).
    pub interned: Vec<InternEntry>,
    /// Whether struct literals are allowed in the current context.
    /// Set to false in condition contexts (if, while, for) to avoid ambiguity.
    pub allow_struct_literal: bool,
    /// Whether a pending '>' remains from splitting a '>>' token.
    /// Used for parsing nested generics like `Option<Vec<T>>`.
    pub pending_gt: bool,
    /// Accumulated doc comment tokens, drained in parse_attributes().
    pub pending_doc_comments: Vec<token::Token>,
}

impl<'src> Parser<'src> {
    /// Create a new parser for the given source.
    pub fn new(source: &'src str) -> Parser<'src> {
        print("[PARSER_NEW] creating lexer...\n");
        let mut lexer = lexer::Lexer::new(source);
        print("[PARSER_NEW] lexer created, getting first token...\n");
        let mut pending_doc_comments: Vec<token::Token> = Vec::new();
        let mut current = lexer.next_token();
        print("[PARSER_NEW] first token obtained\n");
        // Accumulate any leading doc comments
        while current.kind == token::TokenKind::DocComment {
            pending_doc_comments.push(current);
            current = lexer.next_token();
        }
        print("[PARSER_NEW] getting second token...\n");
        let mut next = lexer.next_token();
        print("[PARSER_NEW] second token obtained\n");
        // Accumulate doc comments in lookahead
        while next.kind == token::TokenKind::DocComment {
            pending_doc_comments.push(next);
            next = lexer.next_token();
        }
        print("[PARSER_NEW] building parser struct...\n");

        Parser {
            lexer,
            source,
            current,
            next,
            previous: token::Token::dummy(token::TokenKind::Error),
            errors: Vec::new(),
            panic_mode: false,
            interned: Vec::new(),
            allow_struct_literal: true,
            pending_gt: false,
            pending_doc_comments: pending_doc_comments,
        }
    }

    // ============================================================
    // Token handling
    // ============================================================

    /// Check if the current token matches the given kind.
    pub fn check(self: &Self, kind: token::TokenKind) -> bool {
        self.current.kind == kind
    }

    /// Check if the next token matches the given kind.
    pub fn check_next(self: &Self, kind: token::TokenKind) -> bool {
        self.next.kind == kind
    }

    /// Check if we've reached the end of input.
    pub fn is_at_end(self: &Self) -> bool {
        self.current.kind == token::TokenKind::Eof
    }

    /// Advance to the next token, returning the previous.
    /// Doc comments are automatically skipped.
    pub fn advance(self: &mut Self) -> token::Token {
        self.previous = self.current;
        self.current = self.next;
        self.next = self.lexer.next_token();
        // Accumulate doc comments in lookahead
        while self.next.kind == token::TokenKind::DocComment {
            self.pending_doc_comments.push(self.next);
            self.next = self.lexer.next_token();
        }
        self.previous
    }

    /// Consume a token of the expected kind, or report error.
    pub fn expect(self: &mut Self, kind: token::TokenKind) -> bool {
        if self.check(kind) {
            self.advance();
            true
        } else {
            self.error_expected_kind(kind);
            false
        }
    }

    /// Try to consume a token of the expected kind.
    /// Returns true if consumed, false otherwise.
    pub fn try_consume(self: &mut Self, kind: token::TokenKind) -> bool {
        if self.check(kind) {
            self.advance();
            true
        } else {
            false
        }
    }

    /// Check if current token can be used as an identifier.
    pub fn check_ident(self: &Self) -> bool {
        self.current.kind.can_be_ident()
    }

    // ============================================================
    // Angle bracket helpers (for nested generics like Vec<Option<T>>)
    // ============================================================

    /// Check if we're at a closing angle bracket (handles >> splitting).
    /// Returns true if current token is Gt, or Shr (>>), or pending_gt is set.
    pub fn check_closing_angle(self: &Self) -> bool {
        self.pending_gt || self.current.kind == token::TokenKind::Gt || self.current.kind == token::TokenKind::Shr
    }

    /// Consume a closing angle bracket (handles >> splitting).
    /// For Gt: normal advance. For Shr (>>): advance past token, set pending_gt.
    /// For pending_gt: just clear the flag.
    /// Returns true if successful, false if no closing angle found (reports error).
    pub fn expect_closing_angle(self: &mut Self) -> bool {
        if self.pending_gt {
            self.pending_gt = false;
            self.previous = token::Token { kind: token::TokenKind::Gt, span: self.previous.span, leading_trivia: Vec::new() };
            return true;
        }
        if self.current.kind == token::TokenKind::Gt {
            self.advance();
            return true;
        }
        if self.current.kind == token::TokenKind::Shr {
            let shr_span = self.current.span;
            self.pending_gt = true;
            self.advance();
            self.previous = token::Token { kind: token::TokenKind::Gt, span: shr_span, leading_trivia: Vec::new() };
            return true;
        }
        self.error_expected_kind(token::TokenKind::Gt);
        false
    }

    // ============================================================
    // Error handling
    // ============================================================

    pub fn error_at_current(self: &mut Self, message: String, code: ErrorCode) {
        self.error_at(self.current.span, message, code);
    }

    pub fn error_at(self: &mut Self, span: common::Span, message: String, code: ErrorCode) {
        if self.panic_mode {
            return;
        }
        self.panic_mode = true;
        let diagnostic = make_diagnostic(message, span, code);
        self.errors.push(diagnostic);
    }

    pub fn error_expected_kind(self: &mut Self, expected: token::TokenKind) {
        let mut message = String::new();
        message.push_str("expected ");
        message.push_str(expected.display_name());
        message.push_str(", found ");
        message.push_str(self.current.kind.display_name());
        let code = if self.is_at_end() {
            ErrorCode::UnexpectedEof
        } else {
            ErrorCode::UnexpectedToken
        };
        self.error_at_current(message, code);
    }

    pub fn error_expected(self: &mut Self, expected: &str) {
        let mut message = String::new();
        message.push_str("expected ");
        message.push_str(expected);
        message.push_str(", found ");
        message.push_str(self.current.kind.display_name());
        let code = if self.is_at_end() {
            ErrorCode::UnexpectedEof
        } else {
            ErrorCode::UnexpectedToken
        };
        self.error_at_current(message, code);
    }

    /// Synchronize after an error by skipping to a statement boundary.
    pub fn synchronize(self: &mut Self) {
        self.panic_mode = false;

        while !self.is_at_end() {
            // Stop at end of statement
            if self.previous.kind == token::TokenKind::Semi {
                return;
            }

            // Stop at declaration keywords
            match self.current.kind {
                token::TokenKind::Fn => { return; }
                token::TokenKind::Struct => { return; }
                token::TokenKind::Enum => { return; }
                token::TokenKind::Trait => { return; }
                token::TokenKind::Impl => { return; }
                token::TokenKind::Type => { return; }
                token::TokenKind::Const => { return; }
                token::TokenKind::Static => { return; }
                token::TokenKind::Mod => { return; }
                token::TokenKind::Use => { return; }
                token::TokenKind::Pub => { return; }
                token::TokenKind::Effect => { return; }
                token::TokenKind::Handler => { return; }
                token::TokenKind::Bridge => { return; }
                token::TokenKind::RBrace => { return; }
                // For all other tokens, skip
                token::TokenKind::As => { self.advance(); }
                token::TokenKind::Async => { self.advance(); }
                token::TokenKind::Await => { self.advance(); }
                token::TokenKind::Break => { self.advance(); }
                token::TokenKind::Continue => { self.advance(); }
                token::TokenKind::Crate => { self.advance(); }
                token::TokenKind::Deep => { self.advance(); }
                token::TokenKind::Default => { self.advance(); }
                token::TokenKind::Dyn => { self.advance(); }
                token::TokenKind::Else => { self.advance(); }
                token::TokenKind::Extends => { self.advance(); }
                token::TokenKind::Extern => { self.advance(); }
                token::TokenKind::False => { self.advance(); }
                token::TokenKind::For => { self.advance(); }
                token::TokenKind::Forall => { self.advance(); }
                token::TokenKind::Handle => { self.advance(); }
                token::TokenKind::If => { self.advance(); }
                token::TokenKind::In => { self.advance(); }
                token::TokenKind::Let => { self.advance(); }
                token::TokenKind::Linear => { self.advance(); }
                token::TokenKind::Loop => { self.advance(); }
                token::TokenKind::Match => { self.advance(); }
                token::TokenKind::Module => { self.advance(); }
                token::TokenKind::Move => { self.advance(); }
                token::TokenKind::Mut => { self.advance(); }
                token::TokenKind::Op => { self.advance(); }
                token::TokenKind::Perform => { self.advance(); }
                token::TokenKind::Pure => { self.advance(); }
                token::TokenKind::Ref => { self.advance(); }
                token::TokenKind::Region => { self.advance(); }
                token::TokenKind::Resume => { self.advance(); }
                token::TokenKind::Return => { self.advance(); }
                token::TokenKind::SelfLower => { self.advance(); }
                token::TokenKind::SelfUpper => { self.advance(); }
                token::TokenKind::Shallow => { self.advance(); }
                token::TokenKind::Super => { self.advance(); }
                token::TokenKind::True => { self.advance(); }
                token::TokenKind::Unsafe => { self.advance(); }
                token::TokenKind::Where => { self.advance(); }
                token::TokenKind::While => { self.advance(); }
                token::TokenKind::With => { self.advance(); }
                token::TokenKind::Affine => { self.advance(); }
                token::TokenKind::Try => { self.advance(); }
                token::TokenKind::Abstract => { self.advance(); }
                token::TokenKind::Become => { self.advance(); }
                token::TokenKind::Box => { self.advance(); }
                token::TokenKind::Do => { self.advance(); }
                token::TokenKind::Final => { self.advance(); }
                token::TokenKind::Macro => { self.advance(); }
                token::TokenKind::Override => { self.advance(); }
                token::TokenKind::Priv => { self.advance(); }
                token::TokenKind::Typeof => { self.advance(); }
                token::TokenKind::Unsized => { self.advance(); }
                token::TokenKind::Virtual => { self.advance(); }
                token::TokenKind::Yield => { self.advance(); }
                token::TokenKind::Catch => { self.advance(); }
                token::TokenKind::Finally => { self.advance(); }
                token::TokenKind::Throw => { self.advance(); }
                token::TokenKind::Union => { self.advance(); }
                token::TokenKind::IntLit => { self.advance(); }
                token::TokenKind::FloatLit => { self.advance(); }
                token::TokenKind::StringLit => { self.advance(); }
                token::TokenKind::ByteStringLit => { self.advance(); }
                token::TokenKind::RawStringLit => { self.advance(); }
                token::TokenKind::CharLit => { self.advance(); }
                token::TokenKind::Ident => { self.advance(); }
                token::TokenKind::TypeIdent => { self.advance(); }
                token::TokenKind::Lifetime => { self.advance(); }
                token::TokenKind::Plus => { self.advance(); }
                token::TokenKind::Minus => { self.advance(); }
                token::TokenKind::Star => { self.advance(); }
                token::TokenKind::Slash => { self.advance(); }
                token::TokenKind::Percent => { self.advance(); }
                token::TokenKind::EqEq => { self.advance(); }
                token::TokenKind::NotEq => { self.advance(); }
                token::TokenKind::Lt => { self.advance(); }
                token::TokenKind::Gt => { self.advance(); }
                token::TokenKind::LtEq => { self.advance(); }
                token::TokenKind::GtEq => { self.advance(); }
                token::TokenKind::AndAnd => { self.advance(); }
                token::TokenKind::OrOr => { self.advance(); }
                token::TokenKind::Not => { self.advance(); }
                token::TokenKind::And => { self.advance(); }
                token::TokenKind::Or => { self.advance(); }
                token::TokenKind::Caret => { self.advance(); }
                token::TokenKind::Shl => { self.advance(); }
                token::TokenKind::Shr => { self.advance(); }
                token::TokenKind::Eq => { self.advance(); }
                token::TokenKind::PlusEq => { self.advance(); }
                token::TokenKind::MinusEq => { self.advance(); }
                token::TokenKind::StarEq => { self.advance(); }
                token::TokenKind::SlashEq => { self.advance(); }
                token::TokenKind::PercentEq => { self.advance(); }
                token::TokenKind::AndEq => { self.advance(); }
                token::TokenKind::OrEq => { self.advance(); }
                token::TokenKind::CaretEq => { self.advance(); }
                token::TokenKind::ShlEq => { self.advance(); }
                token::TokenKind::ShrEq => { self.advance(); }
                token::TokenKind::LParen => { self.advance(); }
                token::TokenKind::RParen => { self.advance(); }
                token::TokenKind::LBrace => { self.advance(); }
                token::TokenKind::LBracket => { self.advance(); }
                token::TokenKind::RBracket => { self.advance(); }
                token::TokenKind::Comma => { self.advance(); }
                token::TokenKind::Semi => { self.advance(); }
                token::TokenKind::Colon => { self.advance(); }
                token::TokenKind::ColonColon => { self.advance(); }
                token::TokenKind::Dot => { self.advance(); }
                token::TokenKind::DotDot => { self.advance(); }
                token::TokenKind::DotDotEq => { self.advance(); }
                token::TokenKind::Arrow => { self.advance(); }
                token::TokenKind::FatArrow => { self.advance(); }
                token::TokenKind::Pipe => { self.advance(); }
                token::TokenKind::At => { self.advance(); }
                token::TokenKind::Hash => { self.advance(); }
                token::TokenKind::Question => { self.advance(); }
                token::TokenKind::Dollar => { self.advance(); }
                token::TokenKind::AtUnsafe => { self.advance(); }
                token::TokenKind::AtHeap => { self.advance(); }
                token::TokenKind::AtStack => { self.advance(); }
                token::TokenKind::DocComment => { self.advance(); }
                token::TokenKind::Eof => { return; }
                token::TokenKind::Error => { self.advance(); }
            }
        }
    }

    /// Skip tokens until we find a closing brace, handling nesting.
    pub fn skip_to_closing_brace(self: &mut Self) {
        let mut depth: u32 = 1;
        while !self.is_at_end() {
            if self.current.kind == token::TokenKind::LBrace {
                depth = depth + 1;
            }
            if self.current.kind == token::TokenKind::RBrace {
                depth = depth - 1;
                if depth == 0 {
                    return;
                }
            }
            self.advance();
        }
    }

    // ============================================================
    // Public API
    // ============================================================

    /// Check if there are any parsing errors.
    pub fn has_errors(self: &Self) -> bool {
        self.errors.len() > 0
    }

    /// Get the number of errors.
    pub fn error_count(self: &Self) -> usize {
        self.errors.len()
    }

    /// Take ownership of the errors, leaving an empty vector in the parser.
    pub fn take_errors(self: &mut Self) -> Vec<Diagnostic> {
        let errors = self.errors;
        self.errors = Vec::new();
        errors
    }

    // ============================================================
    // Symbol Interning
    // ============================================================

    /// Get byte at position in source (returns 0 if out of bounds).
    pub fn source_byte_at(self: &Self, pos: usize) -> u8 {
        if pos >= self.source.len() {
            0
        } else {
            let ptr = @unsafe { self.source as *const u8 };
            let offset_ptr = @unsafe { (ptr as usize + pos) as *const u8 };
            @unsafe { *offset_ptr }
        }
    }

    /// Intern a symbol given its span, returning a unique index.
    pub fn intern_symbol(self: &mut Self, start: u32, end: u32) -> u32 {
        let len = end - start;

        // Search for existing entry with same content
        let mut i: usize = 0;
        while i < self.interned.len() {
            let entry = self.interned[i];
            let entry_len = entry.end - entry.start;

            if entry_len == len {
                // Same length, compare bytes
                let mut matches = true;
                let mut j: u32 = 0;
                while j < len {
                    let a = self.source_byte_at((start + j) as usize);
                    let b = self.source_byte_at((entry.start + j) as usize);
                    if a != b {
                        matches = false;
                        break;
                    }
                    j = j + 1;
                }

                if matches {
                    return i as u32;
                }
            }

            i = i + 1;
        }

        // Not found, add new entry
        let new_index = self.interned.len() as u32;
        let entry = InternEntry { start: start, end: end };
        self.interned.push(entry);
        new_index
    }

    /// Parse a spanned symbol from current token.
    pub fn parse_spanned_symbol(self: &mut Self) -> common::SpannedSymbol {
        let span = self.current.span;
        let index = self.intern_symbol(span.start as u32, span.end as u32);
        let symbol = common::Symbol { index: index };
        self.advance();
        common::SpannedSymbol { symbol: symbol, span: span }
    }

    /// Check if a token is exactly the underscore character.
    pub fn token_is_underscore(self: &Self, tok: token::Token) -> bool {
        let start = tok.span.start as usize;
        let end = tok.span.end as usize;
        // Check length is 1 and the byte is '_' (95)
        (end - start) == 1 && self.source_byte_at(start) == 95
    }

    /// Extract doc text from a DocComment token.
    /// The token span covers `/// text here` (from `///` to end of line).
    /// Skip first 3 bytes (`///`), then skip one optional leading space.
    pub fn extract_doc_text(self: &Self, tok: token::Token) -> String {
        let start = tok.span.start as usize;
        let end = tok.span.end as usize;
        let mut pos = start + 3; // skip "///"
        // Skip one optional leading space
        if pos < end && self.source_byte_at(pos) == 32 {
            pos = pos + 1;
        }
        let mut result = String::new();
        while pos < end {
            let b = self.source_byte_at(pos);
            result.push(b as char);
            pos = pos + 1;
        }
        result
    }
}

// ============================================================
// Literal Value Extraction from Source Text
// ============================================================

/// Parse an integer value from the source text at the given span.
/// Handles decimal, hex (0x), octal (0o), and binary (0b) formats.
/// Skips underscore separators and stops at suffix characters.
pub fn parse_int_value_from_span(parser: &mut Parser, span: common::Span) -> u128 {
    let start = span.start;
    let end = span.end;
    let mut pos = start;
    let mut val: u128 = 0;
    let mut base: u128 = 10;

    // Check for 0x/0o/0b prefix
    if pos + 1 < end {
        let first = parser.source_byte_at(pos);
        let second = parser.source_byte_at(pos + 1);
        if first == 48 {
            // '0' prefix
            if second == 120 || second == 88 {
                // 'x' or 'X' — hex
                base = 16;
                pos = pos + 2;
            } else if second == 111 || second == 79 {
                // 'o' or 'O' — octal
                base = 8;
                pos = pos + 2;
            } else if second == 98 || second == 66 {
                // 'b' or 'B' — binary
                base = 2;
                pos = pos + 2;
            }
        }
    }

    // Parse digits, stop at suffix or end
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 95 {
            // Underscore separator — skip
            pos = pos + 1;
        } else if b >= 48 && b <= 57 {
            // '0'-'9'
            let digit = (b - 48) as u128;
            if digit < base {
                val = val * base + digit;
            }
            pos = pos + 1;
        } else if base == 16 && b >= 97 && b <= 102 {
            // 'a'-'f' (hex lowercase)
            let digit = (b - 97 + 10) as u128;
            val = val * base + digit;
            pos = pos + 1;
        } else if base == 16 && b >= 65 && b <= 70 {
            // 'A'-'F' (hex uppercase)
            let digit = (b - 65 + 10) as u128;
            val = val * base + digit;
            pos = pos + 1;
        } else {
            // Hit suffix or other non-digit character
            break;
        }
    }

    val
}

/// Extract the integer suffix from the source text at the given span.
/// Integer suffixes start with 'i' or 'u' (e.g., i32, u64, isize, usize).
pub fn parse_int_suffix_from_span(parser: &mut Parser, span: common::Span) -> Option<ast::IntSuffix> {
    let start = span.start;
    let end = span.end;
    let mut pos = start;

    // Skip past 0x/0o/0b prefix
    if pos + 1 < end {
        let first = parser.source_byte_at(pos);
        let second = parser.source_byte_at(pos + 1);
        if first == 48 && (second == 120 || second == 88 || second == 111 || second == 79 || second == 98 || second == 66) {
            pos = pos + 2;
        }
    }

    // Skip past digits and underscores
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 95 || (b >= 48 && b <= 57) {
            // Underscore or decimal digit
            pos = pos + 1;
        } else if b >= 97 && b <= 102 {
            // Could be hex digit or start of suffix
            if b == 105 || b == 117 {
                // 'i' or 'u' — this is a suffix
                break;
            }
            pos = pos + 1;
        } else if b >= 65 && b <= 70 {
            // Uppercase hex digit
            pos = pos + 1;
        } else {
            // Non-digit, non-hex — start of suffix
            break;
        }
    }

    // Parse suffix if present
    if pos >= end {
        return Option::None;
    }

    let first = parser.source_byte_at(pos);
    let suffix_len = end - pos;

    if first == 105 {
        // 'i' prefix
        if suffix_len == 2 && parser.source_byte_at(pos + 1) == 56 {
            // "i8"
            return Option::Some(ast::IntSuffix::I8);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 54 {
            // "i16"
            return Option::Some(ast::IntSuffix::I16);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 51 && parser.source_byte_at(pos + 2) == 50 {
            // "i32"
            return Option::Some(ast::IntSuffix::I32);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 54 && parser.source_byte_at(pos + 2) == 52 {
            // "i64"
            return Option::Some(ast::IntSuffix::I64);
        }
        if suffix_len == 4 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 50 && parser.source_byte_at(pos + 3) == 56 {
            // "i128"
            return Option::Some(ast::IntSuffix::I128);
        }
        if suffix_len == 5 && parser.source_byte_at(pos + 1) == 115 && parser.source_byte_at(pos + 2) == 105 && parser.source_byte_at(pos + 3) == 122 && parser.source_byte_at(pos + 4) == 101 {
            // "isize"
            return Option::Some(ast::IntSuffix::Isize);
        }
    }

    if first == 117 {
        // 'u' prefix
        if suffix_len == 2 && parser.source_byte_at(pos + 1) == 56 {
            // "u8"
            return Option::Some(ast::IntSuffix::U8);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 54 {
            // "u16"
            return Option::Some(ast::IntSuffix::U16);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 51 && parser.source_byte_at(pos + 2) == 50 {
            // "u32"
            return Option::Some(ast::IntSuffix::U32);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 54 && parser.source_byte_at(pos + 2) == 52 {
            // "u64"
            return Option::Some(ast::IntSuffix::U64);
        }
        if suffix_len == 4 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 50 && parser.source_byte_at(pos + 3) == 56 {
            // "u128"
            return Option::Some(ast::IntSuffix::U128);
        }
        if suffix_len == 5 && parser.source_byte_at(pos + 1) == 115 && parser.source_byte_at(pos + 2) == 105 && parser.source_byte_at(pos + 3) == 122 && parser.source_byte_at(pos + 4) == 101 {
            // "usize"
            return Option::Some(ast::IntSuffix::Usize);
        }
    }

    Option::None
}

/// Parse a float value from the source text and return its bits as u64.
/// Parses the decimal representation and converts to IEEE 754 f64 bits.
pub fn parse_float_bits_from_span(parser: &mut Parser, span: common::Span) -> u64 {
    let start = span.start;
    let end = span.end;

    // Extract the numeric part (before any suffix)
    let mut num_end = start;
    while num_end < end {
        let b = parser.source_byte_at(num_end);
        if (b >= 48 && b <= 57) || b == 46 || b == 95 || b == 101 || b == 69 || b == 43 || b == 45 {
            // digit, '.', '_', 'e', 'E', '+', '-'
            num_end = num_end + 1;
        } else {
            break;
        }
    }

    // Parse integer part
    let mut pos = start;
    let mut int_part: u64 = 0;
    while pos < num_end {
        let b = parser.source_byte_at(pos);
        if b >= 48 && b <= 57 {
            int_part = int_part * 10 + ((b - 48) as u64);
        } else if b == 46 || b == 101 || b == 69 {
            break;
        }
        // Skip underscores
        pos = pos + 1;
    }

    // Parse fractional part
    let mut frac_val: u64 = 0;
    let mut frac_digits: u32 = 0;
    if pos < num_end && parser.source_byte_at(pos) == 46 {
        pos = pos + 1;
        while pos < num_end {
            let b = parser.source_byte_at(pos);
            if b >= 48 && b <= 57 {
                frac_val = frac_val * 10 + ((b - 48) as u64);
                frac_digits = frac_digits + 1;
            } else if b == 101 || b == 69 {
                break;
            }
            // Skip underscores
            pos = pos + 1;
        }
    }

    // Parse exponent
    let mut exp: i32 = 0;
    let mut exp_neg = false;
    if pos < num_end && (parser.source_byte_at(pos) == 101 || parser.source_byte_at(pos) == 69) {
        pos = pos + 1;
        if pos < num_end && parser.source_byte_at(pos) == 45 {
            exp_neg = true;
            pos = pos + 1;
        } else if pos < num_end && parser.source_byte_at(pos) == 43 {
            pos = pos + 1;
        }
        while pos < num_end {
            let b = parser.source_byte_at(pos);
            if b >= 48 && b <= 57 {
                exp = exp * 10 + ((b - 48) as i32);
            }
            pos = pos + 1;
        }
        if exp_neg {
            exp = 0 - exp;
        }
    }

    // Convert to f64 bits
    let mut result: f64 = int_part as f64;

    // Add fractional part
    if frac_digits > 0 {
        let mut divisor: f64 = 1.0;
        let mut d: u32 = 0;
        while d < frac_digits {
            divisor = divisor * 10.0;
            d = d + 1;
        }
        result = result + (frac_val as f64) / divisor;
    }

    // Apply exponent
    if exp > 0 {
        let mut e: i32 = 0;
        while e < exp {
            result = result * 10.0;
            e = e + 1;
        }
    } else if exp < 0 {
        let mut e: i32 = exp;
        while e < 0 {
            result = result / 10.0;
            e = e + 1;
        }
    }

    // Convert f64 to bits
    @unsafe { *(&result as *const u64) }
}

/// Extract the float suffix from the source text (f32 or f64).
pub fn parse_float_suffix_from_span(parser: &mut Parser, span: common::Span) -> Option<ast::FloatSuffix> {
    let end = span.end;

    // Check if span ends with f32 or f64
    if end >= span.start + 3 {
        let b0 = parser.source_byte_at(end - 3);
        let b1 = parser.source_byte_at(end - 2);
        let b2 = parser.source_byte_at(end - 1);
        if b0 == 102 {
            // 'f'
            if b1 == 51 && b2 == 50 {
                // "f32"
                return Option::Some(ast::FloatSuffix::F32);
            }
            if b1 == 54 && b2 == 52 {
                // "f64"
                return Option::Some(ast::FloatSuffix::F64);
            }
        }
    }

    Option::None
}

/// Parse a string literal from the source text (strips quotes, handles escape sequences).
pub fn parse_string_from_span(parser: &mut Parser, span: common::Span) -> String {
    let start = span.start;
    let end = span.end;
    let mut result = String::new();

    // Skip opening quote
    let mut pos = start + 1;

    // Parse until closing quote
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 34 {
            // '"' — closing quote
            break;
        }
        if b == 92 && pos + 1 < end {
            // '\' — escape sequence
            pos = pos + 1;
            let esc = parser.source_byte_at(pos);
            if esc == 110 {
                // \n
                result.push(10 as char);
            } else if esc == 116 {
                // \t
                result.push(9 as char);
            } else if esc == 114 {
                // \r
                result.push(13 as char);
            } else if esc == 92 {
                // \\
                result.push(92 as char);
            } else if esc == 34 {
                // \"
                result.push(34 as char);
            } else if esc == 48 {
                // \0
                result.push(0 as char);
            } else if esc == 39 {
                // \'
                result.push(39 as char);
            } else if esc == 120 {
                // \x## — hex escape (2 hex digits)
                pos = pos + 1;
                let mut hex_val: u32 = 0;
                if pos < end {
                    let h1 = parser.source_byte_at(pos);
                    hex_val = hex_digit_value(h1);
                    pos = pos + 1;
                }
                if pos < end {
                    let h2 = parser.source_byte_at(pos);
                    hex_val = hex_val * 16 + hex_digit_value(h2);
                }
                result.push(hex_val as char);
            } else if esc == 117 {
                // \u{####} — unicode escape
                pos = pos + 1;
                if pos < end && parser.source_byte_at(pos) == 123 {
                    // skip '{'
                    pos = pos + 1;
                    let mut code_point: u32 = 0;
                    while pos < end && parser.source_byte_at(pos) != 125 {
                        let digit = parser.source_byte_at(pos);
                        code_point = code_point * 16 + hex_digit_value(digit);
                        pos = pos + 1;
                    }
                    // skip '}'
                    if pos < end && parser.source_byte_at(pos) == 125 {
                        pos = pos + 1;
                    }
                    result.push(code_point as char);
                    pos = pos - 1; // adjust for outer pos = pos + 1
                }
            } else {
                // Unknown escape — include as-is
                result.push(92 as char);
                result.push(esc as char);
            }
        } else if b < 128 {
            // ASCII byte — safe to push directly
            result.push(b as char);
        } else {
            // Multi-byte UTF-8 sequence — decode to code point then push
            // UTF-8 encoding:
            //   110xxxxx 10xxxxxx                     → 2 bytes
            //   1110xxxx 10xxxxxx 10xxxxxx            → 3 bytes
            //   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   → 4 bytes
            if b >= 240 && pos + 3 < end {
                // 4-byte sequence: 11110xxx
                let b1 = parser.source_byte_at(pos + 1);
                let b2 = parser.source_byte_at(pos + 2);
                let b3 = parser.source_byte_at(pos + 3);
                let cp = ((b as u32 & 7) << 18)
                       | ((b1 as u32 & 63) << 12)
                       | ((b2 as u32 & 63) << 6)
                       | (b3 as u32 & 63);
                result.push(cp as char);
                pos = pos + 3; // +1 at end of loop
            } else if b >= 224 && pos + 2 < end {
                // 3-byte sequence: 1110xxxx
                let b1 = parser.source_byte_at(pos + 1);
                let b2 = parser.source_byte_at(pos + 2);
                let cp = ((b as u32 & 15) << 12)
                       | ((b1 as u32 & 63) << 6)
                       | (b2 as u32 & 63);
                result.push(cp as char);
                pos = pos + 2; // +1 at end of loop
            } else if b >= 192 && pos + 1 < end {
                // 2-byte sequence: 110xxxxx
                let b1 = parser.source_byte_at(pos + 1);
                let cp = ((b as u32 & 31) << 6)
                       | (b1 as u32 & 63);
                result.push(cp as char);
                pos = pos + 1; // +1 at end of loop
            } else {
                // Invalid UTF-8 continuation byte or truncated — emit as-is
                result.push(b as char);
            }
        }
        pos = pos + 1;
    }

    result
}

/// Parse a character literal from the source text (strips quotes, handles escapes).
pub fn parse_char_from_span(parser: &mut Parser, span: common::Span) -> char {
    let start = span.start;
    let end = span.end;

    // Skip opening quote '
    let pos = start + 1;

    if pos >= end {
        return '?';
    }

    let b = parser.source_byte_at(pos);
    if b == 92 && pos + 1 < end {
        // Escape sequence
        let esc = parser.source_byte_at(pos + 1);
        if esc == 110 { return 10 as char; }       // \n
        if esc == 116 { return 9 as char; }        // \t
        if esc == 114 { return 13 as char; }       // \r
        if esc == 92 { return 92 as char; }        // \\
        if esc == 39 { return 39 as char; }        // \'
        if esc == 48 { return 0 as char; }         // \0
        if esc == 34 { return 34 as char; }        // \"
        if esc == 120 {
            // \x## — hex escape
            let mut hex_val: u32 = 0;
            if pos + 2 < end {
                hex_val = hex_digit_value(parser.source_byte_at(pos + 2));
            }
            if pos + 3 < end {
                hex_val = hex_val * 16 + hex_digit_value(parser.source_byte_at(pos + 3));
            }
            return hex_val as char;
        }
        if esc == 117 {
            // \u{####} — unicode escape
            let mut idx = pos + 2;
            if idx < end && parser.source_byte_at(idx) == 123 {
                idx = idx + 1;
                let mut code_point: u32 = 0;
                while idx < end && parser.source_byte_at(idx) != 125 {
                    code_point = code_point * 16 + hex_digit_value(parser.source_byte_at(idx));
                    idx = idx + 1;
                }
                return code_point as char;
            }
        }
        return esc as char;
    }

    // Decode UTF-8 multi-byte sequences for non-ASCII characters
    if b < 128 {
        b as char
    } else if b >= 240 && pos + 3 < end {
        // 4-byte UTF-8 sequence
        let b1 = parser.source_byte_at(pos + 1);
        let b2 = parser.source_byte_at(pos + 2);
        let b3 = parser.source_byte_at(pos + 3);
        let cp = ((b as u32 & 7) << 18)
               | ((b1 as u32 & 63) << 12)
               | ((b2 as u32 & 63) << 6)
               | (b3 as u32 & 63);
        cp as char
    } else if b >= 224 && pos + 2 < end {
        // 3-byte UTF-8 sequence
        let b1 = parser.source_byte_at(pos + 1);
        let b2 = parser.source_byte_at(pos + 2);
        let cp = ((b as u32 & 15) << 12)
               | ((b1 as u32 & 63) << 6)
               | (b2 as u32 & 63);
        cp as char
    } else if b >= 192 && pos + 1 < end {
        // 2-byte UTF-8 sequence
        let b1 = parser.source_byte_at(pos + 1);
        let cp = ((b as u32 & 31) << 6)
               | (b1 as u32 & 63);
        cp as char
    } else {
        b as char
    }
}

/// Convert a hex digit byte to its numeric value (0-15).
fn hex_digit_value(b: u8) -> u32 {
    if b >= 48 && b <= 57 {
        // '0'-'9'
        (b - 48) as u32
    } else if b >= 65 && b <= 70 {
        // 'A'-'F'
        (b - 55) as u32
    } else if b >= 97 && b <= 102 {
        // 'a'-'f'
        (b - 87) as u32
    } else {
        0
    }
}
