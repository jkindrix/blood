// Blood Self-Hosted Compiler - Context-Aware Type Size Functions
//
// Canonical implementations of type size and LLVM type conversion
// functions that use the ADT registry. This module exists to avoid
// circular dependencies between codegen_expr and codegen_stmt.

mod common;
mod hir_def;
mod hir_ty;
mod codegen_types;
mod codegen_ctx;
mod type_intern;

// ============================================================
// Public API
// ============================================================

/// Converts a type to LLVM IR, using the ADT registry for struct/enum types.
/// Falls back to `codegen_types::type_to_llvm` for non-ADT types.
pub fn type_to_llvm_with_ctx(
    ctx: &mut codegen_ctx::CodegenCtx,
    ty: &hir_ty::Type,
) -> String {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let result = ctx.adt_llvm_type(def_id.index);
            // Generic builtin enum not in registry (Option<T>, Result<T,E>)?
            // adt_llvm_type returns "ptr" (3 bytes) as fallback for unknown ADTs.
            // Only expand when the ADT is truly unregistered. Registered ADTs
            // like Box<T> that return "ptr" should NOT be expanded.
            if result.as_bytes().len() == 3
                && result.as_bytes()[0] == 112
                && result.as_bytes()[1] == 116
                && result.as_bytes()[2] == 114
                && args.len() > 0
                && !is_adt_registered(ctx, def_id.index)
            {
                let mut payload_size: u64 = 0;
                let mut max_align: u64 = 1;
                let mut ai: usize = 0;
                while ai < args.len() {
                    let arg_llvm = type_to_llvm_with_ctx(ctx, &args[ai]);
                    payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                    let a = llvm_type_alignment(arg_llvm.as_str());
                    if a > max_align {
                        max_align = a;
                    }
                    ai = ai + 1;
                }
                if payload_size > 0 {
                    return build_enum_type_string(payload_size, max_align);
                }
            }
            // For registered generic enums (Option<T>, Result<T,E>) with type args,
            // check if the concrete payload exceeds the registered max_payload_size.
            // e.g. Option<IntHolder> where IntHolder is { i32, i64 } = 16 bytes
            // but registered Option has max_payload_size = 8.
            if args.len() > 0 {
                let registered_max = match ctx.lookup_enum(def_id.index) {
                    Option::Some(layout) => layout.max_payload_size,
                    Option::None => 0,
                };
                if registered_max > 0 {
                    let mut payload_size: u64 = 0;
                    let mut max_align: u64 = 1;
                    let mut ai: usize = 0;
                    while ai < args.len() {
                        let arg_llvm = type_to_llvm_with_ctx(ctx, &args[ai]);
                        payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                        let a = llvm_type_alignment(arg_llvm.as_str());
                        if a > max_align {
                            max_align = a;
                        }
                        ai = ai + 1;
                    }
                    if payload_size > registered_max {
                        return build_enum_type_string(payload_size, max_align);
                    }
                }
            }
            result
        }
        _ => codegen_types::type_to_llvm(ty),
    }
}

/// Gets the size of a type in bytes, using the ADT registry for struct/enum types.
/// This is context-aware and returns correct sizes for user-defined ADTs.
pub fn type_size_with_ctx(ctx: &mut codegen_ctx::CodegenCtx, ty: &hir_ty::Type) -> u64 {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let base = adt_size_bytes(ctx, def_id.index);
            if base == 8 && args.len() > 0 && !is_adt_registered(ctx, def_id.index) {
                let mut payload_size: u64 = 0;
                let mut max_align: u64 = 1;
                let mut ai: usize = 0;
                while ai < args.len() {
                    let arg_llvm = type_to_llvm_with_ctx(ctx, &args[ai]);
                    payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                    let a = llvm_type_alignment(arg_llvm.as_str());
                    if a > max_align {
                        max_align = a;
                    }
                    ai = ai + 1;
                }
                if payload_size > 8 {
                    let enum_ty = build_enum_type_string(payload_size, max_align);
                    return llvm_type_size(enum_ty.as_str());
                }
            }
            // For registered generic enums, check if concrete payload exceeds registered size.
            if args.len() > 0 {
                let registered_max = match ctx.lookup_enum(def_id.index) {
                    Option::Some(layout) => layout.max_payload_size,
                    Option::None => 0,
                };
                if registered_max > 0 {
                    let mut payload_size: u64 = 0;
                    let mut max_align: u64 = 1;
                    let mut ai: usize = 0;
                    while ai < args.len() {
                        let arg_llvm = type_to_llvm_with_ctx(ctx, &args[ai]);
                        payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                        let a = llvm_type_alignment(arg_llvm.as_str());
                        if a > max_align {
                            max_align = a;
                        }
                        ai = ai + 1;
                    }
                    if payload_size > registered_max {
                        let enum_ty = build_enum_type_string(payload_size, max_align);
                        return llvm_type_size(enum_ty.as_str());
                    }
                }
            }
            base
        }
        _ => codegen_types::type_size_bytes(ty),
    }
}

// ============================================================
// TyId-Native Public API
// ============================================================

/// Fast path: returns a static &str for common LLVM types from TyId without
/// String allocation. Returns None for compound types that need dynamic construction.
/// Matches on InternedTypeKind directly â€” no Type tree reconstruction.
pub fn type_to_llvm_fast_id(ty_id: type_intern::TyId) -> Option<&str> {
    let kind = type_intern::type_interner().get(ty_id);
    match kind {
        &type_intern::InternedTypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::Bool => Option::Some("i1"),
                &hir_ty::PrimitiveTy::Char => Option::Some("i32"),
                &hir_ty::PrimitiveTy::I8 => Option::Some("i8"),
                &hir_ty::PrimitiveTy::I16 => Option::Some("i16"),
                &hir_ty::PrimitiveTy::I32 => Option::Some("i32"),
                &hir_ty::PrimitiveTy::I64 => Option::Some("i64"),
                &hir_ty::PrimitiveTy::I128 => Option::Some("i128"),
                &hir_ty::PrimitiveTy::Isize => Option::Some("i64"),
                &hir_ty::PrimitiveTy::U8 => Option::Some("i8"),
                &hir_ty::PrimitiveTy::U16 => Option::Some("i16"),
                &hir_ty::PrimitiveTy::U32 => Option::Some("i32"),
                &hir_ty::PrimitiveTy::U64 => Option::Some("i64"),
                &hir_ty::PrimitiveTy::U128 => Option::Some("i128"),
                &hir_ty::PrimitiveTy::Usize => Option::Some("i64"),
                &hir_ty::PrimitiveTy::F32 => Option::Some("float"),
                &hir_ty::PrimitiveTy::F64 => Option::Some("double"),
                &hir_ty::PrimitiveTy::Str => Option::Some("{ ptr, i64 }"),
            }
        }
        &type_intern::InternedTypeKind::Never => Option::Some("void"),
        &type_intern::InternedTypeKind::Ref { inner, mutable: _ } => {
            // Fat pointer for unsized types (&str, &[T], &dyn Trait)
            let inner_kind = type_intern::type_interner().get(inner);
            match inner_kind {
                &type_intern::InternedTypeKind::Primitive(ref p) => {
                    match p {
                        &hir_ty::PrimitiveTy::Str => Option::Some("{ ptr, i64 }"),
                        _ => Option::Some("ptr"),
                    }
                }
                &type_intern::InternedTypeKind::Slice { element: _ } => Option::Some("{ ptr, i64 }"),
                &type_intern::InternedTypeKind::DynTrait { trait_id: _, auto_traits: _ } => Option::Some("{ ptr, ptr }"),
                _ => Option::Some("ptr"),
            }
        }
        &type_intern::InternedTypeKind::Ptr { inner, mutable: _ } => {
            // Fat pointer for unsized types (*const str, *const [T], *const dyn Trait)
            let inner_kind = type_intern::type_interner().get(inner);
            match inner_kind {
                &type_intern::InternedTypeKind::Primitive(ref p) => {
                    match p {
                        &hir_ty::PrimitiveTy::Str => Option::Some("{ ptr, i64 }"),
                        _ => Option::Some("ptr"),
                    }
                }
                &type_intern::InternedTypeKind::Slice { element: _ } => Option::Some("{ ptr, i64 }"),
                &type_intern::InternedTypeKind::DynTrait { trait_id: _, auto_traits: _ } => Option::Some("{ ptr, ptr }"),
                _ => Option::Some("ptr"),
            }
        }
        &type_intern::InternedTypeKind::Fn { params: _, ret: _, effects: _ } => Option::Some("ptr"),
        &type_intern::InternedTypeKind::Closure { def_id: _, params: _, ret: _ } => Option::Some("ptr"),
        &type_intern::InternedTypeKind::Infer(_) => Option::Some("i64"),
        &type_intern::InternedTypeKind::Record { fields: _, row_var: _ } => Option::Some("ptr"),
        &type_intern::InternedTypeKind::Forall { params: _, body: _ } => Option::Some("ptr"),
        &type_intern::InternedTypeKind::Error => Option::Some("i64"),
        _ => Option::None,
    }
}

/// Converts a TyId to LLVM IR, using the ADT registry for struct/enum types.
/// Uses fast path for common types, falls back to ty_id_to_type for compounds.
pub fn type_to_llvm_with_ctx_id(
    ctx: &mut codegen_ctx::CodegenCtx,
    ty_id: type_intern::TyId,
) -> String {
    // Fast path: check for Adt first (needs registry lookup)
    let kind = type_intern::type_interner().get(ty_id);
    match kind {
        &type_intern::InternedTypeKind::Adt { def_id, args } => {
            let result = ctx.adt_llvm_type(def_id.index);
            let interner = type_intern::type_interner();
            let arg_len = interner.ty_list_len(args);
            if result.as_bytes().len() == 3
                && result.as_bytes()[0] == 112
                && result.as_bytes()[1] == 116
                && result.as_bytes()[2] == 114
                && arg_len > 0
                && !is_adt_registered(ctx, def_id.index)
            {
                let mut payload_size: u64 = 0;
                let mut max_align: u64 = 1;
                let mut ai: usize = 0;
                while ai < arg_len {
                    let arg_id = interner.get_ty_list_element(args, ai);
                    let arg_llvm = type_to_llvm_with_ctx_id(ctx, arg_id);
                    payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                    let a = llvm_type_alignment(arg_llvm.as_str());
                    if a > max_align {
                        max_align = a;
                    }
                    ai = ai + 1;
                }
                if payload_size > 0 {
                    return build_enum_type_string(payload_size, max_align);
                }
            }
            // For registered generic enums (Option<T>, Result<T,E>) with type args,
            // check if the concrete payload exceeds the registered max_payload_size.
            if arg_len > 0 {
                let registered_max = match ctx.lookup_enum(def_id.index) {
                    Option::Some(layout) => layout.max_payload_size,
                    Option::None => 0,
                };
                if registered_max > 0 {
                    let interner2 = type_intern::type_interner();
                    let mut payload_size: u64 = 0;
                    let mut max_align: u64 = 1;
                    let mut ai: usize = 0;
                    while ai < arg_len {
                        let arg_id = interner2.get_ty_list_element(args, ai);
                        let arg_llvm = type_to_llvm_with_ctx_id(ctx, arg_id);
                        payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                        let a = llvm_type_alignment(arg_llvm.as_str());
                        if a > max_align {
                            max_align = a;
                        }
                        ai = ai + 1;
                    }
                    if payload_size > registered_max {
                        return build_enum_type_string(payload_size, max_align);
                    }
                }
            }
            // For registered structs with type args, rebuild with concrete types.
            // This handles user-defined generic structs like Pair<i32, i32>.
            if arg_len > 0 {
                let needs_rebuild = match ctx.lookup_struct(def_id.index) {
                    Option::Some(layout) => struct_layout_has_param_fields(layout),
                    Option::None => false,
                };
                if needs_rebuild {
                    return rebuild_struct_with_args_id(ctx, def_id.index, args);
                }
            }
            result
        }
        _ => {
            // Fast path for non-ADT types
            match type_to_llvm_fast_id(ty_id) {
                Option::Some(s) => common::make_string(s),
                Option::None => {
                    // Slow path: reconstruct Type for compound types
                    let ty = type_intern::ty_id_to_type(ty_id);
                    codegen_types::type_to_llvm(&ty)
                }
            }
        }
    }
}

/// Gets the size of a type in bytes from TyId, using the ADT registry.
pub fn type_size_with_ctx_id(ctx: &mut codegen_ctx::CodegenCtx, ty_id: type_intern::TyId) -> u64 {
    let kind = type_intern::type_interner().get(ty_id);
    match kind {
        &type_intern::InternedTypeKind::Adt { def_id, args } => {
            let base = adt_size_bytes(ctx, def_id.index);
            let arg_len = type_intern::type_interner().ty_list_len(args);
            if base == 8 && arg_len > 0 && !is_adt_registered(ctx, def_id.index) {
                let mut payload_size: u64 = 0;
                let mut max_align: u64 = 1;
                let mut ai: usize = 0;
                while ai < arg_len {
                    let arg_id = type_intern::type_interner().get_ty_list_element(args, ai);
                    let arg_llvm = type_to_llvm_with_ctx_id(ctx, arg_id);
                    payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                    let a = llvm_type_alignment(arg_llvm.as_str());
                    if a > max_align {
                        max_align = a;
                    }
                    ai = ai + 1;
                }
                if payload_size > 8 {
                    let enum_ty = build_enum_type_string(payload_size, max_align);
                    return llvm_type_size(enum_ty.as_str());
                }
            }
            // For registered generic enums, check if concrete payload exceeds registered size.
            if arg_len > 0 {
                let registered_max = match ctx.lookup_enum(def_id.index) {
                    Option::Some(layout) => layout.max_payload_size,
                    Option::None => 0,
                };
                if registered_max > 0 {
                    let mut payload_size: u64 = 0;
                    let mut max_align: u64 = 1;
                    let mut ai: usize = 0;
                    while ai < arg_len {
                        let arg_id = type_intern::type_interner().get_ty_list_element(args, ai);
                        let arg_llvm = type_to_llvm_with_ctx_id(ctx, arg_id);
                        payload_size = payload_size + llvm_type_size(arg_llvm.as_str());
                        let a = llvm_type_alignment(arg_llvm.as_str());
                        if a > max_align {
                            max_align = a;
                        }
                        ai = ai + 1;
                    }
                    if payload_size > registered_max {
                        let enum_ty = build_enum_type_string(payload_size, max_align);
                        return llvm_type_size(enum_ty.as_str());
                    }
                }
            }
            // For registered generic structs, compute size from rebuilt LLVM type
            if arg_len > 0 {
                let needs_rebuild = match ctx.lookup_struct(def_id.index) {
                    Option::Some(layout) => struct_layout_has_param_fields(layout),
                    Option::None => false,
                };
                if needs_rebuild {
                    let rebuilt = rebuild_struct_with_args_id(ctx, def_id.index, args);
                    return llvm_type_size(rebuilt.as_str());
                }
            }
            base
        }
        _ => {
            // Fast path: use fast_id to get LLVM type string, then compute size
            match type_to_llvm_fast_id(ty_id) {
                Option::Some(s) => llvm_type_size(s),
                Option::None => {
                    let ty = type_intern::ty_id_to_type(ty_id);
                    codegen_types::type_size_bytes(&ty)
                }
            }
        }
    }
}

// ============================================================
// Generic Struct Rebuild
// ============================================================

/// Checks if a struct layout has any fields with Param or Infer types
/// that need substitution with concrete type args.
fn struct_layout_has_param_fields(layout: &codegen_ctx::StructLayout) -> bool {
    let mut i: usize = 0;
    while i < layout.fields.len() {
        match &layout.fields[i].hir_type {
            &Option::Some(ty_id) => {
                if ty_id_contains_param(ty_id) {
                    return true;
                }
            }
            &Option::None => {}
        }
        i = i + 1;
    }
    false
}

/// Checks if a TyId is or contains a Param or Infer type.
fn ty_id_contains_param(ty_id: type_intern::TyId) -> bool {
    let kind = type_intern::type_interner().get(ty_id);
    match kind {
        &type_intern::InternedTypeKind::Param(_) => true,
        &type_intern::InternedTypeKind::Infer(_) => true,
        &type_intern::InternedTypeKind::Ref { inner, mutable: _ } => ty_id_contains_param(inner),
        _ => false,
    }
}

/// Rebuilds a struct's LLVM type with concrete type args from a TyListId.
/// Substitutes Param/Infer field types with the corresponding arg from `args`.
fn rebuild_struct_with_args_id(
    ctx: &mut codegen_ctx::CodegenCtx,
    def_id: u32,
    args: type_intern::TyListId,
) -> String {
    // Collect field info to avoid holding reference into ctx
    let mut field_hir_types: Vec<Option<type_intern::TyId>> = Vec::new();
    let mut field_llvm_types: Vec<String> = Vec::new();
    match ctx.lookup_struct(def_id) {
        Option::Some(layout) => {
            let mut i: usize = 0;
            while i < layout.fields.len() {
                field_hir_types.push(layout.fields[i].hir_type);
                field_llvm_types.push(common::make_string(layout.fields[i].llvm_type.as_str()));
                i = i + 1;
            }
        }
        Option::None => {}
    }

    let interner = type_intern::type_interner();
    let arg_len = interner.ty_list_len(args);
    let mut result = common::make_string("{ ");
    let mut param_idx: usize = 0;
    let mut fi: usize = 0;
    while fi < field_hir_types.len() {
        if fi > 0 {
            result.push_str(", ");
        }
        let field_ty = match &field_hir_types[fi] {
            &Option::Some(ty_id) => {
                substitute_param_type_id(ctx, ty_id, args, arg_len, &mut param_idx)
            }
            &Option::None => {
                common::make_string(field_llvm_types[fi].as_str())
            }
        };
        result.push_str(field_ty.as_str());
        fi = fi + 1;
    }
    result.push_str(" }");
    result
}

/// Substitutes Param/Infer types with concrete args from a TyListId.
fn substitute_param_type_id(
    ctx: &mut codegen_ctx::CodegenCtx,
    ty_id: type_intern::TyId,
    args: type_intern::TyListId,
    arg_len: usize,
    param_idx: &mut usize,
) -> String {
    let kind = type_intern::type_interner().get(ty_id);
    match kind {
        &type_intern::InternedTypeKind::Param(_) => {
            let idx = *param_idx;
            if idx < arg_len {
                *param_idx = idx + 1;
                let arg_id = type_intern::type_interner().get_ty_list_element(args, idx);
                type_to_llvm_with_ctx_id(ctx, arg_id)
            } else {
                let mut err_msg = common::make_string("Param type index ");
                err_msg.push_str(codegen_types::format_u64(idx as u64).as_str());
                err_msg.push_str(" exceeds available type args (");
                err_msg.push_str(codegen_types::format_u64(arg_len as u64).as_str());
                err_msg.push(')');
                ctx.codegen_error(codegen_ctx::CodegenErrorKind::TypeSubstitutionFailed, err_msg);
                common::make_string("ptr")
            }
        }
        &type_intern::InternedTypeKind::Infer(_) => {
            let idx = *param_idx;
            if idx < arg_len {
                *param_idx = idx + 1;
                let arg_id = type_intern::type_interner().get_ty_list_element(args, idx);
                type_to_llvm_with_ctx_id(ctx, arg_id)
            } else {
                let mut err_msg = common::make_string("Infer type index ");
                err_msg.push_str(codegen_types::format_u64(idx as u64).as_str());
                err_msg.push_str(" exceeds available type args (");
                err_msg.push_str(codegen_types::format_u64(arg_len as u64).as_str());
                err_msg.push(')');
                ctx.codegen_error(codegen_ctx::CodegenErrorKind::TypeSubstitutionFailed, err_msg);
                common::make_string("ptr")
            }
        }
        _ => type_to_llvm_with_ctx_id(ctx, ty_id),
    }
}

// ============================================================
// Internal Helpers
// ============================================================

/// Checks whether an ADT is registered in the struct/enum registry or is a known
/// builtin ADT (Vec, String, HashMap, Box).
fn is_adt_registered(ctx: &mut codegen_ctx::CodegenCtx, def_id: u32) -> bool {
    match ctx.lookup_struct(def_id) {
        Option::Some(_) => { return true; }
        Option::None => {}
    }
    match ctx.lookup_enum(def_id) {
        Option::Some(_) => { return true; }
        Option::None => {}
    }
    match ctx.lookup_def_name(def_id) {
        Option::Some(name) => {
            let nb = name.as_bytes();
            // Vec
            if nb.len() == 3 && nb[0] == 86 && nb[1] == 101 && nb[2] == 99 {
                return true;
            }
            // String
            if nb.len() == 6 && nb[0] == 83 && nb[1] == 116 && nb[2] == 114 {
                return true;
            }
            // HashMap
            if nb.len() == 7 && nb[0] == 72 && nb[1] == 97 && nb[2] == 115 && nb[3] == 104 {
                return true;
            }
            // Box
            if nb.len() == 3 && nb[0] == 66 && nb[1] == 111 && nb[2] == 120 {
                return true;
            }
            false
        }
        Option::None => false,
    }
}

/// Gets the size of an ADT type from the registry.
fn adt_size_bytes(ctx: &mut codegen_ctx::CodegenCtx, def_id: u32) -> u64 {
    match ctx.lookup_struct(def_id) {
        Option::Some(layout) => {
            return compute_struct_size(layout);
        }
        Option::None => {}
    }
    match ctx.lookup_enum(def_id) {
        Option::Some(layout) => {
            return compute_enum_size(layout);
        }
        Option::None => {}
    }
    let llvm_ty = ctx.adt_llvm_type(def_id);
    llvm_type_size(llvm_ty.as_str())
}

/// Computes size of a struct from its layout, using proper field alignment.
fn compute_struct_size(layout: &codegen_ctx::StructLayout) -> u64 {
    let mut size: u64 = 0;
    let mut max_align: u64 = 1;
    let mut i: usize = 0;
    while i < layout.fields.len() {
        let field = &layout.fields[i];
        let field_size = llvm_type_size(field.llvm_type.as_str());
        let field_align = llvm_type_alignment(field.llvm_type.as_str());
        if field_align > max_align {
            max_align = field_align;
        }
        // Align current offset to field's natural alignment
        let padding = (field_align - (size % field_align)) % field_align;
        size = size + padding + field_size;
        i = i + 1;
    }
    if size == 0 {
        let from_type = llvm_type_size(layout.llvm_type.as_str());
        if from_type > 0 {
            return from_type;
        }
        return 8;
    }
    // Final padding to struct alignment (max of all field alignments)
    let final_padding = (max_align - (size % max_align)) % max_align;
    size + final_padding
}

/// Computes size of an enum from its layout.
/// The layout's llvm_type is the correct struct type (e.g. { i32, [3 x i64] }).
fn compute_enum_size(layout: &codegen_ctx::EnumLayout) -> u64 {
    llvm_type_size(layout.llvm_type.as_str())
}

/// Builds an enum LLVM type string with i32 discriminant and alignment-aware payload.
/// Selects the array element type based on max_align: i64, i32, i16, or i8.
pub fn build_enum_type_string(payload_size: u64, max_align: u64) -> String {
    let mut s = common::make_string("{ i32, [");
    if max_align >= 8 {
        let num_elements = (payload_size + 7) / 8;
        let count_str = codegen_types::format_u64(num_elements);
        s.push_str(count_str.as_str());
        s.push_str(" x i64] }");
    } else if max_align >= 4 {
        let num_elements = (payload_size + 3) / 4;
        let count_str = codegen_types::format_u64(num_elements);
        s.push_str(count_str.as_str());
        s.push_str(" x i32] }");
    } else if max_align >= 2 {
        let num_elements = (payload_size + 1) / 2;
        let count_str = codegen_types::format_u64(num_elements);
        s.push_str(count_str.as_str());
        s.push_str(" x i16] }");
    } else {
        let size_str = codegen_types::format_u64(payload_size);
        s.push_str(size_str.as_str());
        s.push_str(" x i8] }");
    }
    s
}

/// Estimates the size of an LLVM type from its string representation.
pub fn llvm_type_size(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    if bytes.len() == 0 {
        return 8;
    }
    // i1 -> 1 byte
    if bytes.len() == 2 && bytes[0] == 105 && bytes[1] == 49 {
        return 1;
    }
    // i8 -> 1 byte
    if bytes.len() == 2 && bytes[0] == 105 && bytes[1] == 56 {
        return 1;
    }
    // i16 -> 2 bytes
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 49 && bytes[2] == 54 {
        return 2;
    }
    // i32 -> 4 bytes
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 51 && bytes[2] == 50 {
        return 4;
    }
    // i64 -> 8 bytes
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 54 && bytes[2] == 52 {
        return 8;
    }
    // i128 -> 16 bytes
    if bytes.len() == 4 && bytes[0] == 105 && bytes[1] == 49 && bytes[2] == 50 && bytes[3] == 56 {
        return 16;
    }
    // ptr -> 8 bytes
    if bytes.len() == 3 && bytes[0] == 112 && bytes[1] == 116 && bytes[2] == 114 {
        return 8;
    }
    // float -> 4 bytes
    if bytes.len() == 5 && bytes[0] == 102 && bytes[1] == 108 {
        return 4;
    }
    // double -> 8 bytes
    if bytes.len() == 6 && bytes[0] == 100 && bytes[1] == 111 {
        return 8;
    }
    // Struct { ... }
    if bytes[0] == 123 {
        return parse_struct_size(ty);
    }
    // Array [N x T]
    if bytes[0] == 91 {
        return parse_array_size(ty);
    }
    8
}

/// Parses a struct type string and computes its size using proper alignment.
/// Each field is aligned to its natural alignment, and the struct is padded
/// to a multiple of the max field alignment.
fn parse_struct_size(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    let mut offset: u64 = 0;
    let mut max_align: u64 = 1;
    let mut i: usize = 0;
    let mut depth: i32 = 0;
    let mut field_start: usize = 0;
    let mut field_count: u64 = 0;

    while i < bytes.len() {
        let c = bytes[i];
        if c == 123 {
            depth = depth + 1;
            if depth == 1 {
                field_start = i + 1;
            }
        } else if c == 125 {
            if depth == 1 && field_start < i {
                let field_ty = substring(ty, field_start, i);
                let trimmed = trim_whitespace(field_ty.as_str());
                if trimmed.len() > 0 {
                    let field_size = llvm_type_size(trimmed.as_str());
                    let field_align = llvm_type_alignment(trimmed.as_str());
                    if field_align > max_align {
                        max_align = field_align;
                    }
                    let padding = (field_align - (offset % field_align)) % field_align;
                    offset = offset + padding + field_size;
                    field_count = field_count + 1;
                }
            }
            depth = depth - 1;
        } else if c == 44 && depth == 1 {
            let field_ty = substring(ty, field_start, i);
            let trimmed = trim_whitespace(field_ty.as_str());
            if trimmed.len() > 0 {
                let field_size = llvm_type_size(trimmed.as_str());
                let field_align = llvm_type_alignment(trimmed.as_str());
                if field_align > max_align {
                    max_align = field_align;
                }
                let padding = (field_align - (offset % field_align)) % field_align;
                offset = offset + padding + field_size;
                field_count = field_count + 1;
            }
            field_start = i + 1;
        }
        i = i + 1;
    }

    if field_count == 0 {
        return 8;
    }
    // Final padding to struct alignment (max of all field alignments)
    let final_padding = (max_align - (offset % max_align)) % max_align;
    offset + final_padding
}

/// Parses an array type string `[N x T]` and returns N * sizeof(T).
fn parse_array_size(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    let mut i: usize = 1;
    while i < bytes.len() && bytes[i] == 32 {
        i = i + 1;
    }
    let mut count: u64 = 0;
    while i < bytes.len() && bytes[i] >= 48 && bytes[i] <= 57 {
        count = count * 10 + ((bytes[i] - 48) as u64);
        i = i + 1;
    }
    while i < bytes.len() && (bytes[i] == 32 || bytes[i] == 120) {
        i = i + 1;
    }
    let elem_start = i;
    let mut elem_end = bytes.len();
    let mut j: usize = bytes.len();
    while j > elem_start {
        j = j - 1;
        if bytes[j] == 93 {
            elem_end = j;
            break;
        }
    }
    let elem_ty = substring(ty, elem_start, elem_end);
    let trimmed = trim_whitespace(elem_ty.as_str());
    let elem_size = llvm_type_size(trimmed.as_str());
    count * elem_size
}

/// Returns the ABI alignment of an LLVM type in bytes.
/// Follows LLVM's default data layout rules for x86_64:
///   i1, i8 -> 1, i16 -> 2, i32/float -> 4, i64/ptr/double -> 8
///   struct -> max alignment of fields, array [N x T] -> alignment of T
pub fn llvm_type_alignment(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    if bytes.len() == 0 {
        return 8;
    }
    // i1 -> 1
    if bytes.len() == 2 && bytes[0] == 105 && bytes[1] == 49 {
        return 1;
    }
    // i8 -> 1
    if bytes.len() == 2 && bytes[0] == 105 && bytes[1] == 56 {
        return 1;
    }
    // i16 -> 2
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 49 && bytes[2] == 54 {
        return 2;
    }
    // i32 -> 4
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 51 && bytes[2] == 50 {
        return 4;
    }
    // i64 -> 8
    if bytes.len() == 3 && bytes[0] == 105 && bytes[1] == 54 && bytes[2] == 52 {
        return 8;
    }
    // i128 -> 8 (on x86_64, i128 has 8-byte alignment)
    if bytes.len() == 4 && bytes[0] == 105 && bytes[1] == 49 && bytes[2] == 50 && bytes[3] == 56 {
        return 8;
    }
    // ptr -> 8
    if bytes.len() == 3 && bytes[0] == 112 && bytes[1] == 116 && bytes[2] == 114 {
        return 8;
    }
    // float -> 4
    if bytes.len() == 5 && bytes[0] == 102 && bytes[1] == 108 {
        return 4;
    }
    // double -> 8
    if bytes.len() == 6 && bytes[0] == 100 && bytes[1] == 111 {
        return 8;
    }
    // Struct { ... } -> max alignment of fields
    if bytes[0] == 123 {
        return parse_struct_alignment(ty);
    }
    // Array [N x T] -> alignment of element type
    if bytes[0] == 91 {
        return parse_array_alignment(ty);
    }
    8
}

/// Parses a struct type string and returns the max field alignment.
fn parse_struct_alignment(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    let mut max_align: u64 = 1;
    let mut i: usize = 0;
    let mut depth: i32 = 0;
    let mut field_start: usize = 0;

    while i < bytes.len() {
        let c = bytes[i];
        if c == 123 {
            depth = depth + 1;
            if depth == 1 {
                field_start = i + 1;
            }
        } else if c == 125 {
            if depth == 1 && field_start < i {
                let field_ty = substring(ty, field_start, i);
                let trimmed = trim_whitespace(field_ty.as_str());
                if trimmed.len() > 0 {
                    let a = llvm_type_alignment(trimmed.as_str());
                    if a > max_align {
                        max_align = a;
                    }
                }
            }
            depth = depth - 1;
        } else if c == 44 && depth == 1 {
            let field_ty = substring(ty, field_start, i);
            let trimmed = trim_whitespace(field_ty.as_str());
            if trimmed.len() > 0 {
                let a = llvm_type_alignment(trimmed.as_str());
                if a > max_align {
                    max_align = a;
                }
            }
            field_start = i + 1;
        }
        i = i + 1;
    }
    max_align
}

/// Parses an array type string `[N x T]` and returns alignment of T.
fn parse_array_alignment(ty: &str) -> u64 {
    let bytes = ty.as_bytes();
    // Skip '['
    let mut i: usize = 1;
    // Skip whitespace
    while i < bytes.len() && bytes[i] == 32 {
        i = i + 1;
    }
    // Skip the count N
    while i < bytes.len() && bytes[i] >= 48 && bytes[i] <= 57 {
        i = i + 1;
    }
    // Skip " x "
    while i < bytes.len() && (bytes[i] == 32 || bytes[i] == 120) {
        i = i + 1;
    }
    let elem_start = i;
    let mut elem_end = bytes.len();
    let mut j: usize = bytes.len();
    while j > elem_start {
        j = j - 1;
        if bytes[j] == 93 {
            elem_end = j;
            break;
        }
    }
    let elem_ty = substring(ty, elem_start, elem_end);
    let trimmed = trim_whitespace(elem_ty.as_str());
    llvm_type_alignment(trimmed.as_str())
}

// ============================================================
// String Helpers
// ============================================================

fn substring(s: &str, start: usize, end: usize) -> String {
    let bytes = s.as_bytes();
    let mut result = String::new();
    let mut i = start;
    while i < end && i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

fn trim_whitespace(s: &str) -> String {
    let bytes = s.as_bytes();
    let mut start: usize = 0;
    let mut end: usize = bytes.len();

    while start < bytes.len() && (bytes[start] == 32 || bytes[start] == 9) {
        start = start + 1;
    }
    while end > start && (bytes[end - 1] == 32 || bytes[end - 1] == 9) {
        end = end - 1;
    }

    substring(s, start, end)
}
