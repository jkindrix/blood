// Blood Self-Hosted Compiler - MIR Expression Lowering
//
// This module handles lowering HIR expressions to MIR. Each HIR expression
// is translated into a sequence of MIR statements and terminators.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod mir_lower_ctx;
mod mir_lower_util;
mod mir_lower_pattern;

// ============================================================
// Cross-Module Helper Functions
// ============================================================
// Uses mir_lower_ctx::Destination and standalone helper functions:
// - mir_lower_ctx::destination_local(id) - for local destinations
// - mir_lower_ctx::destination_return_place() - for return destinations
// - mir_lower_ctx::destination_ignore() - for ignored destinations
// - mir_lower_ctx::Destination::Place(...) - direct variant construction

/// Lowers an expression, storing the result to the return place.
/// This is a convenience function for use from other modules.
pub fn lower_expr_to_return(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    expr: &hir_expr::Expr,
) {
    lower_expr(ctx, expr, mir_lower_ctx::destination_return_place());
}

/// Lowers an expression, storing the result to a specific place.
/// This is a convenience function for use from other modules.
pub fn lower_expr_to_place(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    expr: &hir_expr::Expr,
    place: mir_types::Place,
) {
    lower_expr(ctx, expr, mir_lower_ctx::Destination::Place(place));
}

/// Lowers an expression for side effects only, ignoring the result.
/// This is a convenience function for use from other modules.
pub fn lower_expr_for_effects(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    expr: &hir_expr::Expr,
) {
    lower_expr(ctx, expr, mir_lower_ctx::destination_ignore());
}

// ============================================================
// Expression Lowering
// ============================================================

/// Lowers an HIR expression into MIR, storing the result in the destination.
///
/// The destination specifies where to put the result. If Ignore, the
/// expression is evaluated for side effects only.
pub fn lower_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    expr: &hir_expr::Expr,
    dest: mir_lower_ctx::Destination,
) {
    // Resolve the expression's type through the substitution table
    // so all sub-functions receive concrete types instead of TypeKind::Infer
    let resolved_ty = ctx.resolve_type(&expr.ty);

    match &expr.kind {
        &hir_expr::ExprKind::Literal(ref lit) => {
            lower_literal_expr(ctx, lit, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Local(local_id) => {
            lower_local_expr(ctx, local_id, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Path(ref path) => {
            lower_path_expr(ctx, path, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Binary { op: the_op, ref left, ref right } => {
            lower_binary_expr(ctx, the_op, left.as_ref(), right.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Unary { op: the_op, ref operand } => {
            lower_unary_expr(ctx, the_op, operand.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Call { ref callee, ref args } => {
            lower_call_expr(ctx, callee.as_ref(), args, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::MethodCall { ref receiver, ref method, method_def, ref type_args, ref args } => {
            lower_method_call_expr(ctx, receiver.as_ref(), method, method_def, type_args, args, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Field { ref base, ref field } => {
            lower_field_expr(ctx, base.as_ref(), field, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            lower_index_expr(ctx, base.as_ref(), idx.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Tuple(ref elems) => {
            lower_tuple_expr(ctx, elems, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Array(ref arr) => {
            lower_array_expr(ctx, arr, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Struct { ref path, ref fields, ref base } => {
            lower_struct_expr(ctx, path, fields, base, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::AnonRecord { ref fields } => {
            lower_anon_record_expr(ctx, fields, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Range { ref start, ref end_val, inclusive } => {
            lower_range_expr(ctx, start, end_val, inclusive, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Cast { expr: ref inner, ty: ref cast_ty } => {
            lower_cast_expr(ctx, inner.as_ref(), cast_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Assign { ref target, ref val } => {
            lower_assign_expr(ctx, target.as_ref(), val.as_ref(), dest, expr.span);
        }
        &hir_expr::ExprKind::AssignOp { op: the_op, ref target, ref val } => {
            lower_assign_op_expr(ctx, the_op, target.as_ref(), val.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::AddrOf { mutable, expr: ref inner } => {
            lower_addr_of_expr(ctx, mutable, inner.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Block(ref block) => {
            lower_block_expr(ctx, block, dest, expr.span);
        }
        &hir_expr::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            lower_if_expr(ctx, condition.as_ref(), then_branch.as_ref(), else_branch, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Match { ref scrutinee, ref arms } => {
            lower_match_expr(ctx, scrutinee.as_ref(), arms, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Loop { ref label, ref body } => {
            lower_loop_expr(ctx, label, body.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Return(ref val) => {
            lower_return_expr(ctx, val, expr.span);
        }
        &hir_expr::ExprKind::Break { ref label, ref val } => {
            lower_break_expr(ctx, label, val, expr.span);
        }
        &hir_expr::ExprKind::Continue { ref label } => {
            lower_continue_expr(ctx, label, expr.span);
        }
        &hir_expr::ExprKind::Closure { ref captures, ref params, ref return_ty, ref body, body_id } => {
            lower_closure_expr(ctx, captures, params, return_ty, body.as_ref(), body_id, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::WithHandle { handler: ref handler_expr, body: ref body_expr } => {
            lower_with_handle_expr(ctx, handler_expr.as_ref(), body_expr.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Perform { effect_def, op_def, ref args } => {
            lower_perform_expr(ctx, effect_def, op_def, args, &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Resume(ref val) => {
            lower_resume_expr(ctx, val.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Try(ref inner) => {
            lower_try_expr(ctx, inner.as_ref(), &resolved_ty, dest, expr.span);
        }
        &hir_expr::ExprKind::Unsafe(ref inner) => {
            // Unsafe blocks are transparent in MIR
            lower_expr(ctx, inner.as_ref(), dest);
        }
        &hir_expr::ExprKind::Default => {
            // Default expression: produce zero-initialized value
            // TODO: In the future, call Default trait method if available
            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::ZeroInit(resolved_ty),
                        expr.span,
                    );
                }
                Option::None => {}
            }
        }
        &hir_expr::ExprKind::Error => {
            // Error expression: produce undefined value
            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::ZeroInit(ctx.resolve_type(&expr.ty)),
                        expr.span,
                    );
                }
                Option::None => {}
            }
        }
    }
}

// ============================================================
// Individual Expression Lowering
// ============================================================

fn lower_literal_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    lit: &hir_expr::Literal,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    match dest.as_place() {
        Option::Some(place) => {
            let constant = mir_lower_util::lower_literal(lit, ty);
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Use(mir_types::Operand::Constant(constant)),
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_local_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    local_id: hir_def::LocalId,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    match dest.as_place() {
        Option::Some(place) => {
            let mir_local = ctx.lookup_local(local_id);
            match mir_local {
                Option::Some(local) => {
                    let source_place = mir_types::Place::local(local);
                    let operand = mir_lower_util::operand_from_place(source_place, ty);
                    ctx.emit_assign(place, mir_types::Rvalue::Use(operand), span);
                }
                Option::None => {
                    // Local not found - error recovery
                    ctx.emit_assign(place, mir_types::Rvalue::ZeroInit(ty.clone()), span);
                }
            }
        }
        Option::None => {}
    }
}

fn lower_path_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    path: &hir_def::ResolvedPath,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    match dest.as_place() {
        Option::Some(place) => {
            // Path could be a function, constant, or static
            let constant = mir_types::Constant::new(
                ty.clone(),
                mir_types::ConstantKind::FnDef(path.def_id),
            );
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Use(mir_types::Operand::Constant(constant)),
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_binary_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    bin_op: common::BinOp,
    left: &hir_expr::Expr,
    right: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Check for short-circuit operators
    if mir_lower_util::is_short_circuit_op(bin_op) {
        lower_short_circuit_binary(ctx, bin_op, left, right, ty, dest, span);
        return;
    }

    // Normal binary operation
    let mir_op = mir_lower_util::convert_binop(bin_op);
    match mir_op {
        Option::Some(mir_bin_op) => {
            // Evaluate operands
            let left_temp = ctx.new_temp(left.ty.clone(), span);
            lower_expr(ctx, left, mir_lower_ctx::destination_local(left_temp));

            let right_temp = ctx.new_temp(right.ty.clone(), span);
            lower_expr(ctx, right, mir_lower_ctx::destination_local(right_temp));

            match dest.as_place() {
                Option::Some(place) => {
                    let left_operand = mir_lower_util::operand_from_place(
                        mir_types::Place::local(left_temp),
                        &left.ty,
                    );
                    let right_operand = mir_lower_util::operand_from_place(
                        mir_types::Place::local(right_temp),
                        &right.ty,
                    );
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::BinaryOp {
                            op: mir_bin_op,
                            left: left_operand,
                            right: right_operand,
                        },
                        span,
                    );
                }
                Option::None => {}
            }
        }
        Option::None => {
            // Pipe operator or other special handling
            // For pipe: left |> right means right(left)
            match bin_op {
                common::BinOp::Pipe => {
                    // Evaluate left side first
                    let left_temp = ctx.new_temp(left.ty.clone(), span);
                    lower_expr(ctx, left, mir_lower_ctx::destination_local(left_temp));

                    // Call right with left as argument
                    let func_temp = ctx.new_temp(right.ty.clone(), span);
                    lower_expr(ctx, right, mir_lower_ctx::destination_local(func_temp));

                    match dest.as_place() {
                        Option::Some(place) => {
                            let func_operand = mir_types::Operand::Copy(mir_types::Place::local(func_temp));
                            let mut args = Vec::new();
                            args.push(mir_lower_util::operand_from_place(
                                mir_types::Place::local(left_temp),
                                &left.ty,
                            ));
                            let next_block = ctx.new_block();
                            ctx.terminate_call(func_operand, args, place, next_block, span);
                            ctx.set_current_block(next_block);
                        }
                        Option::None => {}
                    }
                }
                _ => {
                    // Should not happen
                }
            }
        }
    }
}

fn lower_short_circuit_binary(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    bin_op: common::BinOp,
    left: &hir_expr::Expr,
    right: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // For && and ||, we need to conditionally evaluate the right side
    let result_place = match dest.as_place() {
        Option::Some(p) => p,
        Option::None => {
            // No destination, still need to evaluate for side effects
            let temp = ctx.new_temp(ty.clone(), span);
            mir_types::Place::local(temp)
        }
    };

    // Evaluate left side
    let left_temp = ctx.new_temp(left.ty.clone(), span);
    lower_expr(ctx, left, mir_lower_ctx::destination_local(left_temp));

    // Create blocks
    let eval_right_block = ctx.new_block();
    let skip_right_block = ctx.new_block();
    let join_block = ctx.new_block();

    let left_operand = mir_types::Operand::Copy(mir_types::Place::local(left_temp));

    match bin_op {
        common::BinOp::And => {
            // If left is false, result is false; otherwise evaluate right
            ctx.terminate_if(left_operand, eval_right_block, skip_right_block, span);

            // Skip right block: result = false
            ctx.set_current_block(skip_right_block);
            ctx.emit_assign(
                result_place.clone(),
                mir_types::Rvalue::Use(mir_types::Operand::Constant(mir_types::Constant::bool_val(false))),
                span,
            );
            ctx.terminate_goto(join_block, span);
        }
        common::BinOp::Or => {
            // If left is true, result is true; otherwise evaluate right
            ctx.terminate_if(left_operand, skip_right_block, eval_right_block, span);

            // Skip right block: result = true
            ctx.set_current_block(skip_right_block);
            ctx.emit_assign(
                result_place.clone(),
                mir_types::Rvalue::Use(mir_types::Operand::Constant(mir_types::Constant::bool_val(true))),
                span,
            );
            ctx.terminate_goto(join_block, span);
        }
        _ => {
            // Should not happen
            ctx.terminate_goto(join_block, span);
        }
    }

    // Evaluate right block
    ctx.set_current_block(eval_right_block);
    lower_expr(ctx, right, mir_lower_ctx::Destination::Place(result_place.clone()));
    ctx.terminate_goto(join_block, span);

    // Continue from join block
    ctx.set_current_block(join_block);
}

fn lower_unary_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    unary_op: common::UnaryOp,
    operand: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    match unary_op {
        common::UnaryOp::Deref => {
            // Evaluate to a place and deref
            let ptr_temp = ctx.new_temp(operand.ty.clone(), span);
            lower_expr(ctx, operand, mir_lower_ctx::destination_local(ptr_temp));

            match dest.as_place() {
                Option::Some(place) => {
                    let deref_place = mir_types::Place::local(ptr_temp)
                        .project(mir_types::PlaceElem::Deref);
                    let result_operand = mir_lower_util::operand_from_place(deref_place, ty);
                    ctx.emit_assign(place, mir_types::Rvalue::Use(result_operand), span);
                }
                Option::None => {}
            }
        }
        common::UnaryOp::Ref => {
            // Take a reference
            let temp = ctx.new_temp(operand.ty.clone(), span);
            lower_expr(ctx, operand, mir_lower_ctx::destination_local(temp));

            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Ref {
                            place: mir_types::Place::local(temp),
                            mutable: false,
                        },
                        span,
                    );
                }
                Option::None => {}
            }
        }
        common::UnaryOp::RefMut => {
            // Take a mutable reference
            let temp = ctx.new_temp(operand.ty.clone(), span);
            lower_expr(ctx, operand, mir_lower_ctx::destination_local(temp));

            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Ref {
                            place: mir_types::Place::local(temp),
                            mutable: true,
                        },
                        span,
                    );
                }
                Option::None => {}
            }
        }
        common::UnaryOp::Neg => {
            lower_simple_unary(ctx, mir_types::MirUnOp::Neg, operand, ty, dest, span);
        }
        common::UnaryOp::Not => {
            lower_simple_unary(ctx, mir_types::MirUnOp::Not, operand, ty, dest, span);
        }
    }
}

fn lower_simple_unary(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    mir_op: mir_types::MirUnOp,
    operand: &hir_expr::Expr,
    _ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    let temp = ctx.new_temp(operand.ty.clone(), span);
    lower_expr(ctx, operand, mir_lower_ctx::destination_local(temp));

    match dest.as_place() {
        Option::Some(place) => {
            let result_operand = mir_lower_util::operand_from_place(mir_types::Place::local(temp), &operand.ty);
            ctx.emit_assign(
                place,
                mir_types::Rvalue::UnaryOp { op: mir_op, operand: result_operand },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_call_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    callee: &hir_expr::Expr,
    args: &Vec<hir_expr::Expr>,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate callee
    let func_temp = ctx.new_temp(callee.ty.clone(), span);
    lower_expr(ctx, callee, mir_lower_ctx::destination_local(func_temp));

    // Evaluate arguments
    let mut arg_operands = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg = &args[i];
        let arg_temp = ctx.new_temp(arg.ty.clone(), span);
        lower_expr(ctx, arg, mir_lower_ctx::destination_local(arg_temp));
        arg_operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(arg_temp),
            &arg.ty,
        ));
        i = i + 1;
    }

    // Create call
    let dest_place = match dest.as_place() {
        Option::Some(p) => p,
        Option::None => {
            let temp = ctx.new_temp(ty.clone(), span);
            mir_types::Place::local(temp)
        }
    };

    let func_operand = mir_types::Operand::Copy(mir_types::Place::local(func_temp));
    let next_block = ctx.new_block();
    ctx.terminate_call(func_operand, arg_operands, dest_place, next_block, span);
    ctx.set_current_block(next_block);
}

fn lower_method_call_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    receiver: &hir_expr::Expr,
    _method: &common::SpannedSymbol,
    method_def: Option<hir_def::DefId>,
    _type_args: &Vec<hir_ty::Type>,
    args: &Vec<hir_expr::Expr>,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate receiver
    let recv_temp = ctx.new_temp(receiver.ty.clone(), span);
    lower_expr(ctx, receiver, mir_lower_ctx::destination_local(recv_temp));

    // Build argument list (receiver first)
    let mut arg_operands = Vec::new();
    arg_operands.push(mir_lower_util::operand_from_place(
        mir_types::Place::local(recv_temp),
        &receiver.ty,
    ));

    // Evaluate remaining arguments
    let mut i: usize = 0;
    while i < args.len() {
        let arg = &args[i];
        let arg_temp = ctx.new_temp(arg.ty.clone(), span);
        lower_expr(ctx, arg, mir_lower_ctx::destination_local(arg_temp));
        arg_operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(arg_temp),
            &arg.ty,
        ));
        i = i + 1;
    }

    // Get method function
    let func_operand = match method_def {
        Option::Some(def_id) => {
            mir_types::Operand::Constant(mir_types::Constant::new(
                hir_ty::Type::error(),
                mir_types::ConstantKind::FnDef(def_id),
            ))
        }
        Option::None => {
            // Method not resolved - error recovery
            mir_types::Operand::Constant(mir_types::Constant::unit())
        }
    };

    // Create call
    let dest_place = match dest.as_place() {
        Option::Some(p) => p,
        Option::None => {
            let temp = ctx.new_temp(ty.clone(), span);
            mir_types::Place::local(temp)
        }
    };

    let next_block = ctx.new_block();
    ctx.terminate_call(func_operand, arg_operands, dest_place, next_block, span);
    ctx.set_current_block(next_block);
}

fn lower_field_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    base: &hir_expr::Expr,
    field: &hir_expr::FieldAccess,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate base
    let base_temp = ctx.new_temp(base.ty.clone(), span);
    lower_expr(ctx, base, mir_lower_ctx::destination_local(base_temp));

    // Get field index
    let field_idx = match field {
        &hir_expr::FieldAccess::Named { name: _, field_idx } => {
            match field_idx {
                Option::Some(idx) => idx,
                Option::None => 0,
            }
        }
        &hir_expr::FieldAccess::Index(idx) => idx,
    };

    match dest.as_place() {
        Option::Some(place) => {
            let field_place = mir_types::Place::local(base_temp)
                .project(mir_types::PlaceElem::Field(field_idx));
            let operand = mir_lower_util::operand_from_place(field_place, ty);
            ctx.emit_assign(place, mir_types::Rvalue::Use(operand), span);
        }
        Option::None => {}
    }
}

fn lower_index_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    base: &hir_expr::Expr,
    idx: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate base
    let base_temp = ctx.new_temp(base.ty.clone(), span);
    lower_expr(ctx, base, mir_lower_ctx::destination_local(base_temp));

    // Evaluate index
    let idx_temp = ctx.new_temp(idx.ty.clone(), span);
    lower_expr(ctx, idx, mir_lower_ctx::destination_local(idx_temp));

    match dest.as_place() {
        Option::Some(place) => {
            let indexed_place = mir_types::Place::local(base_temp)
                .project(mir_types::PlaceElem::Index(idx_temp));
            let operand = mir_lower_util::operand_from_place(indexed_place, ty);
            ctx.emit_assign(place, mir_types::Rvalue::Use(operand), span);
        }
        Option::None => {}
    }
}

fn lower_tuple_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    elems: &Vec<hir_expr::Expr>,
    _ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate all elements
    let mut operands = Vec::new();
    let mut i: usize = 0;
    while i < elems.len() {
        let elem = &elems[i];
        let temp = ctx.new_temp(elem.ty.clone(), span);
        lower_expr(ctx, elem, mir_lower_ctx::destination_local(temp));
        operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(temp),
            &elem.ty,
        ));
        i = i + 1;
    }

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Aggregate {
                    kind: mir_types::AggregateKind::Tuple,
                    operands: operands,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_array_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    arr: &hir_expr::ArrayExpr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    match arr {
        &hir_expr::ArrayExpr::List(ref elems) => {
            // Array literal [a, b, c]
            let mut operands = Vec::new();
            let elem_ty = get_array_element_type(ty);
            let mut i: usize = 0;
            while i < elems.len() {
                let elem = &elems[i];
                let temp = ctx.new_temp(elem.ty.clone(), span);
                lower_expr(ctx, elem, mir_lower_ctx::destination_local(temp));
                operands.push(mir_lower_util::operand_from_place(
                    mir_types::Place::local(temp),
                    &elem.ty,
                ));
                i = i + 1;
            }

            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Aggregate {
                            kind: mir_types::AggregateKind::Array(elem_ty),
                            operands: operands,
                        },
                        span,
                    );
                }
                Option::None => {}
            }
        }
        &hir_expr::ArrayExpr::Repeat { ref val, count } => {
            // Array repeat [val; count]
            let val_temp = ctx.new_temp(val.as_ref().ty.clone(), span);
            lower_expr(ctx, val.as_ref(), mir_lower_ctx::destination_local(val_temp));

            let mut operands = Vec::new();
            let elem_ty = val.as_ref().ty.clone();
            let mut i: u64 = 0;
            while i < count {
                operands.push(mir_types::Operand::Copy(mir_types::Place::local(val_temp)));
                i = i + 1;
            }

            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Aggregate {
                            kind: mir_types::AggregateKind::Array(elem_ty),
                            operands: operands,
                        },
                        span,
                    );
                }
                Option::None => {}
            }
        }
    }
}

fn get_array_element_type(ty: &hir_ty::Type) -> hir_ty::Type {
    match &ty.kind {
        &hir_ty::TypeKind::Array { ref element, size: _ } => element.as_ref().clone(),
        _ => hir_ty::Type::error(),
    }
}

fn lower_struct_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    path: &hir_def::ResolvedPath,
    fields: &Vec<hir_expr::FieldExpr>,
    _base: &Option<Box<hir_expr::Expr>>,
    _ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate all field values
    let mut operands = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let field = &fields[i];
        let temp = ctx.new_temp(field.val.ty.clone(), span);
        lower_expr(ctx, &field.val, mir_lower_ctx::destination_local(temp));
        operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(temp),
            &field.val.ty,
        ));
        i = i + 1;
    }

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Aggregate {
                    kind: mir_types::AggregateKind::Adt {
                        def_id: path.def_id,
                        variant_idx: 0,
                        type_args: Vec::new(),
                    },
                    operands: operands,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_anon_record_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    fields: &Vec<hir_expr::AnonRecordField>,
    _ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate all field values
    let mut operands = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let field = &fields[i];
        let temp = ctx.new_temp(field.val.ty.clone(), span);
        lower_expr(ctx, &field.val, mir_lower_ctx::destination_local(temp));
        operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(temp),
            &field.val.ty,
        ));
        i = i + 1;
    }

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Aggregate {
                    kind: mir_types::AggregateKind::Record,
                    operands: operands,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_range_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    start: &Option<Box<hir_expr::Expr>>,
    end_val: &Option<Box<hir_expr::Expr>>,
    inclusive: bool,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    let mut operands = Vec::new();

    // Evaluate start if present
    match start {
        &Option::Some(ref s) => {
            let temp = ctx.new_temp(s.as_ref().ty.clone(), span);
            lower_expr(ctx, s.as_ref(), mir_lower_ctx::destination_local(temp));
            operands.push(mir_lower_util::operand_from_place(
                mir_types::Place::local(temp),
                &s.as_ref().ty,
            ));
        }
        &Option::None => {}
    }

    // Evaluate end if present
    match end_val {
        &Option::Some(ref e) => {
            let temp = ctx.new_temp(e.as_ref().ty.clone(), span);
            lower_expr(ctx, e.as_ref(), mir_lower_ctx::destination_local(temp));
            operands.push(mir_lower_util::operand_from_place(
                mir_types::Place::local(temp),
                &e.as_ref().ty,
            ));
        }
        &Option::None => {}
    }

    let elem_ty = get_range_element_type(ty);

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Aggregate {
                    kind: mir_types::AggregateKind::Range {
                        element: elem_ty,
                        inclusive: inclusive,
                    },
                    operands: operands,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn get_range_element_type(_ty: &hir_ty::Type) -> hir_ty::Type {
    // Range types encode their element type in their ADT
    // For simplicity, default to usize
    hir_ty::Type::usize_ty()
}

fn lower_cast_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    inner: &hir_expr::Expr,
    target_ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    let temp = ctx.new_temp(inner.ty.clone(), span);
    lower_expr(ctx, inner, mir_lower_ctx::destination_local(temp));

    match dest.as_place() {
        Option::Some(place) => {
            let operand = mir_lower_util::operand_from_place(
                mir_types::Place::local(temp),
                &inner.ty,
            );
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Cast {
                    operand: operand,
                    target_ty: target_ty.clone(),
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_assign_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    _dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate target to a place
    let target_place = expr_to_place(ctx, target, span);

    // Evaluate value
    let val_temp = ctx.new_temp(val.ty.clone(), span);
    lower_expr(ctx, val, mir_lower_ctx::destination_local(val_temp));

    // Assign
    let operand = mir_lower_util::operand_from_place(
        mir_types::Place::local(val_temp),
        &val.ty,
    );
    ctx.emit_assign(target_place, mir_types::Rvalue::Use(operand), span);

    // Assignment expressions have unit type
}

fn lower_assign_op_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    bin_op: common::BinOp,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    _ty: &hir_ty::Type,
    _dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // target op= val means target = target op val
    let target_place = expr_to_place(ctx, target, span);

    // Read current value
    let current_temp = ctx.new_temp(target.ty.clone(), span);
    let current_operand = mir_lower_util::operand_from_place(target_place.clone(), &target.ty);
    ctx.emit_assign(
        mir_types::Place::local(current_temp),
        mir_types::Rvalue::Use(current_operand),
        span,
    );

    // Evaluate right side
    let val_temp = ctx.new_temp(val.ty.clone(), span);
    lower_expr(ctx, val, mir_lower_ctx::destination_local(val_temp));

    // Perform operation
    let mir_op = mir_lower_util::convert_binop(bin_op);
    match mir_op {
        Option::Some(mir_bin_op) => {
            let result_temp = ctx.new_temp(target.ty.clone(), span);
            let left_op = mir_types::Operand::Copy(mir_types::Place::local(current_temp));
            let right_op = mir_lower_util::operand_from_place(
                mir_types::Place::local(val_temp),
                &val.ty,
            );
            ctx.emit_assign(
                mir_types::Place::local(result_temp),
                mir_types::Rvalue::BinaryOp {
                    op: mir_bin_op,
                    left: left_op,
                    right: right_op,
                },
                span,
            );

            // Store result
            let result_op = mir_types::Operand::Move(mir_types::Place::local(result_temp));
            ctx.emit_assign(target_place, mir_types::Rvalue::Use(result_op), span);
        }
        Option::None => {}
    }
}

fn lower_addr_of_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    mutable: bool,
    inner: &hir_expr::Expr,
    _ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    let temp = ctx.new_temp(inner.ty.clone(), span);
    lower_expr(ctx, inner, mir_lower_ctx::destination_local(temp));

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::AddressOf {
                    place: mir_types::Place::local(temp),
                    mutable: mutable,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_block_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    block: &hir_expr::Block,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Lower each statement
    let mut i: usize = 0;
    while i < block.stmts.len() {
        lower_stmt(ctx, &block.stmts[i]);
        i = i + 1;
    }

    // Lower trailing expression if present
    match &block.expr {
        &Option::Some(ref e) => {
            lower_expr(ctx, e.as_ref(), dest);
        }
        &Option::None => {
            // Block has unit type
            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Use(mir_types::Operand::Constant(mir_types::Constant::unit())),
                        span,
                    );
                }
                Option::None => {}
            }
        }
    }
}

fn lower_stmt(ctx: &mut mir_lower_ctx::MirLowerCtx, stmt: &hir_expr::Stmt) {
    match stmt {
        &hir_expr::Stmt::Let { ref pattern, ty: _, ref init, span } => {
            // Evaluate initializer if present
            match init {
                &Option::Some(ref e) => {
                    let temp = ctx.new_temp(e.ty.clone(), span);
                    lower_expr(ctx, e, mir_lower_ctx::destination_local(temp));
                    mir_lower_pattern::lower_irrefutable_pattern(
                        ctx,
                        pattern,
                        mir_types::Place::local(temp),
                        span,
                    );
                }
                &Option::None => {
                    // Uninitialzed binding - just create the locals
                    // The pattern lowering will create the necessary locals
                }
            }
        }
        &hir_expr::Stmt::Expr { ref expr, has_semi: _ } => {
            lower_expr(ctx, expr, mir_lower_ctx::destination_ignore());
        }
        &hir_expr::Stmt::Item(_) => {
            // Item statements are processed separately
        }
    }
}

fn lower_if_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    condition: &hir_expr::Expr,
    then_branch: &hir_expr::Expr,
    else_branch: &Option<Box<hir_expr::Expr>>,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Create blocks
    let then_block = ctx.new_block();
    let else_block = ctx.new_block();
    let join_block = ctx.new_block();

    // Evaluate condition
    let cond_temp = ctx.new_temp(condition.ty.clone(), span);
    lower_expr(ctx, condition, mir_lower_ctx::destination_local(cond_temp));

    let cond_operand = mir_types::Operand::Copy(mir_types::Place::local(cond_temp));
    ctx.terminate_if(cond_operand, then_block, else_block, span);

    // Lower then branch
    ctx.set_current_block(then_block);
    lower_expr(ctx, then_branch, dest.clone());
    if !ctx.is_terminated() {
        ctx.terminate_goto(join_block, span);
    }

    // Lower else branch
    ctx.set_current_block(else_block);
    match else_branch {
        &Option::Some(ref e) => {
            lower_expr(ctx, e.as_ref(), dest);
        }
        &Option::None => {
            // No else branch - unit value
            match dest.as_place() {
                Option::Some(place) => {
                    ctx.emit_assign(
                        place,
                        mir_types::Rvalue::Use(mir_types::Operand::Constant(mir_types::Constant::unit())),
                        span,
                    );
                }
                Option::None => {}
            }
        }
    }
    if !ctx.is_terminated() {
        ctx.terminate_goto(join_block, span);
    }

    // Continue from join block
    ctx.set_current_block(join_block);
}

fn lower_match_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    scrutinee: &hir_expr::Expr,
    arms: &Vec<hir_expr::MatchArm>,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate scrutinee
    let scrut_temp = ctx.new_temp(scrutinee.ty.clone(), span);
    lower_expr(ctx, scrutinee, mir_lower_ctx::destination_local(scrut_temp));
    let scrut_place = mir_types::Place::local(scrut_temp);

    let join_block = ctx.new_block();

    // For simplicity, generate a chain of if-else blocks
    let mut i: usize = 0;
    while i < arms.len() {
        let arm = &arms[i];
        let arm_block = ctx.new_block();
        let next_arm_block = if i + 1 < arms.len() {
            ctx.new_block()
        } else {
            // Last arm - should be exhaustive
            join_block
        };

        // Test pattern
        let test = mir_lower_pattern::pattern_test(ctx, &arm.pattern, &scrut_place, span);
        match test {
            Option::Some(t) => {
                // Create switch for this arm
                let mut targets = Vec::new();
                targets.push(mir_types::SwitchTarget::new(t.expected, arm_block));
                let switch_targets = mir_types::SwitchTargets::new(targets, next_arm_block);
                ctx.terminate_switch(t.discriminant, switch_targets, span);
            }
            Option::None => {
                // Irrefutable pattern - go directly to arm
                ctx.terminate_goto(arm_block, span);
            }
        }

        // Lower arm body
        ctx.set_current_block(arm_block);
        mir_lower_pattern::bind_arm_pattern(ctx, &arm.pattern, scrut_place.clone(), span);
        lower_expr(ctx, &arm.body, dest.clone());
        if !ctx.is_terminated() {
            ctx.terminate_goto(join_block, span);
        }

        ctx.set_current_block(next_arm_block);
        i = i + 1;
    }

    ctx.set_current_block(join_block);
}

fn lower_loop_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    label: &Option<common::Symbol>,
    body: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    let loop_header = ctx.new_block();
    let loop_body = ctx.new_block();
    let break_block = ctx.new_block();

    // Go to loop header
    ctx.terminate_goto(loop_header, span);

    // Loop header
    ctx.set_current_block(loop_header);
    ctx.terminate_goto(loop_body, span);

    // Push loop context
    ctx.push_loop(*label, break_block, loop_header);

    // Lower body
    ctx.set_current_block(loop_body);
    lower_expr(ctx, body, mir_lower_ctx::destination_ignore());
    if !ctx.is_terminated() {
        // Loop back
        ctx.terminate_goto(loop_header, span);
    }

    // Pop loop context
    ctx.pop_loop();

    // Continue from break block
    ctx.set_current_block(break_block);
}

fn lower_return_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) {
    match val {
        &Option::Some(ref e) => {
            lower_expr(ctx, e.as_ref(), mir_lower_ctx::destination_return_place());
        }
        &Option::None => {
            ctx.emit_assign(
                mir_types::Place::return_place(),
                mir_types::Rvalue::Use(mir_types::Operand::Constant(mir_types::Constant::unit())),
                span,
            );
        }
    }
    ctx.terminate_return(span);
}

fn lower_break_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    label: &Option<common::Symbol>,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) {
    // Evaluate break value if present
    match val {
        &Option::Some(ref e) => {
            lower_expr(ctx, e.as_ref(), mir_lower_ctx::destination_ignore());
        }
        &Option::None => {}
    }

    // Jump to break target
    let break_block = ctx.find_break_block(*label);
    match break_block {
        Option::Some(bb) => {
            ctx.terminate_goto(bb, span);
        }
        Option::None => {
            // No enclosing loop - error
            ctx.terminate_unreachable(span);
        }
    }
}

fn lower_continue_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    label: &Option<common::Symbol>,
    span: common::Span,
) {
    let continue_block = ctx.find_continue_block(*label);
    match continue_block {
        Option::Some(bb) => {
            ctx.terminate_goto(bb, span);
        }
        Option::None => {
            // No enclosing loop - error
            ctx.terminate_unreachable(span);
        }
    }
}

fn lower_closure_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    captures: &Vec<hir_expr::Capture>,
    _params: &Vec<hir_expr::ClosureParam>,
    _return_ty: &hir_ty::Type,
    _body: &hir_expr::Expr,
    _body_id: hir_def::BodyId,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Closures are lowered as aggregate constructions
    // The closure body is lowered separately

    // Gather capture operands
    let mut operands = Vec::new();
    let mut i: usize = 0;
    while i < captures.len() {
        let capture = &captures[i];
        let mir_local = ctx.lookup_local(capture.local_id);
        match mir_local {
            Option::Some(local) => {
                // Get captured value based on capture kind
                let operand = match capture.kind {
                    hir_expr::CaptureKind::ByValue => {
                        mir_types::Operand::Move(mir_types::Place::local(local))
                    }
                    hir_expr::CaptureKind::ByRef => {
                        // Create reference
                        let ref_temp = ctx.new_temp(hir_ty::Type::error(), span);
                        ctx.emit_assign(
                            mir_types::Place::local(ref_temp),
                            mir_types::Rvalue::Ref {
                                place: mir_types::Place::local(local),
                                mutable: false,
                            },
                            span,
                        );
                        mir_types::Operand::Move(mir_types::Place::local(ref_temp))
                    }
                    hir_expr::CaptureKind::ByMutRef => {
                        let ref_temp = ctx.new_temp(hir_ty::Type::error(), span);
                        ctx.emit_assign(
                            mir_types::Place::local(ref_temp),
                            mir_types::Rvalue::Ref {
                                place: mir_types::Place::local(local),
                                mutable: true,
                            },
                            span,
                        );
                        mir_types::Operand::Move(mir_types::Place::local(ref_temp))
                    }
                };
                operands.push(operand);
            }
            Option::None => {}
        }
        i = i + 1;
    }

    match dest.as_place() {
        Option::Some(place) => {
            ctx.emit_assign(
                place,
                mir_types::Rvalue::Aggregate {
                    kind: mir_types::AggregateKind::Closure {
                        def_id: hir_def::DefId::dummy(),
                    },
                    operands: operands,
                },
                span,
            );
        }
        Option::None => {}
    }
}

fn lower_with_handle_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    handler_expr: &hir_expr::Expr,
    body: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Effect handling with proper handler stack management
    //
    // The structure is:
    //   1. Evaluate the handler expression into a state place
    //   2. Push the handler onto the handler stack
    //   3. Execute the body with the handler active
    //   4. Pop the handler from the stack
    //   5. Store the result to the destination

    // Step 1: Create state place and lower handler expression
    let state_temp = ctx.new_temp(handler_expr.ty.clone(), span);
    let state_place = mir_types::Place::local(state_temp);
    lower_expr(ctx, handler_expr, mir_lower_ctx::destination_local(state_temp));

    // Step 2: Determine handler state kind based on handler type
    let state_kind = classify_handler_state(&handler_expr.ty);

    // Step 3: Extract effect_id from handler type if available
    // For now, use a dummy DefId - proper implementation would
    // inspect the handler type to find the effect being handled
    let handler_id = extract_handler_def_id(&handler_expr.ty);

    // Step 4: Emit PushHandler statement
    ctx.emit_stmt(mir_stmt::Statement::new(
        mir_stmt::StatementKind::PushHandler {
            handler_id: handler_id,
            state_place: copy_place(&state_place),
            state_kind: state_kind,
        },
        span,
    ));

    // Step 5: Create blocks for body execution and continuation
    let body_block = ctx.new_block();
    let after_block = ctx.new_block();

    // Jump to body block
    ctx.builder.terminate(mir_term::Terminator::goto(body_block, span));

    // Step 6: Execute body in body_block
    ctx.set_current_block(body_block);

    // Create temp for body result if destination is a place
    let body_result_temp = ctx.new_temp(body.ty.clone(), span);
    lower_expr(ctx, body, mir_lower_ctx::destination_local(body_result_temp));

    // Step 7: Emit PopHandler statement (only if block not terminated)
    if !ctx.is_terminated() {
        ctx.emit_stmt(mir_stmt::Statement::new(
            mir_stmt::StatementKind::PopHandler,
            span,
        ));

        // Store body result to destination
        match dest.as_place() {
            Option::Some(dest_place) => {
                let body_operand = mir_lower_util::operand_from_place(
                    mir_types::Place::local(body_result_temp),
                    &body.ty,
                );
                ctx.emit_assign(
                    dest_place,
                    mir_types::Rvalue::Use(body_operand),
                    span,
                );
            }
            Option::None => {}
        }

        // Jump to continuation
        ctx.builder.terminate(mir_term::Terminator::goto(after_block, span));
    }

    // Step 8: Set current block to continuation
    ctx.set_current_block(after_block);
}

/// Classifies the state kind of a handler based on its type.
fn classify_handler_state(ty: &hir_ty::Type) -> mir_stmt::HandlerStateKind {
    match &ty.kind {
        // Unit type means stateless handler
        &hir_ty::TypeKind::Tuple(ref elems) => {
            if elems.len() == 0 {
                mir_stmt::HandlerStateKind::Stateless
            } else {
                mir_stmt::HandlerStateKind::Dynamic
            }
        }
        // Never type (diverging handler) is stateless
        &hir_ty::TypeKind::Never => mir_stmt::HandlerStateKind::Stateless,
        // Everything else needs dynamic state
        &hir_ty::TypeKind::Primitive(_) => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Ref { inner: _, mutable: _ } => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Ptr { inner: _, mutable: _ } => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Array { element: _, size: _ } => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Slice { element: _ } => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            // Check if it's a zero-sized type (unit struct)
            // For now, assume dynamic
            mir_stmt::HandlerStateKind::Dynamic
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            mir_stmt::HandlerStateKind::Dynamic
        }
        &hir_ty::TypeKind::Param(_) => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Infer(_) => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Error => mir_stmt::HandlerStateKind::Dynamic,
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            mir_stmt::HandlerStateKind::Dynamic
        }
        &hir_ty::TypeKind::Forall { params: _, body: _ } => {
            mir_stmt::HandlerStateKind::Dynamic
        }
        &hir_ty::TypeKind::Ownership { qualifier: _, ref inner } => {
            // Classify based on inner type
            classify_handler_state(inner.as_ref())
        }
    }
}

/// Extracts the DefId of a handler from its type.
fn extract_handler_def_id(ty: &hir_ty::Type) -> hir_def::DefId {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, args: _ } => def_id,
        // For other types, return a dummy DefId
        &hir_ty::TypeKind::Primitive(_) => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Tuple(_) => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Array { element: _, size: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Slice { element: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Ref { inner: _, mutable: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Ptr { inner: _, mutable: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Fn { params: _, ret: _, effects: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Infer(_) => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Param(_) => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Record { fields: _, row_var: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Forall { params: _, body: _ } => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Never => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Error => hir_def::DefId::dummy(),
        &hir_ty::TypeKind::Ownership { qualifier: _, ref inner } => extract_handler_def_id(inner.as_ref()),
    }
}

/// Creates a copy of a Place (helper for handler lowering).
fn copy_place(place: &mir_types::Place) -> mir_types::Place {
    mir_types::Place {
        local: place.local,
        projection: copy_projections(&place.projection),
    }
}

/// Copies a projection list.
fn copy_projections(projs: &Vec<mir_types::PlaceElem>) -> Vec<mir_types::PlaceElem> {
    let mut result = Vec::new();
    let mut i: usize = 0;
    while i < projs.len() {
        result.push(copy_projection(&projs[i]));
        i = i + 1;
    }
    result
}

/// Copies a single projection element.
fn copy_projection(proj: &mir_types::PlaceElem) -> mir_types::PlaceElem {
    match proj {
        &mir_types::PlaceElem::Deref => mir_types::PlaceElem::Deref,
        &mir_types::PlaceElem::Field(idx) => mir_types::PlaceElem::Field(idx),
        &mir_types::PlaceElem::Index(local) => mir_types::PlaceElem::Index(local),
        &mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end } => {
            mir_types::PlaceElem::ConstantIndex {
                offset: offset,
                min_length: min_length,
                from_end: from_end,
            }
        }
        &mir_types::PlaceElem::Subslice { from, to, from_end } => {
            mir_types::PlaceElem::Subslice {
                from: from,
                to: to,
                from_end: from_end,
            }
        }
        &mir_types::PlaceElem::Downcast(idx) => mir_types::PlaceElem::Downcast(idx),
    }
}


fn lower_perform_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    effect_def: hir_def::DefId,
    _op_def: hir_def::DefId,
    args: &Vec<hir_expr::Expr>,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate arguments
    let mut arg_operands = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg = &args[i];
        let temp = ctx.new_temp(arg.ty.clone(), span);
        lower_expr(ctx, arg, mir_lower_ctx::destination_local(temp));
        arg_operands.push(mir_lower_util::operand_from_place(
            mir_types::Place::local(temp),
            &arg.ty,
        ));
        i = i + 1;
    }

    let dest_place = match dest.as_place() {
        Option::Some(p) => p,
        Option::None => {
            let temp = ctx.new_temp(ty.clone(), span);
            mir_types::Place::local(temp)
        }
    };

    let next_block = ctx.new_block();
    ctx.builder.terminate(mir_term::effect_perform(
        effect_def,
        0,
        arg_operands,
        dest_place,
        next_block,
        span,
    ));
    ctx.set_current_block(next_block);
}

fn lower_resume_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    val: &hir_expr::Expr,
    _ty: &hir_ty::Type,
    _dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Evaluate value
    let temp = ctx.new_temp(val.ty.clone(), span);
    lower_expr(ctx, val, mir_lower_ctx::destination_local(temp));

    let operand = mir_lower_util::operand_from_place(
        mir_types::Place::local(temp),
        &val.ty,
    );

    ctx.builder.terminate(mir_term::Terminator::new(
        mir_term::TerminatorKind::Resume { value: operand },
        span,
    ));
}

fn lower_try_expr(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    inner: &hir_expr::Expr,
    ty: &hir_ty::Type,
    dest: mir_lower_ctx::Destination,
    span: common::Span,
) {
    // Try expression (?) - simplified
    // Full implementation would check for error and propagate
    lower_expr(ctx, inner, dest);
}

// ============================================================
// Place Conversion
// ============================================================

/// Converts an expression to a place (for assignment targets).
fn expr_to_place(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    expr: &hir_expr::Expr,
    span: common::Span,
) -> mir_types::Place {
    match &expr.kind {
        &hir_expr::ExprKind::Local(local_id) => {
            let mir_local = ctx.lookup_local(local_id);
            match mir_local {
                Option::Some(local) => mir_types::Place::local(local),
                Option::None => {
                    let temp = ctx.new_temp(expr.ty.clone(), span);
                    mir_types::Place::local(temp)
                }
            }
        }
        &hir_expr::ExprKind::Field { ref base, ref field } => {
            let base_place = expr_to_place(ctx, base.as_ref(), span);
            let field_idx = match field {
                &hir_expr::FieldAccess::Named { name: _, field_idx } => {
                    match field_idx {
                        Option::Some(idx) => idx,
                        Option::None => 0,
                    }
                }
                &hir_expr::FieldAccess::Index(idx) => idx,
            };
            base_place.project(mir_types::PlaceElem::Field(field_idx))
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            let base_place = expr_to_place(ctx, base.as_ref(), span);
            let idx_temp = ctx.new_temp(idx.as_ref().ty.clone(), span);
            lower_expr(ctx, idx.as_ref(), mir_lower_ctx::destination_local(idx_temp));
            base_place.project(mir_types::PlaceElem::Index(idx_temp))
        }
        &hir_expr::ExprKind::Unary { op: the_op, ref operand } => {
            match the_op {
                common::UnaryOp::Deref => {
                    let ptr_temp = ctx.new_temp(operand.as_ref().ty.clone(), span);
                    lower_expr(ctx, operand.as_ref(), mir_lower_ctx::destination_local(ptr_temp));
                    mir_types::Place::local(ptr_temp).project(mir_types::PlaceElem::Deref)
                }
                _ => {
                    // Not a place expression
                    let temp = ctx.new_temp(expr.ty.clone(), span);
                    mir_types::Place::local(temp)
                }
            }
        }
        _ => {
            // Not a place expression - create a temp
            let temp = ctx.new_temp(expr.ty.clone(), span);
            lower_expr(ctx, expr, mir_lower_ctx::destination_local(temp));
            mir_types::Place::local(temp)
        }
    }
}

