//! # Blood Compiler Driver
//!
//! The driver module orchestrates the Blood compiler pipeline, coordinating:
//! - Source file management
//! - Lexical analysis
//! - Parsing
//! - Type checking
//! - HIR lowering
//! - MIR lowering
//! - Code generation
//!
//! ## Architecture
//!
//! ```text
//! Source Code
//!     |
//!     v
//! +---------+    +--------+    +-------+    +-------+    +-------+    +--------+
//! | Lexer   | -> | Parser | -> | AST   | -> | HIR   | -> | MIR   | -> | Output |
//! +---------+    +--------+    +-------+    +-------+    +-------+    +--------+
//!                               TypeCheck   Lowering    Lowering    Codegen
//! ```
//!
//! ## Usage
//!
//! ```blood
//! use std.compiler.driver.{Compiler, CompilerConfig}
//!
//! let config = CompilerConfig::default()
//! let compiler = Compiler::new(config)
//! let result = compiler.compile_file("src/main.blood")
//! ```

module std.compiler.driver;

use std.core.Option;
// Result is a builtin type, no import needed
use std.collections.Vec;
// String is a builtin type, no import needed

// Sub-module declarations
// Note: In Blood, sub-modules are imported via `use`, not declared with `pub mod`
// The sub-modules are:
// - config: Compiler configuration
// - session: Compilation session management
// - pipeline: Compilation pipeline stages

// Import types from sub-modules
use std.compiler.driver.config.CompilerConfig;
use std.compiler.driver.config.OutputType;
use std.compiler.driver.config.OptLevel;
use std.compiler.driver.session.Session;
use std.compiler.driver.session.SourceFile;
use std.compiler.driver.pipeline.CompilationResult;
use std.compiler.driver.pipeline.CompilationError;
use std.compiler.driver.pipeline.compile_source;
use std.compiler.driver.pipeline.check_source;

// ============================================================================
// Compiler - Main Entry Point
// ============================================================================

/// The main Blood compiler driver.
///
/// Coordinates all compilation phases and manages the compilation session.
///
/// ## Example
///
/// ```blood
/// let compiler = Compiler::new(CompilerConfig::default())
///
/// // Compile a single file
/// match compiler.compile_file("src/main.blood") {
///     Ok(result) => println("Compilation successful"),
///     Err(errors) => {
///         for err in errors {
///             eprintln("{}", err)
///         }
///     }
/// }
/// ```
pub struct Compiler {
    /// Compiler configuration
    pub config: CompilerConfig,
    /// Compilation session
    session: Session,
}

impl Compiler {
    /// Create a new compiler with the given configuration.
    pub fn new(config: CompilerConfig) -> Compiler {
        Compiler {
            config: config.clone(),
            session: Session::new(config),
        }
    }

    /// Create a compiler with default configuration.
    pub fn default() -> Compiler {
        Compiler::new(CompilerConfig::default())
    }

    /// Compile a single source file.
    ///
    /// Returns the compilation result or a list of errors.
    pub fn compile_file(mut self, path: String) -> Result<CompilationResult, Vec<CompilationError>> {
        // Load the source file
        let source = match self.session.load_file(path.clone()) {
            Ok(src) => src,
            Err(e) => return Result::Err(vec![CompilationError::io_error(path, e)]),
        };

        // Run the compilation pipeline
        pipeline::compile_source(&mut self.session, source)
    }

    /// Compile source code from a string.
    ///
    /// Useful for testing or REPL scenarios.
    pub fn compile_string(mut self, name: String, source: String) -> Result<CompilationResult, Vec<CompilationError>> {
        let file = SourceFile::from_string(name, source);
        pipeline::compile_source(&mut self.session, file)
    }

    /// Check a source file without generating code.
    ///
    /// Performs lexing, parsing, and type checking only.
    pub fn check_file(mut self, path: String) -> Result<(), Vec<CompilationError>> {
        let source = match self.session.load_file(path.clone()) {
            Ok(src) => src,
            Err(e) => return Result::Err(vec![CompilationError::io_error(path, e)]),
        };

        pipeline::check_source(&mut self.session, source)
    }

    /// Check source code from a string without generating code.
    pub fn check_string(mut self, name: String, source: String) -> Result<(), Vec<CompilationError>> {
        let file = SourceFile::from_string(name, source);
        pipeline::check_source(&mut self.session, file)
    }

    /// Get the current compilation session.
    pub fn session(self) -> &Session {
        &self.session
    }

    /// Get a mutable reference to the compilation session.
    pub fn session_mut(mut self) -> &mut Session {
        &mut self.session
    }

    /// Reset the compiler state for a new compilation.
    pub fn reset(mut self) {
        self.session = Session::new(self.config.clone());
    }
}

// ============================================================================
// Quick API - Convenience Functions
// ============================================================================

/// Compile a source file using default configuration.
///
/// This is a convenience function for simple use cases.
///
/// ## Example
///
/// ```blood
/// use std.compiler.driver.compile_file
///
/// match compile_file("src/main.blood") {
///     Ok(result) => println("Success!"),
///     Err(errors) => println("Failed with {} errors", errors.len()),
/// }
/// ```
pub fn compile_file(path: String) -> Result<CompilationResult, Vec<CompilationError>> {
    let compiler = Compiler::default();
    compiler.compile_file(path);
}

/// Compile source code from a string using default configuration.
pub fn compile_string(name: String, source: String) -> Result<CompilationResult, Vec<CompilationError>> {
    let compiler = Compiler::default();
    compiler.compile_string(name, source);
}

/// Check a source file without generating code.
pub fn check_file(path: String) -> Result<(), Vec<CompilationError>> {
    let compiler = Compiler::default();
    compiler.check_file(path);
}

/// Check source code from a string without generating code.
pub fn check_string(name: String, source: String) -> Result<(), Vec<CompilationError>> {
    let compiler = Compiler::default();
    compiler.check_string(name, source);
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_compiler_creation() {
    let compiler = Compiler::default();
    assert(compiler.config.opt_level == OptLevel::None);
}

#[test]
fn test_compile_empty_program() {
    let compiler = Compiler::default();
    let result = compiler.compile_string("test.blood".to_string(), "".to_string());
    // Empty programs should compile successfully
    assert(result.is_ok());
}

#[test]
fn test_compile_simple_function() {
    let compiler = Compiler::default();
    let source = "fn main() {}".to_string();
    let result = compiler.compile_string("test.blood".to_string(), source);
    assert(result.is_ok());
}

#[test]
fn test_check_type_error() {
    let compiler = Compiler::default();
    let source = r#"
        fn main() {
            let x: Int = "hello"
        }
    "#.to_string();
    let result = compiler.check_string("test.blood".to_string(), source);
    // Should fail type checking
    assert(result.is_err());
}
