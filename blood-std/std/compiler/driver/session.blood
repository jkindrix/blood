//! # Compilation Session
//!
//! Manages the state of a compilation session, including:
//! - Source file management
//! - Diagnostic collection
//! - Symbol tables
//! - Type information
//!
//! ## Example
//!
//! ```blood
//! use std.compiler.driver.session.Session
//! use std.compiler.driver.config.CompilerConfig
//!
//! let session = Session::new(CompilerConfig::default())
//! let file = session.load_file("src/main.blood")?
//! ```

module std.compiler.driver.session;

use std.option.Option;
use std.result.Result;
use std.collections.Vec;
use std.collections.HashMap;
use std.string.String;
use std.compiler.driver.config.CompilerConfig;

// ============================================================================
// Source File
// ============================================================================

/// A source file loaded for compilation.
///
/// Contains the file path, content, and metadata needed for error reporting.
#[derive(Clone)]
pub struct SourceFile {
    /// Unique identifier for this file.
    pub id: FileId,
    /// File name or path.
    pub name: String,
    /// Source code content.
    pub content: String,
    /// Precomputed line start byte offsets.
    line_starts: Vec<U32>,
}

impl SourceFile {
    /// Create a source file from a name and content.
    pub fn from_string(name: String, content: String) -> SourceFile {
        let line_starts = compute_line_starts(&content);
        SourceFile {
            id: FileId::new(0), // Will be assigned by Session
            name,
            content,
            line_starts,
        }
    }

    /// Get the source content.
    pub fn source(self) -> &String {
        &self.content
    }

    /// Get the number of lines.
    pub fn line_count(self) -> USize {
        self.line_starts.len();
    }

    /// Get the byte offset of a line start.
    ///
    /// Line numbers are 1-indexed.
    pub fn line_start(self, line: U32) -> Option<U32> {
        if line == 0 || line as USize > self.line_starts.len() {
            return Option::None;
        }
        Option::Some(self.line_starts[(line - 1) as USize])
    }

    /// Get the line number for a byte offset.
    ///
    /// Returns a 1-indexed line number.
    pub fn line_for_offset(self, offset: U32) -> U32 {
        // Binary search for the line
        let mut low: USize = 0;
        let mut high: USize = self.line_starts.len();

        while low < high {
            let mid = low + (high - low) / 2;
            if self.line_starts[mid] <= offset {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        low as U32
    }

    /// Get the column number for a byte offset.
    ///
    /// Returns a 1-indexed column number.
    pub fn column_for_offset(self, offset: U32) -> U32 {
        let line = self.line_for_offset(offset);
        match self.line_start(line) {
            Option::Some(start) => offset - start + 1,
            Option::None => 1,
        }
    }

    /// Get a line of source code.
    ///
    /// Line numbers are 1-indexed.
    pub fn get_line(self, line: U32) -> Option<String> {
        let start = match self.line_start(line) {
            Option::Some(s) => s,
            Option::None => return Option::None,
        };

        let end = match self.line_start(line + 1) {
            Option::Some(e) => e,
            Option::None => self.content.len() as U32,
        };

        // Trim trailing newline
        let mut end_pos = end as USize;
        if end_pos > 0 && self.content.as_bytes()[end_pos - 1] == b'\n' {
            end_pos -= 1;
        };
        if end_pos > 0 && self.content.as_bytes()[end_pos - 1] == b'\r' {
            end_pos -= 1;
        }

        Option::Some(self.content[start as USize..end_pos].to_string())
    }

    /// Get a slice of source code by byte range.
    pub fn slice(self, start: U32, end: U32) -> String {
        let s = start as USize;
        let e = (end as USize).min(self.content.len());
        self.content[s..e].to_string();
    }
}

/// Compute the byte offsets of each line start.
fn compute_line_starts(content: &String) -> Vec<U32> {
    let mut starts = Vec::new();
    starts.push(0); // First line starts at 0

    let bytes = content.as_bytes();
    for i in 0..bytes.len() {
        if bytes[i] == b'\n' {
            starts.push((i + 1) as U32);
        }
    }

    starts
}

// ============================================================================
// File ID
// ============================================================================

/// Unique identifier for a source file.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct FileId {
    id: U32,
}

impl FileId {
    /// Create a new file ID.
    pub fn new(id: U32) -> FileId {
        FileId { id }
    }

    /// Get the raw ID value.
    pub fn as_u32(self) -> U32 {
        self.id
    }

    /// Dummy file ID for synthetic spans.
    pub fn dummy() -> FileId {
        FileId { id: U32::MAX }
    }

    /// Check if this is a dummy file ID.
    pub fn is_dummy(self) -> Bool {
        self.id == U32::MAX;
    }
}

impl Default for FileId {
    fn default() -> FileId {
        FileId::dummy()
    }
}

// ============================================================================
// Compilation Session
// ============================================================================

/// Manages the state of a compilation session.
///
/// The session holds:
/// - All loaded source files
/// - Accumulated diagnostics
/// - Type information
/// - Symbol tables
pub struct Session {
    /// Compiler configuration.
    pub config: CompilerConfig,
    /// Loaded source files.
    files: Vec<SourceFile>,
    /// Map from file path to file ID.
    file_map: HashMap<String, FileId>,
    /// Accumulated error count.
    error_count: U32,
    /// Accumulated warning count.
    warning_count: U32,
    /// Whether compilation has been aborted.
    aborted: Bool,
}

impl Session {
    /// Create a new compilation session.
    pub fn new(config: CompilerConfig) -> Session {
        Session {
            config,
            files: Vec::new(),
            file_map: HashMap::new(),
            error_count: 0,
            warning_count: 0,
            aborted: false,
        }
    }

    /// Load a source file from disk.
    pub fn load_file(mut self, path: String) -> Result<SourceFile, String> {
        // Check if already loaded
        if let Option::Some(&id) = self.file_map.get(&path) {
            return Result::Ok(self.files[id.as_u32() as USize].clone());
        };

        // Read file content
        let content = match std.fs.read_to_string(&path) {
            Result::Ok(c) => c,
            Result::Err(e) => return Result::Err(format!("Failed to read '{}': {}", path, e)),
        };

        // Create source file
        let id = FileId::new(self.files.len() as U32);
        let mut file = SourceFile::from_string(path.clone(), content);
        file.id = id;

        // Register file
        self.files.push(file.clone());
        self.file_map.insert(path, id);

        Result::Ok(file)
    }

    /// Add a source file from a string.
    pub fn add_source(mut self, name: String, content: String) -> SourceFile {
        let id = FileId::new(self.files.len() as U32);
        let mut file = SourceFile::from_string(name.clone(), content);
        file.id = id;

        self.files.push(file.clone());
        self.file_map.insert(name, id);

        file
    }

    /// Get a source file by ID.
    pub fn get_file(self, id: FileId) -> Option<&SourceFile> {
        if id.is_dummy() {
            return Option::None;
        };
        let idx = id.as_u32() as USize;
        if idx >= self.files.len() {
            return Option::None;
        }
        Option::Some(&self.files[idx])
    }

    /// Get a source file by path.
    pub fn get_file_by_path(self, path: &String) -> Option<&SourceFile> {
        match self.file_map.get(path) {
            Option::Some(&id) => self.get_file(id),
            Option::None => Option::None,
        }
    }

    /// Get all loaded source files.
    pub fn files(self) -> &Vec<SourceFile> {
        &self.files
    }

    /// Record an error.
    pub fn record_error(mut self) {
        self.error_count += 1;

        // Check error limit
        if self.error_count >= self.config.error_limit {
            self.aborted = true;
        }
    }

    /// Record a warning.
    pub fn record_warning(mut self) {
        self.warning_count += 1;

        // Check if warnings should be treated as errors
        if self.config.warnings_as_errors {
            self.record_error();
        }
    }

    /// Get the error count.
    pub fn error_count(self) -> U32 {
        self.error_count
    }

    /// Get the warning count.
    pub fn warning_count(self) -> U32 {
        self.warning_count
    }

    /// Check if any errors have occurred.
    pub fn has_errors(self) -> Bool {
        self.error_count > 0
    }

    /// Check if compilation should stop.
    pub fn should_stop(self) -> Bool {
        self.aborted || self.error_count >= self.config.error_limit
    }

    /// Abort compilation.
    pub fn abort(mut self) {
        self.aborted = true;
    }

    /// Reset the session for a new compilation.
    pub fn reset(mut self) {
        self.files.clear();
        self.file_map.clear();
        self.error_count = 0;
        self.warning_count = 0;
        self.aborted = false;
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_source_file_from_string() {
    let file = SourceFile::from_string(
        "test.blood".to_string(),
        "fn main() {\n    println(\"hello\")\n}\n".to_string()
    );

    assert(file.name == "test.blood");
    assert(file.line_count() == 4); // 3 lines + empty after final newline
}

#[test]
fn test_source_file_line_lookup() {
    let file = SourceFile::from_string(
        "test.blood".to_string(),
        "line1\nline2\nline3\n".to_string()
    );

    assert(file.line_for_offset(0) == 1);
    assert(file.line_for_offset(5) == 1); // '\n' at end of line 1
    assert(file.line_for_offset(6) == 2); // Start of line 2
    assert(file.line_for_offset(11) == 2); // '\n' at end of line 2
    assert(file.line_for_offset(12) == 3); // Start of line 3
}

#[test]
fn test_source_file_get_line() {
    let file = SourceFile::from_string(
        "test.blood".to_string(),
        "first line\nsecond line\nthird line\n".to_string()
    );

    assert(file.get_line(1) == Option::Some("first line".to_string()));
    assert(file.get_line(2) == Option::Some("second line".to_string()));
    assert(file.get_line(3) == Option::Some("third line".to_string()));
    assert(file.get_line(0).is_none());
    assert(file.get_line(5).is_none());
}

#[test]
fn test_source_file_column() {
    let file = SourceFile::from_string(
        "test.blood".to_string(),
        "abcdef\nghijkl\n".to_string()
    );

    assert(file.column_for_offset(0) == 1); // 'a'
    assert(file.column_for_offset(3) == 4); // 'd'
    assert(file.column_for_offset(7) == 1); // 'g' (start of line 2);
    assert(file.column_for_offset(10) == 4); // 'j'
}

#[test]
fn test_file_id() {
    let id1 = FileId::new(0);
    let id2 = FileId::new(1);
    let dummy = FileId::dummy();

    assert(id1 != id2);
    assert(id1.as_u32() == 0);
    assert(dummy.is_dummy());
    assert(!id1.is_dummy());
}

#[test]
fn test_session_add_source() {
    let config = CompilerConfig::default();
    let mut session = Session::new(config);

    let file1 = session.add_source("a.blood".to_string(), "fn a() {}".to_string());
    let file2 = session.add_source("b.blood".to_string(), "fn b() {}".to_string());

    assert(file1.id != file2.id);
    assert(session.files().len() == 2);
}

#[test]
fn test_session_get_file() {
    let config = CompilerConfig::default();
    let mut session = Session::new(config);

    let file = session.add_source("test.blood".to_string(), "fn test() {}".to_string());

    assert(session.get_file(file.id).is_some());
    assert(session.get_file_by_path(&"test.blood".to_string()).is_some());
    assert(session.get_file(FileId::dummy()).is_none());
    assert(session.get_file_by_path(&"nonexistent.blood".to_string()).is_none());
}

#[test]
fn test_session_error_tracking() {
    let config = CompilerConfig::default();
    let mut session = Session::new(config);

    assert(!session.has_errors());
    assert(session.error_count() == 0);

    session.record_error();
    assert(session.has_errors());
    assert(session.error_count() == 1);
}

#[test]
fn test_session_error_limit() {
    let mut config = CompilerConfig::default();
    config.error_limit = 3;
    let mut session = Session::new(config);

    session.record_error();
    session.record_error();
    assert(!session.should_stop());

    session.record_error();
    assert(session.should_stop());
}
