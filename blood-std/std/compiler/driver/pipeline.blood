//! # Compilation Pipeline
//!
//! Implements the compilation pipeline stages:
//! 1. Lexing - Source code to tokens
//! 2. Parsing - Tokens to AST
//! 3. Type Checking - Validate types and infer missing annotations
//! 4. HIR Lowering - AST to High-level IR
//! 5. MIR Lowering - HIR to Mid-level IR
//! 6. Code Generation - MIR to target code
//!
//! ## Pipeline Architecture
//!
//! Each stage transforms the program representation and may produce diagnostics.
//! The pipeline can be run partially (e.g., check-only mode) or fully.

module std.compiler.driver.pipeline;

use std.core.Option;
// Result is a builtin type, no import needed
use std.collections.Vec;
use std.collections.HashMap;
// String is a builtin type, no import needed
use std.compiler.driver.session.Session;
use std.compiler.driver.session.SourceFile;
use std.compiler.driver.config.OutputType;
use std.compiler.lexer.tokenize;
use std.compiler.lexer.Token;
use std.compiler.parser.parse;
use std.compiler.parser.Program;
use std.compiler.parser.ParseError;
use std.compiler.typeck.check_program;
use std.compiler.typeck.TypeError;

// HIR imports
use std.compiler.hir.Crate as HirCrate;
use std.compiler.hir.lowering.{lower_to_hir as hir_lower, LoweringResult, LoweringError};

// MIR imports
use std.compiler.mir.lowering.{lower_crate as mir_lower, Diagnostic as MirDiagnostic, InlineHandlerBodies};
use std.compiler.mir.escape.{EscapeAnalyzer, EscapeResults};
use std.compiler.mir.body.MirBody;

// Codegen imports
use std.compiler.codegen.{compile_mir_to_object_with_opt, BloodOptLevel};
use std.compiler.diagnostics.Diagnostic as CodegenDiagnostic;

// Type system imports (for TypeCheckResult)
use std.compiler.typeck.types.{DefId, Type};
use std.compiler.typeck.{TypeCheckResult, TypeErrors};

// Type aliases for codegen compatibility
type MirBodiesMap = HashMap<u32, MirBody>;
type EscapeAnalysisMap = HashMap<u32, EscapeResults>;

// ============================================================================
// Compilation Result
// ============================================================================

/// Result of a successful compilation.
///
/// Contains the generated output and any metadata.
pub struct CompilationResult {
    /// The generated output (bytes).
    pub output: Vec<u8>,
    /// Output type that was generated.
    pub output_type: OutputType,
    /// Source file name.
    pub source_name: String,
    /// Number of warnings generated.
    pub warning_count: u32,
}

impl CompilationResult {
    /// Create a new compilation result.
    pub fn new(output: Vec<u8>, output_type: OutputType, source_name: String) -> CompilationResult {
        CompilationResult {
            output,
            output_type,
            source_name,
            warning_count: 0,
        }
    }

    /// Create an empty result (for check-only mode).
    pub fn empty(source_name: String) -> CompilationResult {
        CompilationResult {
            output: Vec::new(),
            output_type: OutputType::Executable,
            source_name,
            warning_count: 0,
        }
    }

    /// Check if the output is empty.
    pub fn is_empty(self) -> bool {
        self.output.is_empty();
    }

    /// Get the output size in bytes.
    pub fn output_size(self) -> usize {
        self.output.len();
    }
}

// ============================================================================
// Compilation Error
// ============================================================================

/// An error that occurred during compilation.
///
/// Wraps errors from different compilation phases with unified formatting.
#[derive(Clone)]
pub struct CompilationError {
    /// Error phase (lexer, parser, typeck, etc.).
    pub phase: CompilationPhase,
    /// Error message.
    pub message: String,
    /// Source file name.
    pub file: String,
    /// Line number (1-indexed, 0 if unknown).
    pub line: u32,
    /// Column number (1-indexed, 0 if unknown).
    pub column: u32,
    /// Optional help text.
    pub help: Option<String>,
}

impl CompilationError {
    /// Create a new compilation error.
    pub fn new(phase: CompilationPhase, message: String, file: String, line: u32, column: u32) -> CompilationError {
        CompilationError {
            phase,
            message,
            file,
            line,
            column,
            help: Option::None,
        }
    }

    /// Create an I/O error.
    pub fn io_error(file: String, message: String) -> CompilationError {
        CompilationError {
            phase: CompilationPhase::IO,
            message,
            file,
            line: 0,
            column: 0,
            help: Option::None,
        }
    }

    /// Create from a parse error.
    pub fn from_parse_error(err: ParseError, file: String) -> CompilationError {
        CompilationError {
            phase: CompilationPhase::Parser,
            message: err.message.clone(),
            file,
            line: err.span.line,
            column: err.span.column,
            help: Option::None,
        }
    }

    /// Create from a type error.
    pub fn from_type_error(err: TypeError, file: String) -> CompilationError {
        CompilationError {
            phase: CompilationPhase::TypeCheck,
            message: err.message.clone(),
            file,
            line: err.span.line,
            column: err.span.column,
            help: err.help.clone(),
        }
    }

    /// Add help text.
    pub fn with_help(mut self, help: String) -> CompilationError {
        self.help = Option::Some(help);
        self
    }

    /// Format the error for display.
    pub fn format(self) -> String {
        let location = if self.line > 0 {
            format!("{}:{}:{}", self.file, self.line, self.column)
        } else {
            self.file.clone();
        };

        let phase_name = match self.phase {
            CompilationPhase::IO => "io",
            CompilationPhase::Lexer => "lexer",
            CompilationPhase::Parser => "parser",
            CompilationPhase::TypeCheck => "type",
            CompilationPhase::HIRLowering => "hir",
            CompilationPhase::MIRLowering => "mir",
            CompilationPhase::CodeGen => "codegen",
        };

        let base = format!("error[{}]: {} --> {}", phase_name, self.message, location);

        match self.help {
            Option::Some(h) => format!("{}\n  help: {}", base, h),
            Option::None => base,
        }
    }
}

/// Compilation phase where an error occurred.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum CompilationPhase {
    /// File I/O phase.
    IO,
    /// Lexical analysis phase.
    Lexer,
    /// Parsing phase.
    Parser,
    /// Type checking phase.
    TypeCheck,
    /// HIR lowering phase.
    HIRLowering,
    /// MIR lowering phase.
    MIRLowering,
    /// Code generation phase.
    CodeGen,
}

// ============================================================================
// Pipeline Entry Points
// ============================================================================

/// Compile a source file to the configured output.
///
/// Runs the full compilation pipeline:
/// 1. Lex
/// 2. Parse
/// 3. Type check
/// 4. Lower to HIR
/// 5. Lower to MIR
/// 6. Generate code
pub fn compile_source(session: &mut Session, file: SourceFile) -> Result<CompilationResult, Vec<CompilationError>> {
    let mut errors: Vec<CompilationError> = Vec::new();

    // Phase 1: Lexing
    let tokens = lex_source(session, &file);

    // Phase 2: Parsing
    let ast = match parse_source(session, &file) {
        Result::Ok(ast) => ast,
        Result::Err(parse_errors) => {
            for err in parse_errors {
                errors.push(CompilationError::from_parse_error(err, file.name.clone()));
                session.record_error();
            };
            return Result::Err(errors);
        }
    };

    // Phase 3: Type Checking
    let type_result = match typecheck_ast(session, &ast) {
        Result::Ok(result) => result,
        Result::Err(type_errors) => {
            for err in type_errors {
                errors.push(CompilationError::from_type_error(err, file.name.clone()));
                session.record_error();
            };
            return Result::Err(errors);
        }
    };

    // Check if we should stop early
    if session.should_stop() {
        return Result::Err(errors);
    };

    // Phase 4: HIR Lowering
    let hir = match lower_to_hir(session, &ast, type_result) {
        Result::Ok(h) => h,
        Result::Err(e) => {
            errors.push(e);
            return Result::Err(errors);
        }
    };

    // Phase 5: MIR Lowering
    let mir = match lower_to_mir(session, &hir) {
        Result::Ok(m) => m,
        Result::Err(e) => {
            errors.push(e);
            return Result::Err(errors);
        }
    };

    // Phase 6: Code Generation
    let output = match generate_code(session, &hir, &mir) {
        Result::Ok(o) => o,
        Result::Err(e) => {
            errors.push(e);
            return Result::Err(errors);
        }
    };

    Result::Ok(CompilationResult {
        output,
        output_type: session.config.output_type,
        source_name: file.name.clone(),
        warning_count: session.warning_count(),
    })
}

/// Check a source file without generating code.
///
/// Runs phases 1-3 only (lex, parse, type check).
pub fn check_source(session: &mut Session, file: SourceFile) -> Result<(), Vec<CompilationError>> {
    let mut errors: Vec<CompilationError> = Vec::new();

    // Phase 1: Lexing (implicitly done in parse)
    // Phase 2: Parsing
    let ast = match parse_source(session, &file) {
        Result::Ok(ast) => ast,
        Result::Err(parse_errors) => {
            for err in parse_errors {
                errors.push(CompilationError::from_parse_error(err, file.name.clone()));
                session.record_error();
            };
            return Result::Err(errors);
        }
    };

    // Phase 3: Type Checking
    match typecheck_ast(session, &ast) {
        Result::Ok(_type_result) => Result::Ok(()),
        Result::Err(type_errors) => {
            for err in type_errors {
                errors.push(CompilationError::from_type_error(err, file.name.clone()));
                session.record_error();
            }
            Result::Err(errors)
        }
    }
}

// ============================================================================
// Pipeline Phases
// ============================================================================

/// Phase 1: Lexical analysis.
///
/// Converts source code to a stream of tokens.
fn lex_source(session: &mut Session, file: &SourceFile) -> Vec<Token> {
    tokenize(file.content.clone())
}

/// Phase 2: Parsing.
///
/// Converts source code to an AST.
fn parse_source(session: &mut Session, file: &SourceFile) -> Result<Program, Vec<ParseError>> {
    parse(file.content.clone())
}

/// Phase 3: Type checking.
///
/// Validates types and infers missing type annotations.
/// Returns TypeCheckResult containing resolved types for all definitions.
fn typecheck_ast(session: &mut Session, ast: &Program) -> Result<TypeCheckResult, Vec<TypeError>> {
    // Call the type checker - now returns TypeCheckResult directly with resolved types
    let result = check_program(ast);

    if result.is_success() {
        Result::Ok(result)
    } else {
        // Extract errors from the result
        let errors = result.get_errors();
        let mut error_vec: Vec<TypeError> = Vec::new();
        let mut i: usize = 0;
        while i < errors.len() {
            error_vec.push(errors[i].clone());
            i = i + 1;
        }
        Result::Err(error_vec)
    }
}

/// Phase 4: HIR lowering.
///
/// Transforms AST to High-level Intermediate Representation.
/// Requires type information from type checking phase.
fn lower_to_hir(session: &mut Session, ast: &Program, type_result: TypeCheckResult) -> Result<HirCrate, CompilationError> {
    // Call the real HIR lowering implementation
    let result = hir_lower(ast, type_result);

    if result.is_success() {
        Result::Ok(result.into_crate())
    } else {
        // Convert first lowering error to compilation error
        let errors = result.errors;
        if errors.len() > 0 {
            let err = &errors[0];
            Result::Err(CompilationError::new(
                CompilationPhase::HIRLowering,
                err.message(),
                session.current_file().unwrap_or("unknown".to_string()),
                err.span().line(),
                err.span().column(),
            ))
        } else {
            Result::Err(CompilationError::new(
                CompilationPhase::HIRLowering,
                "HIR lowering failed with unknown error".to_string(),
                session.current_file().unwrap_or("unknown".to_string()),
                0,
                0,
            ))
        }
    }
}

/// Phase 5: MIR lowering.
///
/// Transforms HIR to Mid-level Intermediate Representation.
/// Returns MIR bodies along with escape analysis results.
fn lower_to_mir(session: &mut Session, hir: &HirCrate) -> Result<MirLoweringResult, CompilationError> {
    // Call the real MIR lowering implementation
    let (mir_bodies, diagnostics, inline_handlers) = mir_lower(hir);

    // Check for errors in diagnostics
    let mut has_error = false;
    let mut i: usize = 0;
    while i < diagnostics.len() {
        if diagnostics[i].is_error {
            has_error = true;
            break;
        };
        i = i + 1;
    };

    if has_error {
        let err = &diagnostics[0];
        return Result::Err(CompilationError::new(
            CompilationPhase::MIRLowering,
            err.message.clone(),
            session.current_file().unwrap_or("unknown".to_string()),
            err.span.line(),
            err.span.column(),
        ));
    };

    // Run escape analysis on all MIR bodies
    let mut escape_results: EscapeAnalysisMap = HashMap::new();
    let mut analyzer = EscapeAnalyzer::new();
    for (def_id, mir_body) in mir_bodies.iter() {
        let results = analyzer.analyze(mir_body);
        escape_results.insert(*def_id, results);
    }

    Result::Ok(MirLoweringResult {
        bodies: mir_bodies,
        escape_analysis: escape_results,
        inline_handlers,
    })
}

/// Phase 6: Code generation.
///
/// Generates target code from MIR.
/// Takes HIR crate for type information and MIR bodies for code generation.
fn generate_code(
    session: &mut Session,
    hir: &HirCrate,
    mir: &MirLoweringResult,
) -> Result<Vec<u8>, CompilationError> {
    // Determine output path from session
    let output_path = session.output_path().unwrap_or("a.out".to_string());

    // Determine optimization level
    let opt_level = if session.config.optimize {
        BloodOptLevel::Aggressive
    } else {
        BloodOptLevel::Default
    };

    // Call the real codegen implementation
    match compile_mir_to_object_with_opt(
        hir,
        &mir.bodies,
        &mir.escape_analysis,
        &mir.inline_handlers,
        &output_path,
        opt_level,
    ) {
        Result::Ok(()) => {
            // Read the generated object file back as bytes
            // In a real implementation, we'd use the File API
            // For now, return success with empty bytes (file was written to disk)
            Result::Ok(Vec::new())
        }
        Result::Err(diagnostics) => {
            if diagnostics.len() > 0 {
                let diag = &diagnostics[0];
                Result::Err(CompilationError::new(
                    CompilationPhase::CodeGen,
                    diag.message.clone(),
                    session.current_file().unwrap_or("unknown".to_string()),
                    diag.span.line(),
                    diag.span.column(),
                ))
            } else {
                Result::Err(CompilationError::new(
                    CompilationPhase::CodeGen,
                    "Code generation failed with unknown error".to_string(),
                    session.current_file().unwrap_or("unknown".to_string()),
                    0,
                    0,
                ))
            }
        }
    }
}

// ============================================================================
// MIR Lowering Result
// ============================================================================

/// Result of MIR lowering phase, containing all data needed for codegen.
pub struct MirLoweringResult {
    /// MIR bodies for all functions, keyed by DefId.
    pub bodies: MirBodiesMap,
    /// Escape analysis results for all functions.
    pub escape_analysis: EscapeAnalysisMap,
    /// Inline handler bodies discovered during MIR lowering.
    pub inline_handlers: InlineHandlerBodies,
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_compilation_result_new() {
    let result = CompilationResult::new(
        vec![0x00, 0x01, 0x02],
        OutputType::Executable,
        "test.blood".to_string()
    );

    assert(!result.is_empty());
    assert(result.output_size() == 3);
    assert(result.source_name == "test.blood");
}

#[test]
fn test_compilation_result_empty() {
    let result = CompilationResult::empty("test.blood".to_string());

    assert(result.is_empty());
    assert(result.output_size() == 0);
}

#[test]
fn test_compilation_error_format() {
    let error = CompilationError::new(
        CompilationPhase::Parser,
        "unexpected token".to_string(),
        "test.blood".to_string(),
        10,
        5
    );

    let formatted = error.format();
    assert(formatted.contains("parser"));
    assert(formatted.contains("unexpected token"));
    assert(formatted.contains("test.blood:10:5"));
}

#[test]
fn test_compilation_error_with_help() {
    let error = CompilationError::new(
        CompilationPhase::TypeCheck,
        "type mismatch".to_string(),
        "test.blood".to_string(),
        15,
        10
    ).with_help("expected Int, found String".to_string());

    let formatted = error.format();
    assert(formatted.contains("help"));
    assert(formatted.contains("expected Int"));
}

#[test]
fn test_compilation_error_io() {
    let error = CompilationError::io_error(
        "missing.blood".to_string(),
        "file not found".to_string()
    );

    assert(error.phase == CompilationPhase::IO);
    assert(error.line == 0);
}

#[test]
fn test_compilation_phase_equality() {
    assert(CompilationPhase::Parser == CompilationPhase::Parser);
    assert(CompilationPhase::Parser != CompilationPhase::TypeCheck);
}
