//! # Compiler Configuration
//!
//! Configuration options for the Blood compiler.
//!
//! ## Example
//!
//! ```blood
//! use std.compiler.driver.config.{CompilerConfig, OptLevel, OutputType}
//!
//! let config = CompilerConfig {
//!     opt_level: OptLevel::Release,
//!     output_type: OutputType::Executable,
//!     debug_info: true,
//!     ..CompilerConfig::default()
//! }
//! ```

module std.compiler.driver.config;

use std.core.Option;
use std.collections.Vec;
use std.core.string.String;

// ============================================================================
// Optimization Level
// ============================================================================

/// Optimization level for code generation.
///
/// | Level | Description |
/// |-------|-------------|
/// | None | No optimization (fastest compile, slowest code) |
/// | Basic | Basic optimizations (good for debug) |
/// | Standard | Standard optimizations (good balance) |
/// | Release | Aggressive optimizations (slowest compile, fastest code) |
/// | Size | Optimize for code size |
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum OptLevel {
    /// No optimization (default for debug builds).
    None,
    /// Basic optimizations (constant folding, dead code elimination).
    Basic,
    /// Standard optimizations (inlining, loop optimizations).
    Standard,
    /// Aggressive optimizations (vectorization, LTO).
    Release,
    /// Optimize for code size.
    Size,
}

impl OptLevel {
    /// Convert to a numeric level (0-4).
    pub fn as_level(self) -> u32 {
        match self {
            OptLevel::None => 0,
            OptLevel::Basic => 1,
            OptLevel::Standard => 2,
            OptLevel::Release => 3,
            OptLevel::Size => 4,
        }
    }

    /// Check if this level includes inlining.
    pub fn enables_inlining(self) -> bool {
        match self {
            OptLevel::None => false,
            OptLevel::Basic => false,
            OptLevel::Standard => true,
            OptLevel::Release => true,
            OptLevel::Size => true,
        }
    }
}

impl Default for OptLevel {
    fn default() -> OptLevel {
        OptLevel::None
    }
}

// ============================================================================
// Output Type
// ============================================================================

/// Type of output to generate.
///
/// | Type | Description |
/// |------|-------------|
/// | Executable | Standalone executable binary |
/// | Library | Static library |
/// | DynamicLibrary | Shared/dynamic library |
/// | Object | Object file only |
/// | Assembly | Assembly output |
/// | LLVMIR | LLVM IR output |
/// | BloodIR | Blood MIR output (for debugging) |
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum OutputType {
    /// Standalone executable binary.
    Executable,
    /// Static library (.a, .lib).
    Library,
    /// Shared/dynamic library (.so, .dylib, .dll).
    DynamicLibrary,
    /// Object file only (.o, .obj).
    Object,
    /// Assembly output (.s, .asm).
    Assembly,
    /// LLVM IR output (.ll).
    LLVMIR,
    /// Blood MIR output for debugging.
    BloodIR,
}

impl Default for OutputType {
    fn default() -> OutputType {
        OutputType::Executable
    }
}

// ============================================================================
// Target
// ============================================================================

/// Target triple for code generation.
///
/// Format: `<arch>-<vendor>-<os>-<env>`
///
/// ## Examples
///
/// - `x86_64-unknown-linux-gnu`
/// - `aarch64-apple-darwin`
/// - `wasm32-unknown-unknown`
#[derive(Clone, PartialEq, Eq)]
pub struct Target {
    /// Architecture (x86_64, aarch64, wasm32, etc.)
    pub arch: String,
    /// Vendor (unknown, apple, pc, etc.)
    pub vendor: String,
    /// Operating system (linux, darwin, windows, etc.)
    pub os: String,
    /// Environment (gnu, musl, msvc, etc.)
    pub env: Option<String>,
}

impl Target {
    /// Create a new target from components.
    pub fn new(arch: String, vendor: String, os: String, env: Option<String>) -> Target {
        Target { arch, vendor, os, env }
    }

    /// Parse a target triple string.
    pub fn parse(triple: String) -> Option<Target> {
        let parts: Vec<String> = triple.split('-').collect();

        if parts.len() < 3 {
            return Option::None;
        }

        Option::Some(Target {
            arch: parts[0].clone(),
            vendor: parts[1].clone(),
            os: parts[2].clone(),
            env: if parts.len() > 3 { Option::Some(parts[3].clone()) } else { Option::None },
        })
    }

    /// Get the host target (the machine we're running on).
    pub fn host() -> Target {
        // TODO: Detect actual host target
        Target {
            arch: "x86_64".to_string(),
            vendor: "unknown".to_string(),
            os: "linux".to_string(),
            env: Option::Some("gnu".to_string()),
        }
    }

    /// Format as a target triple string.
    pub fn triple(self) -> String {
        match self.env {
            Option::Some(env) => format!("{}-{}-{}-{}", self.arch, self.vendor, self.os, env),
            Option::None => format!("{}-{}-{}", self.arch, self.vendor, self.os),
        }
    }

    /// Check if this is a 64-bit target.
    pub fn is_64bit(self) -> bool {
        self.arch == "x86_64" || self.arch == "aarch64" || self.arch == "riscv64"
    }

    /// Check if this is a WebAssembly target.
    pub fn is_wasm(self) -> bool {
        self.arch.starts_with("wasm");
    }
}

impl Default for Target {
    fn default() -> Target {
        Target::host()
    }
}

// ============================================================================
// Compiler Configuration
// ============================================================================

/// Main compiler configuration struct.
///
/// Controls all aspects of compilation including optimization,
/// output format, diagnostics, and target selection.
#[derive(Clone)]
pub struct CompilerConfig {
    /// Optimization level.
    pub opt_level: OptLevel,

    /// Output type (executable, library, etc.).
    pub output_type: OutputType,

    /// Target triple for code generation.
    pub target: Target,

    /// Output file path (None = derive from input).
    pub output_path: Option<String>,

    /// Include debug information.
    pub debug_info: bool,

    /// Enable Link-Time Optimization.
    pub lto: bool,

    /// Enable panic=abort (no unwinding).
    pub panic_abort: bool,

    /// Treat warnings as errors.
    pub warnings_as_errors: bool,

    /// Maximum number of errors before stopping.
    pub error_limit: u32,

    /// Show compiler timing information.
    pub show_timings: bool,

    /// Verbose output.
    pub verbose: bool,

    /// Enable colored output.
    pub color: bool,

    /// Include paths for imports.
    pub include_paths: Vec<String>,

    /// Library search paths.
    pub library_paths: Vec<String>,

    /// Libraries to link.
    pub libraries: Vec<String>,

    /// Define preprocessor symbols.
    pub defines: Vec<String>,

    /// Emit intermediate representation for debugging.
    pub emit_ir: bool,

    /// Emit HIR for debugging.
    pub emit_hir: bool,

    /// Emit MIR for debugging.
    pub emit_mir: bool,

    /// Dump AST for debugging.
    pub dump_ast: bool,

    /// Enable incremental compilation.
    pub incremental: bool,

    /// Incremental compilation cache directory.
    pub incremental_dir: Option<String>,
}

impl CompilerConfig {
    /// Create a new configuration with default values.
    pub fn new() -> CompilerConfig {
        CompilerConfig::default()
    }

    /// Create a configuration optimized for debugging.
    pub fn debug() -> CompilerConfig {
        CompilerConfig {
            opt_level: OptLevel::None,
            debug_info: true,
            ..CompilerConfig::default()
        }
    }

    /// Create a configuration optimized for release builds.
    pub fn release() -> CompilerConfig {
        CompilerConfig {
            opt_level: OptLevel::Release,
            debug_info: false,
            lto: true,
            ..CompilerConfig::default()
        }
    }

    /// Set the optimization level.
    pub fn with_opt_level(mut self, level: OptLevel) -> CompilerConfig {
        self.opt_level = level;
        self
    }

    /// Set the output type.
    pub fn with_output_type(mut self, output_type: OutputType) -> CompilerConfig {
        self.output_type = output_type;
        self
    }

    /// Set the target triple.
    pub fn with_target(mut self, target: Target) -> CompilerConfig {
        self.target = target;
        self
    }

    /// Set the output path.
    pub fn with_output_path(mut self, path: String) -> CompilerConfig {
        self.output_path = Option::Some(path);
        self
    }

    /// Enable debug information.
    pub fn with_debug_info(mut self, enabled: bool) -> CompilerConfig {
        self.debug_info = enabled;
        self
    }

    /// Add an include path.
    pub fn add_include_path(mut self, path: String) -> CompilerConfig {
        self.include_paths.push(path);
        self
    }

    /// Add a library path.
    pub fn add_library_path(mut self, path: String) -> CompilerConfig {
        self.library_paths.push(path);
        self
    }

    /// Add a library to link.
    pub fn add_library(mut self, lib: String) -> CompilerConfig {
        self.libraries.push(lib);
        self
    }

    /// Check if this configuration is for debug mode.
    pub fn is_debug(self) -> bool {
        self.opt_level == OptLevel::None && self.debug_info;
    }

    /// Check if this configuration is for release mode.
    pub fn is_release(self) -> bool {
        self.opt_level == OptLevel::Release;
    }
}

impl Default for CompilerConfig {
    fn default() -> CompilerConfig {
        CompilerConfig {
            opt_level: OptLevel::None,
            output_type: OutputType::Executable,
            target: Target::host(),
            output_path: Option::None,
            debug_info: false,
            lto: false,
            panic_abort: false,
            warnings_as_errors: false,
            error_limit: 20,
            show_timings: false,
            verbose: false,
            color: true,
            include_paths: Vec::new(),
            library_paths: Vec::new(),
            libraries: Vec::new(),
            defines: Vec::new(),
            emit_ir: false,
            emit_hir: false,
            emit_mir: false,
            dump_ast: false,
            incremental: false,
            incremental_dir: Option::None,
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_opt_level_default() {
    let level: OptLevel = OptLevel::default();
    assert(level == OptLevel::None);
    assert(level.as_level() == 0);
}

#[test]
fn test_opt_level_inlining() {
    assert(!OptLevel::None.enables_inlining());
    assert(!OptLevel::Basic.enables_inlining());
    assert(OptLevel::Standard.enables_inlining());
    assert(OptLevel::Release.enables_inlining());
}

#[test]
fn test_target_parse() {
    let target = Target::parse("x86_64-unknown-linux-gnu".to_string());
    assert(target.is_some());

    let t = target.unwrap();
    assert(t.arch == "x86_64");
    assert(t.os == "linux");
    assert(t.is_64bit());
    assert(!t.is_wasm());
}

#[test]
fn test_target_wasm() {
    let target = Target::parse("wasm32-unknown-unknown".to_string());
    assert(target.is_some());

    let t = target.unwrap();
    assert(t.is_wasm());
    assert(!t.is_64bit());
}

#[test]
fn test_config_default() {
    let config = CompilerConfig::default();
    assert(config.opt_level == OptLevel::None);
    assert(config.output_type == OutputType::Executable);
    assert(!config.debug_info);
}

#[test]
fn test_config_debug() {
    let config = CompilerConfig::debug();
    assert(config.is_debug());
    assert(config.debug_info);
    assert(config.opt_level == OptLevel::None);
}

#[test]
fn test_config_release() {
    let config = CompilerConfig::release();
    assert(config.is_release());
    assert(config.lto);
    assert(config.opt_level == OptLevel::Release);
}

#[test]
fn test_config_builder() {
    let config = CompilerConfig::new()
        .with_opt_level(OptLevel::Standard)
        .with_debug_info(true)
        .add_include_path("/usr/include".to_string());

    assert(config.opt_level == OptLevel::Standard);
    assert(config.debug_info);
    assert(config.include_paths.len() == 1);
}
