// Blood Self-Hosted Compiler - Codegen Types
//
// This module handles mapping Blood/HIR types to LLVM IR type strings.
// The strategy is textual LLVM IR generation - we build type strings
// that can be written to .ll files and compiled with llc.

mod common;
mod hir_def;
mod hir_ty;

// ============================================================
// Type Layout Information
// ============================================================

/// Layout information for a type.
pub struct TypeLayout {
    /// Size in bytes.
    pub size: u64,
    /// Alignment in bytes.
    pub align: u64,
    /// LLVM IR type string.
    pub llvm_type: String,
}

impl TypeLayout {
    /// Creates a new type layout.
    pub fn new(size: u64, align: u64, llvm_type: String) -> TypeLayout {
        TypeLayout {
            size: size,
            align: align,
            llvm_type: llvm_type,
        }
    }

    /// Creates layout for a primitive type.
    fn primitive(size: u64, llvm_type: String) -> TypeLayout {
        TypeLayout {
            size: size,
            align: size,
            llvm_type: llvm_type,
        }
    }

    /// Creates layout for a pointer type.
    fn pointer() -> TypeLayout {
        TypeLayout {
            size: 8,
            align: 8,
            llvm_type: common::make_string("ptr"),
        }
    }
}

// ============================================================
// Type to LLVM IR Conversion
// ============================================================

/// Converts an HIR type to its LLVM IR representation.
pub fn type_to_llvm(ty: &hir_ty::Type) -> String {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => primitive_to_llvm(prim),
        &hir_ty::TypeKind::Never => common::make_string("void"),
        &hir_ty::TypeKind::Tuple(ref elems) => tuple_to_llvm(elems),
        &hir_ty::TypeKind::Array { ref element, size } => array_to_llvm(element.as_ref(), size),
        &hir_ty::TypeKind::Slice { ref element } => slice_to_llvm(element.as_ref()),
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => ref_to_llvm(inner.as_ref()),
        &hir_ty::TypeKind::Ptr { ref inner, mutable: _ } => ptr_to_llvm(inner.as_ref()),
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => adt_to_llvm(args),
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => fn_to_llvm(params, ret.as_ref()),
        &hir_ty::TypeKind::Param(ref var_id) => param_to_llvm(var_id),
        &hir_ty::TypeKind::Infer(_) => common::make_string("i64"),
        &hir_ty::TypeKind::Record { fields: _, row_var: _ } => common::make_string("ptr"),
        // Forall types are represented as opaque pointers (polymorphic values)
        &hir_ty::TypeKind::Forall { params: _, body: _ } => common::make_string("ptr"),
        // Ownership qualifiers don't affect runtime representation
        &hir_ty::TypeKind::Ownership { qualifier: _, ref inner } => type_to_llvm(inner.as_ref()),
        &hir_ty::TypeKind::Error => common::make_string("i64"),
    }
}

/// Converts a primitive type to LLVM IR.
fn primitive_to_llvm(prim: &hir_ty::PrimitiveTy) -> String {
    match prim {
        &hir_ty::PrimitiveTy::Bool => common::make_string("i1"),
        &hir_ty::PrimitiveTy::Char => common::make_string("i32"),
        &hir_ty::PrimitiveTy::I8 => common::make_string("i8"),
        &hir_ty::PrimitiveTy::I16 => common::make_string("i16"),
        &hir_ty::PrimitiveTy::I32 => common::make_string("i32"),
        &hir_ty::PrimitiveTy::I64 => common::make_string("i64"),
        &hir_ty::PrimitiveTy::I128 => common::make_string("i128"),
        &hir_ty::PrimitiveTy::Isize => common::make_string("i64"),
        &hir_ty::PrimitiveTy::U8 => common::make_string("i8"),
        &hir_ty::PrimitiveTy::U16 => common::make_string("i16"),
        &hir_ty::PrimitiveTy::U32 => common::make_string("i32"),
        &hir_ty::PrimitiveTy::U64 => common::make_string("i64"),
        &hir_ty::PrimitiveTy::U128 => common::make_string("i128"),
        &hir_ty::PrimitiveTy::Usize => common::make_string("i64"),
        &hir_ty::PrimitiveTy::F32 => common::make_string("float"),
        &hir_ty::PrimitiveTy::F64 => common::make_string("double"),
        &hir_ty::PrimitiveTy::Str => common::make_string("ptr"),
    }
}

/// Converts a tuple type to LLVM IR.
fn tuple_to_llvm(elems: &Vec<hir_ty::Type>) -> String {
    if elems.len() == 0 {
        return common::make_string("{}");
    }

    let mut result = common::make_string("{ ");
    let mut i: usize = 0;
    while i < elems.len() {
        if i > 0 {
            result.push_str(", ");
        }
        let elem_str = type_to_llvm(&elems[i]);
        result.push_str(elem_str.as_str());
        i = i + 1;
    }
    result.push_str(" }");
    result
}

/// Converts an array type to LLVM IR.
fn array_to_llvm(elem: &hir_ty::Type, size: u64) -> String {
    let mut result = common::make_string("[");
    let size_str = format_u64(size);
    result.push_str(size_str.as_str());
    result.push_str(" x ");
    let elem_str = type_to_llvm(elem);
    result.push_str(elem_str.as_str());
    result.push_str("]");
    result
}

/// Converts a slice type to LLVM IR.
/// Slices are fat pointers: { ptr, i64 }
fn slice_to_llvm(_elem: &hir_ty::Type) -> String {
    common::make_string("{ ptr, i64 }")
}

/// Converts a reference type to LLVM IR.
fn ref_to_llvm(_inner: &hir_ty::Type) -> String {
    common::make_string("ptr")
}

/// Converts a raw pointer type to LLVM IR.
fn ptr_to_llvm(_inner: &hir_ty::Type) -> String {
    common::make_string("ptr")
}

/// Converts an ADT (struct/enum) type to LLVM IR.
/// For now, we use an opaque pointer representation.
fn adt_to_llvm(_args: &Vec<hir_ty::Type>) -> String {
    common::make_string("ptr")
}

/// Converts a function type to LLVM IR.
fn fn_to_llvm(params: &Vec<hir_ty::Type>, return_ty: &hir_ty::Type) -> String {
    let mut result = type_to_llvm(return_ty);
    result.push_str(" (");
    let mut i: usize = 0;
    while i < params.len() {
        if i > 0 {
            result.push_str(", ");
        }
        let param_str = type_to_llvm(&params[i]);
        result.push_str(param_str.as_str());
        i = i + 1;
    }
    result.push_str(")*");
    result
}

/// Converts a type parameter to LLVM IR.
/// Type parameters should be monomorphized before codegen.
fn param_to_llvm(_var_id: &hir_def::TyVarId) -> String {
    common::make_string("ptr")
}

// ============================================================
// Type Size and Alignment
// ============================================================

/// Gets the layout for a type.
pub fn get_layout(ty: &hir_ty::Type) -> TypeLayout {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => primitive_layout(prim),
        &hir_ty::TypeKind::Never => TypeLayout::new(0, 1, common::make_string("void")),
        &hir_ty::TypeKind::Tuple(ref elems) => tuple_layout(elems),
        &hir_ty::TypeKind::Array { ref element, size } => array_layout(element.as_ref(), size),
        &hir_ty::TypeKind::Slice { element: _ } => TypeLayout::new(16, 8, common::make_string("{ ptr, i64 }")),
        &hir_ty::TypeKind::Ref { inner: _, mutable: _ } => TypeLayout::pointer(),
        &hir_ty::TypeKind::Ptr { inner: _, mutable: _ } => TypeLayout::pointer(),
        &hir_ty::TypeKind::Adt { def_id: _, args: _ } => TypeLayout::pointer(),
        &hir_ty::TypeKind::Fn { params: _, ret: _, effects: _ } => TypeLayout::pointer(),
        &hir_ty::TypeKind::Param(_) => TypeLayout::pointer(),
        &hir_ty::TypeKind::Infer(_) => TypeLayout::new(8, 8, common::make_string("i64")),
        &hir_ty::TypeKind::Record { fields: _, row_var: _ } => TypeLayout::pointer(),
        &hir_ty::TypeKind::Forall { params: _, body: _ } => TypeLayout::pointer(),
        // Ownership qualifiers don't affect layout
        &hir_ty::TypeKind::Ownership { qualifier: _, ref inner } => get_layout(inner.as_ref()),
        &hir_ty::TypeKind::Error => TypeLayout::new(8, 8, common::make_string("i64")),
    }
}

/// Gets layout for a primitive type.
fn primitive_layout(prim: &hir_ty::PrimitiveTy) -> TypeLayout {
    match prim {
        &hir_ty::PrimitiveTy::Bool => TypeLayout::primitive(1, common::make_string("i1")),
        &hir_ty::PrimitiveTy::Char => TypeLayout::primitive(4, common::make_string("i32")),
        &hir_ty::PrimitiveTy::I8 => TypeLayout::primitive(1, common::make_string("i8")),
        &hir_ty::PrimitiveTy::I16 => TypeLayout::primitive(2, common::make_string("i16")),
        &hir_ty::PrimitiveTy::I32 => TypeLayout::primitive(4, common::make_string("i32")),
        &hir_ty::PrimitiveTy::I64 => TypeLayout::primitive(8, common::make_string("i64")),
        &hir_ty::PrimitiveTy::I128 => TypeLayout::primitive(16, common::make_string("i128")),
        &hir_ty::PrimitiveTy::Isize => TypeLayout::primitive(8, common::make_string("i64")),
        &hir_ty::PrimitiveTy::U8 => TypeLayout::primitive(1, common::make_string("i8")),
        &hir_ty::PrimitiveTy::U16 => TypeLayout::primitive(2, common::make_string("i16")),
        &hir_ty::PrimitiveTy::U32 => TypeLayout::primitive(4, common::make_string("i32")),
        &hir_ty::PrimitiveTy::U64 => TypeLayout::primitive(8, common::make_string("i64")),
        &hir_ty::PrimitiveTy::U128 => TypeLayout::primitive(16, common::make_string("i128")),
        &hir_ty::PrimitiveTy::Usize => TypeLayout::primitive(8, common::make_string("i64")),
        &hir_ty::PrimitiveTy::F32 => TypeLayout::primitive(4, common::make_string("float")),
        &hir_ty::PrimitiveTy::F64 => TypeLayout::primitive(8, common::make_string("double")),
        &hir_ty::PrimitiveTy::Str => TypeLayout::pointer(),
    }
}

/// Gets layout for a tuple type.
fn tuple_layout(elems: &Vec<hir_ty::Type>) -> TypeLayout {
    if elems.len() == 0 {
        return TypeLayout::new(0, 1, common::make_string("{}"));
    }

    let mut size: u64 = 0;
    let mut align: u64 = 1;
    let mut i: usize = 0;
    while i < elems.len() {
        let elem_layout = get_layout(&elems[i]);
        // Align offset
        let padding = (elem_layout.align - (size % elem_layout.align)) % elem_layout.align;
        size = size + padding + elem_layout.size;
        if elem_layout.align > align {
            align = elem_layout.align;
        }
        i = i + 1;
    }
    // Pad to alignment
    let padding = (align - (size % align)) % align;
    size = size + padding;

    TypeLayout::new(size, align, tuple_to_llvm(elems))
}

/// Gets layout for an array type.
fn array_layout(elem: &hir_ty::Type, count: u64) -> TypeLayout {
    let elem_layout = get_layout(elem);
    TypeLayout::new(
        elem_layout.size * count,
        elem_layout.align,
        array_to_llvm(elem, count),
    )
}

/// Returns the size of a type in bytes.
pub fn type_size_bytes(ty: &hir_ty::Type) -> u64 {
    get_layout(ty).size
}

// ============================================================
// Integer to String Conversion
// ============================================================

/// Converts a u64 to its string representation.
pub fn format_u64(n: u64) -> String {
    if n == 0 {
        return common::make_string("0");
    }

    let mut result = String::new();
    let mut value = n;
    let mut digits: Vec<char> = Vec::new();

    while value > 0 {
        let digit = (value % 10) as u32;
        let c = (48u32 + digit) as char;
        digits.push(c);
        value = value / 10;
    }

    // Reverse the digits
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        result.push(digits[i]);
    }

    result
}

/// Converts an i64 to its string representation.
pub fn i64_to_string(n: i64) -> String {
    if n < 0 {
        let mut result = common::make_string("-");
        let abs_val = (0i64 - n) as u64;
        let abs_str = format_u64(abs_val);
        result.push_str(abs_str.as_str());
        result
    } else {
        format_u64(n as u64)
    }
}

/// Converts a u128 to its string representation.
pub fn format_u128(n: u128) -> String {
    if n == 0 {
        return common::make_string("0");
    }

    let mut result = String::new();
    let mut value = n;
    let mut digits: Vec<char> = Vec::new();

    while value > 0 {
        let digit = (value % 10) as u32;
        let c = (48u32 + digit) as char;
        digits.push(c);
        value = value / 10;
    }

    // Reverse the digits
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        result.push(digits[i]);
    }

    result
}

/// Converts an i128 to its string representation.
pub fn i128_to_string(n: i128) -> String {
    if n < 0 {
        let mut result = common::make_string("-");
        let abs_val = (0i128 - n) as u128;
        let abs_str = format_u128(abs_val);
        result.push_str(abs_str.as_str());
        result
    } else {
        format_u128(n as u128)
    }
}

// ============================================================
// Float to String Conversion
// ============================================================

/// Converts an f64 (represented as bits) to its hexadecimal LLVM format.
/// LLVM uses hexadecimal floating point for exact representation.
pub fn f64_bits_to_llvm_hex(bits: u64) -> String {
    let mut result = common::make_string("0x");
    let mut i: i64 = 60;
    while i >= 0 {
        let nibble = ((bits >> (i as u64)) & 0xF) as u32;
        let c = if nibble < 10 {
            (48u32 + nibble) as char
        } else {
            (55u32 + nibble) as char
        };
        result.push(c);
        i = i - 4;
    }
    result
}

/// Converts an f32 (represented as bits) to its hexadecimal LLVM format.
pub fn f32_bits_to_llvm_hex(bits: u32) -> String {
    // LLVM represents f32 as the high bits of an f64 hex constant
    let extended = (bits as u64) << 32;
    f64_bits_to_llvm_hex(extended)
}

// ============================================================
// Utility Functions
// ============================================================

/// Returns true if the type is a zero-sized type.
pub fn is_zst(ty: &hir_ty::Type) -> bool {
    let layout = get_layout(ty);
    layout.size == 0
}

/// Returns true if the type is a primitive integer type.
pub fn is_integer(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::I8 => true,
                &hir_ty::PrimitiveTy::I16 => true,
                &hir_ty::PrimitiveTy::I32 => true,
                &hir_ty::PrimitiveTy::I64 => true,
                &hir_ty::PrimitiveTy::I128 => true,
                &hir_ty::PrimitiveTy::Isize => true,
                &hir_ty::PrimitiveTy::U8 => true,
                &hir_ty::PrimitiveTy::U16 => true,
                &hir_ty::PrimitiveTy::U32 => true,
                &hir_ty::PrimitiveTy::U64 => true,
                &hir_ty::PrimitiveTy::U128 => true,
                &hir_ty::PrimitiveTy::Usize => true,
                _ => false,
            }
        }
        _ => false,
    }
}

/// Returns true if the type is a signed integer type.
pub fn is_signed(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::I8 => true,
                &hir_ty::PrimitiveTy::I16 => true,
                &hir_ty::PrimitiveTy::I32 => true,
                &hir_ty::PrimitiveTy::I64 => true,
                &hir_ty::PrimitiveTy::I128 => true,
                &hir_ty::PrimitiveTy::Isize => true,
                _ => false,
            }
        }
        _ => false,
    }
}

/// Returns true if the type is a floating point type.
pub fn is_float(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::F32 => true,
                &hir_ty::PrimitiveTy::F64 => true,
                _ => false,
            }
        }
        _ => false,
    }
}

/// Returns true if the type is a boolean.
pub fn is_bool(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::Bool => true,
                _ => false,
            }
        }
        _ => false,
    }
}

/// Returns true if the type is a pointer-like type (ref, raw ptr, function ptr).
pub fn is_pointer_like(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Ref { inner: _, mutable: _ } => true,
        &hir_ty::TypeKind::Ptr { inner: _, mutable: _ } => true,
        &hir_ty::TypeKind::Fn { params: _, ret: _, effects: _ } => true,
        _ => false,
    }
}
