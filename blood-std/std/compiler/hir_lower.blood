// Blood Self-Hosted Compiler - HIR Lowering
//
// This module provides the AST-to-HIR lowering pipeline. It transforms
// a parsed AST into the High-level Intermediate Representation (HIR)
// with resolved names and semantic types.
//
// The lowering process:
// 1. Create LoweringCtx with a fresh Resolver
// 2. First pass: Register all type names (structs, enums, traits, effects)
// 3. Second pass: Register all other declarations (functions, consts, statics)
// 4. Third pass: Lower all declarations to HIR items
// 5. Fourth pass: Lower all function bodies to HIR bodies
// 6. Find entry point (main function)
// 7. Return HIR Crate or errors
//
// This module orchestrates the pipeline and handles registration phases.
// Type lowering is in hir_lower_type.blood.
// Item lowering is in hir_lower_item.blood.
// Context types are in hir_lower_ctx.blood.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_item;
mod hir_lower_expr;
mod hir_lower_body;
mod interner;
mod source;
mod parser;

// ============================================================
// Main Lowering Pipeline
// ============================================================

/// Lower an AST Program to an HIR Crate.
pub fn lower_program(program: &ast::Program, source: &str) -> hir_lower_ctx::LowerResult {
    lower_program_with_base_dir(program, common::make_string("."), source)
}

/// Lower an AST Program to an HIR Crate with a specified base directory.
/// The base directory is used for resolving external module paths.
pub fn lower_program_with_base_dir(program: &ast::Program, base_dir: String, source: &str) -> hir_lower_ctx::LowerResult {
    println_str("[lower] Creating context...");
    let mut ctx = hir_lower_ctx::LoweringCtx::with_base_dir(base_dir, common::make_string(source));
    println_str("[lower] Context created");

    // Allocate root module DefId
    println_str("[lower] Allocating root DefId...");
    let root_def_id = ctx.alloc_def_id();
    println_str("[lower] Root DefId allocated");

    // Phase 1: Register type names (structs, enums, traits, effects)
    println_str("[lower] Phase 1: register_type_names...");
    register_type_names(&mut ctx, &program.declarations);
    println_str("[lower] Phase 1 complete");

    // Phase 2: Register other declarations (functions, consts, statics)
    println_str("[lower] Phase 2: register_declarations...");
    register_declarations(&mut ctx, &program.declarations);
    println_str("[lower] Phase 2 complete");

    // Check for errors from registration
    if ctx.has_errors() {
        println_str("[lower] Errors in registration, returning");
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 3: Lower declarations to HIR items
    println_str("[lower] Phase 3: lower_declarations...");
    hir_lower_item::lower_declarations(&mut ctx, &program.declarations);
    println_str("[lower] Phase 3 complete");

    // Phase 3b: Lower external module declarations
    println_str("[lower] Phase 3b: lower_external_module_declarations...");
    lower_external_module_declarations(&mut ctx);
    println_str("[lower] Phase 3b complete");

    // Check for errors from item lowering
    if ctx.has_errors() {
        print_str("[lower] Errors in item lowering: ");
        println_int(ctx.diagnostics.len() as i32);
        // Print first few error messages
        let mut i: usize = 0;
        while i < ctx.diagnostics.len() && i < 5 {
            print_str("[lower] Error ");
            println_int(i as i32);
            print_str("  message: ");
            println_str(ctx.diagnostics[i].message.as_str());
            i = i + 1;
        }
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 4: Lower function bodies to HIR bodies
    println_str("[lower] Phase 4: lower_fn_bodies...");
    lower_fn_bodies(&mut ctx, &program.declarations);
    println_str("[lower] Phase 4 complete");

    // Phase 4b: Lower external module function bodies
    println_str("[lower] Phase 4b: lower_external_module_fn_bodies...");
    lower_external_module_fn_bodies(&mut ctx);
    println_str("[lower] Phase 4b complete");

    // Check for errors from body lowering
    if ctx.has_errors() {
        println_str("[lower] Errors in body lowering, returning");
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Build the Crate
    println_str("[lower] Building Crate...");
    let crate_data = hir::Crate {
        entry: ctx.entry_point,
        root_module: root_def_id,
        item_count: ctx.items.len() as u32,
        body_count: ctx.bodies.len() as u32,
    };
    println_str("[lower] Crate built");

    // Transfer items, item_index, and bodies to the result
    println_str("[lower] Creating result...");
    hir_lower_ctx::LowerResult::success_with_data(crate_data, ctx.items, ctx.item_index, ctx.bodies)
}

// ============================================================
// Phase 1: Register Type Names
// ============================================================

/// First pass: register all type names so they can be referenced.
fn register_type_names(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_type_name(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Register a single declaration's type name if applicable.
fn register_type_name(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Struct,
                    name_symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Enum(ref e) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(e.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    e.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Enum,
                    name_symbol,
                    e.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Trait(ref t) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(t.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    t.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Trait,
                    name_symbol,
                    t.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Effect(ref eff) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(eff.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    eff.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Effect,
                    name_symbol,
                    eff.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(ta.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    ta.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::TypeAlias,
                    name_symbol,
                    ta.name.span,
                    Option::None,
                );
            }
        }
        // Non-type declarations handled in phase 2
        &ast::Declaration::Function(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Inline module: register the module DefId and nested type names
                    let def_id = ctx.alloc_def_id();
                    // Re-intern the name from span to ensure consistent symbol indices
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_symbol = ctx.intern(name_str.as_str());
                    let success = ctx.resolver.define_global(name_symbol, def_id);
                    if !success {
                        ctx.error(
                            hir::DiagnosticCode::E0101,
                            common::make_string("duplicate definition"),
                            m.name.span,
                        );
                    } else {
                        ctx.resolver.register_def_info(
                            def_id,
                            hir_def::DefKind::Module,
                            name_symbol,
                            m.name.span,
                            Option::None,
                        );
                        // Recursively register nested type names
                        register_module_type_names(ctx, def_id, declarations);
                    }
                }
                &Option::None => {
                    // External module - load from file
                    load_external_module(ctx, m.name.symbol, m.name.span, m.vis, m.span);
                }
            }
        }
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// External Module Loading
// ============================================================

/// Loads an external module from a file.
/// Builds the file path, reads, parses, and registers the module's contents.
fn load_external_module(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    name: common::Symbol,
    name_span: common::Span,
    vis: common::Visibility,
    span: common::Span,
) {
    // Build the file path: base_dir/module_name.blood
    let module_name = resolve_symbol_to_string(ctx, name);
    let mut file_path = clone_string(ctx.get_base_dir());
    file_path.push('/');
    append_string(&mut file_path, &module_name);
    file_path.push_str(".blood");

    // Check for circular import
    let existing = ctx.find_loaded_module(&file_path);
    if existing.is_some() {
        // Module already loaded - just define the name pointing to existing DefId
        let existing_def_id = existing.unwrap();
        let success = ctx.resolver.define_global(name, existing_def_id);
        if !success {
            ctx.error(
                hir::DiagnosticCode::E0101,
                common::make_string("duplicate definition"),
                name_span,
            );
        }
        return;
    }

    // Read the file
    let read_result = source::read_file_string(&file_path);
    if !read_result.success {
        let mut msg = common::make_string("failed to load module '");
        append_string(&mut msg, &module_name);
        msg.push_str("': ");
        match &read_result.error {
            &Option::Some(ref e) => msg.push_str(e.as_str()),
            &Option::None => msg.push_str("unknown error"),
        }
        ctx.error(hir::DiagnosticCode::E0104, msg, span);
        return;
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("module file has no content"),
                span,
            );
            return;
        }
    };

    // Parse the file
    let parse_result = parser::parse_file(content.as_str());
    if parse_result.errors.len() > 0 {
        let mut msg = common::make_string("parse error in module '");
        append_string(&mut msg, &module_name);
        msg.push_str("'");
        ctx.error(hir::DiagnosticCode::E0104, msg, span);
        return;
    }

    let program = match &parse_result.program {
        &Option::Some(ref p) => p,
        &Option::None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("no program produced from module file"),
                span,
            );
            return;
        }
    };

    // Allocate DefId for the module
    let def_id = ctx.alloc_def_id();
    let success = ctx.resolver.define_global(name, def_id);
    if !success {
        ctx.error(
            hir::DiagnosticCode::E0101,
            common::make_string("duplicate definition"),
            name_span,
        );
        return;
    }

    ctx.resolver.register_def_info(
        def_id,
        hir_def::DefKind::Module,
        name,
        name_span,
        Option::None,
    );

    // Track the loaded module to prevent circular imports
    ctx.add_loaded_module(name, def_id, clone_string(&file_path));

    // Phase 1: Register nested type names from the loaded module
    register_module_type_names(ctx, def_id, &program.declarations);

    // Phase 2: Register declarations (functions, consts, statics) from the loaded module
    register_module_declarations(ctx, def_id, &program.declarations);
}

/// Resolves a symbol to a string for file path construction.
fn resolve_symbol_to_string(ctx: &mut hir_lower_ctx::LoweringCtx, symbol: common::Symbol) -> String {
    ctx.resolve_symbol(symbol)
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    let bytes = s.as_bytes();
    let mut i: usize = 0;
    while i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Appends a String to another String.
fn append_string(dest: &mut String, src: &String) {
    let bytes = src.as_bytes();
    let mut i: usize = 0;
    while i < bytes.len() {
        dest.push(bytes[i] as char);
        i = i + 1;
    }
}

// ============================================================
// External Module Processing (Phase 3b and 4b)
// ============================================================

/// Collects external module info (path, def_id) to avoid borrow conflicts.
struct ExternalModuleInfo {
    path: String,
    def_id: hir_def::DefId,
}

impl ExternalModuleInfo {
    fn new(path: String, def_id: hir_def::DefId) -> ExternalModuleInfo {
        ExternalModuleInfo { path, def_id }
    }
}

/// Collects info about all external modules.
fn collect_external_modules(ctx: &mut hir_lower_ctx::LoweringCtx) -> Vec<ExternalModuleInfo> {
    let mut result: Vec<ExternalModuleInfo> = Vec::new();
    let mut i: usize = 0;
    while i < ctx.loaded_modules.len() {
        let path = clone_string(&ctx.loaded_modules[i].path);
        let def_id = hir_def::DefId::new(ctx.loaded_modules[i].def_id.index);
        result.push(ExternalModuleInfo::new(path, def_id));
        i = i + 1;
    }
    result
}

/// Phase 3b: Lower declarations from external modules.
fn lower_external_module_declarations(ctx: &mut hir_lower_ctx::LoweringCtx) {
    // Collect module info first to avoid borrow conflicts
    let modules = collect_external_modules(ctx);

    let mut i: usize = 0;
    while i < modules.len() {
        let path = &modules[i].path;
        let def_id = modules[i].def_id;

        // Re-parse the external module
        let read_result = source::read_file_string(path);
        if !read_result.success {
            // Skip - error should have been reported in Phase 1
            i = i + 1;
            continue;
        }

        let content = match &read_result.content {
            &Option::Some(ref c) => c,
            &Option::None => {
                i = i + 1;
                continue;
            }
        };

        let parse_result = parser::parse_file(content.as_str());
        if parse_result.errors.len() > 0 {
            // Skip - error should have been reported in Phase 1
            i = i + 1;
            continue;
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                i = i + 1;
                continue;
            }
        };

        // Lower the module's declarations as if they're inside the module
        hir_lower_item::lower_module_contents(ctx, def_id, &program.declarations);

        i = i + 1;
    }
}

/// Phase 4b: Lower function bodies from external modules.
fn lower_external_module_fn_bodies(ctx: &mut hir_lower_ctx::LoweringCtx) {
    // Collect module info first to avoid borrow conflicts
    let modules = collect_external_modules(ctx);

    let mut i: usize = 0;
    while i < modules.len() {
        let path = &modules[i].path;

        // Re-parse the external module
        let read_result = source::read_file_string(path);
        if !read_result.success {
            i = i + 1;
            continue;
        }

        let content = match &read_result.content {
            &Option::Some(ref c) => c,
            &Option::None => {
                i = i + 1;
                continue;
            }
        };

        let parse_result = parser::parse_file(content.as_str());
        if parse_result.errors.len() > 0 {
            i = i + 1;
            continue;
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                i = i + 1;
                continue;
            }
        };

        // Lower the module's function bodies
        lower_fn_bodies(ctx, &program.declarations);

        i = i + 1;
    }
}

/// Appends a u32 as decimal to a string.
fn append_u32(s: &mut String, n: u32) {
    if n == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<char> = Vec::new();
    let mut val = n;
    while val > 0 {
        let digit = (val % 10) as u8;
        digits.push((48u8 + digit) as char);
        val = val / 10;
    }
    let len = digits.len();
    let mut i: usize = 0;
    while i < len {
        s.push(digits[len - 1 - i]);
        i = i + 1;
    }
}

// ============================================================
// Helper: Register Module Type Names (Phase 1 recursive)
// ============================================================

/// Recursively register type names within a module.
fn register_module_type_names(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decls: &Vec<ast::Declaration>,
) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_module_type_name(ctx, parent_def_id, &decls[i]);
        i = i + 1;
    }
}

/// Register a single type name within a module.
/// Note: Nested items are NOT added to any scope - they're only accessible via qualified paths.
/// We just register them in def_info with the correct parent for lookup_in_parent to find.
fn register_module_type_name(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Only register in def_info - accessible via qualified paths (e.g., mod::Struct)
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Struct,
                s.name.symbol,
                s.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Enum(ref e) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Enum,
                e.name.symbol,
                e.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Trait(ref t) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Trait,
                t.name.symbol,
                t.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Effect(ref eff) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Effect,
                eff.name.symbol,
                eff.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::TypeAlias,
                ta.name.symbol,
                ta.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Module(ref m) => {
            // Nested module
            match &m.body {
                &Option::Some(ref nested_decls) => {
                    let def_id = ctx.alloc_def_id();
                    ctx.resolver.register_def_info(
                        def_id,
                        hir_def::DefKind::Module,
                        m.name.symbol,
                        m.name.span,
                        Option::Some(parent_def_id),
                    );
                    // Recursively register nested module's type names
                    register_module_type_names(ctx, def_id, nested_decls);
                }
                &Option::None => {
                    // External module within inline module - not supported
                    ctx.error(
                        hir::DiagnosticCode::E0104,
                        common::make_string("external modules not yet supported in self-hosted compiler"),
                        m.span,
                    );
                }
            }
        }
        // Non-type declarations handled in phase 2
        &ast::Declaration::Function(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// Phase 2: Register Other Declarations
// ============================================================

/// Second pass: register functions, consts, statics.
fn register_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_declaration(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Register a single non-type declaration.
fn register_declaration(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(f.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    f.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Fn,
                    name_symbol,
                    f.name.span,
                    Option::None,
                );
                // Check if this is the main function
                if name_symbol.index == interner::SpecialIdents::main_sym().index {
                    ctx.entry_point = Option::Some(def_id);
                }
            }
        }
        &ast::Declaration::Const(ref c) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(c.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    c.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Const,
                    name_symbol,
                    c.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Static(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Static,
                    name_symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Handler(ref h) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(h.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    h.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Handler,
                    name_symbol,
                    h.name.span,
                    Option::None,
                );
            }
        }
        // Types already registered in phase 1
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        // Impl blocks don't have names
        &ast::Declaration::Impl(_) => {}
        // Bridge, Module, Macro need special handling
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Look up the module's DefId from Phase 1
                    let lookup = ctx.resolver.lookup(m.name.symbol);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let mod_def_id = hir_def::DefId::new(binding.def_id.index);
                        // Recursively register nested declarations
                        register_module_declarations(ctx, mod_def_id, declarations);
                    }
                }
                &Option::None => {} // Already errored in Phase 1
            }
        }
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// Helper: Register Module Declarations (Phase 2 recursive)
// ============================================================

/// Recursively register declarations (functions, consts, statics) within a module.
fn register_module_declarations(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decls: &Vec<ast::Declaration>,
) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_module_declaration(ctx, parent_def_id, &decls[i]);
        i = i + 1;
    }
}

/// Register a single declaration within a module.
fn register_module_declaration(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            let def_id = ctx.alloc_def_id();
            // Note: Don't use define_global - nested items are accessed via qualified paths
            // Register in def_info with parent so lookup_in_parent can find it
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Fn,
                f.name.symbol,
                f.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Const(ref c) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Const,
                c.name.symbol,
                c.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Static(ref s) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Static,
                s.name.symbol,
                s.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Handler(ref h) => {
            let def_id = ctx.alloc_def_id();
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Handler,
                h.name.symbol,
                h.name.span,
                Option::Some(parent_def_id),
            );
        }
        &ast::Declaration::Module(ref m) => {
            // Nested module - look up its DefId and recurse
            match &m.body {
                &Option::Some(ref nested_decls) => {
                    // Find the nested module's DefId (registered in Phase 1)
                    let nested_mod_def = ctx.resolver.lookup_in_parent(parent_def_id, m.name.symbol);
                    if nested_mod_def.is_some() {
                        let nested_def_id = nested_mod_def.unwrap();
                        register_module_declarations(ctx, nested_def_id, nested_decls);
                    }
                }
                &Option::None => {} // Already errored
            }
        }
        // Types already registered in Phase 1
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        // Impl blocks don't have names
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// Phase 4: Lower Function Bodies
// ============================================================

/// Fourth pass: lower function bodies to HIR bodies.
fn lower_fn_bodies(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        lower_fn_body_if_present(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Lower a function body if the declaration is a function with a body.
fn lower_fn_body_if_present(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            // Only lower if there's a body
            if f.body.is_some() {
                lower_single_fn_body(ctx, f);
            }
        }
        // Other declarations don't have bodies (in this phase)
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Recursively lower function bodies inside the module
                    lower_fn_bodies(ctx, declarations);
                }
                &Option::None => {} // External module - already errored
            }
        }
        &ast::Declaration::Macro(_) => {}
    }
}

/// Lower a single function's body.
fn lower_single_fn_body(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl) {
    println_str("[lower_single_fn_body] Starting...");
    print_str("[lower_single_fn_body] f.params.len() = ");
    println_int(f.params.len() as i32);

    // Allocate a BodyId for this function
    let body_id = ctx.alloc_body_id();

    // Lower the function parameters (for creating locals)
    println_str("[lower_single_fn_body] Calling lower_fn_params...");
    let params = hir_lower_item::lower_fn_params(ctx, &f.params);

    // Lower the body
    let body = hir_lower_body::lower_fn_body(
        ctx,
        body_id,
        &params,
        &f.params,      // AST params for complex pattern destructuring
        &Option::None,  // No expression body (Blood uses block bodies)
        &f.body,
    );

    // Store the body
    ctx.add_body(body_id, body);
}
