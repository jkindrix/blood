// Blood Self-Hosted Compiler - HIR Lowering
//
// This module provides the AST-to-HIR lowering pipeline. It transforms
// a parsed AST into the High-level Intermediate Representation (HIR)
// with resolved names and semantic types.
//
// The lowering process:
// 1. Create LoweringCtx with a fresh Resolver
// 2. First pass: Register all type names (structs, enums, traits, effects)
// 3. Second pass: Register all other declarations (functions, consts, statics)
// 4. Third pass: Lower all declarations to HIR items
// 5. Fourth pass: Lower all function bodies to HIR bodies
// 6. Find entry point (main function)
// 7. Return HIR Crate or errors
//
// This module orchestrates the pipeline and handles registration phases.
// Type lowering is in hir_lower_type.blood.
// Item lowering is in hir_lower_item.blood.
// Context types are in hir_lower_ctx.blood.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_item;
mod hir_lower_expr;
mod hir_lower_body;
mod interner;

// ============================================================
// Main Lowering Pipeline
// ============================================================

/// Lower an AST Program to an HIR Crate.
pub fn lower_program(program: &ast::Program) -> hir_lower_ctx::LowerResult {
    let mut ctx = hir_lower_ctx::LoweringCtx::new();

    // Allocate root module DefId
    let root_def_id = ctx.alloc_def_id();

    // Phase 1: Register type names (structs, enums, traits, effects)
    register_type_names(&mut ctx, &program.declarations);

    // Phase 2: Register other declarations (functions, consts, statics)
    register_declarations(&mut ctx, &program.declarations);

    // Check for errors from registration
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 3: Lower declarations to HIR items
    hir_lower_item::lower_declarations(&mut ctx, &program.declarations);

    // Check for errors from item lowering
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 4: Lower function bodies to HIR bodies
    lower_fn_bodies(&mut ctx, &program.declarations);

    // Check for errors from body lowering
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Build the Crate
    let crate_data = hir::Crate {
        entry: ctx.entry_point,
        root_module: root_def_id,
        item_count: ctx.items.len() as u32,
        body_count: ctx.bodies.len() as u32,
    };

    // Transfer items, item_index, and bodies to the result
    hir_lower_ctx::LowerResult::success_with_data(crate_data, ctx.items, ctx.item_index, ctx.bodies)
}

// ============================================================
// Phase 1: Register Type Names
// ============================================================

/// First pass: register all type names so they can be referenced.
fn register_type_names(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_type_name(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Register a single declaration's type name if applicable.
fn register_type_name(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(s.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Struct,
                    s.name.symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Enum(ref e) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(e.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    e.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Enum,
                    e.name.symbol,
                    e.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Trait(ref t) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(t.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    t.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Trait,
                    t.name.symbol,
                    t.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Effect(ref eff) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(eff.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    eff.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Effect,
                    eff.name.symbol,
                    eff.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(ta.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    ta.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::TypeAlias,
                    ta.name.symbol,
                    ta.name.span,
                    Option::None,
                );
            }
        }
        // Non-type declarations handled in phase 2
        &ast::Declaration::Function(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(_) => {}
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// Phase 2: Register Other Declarations
// ============================================================

/// Second pass: register functions, consts, statics.
fn register_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        register_declaration(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Register a single non-type declaration.
fn register_declaration(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(f.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    f.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Fn,
                    f.name.symbol,
                    f.name.span,
                    Option::None,
                );
                // Check if this is the main function
                if f.name.symbol.index == interner::SpecialIdents::main_sym().index {
                    ctx.entry_point = Option::Some(def_id);
                }
            }
        }
        &ast::Declaration::Const(ref c) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(c.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    c.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Const,
                    c.name.symbol,
                    c.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Static(ref s) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(s.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Static,
                    s.name.symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Handler(ref h) => {
            let def_id = ctx.alloc_def_id();
            let success = ctx.resolver.define_global(h.name.symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    h.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Handler,
                    h.name.symbol,
                    h.name.span,
                    Option::None,
                );
            }
        }
        // Types already registered in phase 1
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        // Impl blocks don't have names
        &ast::Declaration::Impl(_) => {}
        // Bridge, Module, Macro need special handling
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(_) => {}
        &ast::Declaration::Macro(_) => {}
    }
}

// ============================================================
// Phase 4: Lower Function Bodies
// ============================================================

/// Fourth pass: lower function bodies to HIR bodies.
fn lower_fn_bodies(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    let mut i: usize = 0;
    while i < decls.len() {
        lower_fn_body_if_present(ctx, &decls[i]);
        i = i + 1;
    }
}

/// Lower a function body if the declaration is a function with a body.
fn lower_fn_body_if_present(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            // Only lower if there's a body
            if f.body.is_some() {
                lower_single_fn_body(ctx, f);
            }
        }
        // Other declarations don't have bodies (in this phase)
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(_) => {}
        &ast::Declaration::Macro(_) => {}
    }
}

/// Lower a single function's body.
fn lower_single_fn_body(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl) {
    // Allocate a BodyId for this function
    let body_id = ctx.alloc_body_id();

    // Lower the function parameters (for creating locals)
    let params = hir_lower_item::lower_fn_params(ctx, &f.params);

    // Lower the body
    let body = hir_lower_body::lower_fn_body(
        ctx,
        body_id,
        &params,
        &f.params,      // AST params for complex pattern destructuring
        &Option::None,  // No expression body (Blood uses block bodies)
        &f.body,
    );

    // Store the body
    ctx.add_body(body_id, body);
}
