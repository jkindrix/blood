// Blood Self-Hosted Compiler - Type Checking Driver
//
// This module provides the entry point for type checking a lowered HIR.
// It coordinates the TypeChecker from typeck.blood with the expression
// checking from typeck_expr.blood to check all function bodies.
//
// Pipeline integration:
//   AST -> lower_program() -> LoweringCtx -> check_types() -> TypeCheckResult
//
// The type checking driver:
// 1. Collects type information from all items (structs, enums, functions)
// 2. Type checks each function body
// 3. Returns type errors or success

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod unify;
mod typeck;
mod typeck_expr;
mod interner;

// ============================================================
// Type Check Result
// ============================================================

/// Result of type checking a crate.
pub struct TypeCheckResult {
    /// Whether type checking succeeded.
    pub success: bool,
    /// Type errors encountered.
    pub errors: Vec<typeck::TypeError>,
    /// The substitution table from type inference.
    /// Contains resolved type variables that must be applied during MIR lowering.
    pub subst_table: unify::SubstTable,
}

impl TypeCheckResult {
    /// Creates a successful result with a substitution table.
    pub fn ok(subst_table: unify::SubstTable) -> TypeCheckResult {
        TypeCheckResult {
            success: true,
            errors: Vec::new(),
            subst_table: subst_table,
        }
    }

    /// Creates a failed result with errors and a substitution table.
    pub fn failed(errors: Vec<typeck::TypeError>, subst_table: unify::SubstTable) -> TypeCheckResult {
        TypeCheckResult {
            success: false,
            errors: errors,
            subst_table: subst_table,
        }
    }

    /// Returns true if type checking passed.
    pub fn is_ok(self: &Self) -> bool {
        self.success
    }

    /// Returns the number of errors.
    pub fn error_count(self: &Self) -> usize {
        self.errors.len()
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Type check a lowered HIR crate.
///
/// Takes the lowering context which contains all items and bodies,
/// and returns a TypeCheckResult indicating success or failure.
pub fn check_types(ctx: &hir_lower_ctx::LoweringCtx) -> TypeCheckResult {
    let mut checker = typeck::TypeChecker::new();

    // Phase 1: Collect type information from items
    // (For now, we skip this since we don't have item signatures stored separately)

    // Phase 2: Type check all function bodies
    let mut i: usize = 0;
    while i < ctx.bodies.len() {
        let body_entry = &ctx.bodies[i];
        let return_ty = find_return_type_for_body(&ctx.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table)
    } else {
        TypeCheckResult::ok(checker.subst_table)
    }
}

/// Type check using a LowerResult (for driver integration).
///
/// This is the preferred entry point when integrating with the driver,
/// since the driver has LowerResult not LoweringCtx.
pub fn check_lower_result(result: &hir_lower_ctx::LowerResult) -> TypeCheckResult {
    // Start the type checker's TyVarId counter where HIR lowering left off
    // to avoid collisions between HIR inference variables and type checker variables.
    let mut checker = typeck::TypeChecker::new_from(result.next_ty_var);

    // Pass builtin type info from HIR lowering
    checker.next_def_id = result.next_def_id;
    checker.builtin_string_def = copy_opt_def_id(&result.builtin_string_def);
    checker.builtin_vec_def = copy_opt_def_id(&result.builtin_vec_def);
    checker.builtin_option_def = copy_opt_def_id(&result.builtin_option_def);
    checker.builtin_box_def = copy_opt_def_id(&result.builtin_box_def);
    checker.builtin_hashmap_def = copy_opt_def_id(&result.builtin_hashmap_def);
    checker.builtin_result_def = copy_opt_def_id(&result.builtin_result_def);

    // Phase 1: Collect type information from items
    collect_item_signatures(&mut checker, &result.items);

    // Phase 1b: Register builtin method signatures for String, Vec, Option, etc.
    register_builtin_signatures(&mut checker);

    // Phase 1c: Register builtin enum info (Option, Result) for exhaustiveness checking
    register_builtin_enums(&mut checker);

    // Phase 2: Type check function bodies from the main file only.
    // External module bodies (index >= main_body_count) are skipped because
    // their internal cross-module paths may not fully resolve in this context.
    // Each module's bodies are checked when that module is the main file.
    let body_limit = result.main_body_count;
    let mut i: usize = 0;
    while i < body_limit {
        let body_entry = &result.bodies[i];
        let return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table)
    } else {
        TypeCheckResult::ok(checker.subst_table)
    }
}

/// Collects type signatures from HIR items.
///
/// This populates the type checker with information about struct, enum,
/// and function definitions so it can resolve types during body checking.
fn collect_item_signatures(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                // Register function signature
                checker.register_fn_sig(entry.def_id, &fn_def.sig);
            }
            &hir_item::ItemKind::Struct(ref struct_def) => {
                // Register struct definition
                checker.register_struct(entry.def_id, entry.item.name.symbol, struct_def);
            }
            &hir_item::ItemKind::Enum(ref enum_def) => {
                // Register enum definition
                checker.register_enum(entry.def_id, entry.item.name.symbol, enum_def);
            }
            &hir_item::ItemKind::Const(ref const_def) => {
                // Register constant definition
                checker.register_const(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&const_def.ty));
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                // Register static definition
                checker.register_static(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&static_def.ty), static_def.mutable);
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Register impl block for method resolution
                register_impl(checker, entry.def_id, impl_def);
            }
            // Other items don't need registration for basic type checking
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(ref effect_def) => {
                register_effect(checker, entry.def_id, entry.item.name.symbol, effect_def);
            }
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
}

/// Registers an impl block for method resolution.
fn register_impl(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    impl_def: &hir_item::ImplDef,
) {
    // Extract method info from associated items
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();
    let mut i: usize = 0;
    while i < impl_def.items.len() {
        match &impl_def.items[i] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                // Extract parameter types from signature (skipping self param)
                let mut param_tys: Vec<hir_ty::Type> = Vec::new();
                let mut takes_self_ref = false;
                let mut takes_self_mut = false;

                // Check if first param is self
                if assoc_fn.sig.params.len() > 0 {
                    // Check first param for self pattern
                    // For now, assume first param might be self and check params
                    let mut j: usize = 0;
                    while j < assoc_fn.sig.params.len() {
                        // Skip self parameter (index 0) if this looks like a method
                        // In HIR, self is encoded in the first parameter
                        if j == 0 && assoc_fn.sig.params[j].is_self {
                            takes_self_ref = true;
                            takes_self_mut = assoc_fn.sig.params[j].mutable;
                        } else {
                            param_tys.push(hir_ty::copy_type(&assoc_fn.sig.params[j].ty));
                        }
                        j = j + 1;
                    }
                }

                let method_info = typeck::MethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    param_tys,
                    hir_ty::copy_type(&assoc_fn.sig.return_ty),
                    takes_self_ref,
                    takes_self_mut,
                );
                methods.push(method_info);
            }
            &hir_item::AssocItem::Type(_) => {
                // Associated types don't need registration for basic method resolution
            }
            &hir_item::AssocItem::Const(_) => {
                // Associated consts don't need registration for basic method resolution
            }
        }
        i = i + 1;
    }

    // Create and register impl info
    let num_generics = count_type_params(&impl_def.generics.params);
    let impl_info = typeck::ImplInfo::new(
        def_id,
        hir_ty::copy_type(&impl_def.self_ty),
        num_generics,
        methods,
    );
    checker.register_impl(impl_info);
}

/// Registers an effect definition for type checking.
fn register_effect(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    name: common::Symbol,
    effect_def: &hir_item::EffectDef,
) {
    let num_generics = count_type_params(&effect_def.generics.params);

    // Collect operation names
    let mut op_names: Vec<common::Symbol> = Vec::new();
    let mut operations: Vec<typeck::EffectOpInfo> = Vec::new();

    let mut i: usize = 0;
    while i < effect_def.operations.len() {
        let effect_op = &effect_def.operations[i];
        op_names.push(effect_op.name.symbol);

        // Copy parameter types
        let mut param_tys: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < effect_op.param_tys.len() {
            param_tys.push(hir_ty::copy_type(&effect_op.param_tys[j]));
            j = j + 1;
        }

        let op_info = typeck::EffectOpInfo::new(
            effect_op.def_id,
            effect_op.name.symbol,
            param_tys,
            hir_ty::copy_type(&effect_op.return_ty),
        );
        operations.push(op_info);
        i = i + 1;
    }

    let info = typeck::EffectInfo::new(
        def_id,
        name,
        num_generics,
        op_names,
        operations,
    );
    checker.register_effect(def_id, info);
}

// ============================================================
// Generic Parameter Counting
// ============================================================

/// Counts only type parameters in a generics param list, excluding
/// lifetime parameters and const parameters.
fn count_type_params(params: &Vec<hir_ty::GenericParam>) -> u32 {
    let mut count: u32 = 0;
    let mut i: usize = 0;
    while i < params.len() {
        match &params[i] {
            &hir_ty::GenericParam::TypeParam(_) => {
                count = count + 1;
            }
            &hir_ty::GenericParam::LifetimeParam(_) => {}
            &hir_ty::GenericParam::ConstParam(_) => {}
        }
        i = i + 1;
    }
    count
}

// ============================================================
// Body Return Type Lookup
// ============================================================

/// Finds the return type for a body by looking up the corresponding function item.
///
/// Searches the items list for a function whose body_id matches the target,
/// and returns its signature's return type directly (no substitution needed â€”
/// TypeParam nodes unify naturally through the type checker).
/// Falls back to unit type if no matching function is found.
fn find_return_type_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> hir_ty::Type {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return hir_ty::copy_type(&fn_def.sig.return_ty);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return hir_ty::copy_type(&assoc_fn.sig.return_ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(_) => {}
            &hir_item::ItemKind::Static(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to unit type if no matching function found
    hir_ty::Type::unit()
}

// ============================================================
// Body Type Checking
// ============================================================

/// Type checks a single function body.
///
/// The return_ty comes from the function signature (not from body locals).
fn check_body(checker: &mut typeck::TypeChecker, body: &hir_expr::Body, return_ty: &hir_ty::Type) {
    // Clear locals for this body
    checker.clear_locals();

    // Register all locals from the body at their actual LocalId positions.
    // HIR lowering allocates LocalIds globally (not per-body), so a body's
    // locals may have non-zero starting indices. We must grow the locals
    // vector to accommodate the highest LocalId, then place each local at
    // its actual index.
    let mut i: usize = 0;
    while i < body.locals.len() {
        let local = &body.locals[i];
        let target_idx = local.id.index as usize;
        // Grow the locals vector to accommodate this index
        while checker.locals.len() <= target_idx {
            // Pad with dummy locals (will not be accessed for valid programs)
            checker.add_local(
                hir_ty::Type::error(),
                false,
                common::Span::new(0, 0, 1, 1),
            );
        }
        // Overwrite with the real local's type
        checker.locals[target_idx] = typeck::LocalInfo::new(
            hir_ty::copy_type(&local.ty),
            local.mutable,
            local.span,
        );
        i = i + 1;
    }

    // Set return type from the function signature
    checker.set_return_ty(hir_ty::copy_type(return_ty));

    // Type check the body expression
    let body_ty = typeck_expr::infer_expr(checker, &body.expr);

    // Unify body type with return type
    match &checker.return_ty {
        &Some(ref ret_ty) => {
            let ok = checker.unify(&body_ty, ret_ty, body.expr.span);
            let _ = ok;
        }
        &None => {}
    }

    // Clear return type
    checker.clear_return_ty();
}

// ============================================================
// Builtin Method Registration
// ============================================================

/// Copies an Option<DefId> by value (for passing through references).
fn copy_opt_def_id(opt: &Option<hir_def::DefId>) -> Option<hir_def::DefId> {
    match opt {
        &Option::Some(ref d) => Option::Some(hir_def::DefId::new(d.index)),
        &Option::None => Option::None,
    }
}

/// Helper: create a reference type &T.
fn make_ref_ty(inner: hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type::new(hir_ty::TypeKind::Ref { inner: Box::new(inner), mutable: false })
}

/// Helper: create an ADT type with the given DefId and type args.
fn make_adt(def_id: hir_def::DefId, args: Vec<hir_ty::Type>) -> hir_ty::Type {
    hir_ty::Type::new(hir_ty::TypeKind::Adt { def_id: def_id, args: args })
}

/// Helper: create a type parameter Param(n).
fn make_param(n: u32) -> hir_ty::Type {
    hir_ty::Type::param(hir_def::TyVarId::new(n))
}

/// Helper: add a method to the methods list.
fn add_method(
    checker: &mut typeck::TypeChecker,
    methods: &mut Vec<typeck::MethodInfo>,
    name: &str,
    params: Vec<hir_ty::Type>,
    ret: hir_ty::Type,
    self_mut: bool,
) {
    let def_id = checker.alloc_def_id();
    let sym = interner::intern(name);
    methods.push(typeck::MethodInfo::new(def_id, sym, params, ret, true, self_mut));
}

/// Registers builtin method signatures for all builtin types.
fn register_builtin_signatures(checker: &mut typeck::TypeChecker) {
    // String methods
    match checker.builtin_string_def {
        Option::Some(def_id) => {
            register_string_methods(checker, def_id);
        }
        Option::None => {}
    }

    // Vec methods
    match checker.builtin_vec_def {
        Option::Some(def_id) => {
            register_vec_methods(checker, def_id);
        }
        Option::None => {}
    }

    // Option methods
    match checker.builtin_option_def {
        Option::Some(def_id) => {
            register_option_methods(checker, def_id);
        }
        Option::None => {}
    }

    // Box methods
    match checker.builtin_box_def {
        Option::Some(def_id) => {
            register_box_methods(checker, def_id);
        }
        Option::None => {}
    }

    // HashMap methods
    match checker.builtin_hashmap_def {
        Option::Some(def_id) => {
            register_hashmap_methods(checker, def_id);
        }
        Option::None => {}
    }

    // Result methods
    match checker.builtin_result_def {
        Option::Some(def_id) => {
            register_result_methods(checker, def_id);
        }
        Option::None => {}
    }

    // Primitive str methods
    register_str_methods(checker);

    // Slice methods
    register_slice_methods(checker);
}

/// Registers String methods: len, is_empty, push_str, push, as_str, clone,
/// contains, starts_with, ends_with, as_bytes.
fn register_string_methods(checker: &mut typeck::TypeChecker, string_def: hir_def::DefId) {
    let self_ty = make_adt(string_def, Vec::new());
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", Vec::new(), hir_ty::Type::usize_ty(), false);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", Vec::new(), hir_ty::Type::bool_ty(), false);

    // push_str(&mut self, &str) -> ()
    let mut push_str_params: Vec<hir_ty::Type> = Vec::new();
    push_str_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "push_str", push_str_params, hir_ty::Type::unit(), true);

    // push(&mut self, char) -> ()
    let mut push_params: Vec<hir_ty::Type> = Vec::new();
    push_params.push(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    add_method(checker, &mut methods, "push", push_params, hir_ty::Type::unit(), true);

    // as_str(&self) -> &str
    add_method(checker, &mut methods, "as_str", Vec::new(), make_ref_ty(hir_ty::Type::str_ty()), false);

    // clone(&self) -> String
    add_method(checker, &mut methods, "clone", Vec::new(), make_adt(string_def, Vec::new()), false);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "contains", contains_params, hir_ty::Type::bool_ty(), false);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<hir_ty::Type> = Vec::new();
    sw_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "starts_with", sw_params, hir_ty::Type::bool_ty(), false);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<hir_ty::Type> = Vec::new();
    ew_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "ends_with", ew_params, hir_ty::Type::bool_ty(), false);

    // as_bytes(&self) -> &[u8]
    let u8_slice = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(hir_ty::Type::u8_ty()),
    });
    add_method(checker, &mut methods, "as_bytes", Vec::new(), make_ref_ty(u8_slice), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers Vec<T> methods: push, pop, len, is_empty, get, last, clear,
/// remove, insert, contains, clone.
fn register_vec_methods(checker: &mut typeck::TypeChecker, vec_def: hir_def::DefId) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(vec_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // push(&mut self, T) -> ()
    let mut push_params: Vec<hir_ty::Type> = Vec::new();
    push_params.push(make_param(0));
    add_method(checker, &mut methods, "push", push_params, hir_ty::Type::unit(), true);

    // pop(&mut self) -> Option<T>
    let option_def = checker.builtin_option_def;
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(0));
            add_method(checker, &mut methods, "pop", Vec::new(), make_adt(opt_def, opt_args), true);
        }
        Option::None => {
            add_method(checker, &mut methods, "pop", Vec::new(), make_param(0), true);
        }
    }

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", Vec::new(), hir_ty::Type::usize_ty(), false);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", Vec::new(), hir_ty::Type::bool_ty(), false);

    // get(&self, usize) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut get_params: Vec<hir_ty::Type> = Vec::new();
            get_params.push(hir_ty::Type::usize_ty());
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "get", get_params, make_adt(opt_def, opt_args), false);
        }
        Option::None => {
            let mut get_params: Vec<hir_ty::Type> = Vec::new();
            get_params.push(hir_ty::Type::usize_ty());
            add_method(checker, &mut methods, "get", get_params, make_ref_ty(make_param(0)), false);
        }
    }

    // last(&self) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "last", Vec::new(), make_adt(opt_def, opt_args), false);
        }
        Option::None => {
            add_method(checker, &mut methods, "last", Vec::new(), make_ref_ty(make_param(0)), false);
        }
    }

    // clear(&mut self) -> ()
    add_method(checker, &mut methods, "clear", Vec::new(), hir_ty::Type::unit(), true);

    // remove(&mut self, usize) -> T
    let mut remove_params: Vec<hir_ty::Type> = Vec::new();
    remove_params.push(hir_ty::Type::usize_ty());
    add_method(checker, &mut methods, "remove", remove_params, make_param(0), true);

    // insert(&mut self, usize, T) -> ()
    let mut insert_params: Vec<hir_ty::Type> = Vec::new();
    insert_params.push(hir_ty::Type::usize_ty());
    insert_params.push(make_param(0));
    add_method(checker, &mut methods, "insert", insert_params, hir_ty::Type::unit(), true);

    // contains(&self, &T) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains", contains_params, hir_ty::Type::bool_ty(), false);

    // clone(&self) -> Vec<T>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", Vec::new(), make_adt(vec_def, clone_args), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Option<T> methods: is_some, is_none, unwrap, unwrap_or, expect, as_ref, clone.
fn register_option_methods(checker: &mut typeck::TypeChecker, option_def: hir_def::DefId) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(option_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_some(&self) -> bool
    add_method(checker, &mut methods, "is_some", Vec::new(), hir_ty::Type::bool_ty(), false);

    // is_none(&self) -> bool
    add_method(checker, &mut methods, "is_none", Vec::new(), hir_ty::Type::bool_ty(), false);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", Vec::new(), make_param(0), false);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<hir_ty::Type> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", unwrap_or_params, make_param(0), false);

    // expect(self, &str) -> T
    let mut expect_params: Vec<hir_ty::Type> = Vec::new();
    expect_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "expect", expect_params, make_param(0), false);

    // as_ref(&self) -> Option<&T>
    let mut as_ref_args: Vec<hir_ty::Type> = Vec::new();
    as_ref_args.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "as_ref", Vec::new(), make_adt(option_def, as_ref_args), false);

    // clone(&self) -> Option<T>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", Vec::new(), make_adt(option_def, clone_args), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Box<T> methods: as_ref.
fn register_box_methods(checker: &mut typeck::TypeChecker, box_def: hir_def::DefId) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(box_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // as_ref(&self) -> &T
    add_method(checker, &mut methods, "as_ref", Vec::new(), make_ref_ty(make_param(0)), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers HashMap<K, V> methods: insert, get, contains_key, len, is_empty, remove, clone.
fn register_hashmap_methods(checker: &mut typeck::TypeChecker, hashmap_def: hir_def::DefId) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(hashmap_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // insert(&mut self, K, V) -> Option<V>
    let option_def = checker.builtin_option_def;
    let mut insert_params: Vec<hir_ty::Type> = Vec::new();
    insert_params.push(make_param(0));
    insert_params.push(make_param(1));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "insert", insert_params, make_adt(opt_def, opt_args), true);
        }
        Option::None => {
            add_method(checker, &mut methods, "insert", insert_params, make_param(1), true);
        }
    }

    // get(&self, &K) -> Option<&V>
    let mut get_params: Vec<hir_ty::Type> = Vec::new();
    get_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(1)));
            add_method(checker, &mut methods, "get", get_params, make_adt(opt_def, opt_args), false);
        }
        Option::None => {
            add_method(checker, &mut methods, "get", get_params, make_ref_ty(make_param(1)), false);
        }
    }

    // contains_key(&self, &K) -> bool
    let mut ck_params: Vec<hir_ty::Type> = Vec::new();
    ck_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains_key", ck_params, hir_ty::Type::bool_ty(), false);

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", Vec::new(), hir_ty::Type::usize_ty(), false);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", Vec::new(), hir_ty::Type::bool_ty(), false);

    // remove(&mut self, &K) -> Option<V>
    let mut remove_params: Vec<hir_ty::Type> = Vec::new();
    remove_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "remove", remove_params, make_adt(opt_def, opt_args), true);
        }
        Option::None => {
            add_method(checker, &mut methods, "remove", remove_params, make_param(1), true);
        }
    }

    // clone(&self) -> HashMap<K, V>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    clone_args.push(make_param(1));
    add_method(checker, &mut methods, "clone", Vec::new(), make_adt(hashmap_def, clone_args), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers Result<T, E> methods: is_ok, is_err, unwrap, unwrap_or, expect.
fn register_result_methods(checker: &mut typeck::TypeChecker, result_def: hir_def::DefId) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(result_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_ok(&self) -> bool
    add_method(checker, &mut methods, "is_ok", Vec::new(), hir_ty::Type::bool_ty(), false);

    // is_err(&self) -> bool
    add_method(checker, &mut methods, "is_err", Vec::new(), hir_ty::Type::bool_ty(), false);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", Vec::new(), make_param(0), false);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<hir_ty::Type> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", unwrap_or_params, make_param(0), false);

    // expect(self, &str) -> T
    let mut expect_params: Vec<hir_ty::Type> = Vec::new();
    expect_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "expect", expect_params, make_param(0), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers builtin enum definitions (Option, Result) for exhaustiveness checking.
/// These enums may come from external modules and not be present in the HIR items list.
fn register_builtin_enums(checker: &mut typeck::TypeChecker) {
    // Register Option<T> enum: Some(T), None
    match checker.builtin_option_def {
        Option::Some(option_def) => {
            // Only register if not already registered from HIR items
            let def_idx = option_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                let name_sym = interner::intern("Option");
                let some_sym = interner::intern("Some");
                let none_sym = interner::intern("None");
                let mut variant_names: Vec<common::Symbol> = Vec::new();
                variant_names.push(some_sym);
                variant_names.push(none_sym);

                let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                // Some(T) - has one field of type Param(0)
                let mut some_fields: Vec<hir_ty::Type> = Vec::new();
                some_fields.push(make_param(0));
                variants.push(typeck::VariantInfo::new(some_sym, some_fields, 0));
                // None - no fields
                variants.push(typeck::VariantInfo::new(none_sym, Vec::new(), 1));

                let info = typeck::EnumInfo::new(option_def, name_sym, 1, variant_names, variants);
                while checker.enums.len() <= def_idx {
                    checker.enums.push(Option::None);
                }
                checker.enums[def_idx] = Some(info);
            }
        }
        Option::None => {}
    }

    // Register Result<T, E> enum: Ok(T), Err(E)
    match checker.builtin_result_def {
        Option::Some(result_def) => {
            let def_idx = result_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                let name_sym = interner::intern("Result");
                let ok_sym = interner::intern("Ok");
                let err_sym = interner::intern("Err");
                let mut variant_names: Vec<common::Symbol> = Vec::new();
                variant_names.push(ok_sym);
                variant_names.push(err_sym);

                let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                // Ok(T) - one field of type Param(0)
                let mut ok_fields: Vec<hir_ty::Type> = Vec::new();
                ok_fields.push(make_param(0));
                variants.push(typeck::VariantInfo::new(ok_sym, ok_fields, 0));
                // Err(E) - one field of type Param(1)
                let mut err_fields: Vec<hir_ty::Type> = Vec::new();
                err_fields.push(make_param(1));
                variants.push(typeck::VariantInfo::new(err_sym, err_fields, 1));

                let info = typeck::EnumInfo::new(result_def, name_sym, 2, variant_names, variants);
                while checker.enums.len() <= def_idx {
                    checker.enums.push(Option::None);
                }
                checker.enums[def_idx] = Some(info);
            }
        }
        Option::None => {}
    }
}

/// Registers primitive str methods: len, is_empty, as_bytes, contains,
/// starts_with, ends_with.
fn register_str_methods(checker: &mut typeck::TypeChecker) {
    let self_ty = hir_ty::Type::str_ty();
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", Vec::new(), hir_ty::Type::usize_ty(), false);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", Vec::new(), hir_ty::Type::bool_ty(), false);

    // as_bytes(&self) -> &[u8]
    let u8_slice = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(hir_ty::Type::u8_ty()),
    });
    add_method(checker, &mut methods, "as_bytes", Vec::new(), make_ref_ty(u8_slice), false);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "contains", contains_params, hir_ty::Type::bool_ty(), false);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<hir_ty::Type> = Vec::new();
    sw_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "starts_with", sw_params, hir_ty::Type::bool_ty(), false);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<hir_ty::Type> = Vec::new();
    ew_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "ends_with", ew_params, hir_ty::Type::bool_ty(), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers slice [T] methods: len, is_empty.
fn register_slice_methods(checker: &mut typeck::TypeChecker) {
    let self_ty = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(make_param(0)),
    });
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", Vec::new(), hir_ty::Type::usize_ty(), false);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", Vec::new(), hir_ty::Type::bool_ty(), false);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}
