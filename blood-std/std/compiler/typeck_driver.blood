// Blood Self-Hosted Compiler - Type Checking Driver
//
// This module provides the entry point for type checking a lowered HIR.
// It coordinates the TypeChecker from typeck.blood with the expression
// checking from typeck_expr.blood to check all function bodies.
//
// Pipeline integration:
//   AST -> lower_program() -> LoweringCtx -> check_types() -> TypeCheckResult
//
// The type checking driver:
// 1. Collects type information from all items (structs, enums, functions)
// 2. Type checks each function body
// 3. Returns type errors or success

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod unify;
mod typeck;
mod typeck_expr;
mod typeck_info;
mod typeck_linearity;
mod interner;

// ============================================================
// Type Check Result
// ============================================================

/// Result of type checking a crate.
pub struct TypeCheckResult {
    /// Whether type checking succeeded.
    pub success: bool,
    /// Type errors encountered.
    pub errors: Vec<typeck::TypeError>,
    /// The substitution table from type inference.
    /// Contains resolved type variables that must be applied during MIR lowering.
    pub subst_table: unify::SubstTable,
    /// Builtin DefId-to-runtime-name mapping for codegen.
    /// Maps synthetic type checker DefIds to runtime function names.
    pub builtin_def_names: Vec<typeck::BuiltinDefName>,
    /// Method resolution side table from type checking.
    /// Maps expression span starts to resolved method DefIds for MIR lowering.
    pub method_resolutions: Vec<common::MethodResEntry>,
    /// Field resolution side table from type checking.
    /// Maps field access expression span starts to resolved field indices.
    pub field_resolutions: Vec<common::FieldResEntry>,
}

impl TypeCheckResult {
    /// Creates a successful result with a substitution table, builtin name mappings,
    /// and method resolution side table.
    pub fn ok(
        subst_table: unify::SubstTable,
        builtin_def_names: Vec<typeck::BuiltinDefName>,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
    ) -> TypeCheckResult {
        TypeCheckResult {
            success: true,
            errors: Vec::new(),
            subst_table: subst_table,
            builtin_def_names: builtin_def_names,
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
        }
    }

    /// Creates a failed result with errors, a substitution table, and method resolutions.
    pub fn failed(
        errors: Vec<typeck::TypeError>,
        subst_table: unify::SubstTable,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
    ) -> TypeCheckResult {
        TypeCheckResult {
            success: false,
            errors: errors,
            subst_table: subst_table,
            builtin_def_names: Vec::new(),
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
        }
    }

    /// Returns true if type checking passed.
    pub fn is_ok(self: &Self) -> bool {
        self.success
    }

    /// Returns the number of errors.
    pub fn error_count(self: &Self) -> usize {
        self.errors.len()
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Type check a lowered HIR crate.
///
/// Takes the lowering context which contains all items and bodies,
/// and returns a TypeCheckResult indicating success or failure.
pub fn check_types(ctx: &hir_lower_ctx::LoweringCtx) -> TypeCheckResult {
    let mut checker = typeck::TypeChecker::new();

    // Phase 1: Collect type information from items
    // (For now, we skip this since we don't have item signatures stored separately)

    // Phase 2: Type check all function bodies
    let mut i: usize = 0;
    while i < ctx.bodies.len() {
        let body_entry = &ctx.bodies[i];
        let return_ty = find_return_type_for_body(&ctx.items, body_entry.body_id);
        checker.current_body_def_id = find_def_id_for_body(&ctx.items, body_entry.body_id);
        checker.current_effect_row = find_effect_row_for_body(&ctx.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Phase 3: Deferred method resolution for Infer-receiver calls
    resolve_pending_methods(&mut checker);

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table, checker.method_resolutions, checker.field_resolutions)
    } else {
        TypeCheckResult::ok(checker.subst_table, checker.builtin_def_names, checker.method_resolutions, checker.field_resolutions)
    }
}

/// Type check using a LowerResult (for driver integration).
///
/// This is the preferred entry point when integrating with the driver,
/// since the driver has LowerResult not LoweringCtx.
pub fn check_lower_result(result: &hir_lower_ctx::LowerResult) -> TypeCheckResult {
    // Start the type checker's TyVarId counter where HIR lowering left off
    // to avoid collisions between HIR inference variables and type checker variables.
    let mut checker = typeck::TypeChecker::new_from(result.next_ty_var);

    // Pass builtin type info from HIR lowering
    checker.next_def_id = result.next_def_id;
    checker.builtin_string_def = copy_opt_def_id(&result.builtin_string_def);
    checker.builtin_vec_def = copy_opt_def_id(&result.builtin_vec_def);
    checker.builtin_option_def = copy_opt_def_id(&result.builtin_option_def);
    checker.builtin_box_def = copy_opt_def_id(&result.builtin_box_def);
    checker.builtin_hashmap_def = copy_opt_def_id(&result.builtin_hashmap_def);
    checker.builtin_result_def = copy_opt_def_id(&result.builtin_result_def);

    // Phase 1: Collect type information from items
    collect_item_signatures(&mut checker, &result.items);

    // Phase 1b: Register builtin method signatures for String, Vec, Option, etc.
    // Pass the interner from HIR lowering so method name symbols match.
    register_builtin_signatures(&mut checker, &result.interner);

    // Phase 1b2: Register builtin constructor signatures (String::new, Vec::new, etc.)
    // This enables type inference to resolve return types for constructor calls.
    register_builtin_constructor_signatures(&mut checker, &result.builtin_fn_defs);

    // Phase 1c: Register builtin enum info (Option, Result) for exhaustiveness checking
    register_builtin_enums(
        &mut checker,
        &result.interner,
        &result.builtin_option_some_def,
        &result.builtin_option_none_def,
        &result.builtin_result_ok_def,
        &result.builtin_result_err_def,
    );

    // Phase 2: Type check main file bodies (determines success/failure).
    let body_limit = result.main_body_count;
    let mut i: usize = 0;
    while i < body_limit {
        let body_entry = &result.bodies[i];
        let return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        let found_def_id = find_def_id_for_body(&result.items, body_entry.body_id);
        checker.current_body_def_id = found_def_id;
        checker.current_effect_row = find_effect_row_for_body(&result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Capture main-file error count before checking external bodies.
    let main_error_count = checker.errors.len();

    // Phase 2b: Type check external module bodies to record method resolutions.
    // These bodies are MIR-lowered and code-generated, so their method calls
    // must be resolved. Errors from external bodies are discarded since each
    // module is authoritative only when compiled as the main file.
    let mut j: usize = body_limit;
    while j < result.bodies.len() {
        let body_entry = &result.bodies[j];
        let return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        let found_def_id = find_def_id_for_body(&result.items, body_entry.body_id);
        checker.current_body_def_id = found_def_id;
        checker.current_effect_row = find_effect_row_for_body(&result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        j = j + 1;
    }

    // Discard errors from external bodies by truncating back to main error count.
    while checker.errors.len() > main_error_count {
        checker.errors.pop();
    }

    // Phase 3: Deferred method resolution for Infer-receiver calls
    resolve_pending_methods(&mut checker);

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table, checker.method_resolutions, checker.field_resolutions)
    } else {
        TypeCheckResult::ok(checker.subst_table, checker.builtin_def_names, checker.method_resolutions, checker.field_resolutions)
    }
}

/// Collects type signatures from HIR items.
///
/// This populates the type checker with information about struct, enum,
/// and function definitions so it can resolve types during body checking.
fn collect_item_signatures(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                // Register function signature
                checker.register_fn_sig(entry.def_id, &fn_def.sig);
            }
            &hir_item::ItemKind::Struct(ref struct_def) => {
                // Register struct definition
                checker.register_struct(entry.def_id, entry.item.name.symbol, struct_def);
            }
            &hir_item::ItemKind::Enum(ref enum_def) => {
                // Register enum definition
                checker.register_enum(entry.def_id, entry.item.name.symbol, enum_def);
            }
            &hir_item::ItemKind::Const(ref const_def) => {
                // Register constant definition
                checker.register_const(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&const_def.ty));
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                // Register static definition
                checker.register_static(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&static_def.ty), static_def.mutable);
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Register impl block for method resolution
                register_impl(checker, entry.def_id, impl_def);
            }
            // Other items don't need registration for basic type checking
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(ref effect_def) => {
                register_effect(checker, entry.def_id, entry.item.name.symbol, effect_def);
            }
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                register_foreign_fns(checker, foreign_def);
            }
        }
        i = i + 1;
    }
}

/// Registers function signatures from a foreign (bridge) definition.
///
/// This processes ForeignFn items and registers their typed signatures
/// so the type checker can validate calls to builtin/FFI functions.
fn register_foreign_fns(
    checker: &mut typeck::TypeChecker,
    foreign_def: &hir_item::ForeignDef,
) {
    let mut i: usize = 0;
    while i < foreign_def.items.len() {
        match &foreign_def.items[i] {
            &hir_item::ForeignItem::Fn(ref foreign_fn) => {
                let mut param_tys: Vec<hir_ty::Type> = Vec::new();
                let mut j: usize = 0;
                while j < foreign_fn.param_tys.len() {
                    param_tys.push(hir_ty::copy_type(&foreign_fn.param_tys[j]));
                    j = j + 1;
                }
                checker.register_fn_sig_direct(
                    foreign_fn.def_id,
                    param_tys,
                    hir_ty::copy_type(&foreign_fn.return_ty),
                    0,
                );
            }
            &hir_item::ForeignItem::Static(ref foreign_static) => {
                checker.register_static(
                    foreign_static.def_id,
                    foreign_static.name.symbol,
                    hir_ty::copy_type(&foreign_static.ty),
                    foreign_static.mutable,
                );
            }
            &hir_item::ForeignItem::OpaqueType(_) => {}
        }
        i = i + 1;
    }
}

/// Registers an impl block for method resolution.
fn register_impl(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    impl_def: &hir_item::ImplDef,
) {
    // Extract method info from associated items
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();
    let mut i: usize = 0;
    while i < impl_def.items.len() {
        match &impl_def.items[i] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                // Extract parameter types from signature (skipping self param)
                let mut param_tys: Vec<hir_ty::Type> = Vec::new();
                let mut takes_self_ref = false;
                let mut takes_self_mut = false;

                // Check if first param is self
                if assoc_fn.sig.params.len() > 0 {
                    // Check first param for self pattern
                    // For now, assume first param might be self and check params
                    let mut j: usize = 0;
                    while j < assoc_fn.sig.params.len() {
                        // Skip self parameter (index 0) if this looks like a method
                        // In HIR, self is encoded in the first parameter
                        if j == 0 && assoc_fn.sig.params[j].is_self {
                            takes_self_ref = true;
                            takes_self_mut = assoc_fn.sig.params[j].mutable;
                        } else {
                            param_tys.push(hir_ty::copy_type(&assoc_fn.sig.params[j].ty));
                        }
                        j = j + 1;
                    }
                }

                let method_info = typeck::MethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    param_tys,
                    hir_ty::copy_type(&assoc_fn.sig.return_ty),
                    takes_self_ref,
                    takes_self_mut,
                );
                methods.push(method_info);

                // Also register the full function signature in fn_sigs so that
                // infer_path can find associated functions by DefId. Without this,
                // calls like Counter::new(10) would fail to resolve the return type,
                // leaving downstream method call receivers as Infer variables.
                checker.register_fn_sig(assoc_fn.def_id, &assoc_fn.sig);
            }
            &hir_item::AssocItem::Type(_) => {
                // Associated types don't need registration for basic method resolution
            }
            &hir_item::AssocItem::Const(_) => {
                // Associated consts don't need registration for basic method resolution
            }
        }
        i = i + 1;
    }

    // Create and register impl info
    let num_generics = count_type_params(&impl_def.generics.params);
    let impl_info = typeck::ImplInfo::new(
        def_id,
        hir_ty::copy_type(&impl_def.self_ty),
        num_generics,
        methods,
    );
    checker.register_impl(impl_info);
}

/// Registers an effect definition for type checking.
fn register_effect(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    name: common::Symbol,
    effect_def: &hir_item::EffectDef,
) {
    let num_generics = count_type_params(&effect_def.generics.params);

    // Collect operation names
    let mut op_names: Vec<common::Symbol> = Vec::new();
    let mut operations: Vec<typeck::EffectOpInfo> = Vec::new();

    let mut i: usize = 0;
    while i < effect_def.operations.len() {
        let effect_op = &effect_def.operations[i];
        op_names.push(effect_op.name.symbol);

        // Copy parameter types
        let mut param_tys: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < effect_op.param_tys.len() {
            param_tys.push(hir_ty::copy_type(&effect_op.param_tys[j]));
            j = j + 1;
        }

        let op_info = typeck::EffectOpInfo::new(
            effect_op.def_id,
            effect_op.name.symbol,
            param_tys,
            hir_ty::copy_type(&effect_op.return_ty),
        );
        operations.push(op_info);
        i = i + 1;
    }

    let info = typeck::EffectInfo::new(
        def_id,
        name,
        num_generics,
        op_names,
        operations,
    );
    checker.register_effect(def_id, info);
}

// ============================================================
// Generic Parameter Counting
// ============================================================

/// Counts only type parameters in a generics param list, excluding
/// lifetime parameters and const parameters.
fn count_type_params(params: &Vec<hir_ty::GenericParam>) -> u32 {
    let mut count: u32 = 0;
    let mut i: usize = 0;
    while i < params.len() {
        match &params[i] {
            &hir_ty::GenericParam::TypeParam(_) => {
                count = count + 1;
            }
            &hir_ty::GenericParam::LifetimeParam(_) => {}
            &hir_ty::GenericParam::ConstParam(_) => {}
        }
        i = i + 1;
    }
    count
}

// ============================================================
// Body Return Type Lookup
// ============================================================

/// Finds the return type for a body by looking up the corresponding function item.
///
/// Searches the items list for a function whose body_id matches the target,
/// and returns its signature's return type directly (no substitution needed —
/// TypeParam nodes unify naturally through the type checker).
/// Falls back to unit type if no matching function is found.
fn find_return_type_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> hir_ty::Type {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return hir_ty::copy_type(&fn_def.sig.return_ty);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return hir_ty::copy_type(&assoc_fn.sig.return_ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return hir_ty::copy_type(&assoc_const.ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(ref const_def) => {
                if const_def.body_id.index == target_body_id.index {
                    return hir_ty::copy_type(&const_def.ty);
                }
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                if static_def.body_id.index == target_body_id.index {
                    return hir_ty::copy_type(&static_def.ty);
                }
            }
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(ref handler_def) => {
                // Check return clause body
                match &handler_def.return_clause {
                    &Option::Some(ref rc) => {
                        if rc.body_id.index == target_body_id.index {
                            return hir_ty::Type::unit();
                        }
                    }
                    &Option::None => {}
                }
                // Check op implementation bodies
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        return hir_ty::Type::unit();
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to unit type if no matching function found
    hir_ty::Type::unit()
}

/// Finds the effect row DefIds for the function containing a given body.
/// Returns a Vec<u32> of effect DefIds declared in the function's effect row.
fn find_effect_row_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> Vec<u32> {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return collect_effect_def_ids(&fn_def.sig.effects);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return collect_effect_def_ids(&assoc_fn.sig.effects);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    Vec::new()
}

/// Helper to extract effect DefIds from an EffectRow.
fn collect_effect_def_ids(row: &hir_ty::EffectRow) -> Vec<u32> {
    let mut result: Vec<u32> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        result.push(row.effects[i].def_id.index);
        i = i + 1;
    }
    result
}

/// Finds the DefId for the function containing a given body.
/// Returns 0 if no matching function found.
fn find_def_id_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> u32 {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return entry.item.def_id.index;
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return assoc_fn.def_id.index;
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return assoc_const.def_id.index;
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(ref const_def) => {
                if const_def.body_id.index == target_body_id.index {
                    return entry.item.def_id.index;
                }
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                if static_def.body_id.index == target_body_id.index {
                    return entry.item.def_id.index;
                }
            }
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(ref handler_def) => {
                // Check return clause body
                match &handler_def.return_clause {
                    &Option::Some(ref rc) => {
                        if rc.body_id.index == target_body_id.index {
                            return entry.item.def_id.index;
                        }
                    }
                    &Option::None => {}
                }
                // Check op implementation bodies
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        return handler_def.op_impls[j].op_def_id.index;
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to body_id's index if no matching function found.
    // This must match the fallback in driver.blood's MIR lowering
    // to ensure method resolution lookups use consistent keys.
    target_body_id.index
}

// ============================================================
// Linearity Checking
// ============================================================

/// Tracks ownership qualifier and usage count for a local variable.
struct LinearEntry {
    local_idx: u32,
    is_linear: bool,
    is_affine: bool,
    use_count: u32,
    def_span: common::Span,
}

/// Checks linearity constraints on a function body after type checking.
fn check_linearity(checker: &mut typeck::TypeChecker, body: &hir_expr::Body) {
    // Collect locals with ownership qualifiers
    let mut entries: Vec<LinearEntry> = Vec::new();
    let mut li: usize = 0;
    while li < body.locals.len() {
        let local = &body.locals[li];
        let resolved_ty = checker.resolve(&local.ty);
        match &resolved_ty.kind {
            &hir_ty::TypeKind::Ownership { ref qualifier, inner: _ } => {
                let is_lin = match qualifier {
                    &hir_ty::OwnershipQualifier::Linear => true,
                    &hir_ty::OwnershipQualifier::Affine => false,
                };
                let is_aff = match qualifier {
                    &hir_ty::OwnershipQualifier::Linear => false,
                    &hir_ty::OwnershipQualifier::Affine => true,
                };
                let entry = LinearEntry {
                    local_idx: local.id.index,
                    is_linear: is_lin,
                    is_affine: is_aff,
                    use_count: 0,
                    def_span: local.span,
                };
                entries.push(entry);
            }
            _ => {}
        }
        li = li + 1;
    }

    // If no ownership-qualified locals, skip usage scanning
    if entries.len() == 0 {
        return;
    }

    // Count usages by scanning the body expression
    count_usages_expr(&mut entries, &body.expr);

    // Report violations
    let mut ei: usize = 0;
    while ei < entries.len() {
        let entry = &entries[ei];
        if entry.is_linear {
            if entry.use_count == 0 {
                checker.error(typeck::TypeErrorKind::LinearNotUsed, entry.def_span);
            } else if entry.use_count > 1 {
                checker.error(typeck::TypeErrorKind::LinearUsedMultipleTimes, entry.def_span);
            }
        } else if entry.is_affine {
            if entry.use_count > 1 {
                checker.error(typeck::TypeErrorKind::AffineUsedMultipleTimes, entry.def_span);
            }
        }
        ei = ei + 1;
    }
}

/// Increments use_count for a local if it's tracked.
fn record_linear_use(entries: &mut Vec<LinearEntry>, local_idx: u32) {
    let mut i: usize = 0;
    while i < entries.len() {
        if entries[i].local_idx == local_idx {
            entries[i].use_count = entries[i].use_count + 1;
            return;
        }
        i = i + 1;
    }
}

/// Counts usages of tracked locals in an expression.
fn count_usages_expr(entries: &mut Vec<LinearEntry>, expr: &hir_expr::Expr) {
    match &expr.kind {
        &hir_expr::ExprKind::Local(ref local_id) => {
            record_linear_use(entries, local_id.index);
        }
        &hir_expr::ExprKind::Binary { ref left, ref right, op: _ } => {
            count_usages_expr(entries, left.as_ref());
            count_usages_expr(entries, right.as_ref());
        }
        &hir_expr::ExprKind::Unary { ref operand, op: _ } => {
            count_usages_expr(entries, operand.as_ref());
        }
        &hir_expr::ExprKind::Call { ref callee, ref args } => {
            count_usages_expr(entries, callee.as_ref());
            let mut i: usize = 0;
            while i < args.len() {
                count_usages_expr(entries, &args[i]);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::MethodCall { ref receiver, method: _, method_def: _, type_args: _, ref args } => {
            count_usages_expr(entries, receiver.as_ref());
            let mut i: usize = 0;
            while i < args.len() {
                count_usages_expr(entries, &args[i]);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            count_usages_expr(entries, condition.as_ref());
            count_usages_expr(entries, then_branch.as_ref());
            match else_branch {
                &Option::Some(ref eb) => {
                    count_usages_expr(entries, eb.as_ref());
                }
                &Option::None => {}
            }
        }
        &hir_expr::ExprKind::Block(ref block) => {
            count_usages_block(entries, block);
        }
        &hir_expr::ExprKind::Match { ref scrutinee, ref arms } => {
            count_usages_expr(entries, scrutinee.as_ref());
            let mut i: usize = 0;
            while i < arms.len() {
                count_usages_expr(entries, &arms[i].body);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::Assign { ref target, ref val } => {
            count_usages_expr(entries, target.as_ref());
            count_usages_expr(entries, val.as_ref());
        }
        &hir_expr::ExprKind::Return(ref opt_val) => {
            match opt_val {
                &Option::Some(ref v) => {
                    count_usages_expr(entries, v.as_ref());
                }
                &Option::None => {}
            }
        }
        &hir_expr::ExprKind::Field { ref base, field: _ } => {
            count_usages_expr(entries, base.as_ref());
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            count_usages_expr(entries, base.as_ref());
            count_usages_expr(entries, idx.as_ref());
        }
        &hir_expr::ExprKind::AddrOf { mutable: _, ref expr } => {
            count_usages_expr(entries, expr.as_ref());
        }
        &hir_expr::ExprKind::Cast { ref expr, ty: _ } => {
            count_usages_expr(entries, expr.as_ref());
        }
        &hir_expr::ExprKind::Loop { label: _, ref body } => {
            count_usages_expr(entries, body.as_ref());
        }
        _ => {
            // Literal, Path, Error, etc. — no local usage to track
        }
    }
}

/// Counts usages of tracked locals in a block.
fn count_usages_block(entries: &mut Vec<LinearEntry>, block: &hir_expr::Block) {
    let mut i: usize = 0;
    while i < block.stmts.len() {
        match &block.stmts[i] {
            &hir_expr::Stmt::Expr { ref expr, has_semi: _ } => {
                count_usages_expr(entries, expr);
            }
            &hir_expr::Stmt::Let { pattern: _, ty: _, ref init, span: _ } => {
                match init {
                    &Option::Some(ref init_expr) => {
                        count_usages_expr(entries, init_expr);
                    }
                    &Option::None => {}
                }
            }
            &hir_expr::Stmt::Item(_) => {}
        }
        i = i + 1;
    }
    match &block.expr {
        &Option::Some(ref e) => {
            count_usages_expr(entries, e.as_ref());
        }
        &Option::None => {}
    }
}

// ============================================================
// Body Type Checking
// ============================================================

/// Type checks a single function body.
///
/// The return_ty comes from the function signature (not from body locals).
fn check_body(checker: &mut typeck::TypeChecker, body: &hir_expr::Body, return_ty: &hir_ty::Type) {
    // Clear locals for this body
    checker.clear_locals();

    // Register all locals from the body at their actual LocalId positions.
    // HIR lowering allocates LocalIds globally (not per-body), so a body's
    // locals may have non-zero starting indices. We must grow the locals
    // vector to accommodate the highest LocalId, then place each local at
    // its actual index.
    let mut i: usize = 0;
    while i < body.locals.len() {
        let local = &body.locals[i];
        let target_idx = local.id.index as usize;
        // Grow the locals vector to accommodate this index
        while checker.locals.len() <= target_idx {
            // Pad with dummy locals (will not be accessed for valid programs)
            checker.add_local(
                hir_ty::Type::error(),
                false,
                common::Span::new(0, 0, 1, 1),
            );
        }
        // Overwrite with the real local's type
        checker.locals[target_idx] = typeck::LocalInfo::new(
            hir_ty::copy_type(&local.ty),
            local.mutable,
            local.span,
        );
        i = i + 1;
    }

    // Set return type from the function signature
    checker.set_return_ty(hir_ty::copy_type(return_ty));

    // Type check the body expression
    let body_ty = typeck_expr::infer_expr(checker, &body.expr);

    // Unify body type with return type
    match &checker.return_ty {
        &Some(ref ret_ty) => {
            let ok = checker.unify(&body_ty, ret_ty, body.expr.span);
            let _ = ok;
        }
        &None => {}
    }

    // Run linearity checking: scan locals for ownership qualifiers,
    // count usages in body expression, report violations.
    // Inline implementation to avoid potential codegen issues with the module.
    check_linearity(checker, body);

    // Clear return type
    checker.clear_return_ty();
}

// ============================================================
// Deferred Method Resolution
// ============================================================

/// Resolves pending method calls whose receivers were Infer variables.
/// Uses a fixpoint loop: resolving one call may produce a return type
/// that allows another receiver to become concrete.
fn resolve_pending_methods(checker: &mut typeck::TypeChecker) {
    let mut resolved_count: usize = 1;
    while resolved_count > 0 {
        resolved_count = 0;
        let mut i: usize = 0;
        while i < checker.pending_method_calls.len() {
            let body_def_id = checker.pending_method_calls[i].body_def_id;
            let span_start = checker.pending_method_calls[i].span_start;
            let receiver_var = checker.pending_method_calls[i].receiver_var;
            let method_symbol = checker.pending_method_calls[i].method_symbol;
            let return_ty_var = checker.pending_method_calls[i].return_ty_var;

            // Skip if already resolved in a previous iteration
            if is_already_resolved(checker, body_def_id, span_start) {
                i = i + 1;
                continue;
            }

            // Try to resolve the receiver type variable
            let infer_ty = hir_ty::Type::new(hir_ty::TypeKind::Infer(
                hir_def::TyVarId::new(receiver_var)
            ));
            let receiver_ty = checker.resolve(&infer_ty);
            let stripped = typeck_expr::strip_refs(&receiver_ty);

            match &stripped.kind {
                &hir_ty::TypeKind::Infer(ref var_id) => {
                    // Still unresolved, skip for now
                }
                _ => {
                    // Receiver is now concrete - look up the method
                    match checker.lookup_method(&stripped, method_symbol) {
                        Option::Some(ref lookup_result) => {
                            let method_def_id_index = checker.get_method_from_lookup(lookup_result).def_id.index;
                            let method_return_ty = hir_ty::copy_type(&checker.get_method_from_lookup(lookup_result).return_ty);
                            let impl_num_generics = checker.get_impl_from_lookup(lookup_result).num_generics;
                            let impl_self_ty = hir_ty::copy_type(&checker.get_impl_from_lookup(lookup_result).self_ty);

                            // Record the resolution with the body's DefId for scoping
                            checker.current_body_def_id = body_def_id;
                            checker.record_method_resolution(span_start, method_def_id_index);

                            // Unify return type with actual method return type
                            let mut subst = unify::TypeParamSubst::new();
                            if impl_num_generics > 0 {
                                unify::extract_type_params_from_self_ty(
                                    &impl_self_ty, &stripped, &mut subst
                                );
                            }
                            let actual_ret = unify::substitute_type_params(
                                &method_return_ty, &subst
                            );
                            let return_infer = hir_ty::Type::new(hir_ty::TypeKind::Infer(
                                hir_def::TyVarId::new(return_ty_var)
                            ));
                            checker.unify(&return_infer, &actual_ret, common::Span::dummy());

                            resolved_count = resolved_count + 1;
                        }
                        Option::None => {
                            // Method not found even with concrete receiver — skip
                        }
                    }
                }
            }
            i = i + 1;
        }
    }
    // Count unresolved pending calls
    let mut unresolved: usize = 0;
    let mut j: usize = 0;
    while j < checker.pending_method_calls.len() {
        let body_def_id = checker.pending_method_calls[j].body_def_id;
        let span_start = checker.pending_method_calls[j].span_start;
        if !is_already_resolved(checker, body_def_id, span_start) {
            unresolved = unresolved + 1;
        }
        j = j + 1;
    }
    // Pending methods resolved
}

/// Checks if a method call at the given span_start has already been resolved.
fn is_already_resolved(checker: &mut typeck::TypeChecker, body_def_id: u32, span_start: usize) -> bool {
    let mut i: usize = 0;
    while i < checker.method_resolutions.len() {
        if checker.method_resolutions[i].body_def_id == body_def_id &&
           checker.method_resolutions[i].span_start == span_start {
            return true;
        }
        i = i + 1;
    }
    false
}

// ============================================================
// Builtin Method Registration
// ============================================================

/// Copies an Option<DefId> by value (for passing through references).
fn copy_opt_def_id(opt: &Option<hir_def::DefId>) -> Option<hir_def::DefId> {
    match opt {
        &Option::Some(ref d) => Option::Some(hir_def::DefId::new(d.index)),
        &Option::None => Option::None,
    }
}

/// Helper: create a reference type &T.
fn make_ref_ty(inner: hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type::new(hir_ty::TypeKind::Ref { inner: Box::new(inner), mutable: false })
}

/// Helper: create an ADT type with the given DefId and type args.
fn make_adt(def_id: hir_def::DefId, args: Vec<hir_ty::Type>) -> hir_ty::Type {
    hir_ty::Type::new(hir_ty::TypeKind::Adt { def_id: def_id, args: args })
}

/// Helper: create a type parameter Param(n).
fn make_param(n: u32) -> hir_ty::Type {
    hir_ty::Type::param(hir_def::TyVarId::new(n))
}

/// Helper: add a method to the methods list and record its runtime function name.
/// The interner must be the same interner used during HIR lowering so that
/// method name symbols match.
fn add_method(
    checker: &mut typeck::TypeChecker,
    methods: &mut Vec<typeck::MethodInfo>,
    name: &str,
    runtime_name: &str,
    params: Vec<hir_ty::Type>,
    ret: hir_ty::Type,
    self_mut: bool,
    interner: &interner::StringInterner,
) {
    let def_id = checker.alloc_def_id();
    // Use the same interner as HIR lowering to get matching Symbol indices.
    // All builtin method names are pre-interned, so find() will always succeed.
    let sym = interner.find(name).unwrap();
    methods.push(typeck::MethodInfo::new(def_id, sym, params, ret, true, self_mut));
    // Record mapping from synthetic DefId to runtime function name for codegen
    checker.builtin_def_names.push(
        typeck::BuiltinDefName::new(def_id.index, common::make_string(runtime_name)),
    );
}

/// Registers builtin method signatures for all builtin types.
/// The interner parameter must be the same interner used during HIR lowering
/// so that method name symbols match between HIR and type checking.
fn register_builtin_signatures(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    // String methods
    match checker.builtin_string_def {
        Option::Some(def_id) => {
            register_string_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Vec methods
    match checker.builtin_vec_def {
        Option::Some(def_id) => {
            register_vec_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Option methods
    match checker.builtin_option_def {
        Option::Some(def_id) => {
            register_option_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Box methods
    match checker.builtin_box_def {
        Option::Some(def_id) => {
            register_box_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // HashMap methods
    match checker.builtin_hashmap_def {
        Option::Some(def_id) => {
            register_hashmap_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Result methods
    match checker.builtin_result_def {
        Option::Some(def_id) => {
            register_result_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Primitive str methods
    register_str_methods(checker, interner);

    // Slice methods
    register_slice_methods(checker, interner);
}

/// Registers String methods: len, is_empty, push_str, push, as_str, clone,
/// contains, starts_with, ends_with, as_bytes.
fn register_string_methods(checker: &mut typeck::TypeChecker, string_def: hir_def::DefId, interner: &interner::StringInterner) {
    let self_ty = make_adt(string_def, Vec::new());
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "string_len", Vec::new(), hir_ty::Type::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "string_is_empty", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // push_str(&mut self, &str) -> ()
    let mut push_str_params: Vec<hir_ty::Type> = Vec::new();
    push_str_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "push_str", "string_push_str", push_str_params, hir_ty::Type::unit(), true, interner);

    // push(&mut self, char) -> ()
    let mut push_params: Vec<hir_ty::Type> = Vec::new();
    push_params.push(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    add_method(checker, &mut methods, "push", "string_push", push_params, hir_ty::Type::unit(), true, interner);

    // as_str(&self) -> &str
    add_method(checker, &mut methods, "as_str", "string_as_str", Vec::new(), make_ref_ty(hir_ty::Type::str_ty()), false, interner);

    // clone(&self) -> String
    add_method(checker, &mut methods, "clone", "string_clone", Vec::new(), make_adt(string_def, Vec::new()), false, interner);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "contains", "string_contains", contains_params, hir_ty::Type::bool_ty(), false, interner);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<hir_ty::Type> = Vec::new();
    sw_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "starts_with", "string_starts_with", sw_params, hir_ty::Type::bool_ty(), false, interner);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<hir_ty::Type> = Vec::new();
    ew_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "ends_with", "string_ends_with", ew_params, hir_ty::Type::bool_ty(), false, interner);

    // as_bytes(&self) -> &[u8]
    let u8_slice = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(hir_ty::Type::u8_ty()),
    });
    add_method(checker, &mut methods, "as_bytes", "string_as_bytes", Vec::new(), make_ref_ty(u8_slice), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers Vec<T> methods: push, pop, len, is_empty, get, last, clear,
/// remove, insert, contains, clone.
fn register_vec_methods(checker: &mut typeck::TypeChecker, vec_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(vec_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // push(&mut self, T) -> ()
    let mut push_params: Vec<hir_ty::Type> = Vec::new();
    push_params.push(make_param(0));
    add_method(checker, &mut methods, "push", "vec_push", push_params, hir_ty::Type::unit(), true, interner);

    // pop(&mut self) -> Option<T>
    let option_def = checker.builtin_option_def;
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(0));
            add_method(checker, &mut methods, "pop", "vec_pop", Vec::new(), make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "pop", "vec_pop", Vec::new(), make_param(0), true, interner);
        }
    }

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "vec_len", Vec::new(), hir_ty::Type::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "vec_is_empty", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // get(&self, usize) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut get_params: Vec<hir_ty::Type> = Vec::new();
            get_params.push(hir_ty::Type::usize_ty());
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "get", "vec_get", get_params, make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            let mut get_params: Vec<hir_ty::Type> = Vec::new();
            get_params.push(hir_ty::Type::usize_ty());
            add_method(checker, &mut methods, "get", "vec_get", get_params, make_ref_ty(make_param(0)), false, interner);
        }
    }

    // last(&self) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "last", "vec_last", Vec::new(), make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "last", "vec_last", Vec::new(), make_ref_ty(make_param(0)), false, interner);
        }
    }

    // clear(&mut self) -> ()
    add_method(checker, &mut methods, "clear", "vec_clear", Vec::new(), hir_ty::Type::unit(), true, interner);

    // remove(&mut self, usize) -> T
    let mut remove_params: Vec<hir_ty::Type> = Vec::new();
    remove_params.push(hir_ty::Type::usize_ty());
    add_method(checker, &mut methods, "remove", "vec_remove", remove_params, make_param(0), true, interner);

    // insert(&mut self, usize, T) -> ()
    let mut insert_params: Vec<hir_ty::Type> = Vec::new();
    insert_params.push(hir_ty::Type::usize_ty());
    insert_params.push(make_param(0));
    add_method(checker, &mut methods, "insert", "vec_insert", insert_params, hir_ty::Type::unit(), true, interner);

    // contains(&self, &T) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains", "vec_contains", contains_params, hir_ty::Type::bool_ty(), false, interner);

    // clone(&self) -> Vec<T>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", "vec_clone", Vec::new(), make_adt(vec_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Option<T> methods: is_some, is_none, unwrap, unwrap_or, expect, as_ref, clone.
fn register_option_methods(checker: &mut typeck::TypeChecker, option_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(option_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_some(&self) -> bool
    add_method(checker, &mut methods, "is_some", "option_is_some", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // is_none(&self) -> bool
    add_method(checker, &mut methods, "is_none", "option_is_none", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", "option_unwrap", Vec::new(), make_param(0), false, interner);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<hir_ty::Type> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", "option_unwrap_or", unwrap_or_params, make_param(0), false, interner);

    // expect(self, &str) -> T
    let mut expect_params: Vec<hir_ty::Type> = Vec::new();
    expect_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "expect", "option_expect", expect_params, make_param(0), false, interner);

    // as_ref(&self) -> Option<&T>
    let mut as_ref_args: Vec<hir_ty::Type> = Vec::new();
    as_ref_args.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "as_ref", "option_as_ref", Vec::new(), make_adt(option_def, as_ref_args), false, interner);

    // clone(&self) -> Option<T>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", "option_clone", Vec::new(), make_adt(option_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Box<T> methods: as_ref.
fn register_box_methods(checker: &mut typeck::TypeChecker, box_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(box_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // as_ref(&self) -> &T
    add_method(checker, &mut methods, "as_ref", "box_as_ref", Vec::new(), make_ref_ty(make_param(0)), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers HashMap<K, V> methods: insert, get, contains_key, len, is_empty, remove, clone.
fn register_hashmap_methods(checker: &mut typeck::TypeChecker, hashmap_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(hashmap_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // insert(&mut self, K, V) -> Option<V>
    let option_def = checker.builtin_option_def;
    let mut insert_params: Vec<hir_ty::Type> = Vec::new();
    insert_params.push(make_param(0));
    insert_params.push(make_param(1));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "insert", "hashmap_insert", insert_params, make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "insert", "hashmap_insert", insert_params, make_param(1), true, interner);
        }
    }

    // get(&self, &K) -> Option<&V>
    let mut get_params: Vec<hir_ty::Type> = Vec::new();
    get_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_ref_ty(make_param(1)));
            add_method(checker, &mut methods, "get", "hashmap_get", get_params, make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "get", "hashmap_get", get_params, make_ref_ty(make_param(1)), false, interner);
        }
    }

    // contains_key(&self, &K) -> bool
    let mut ck_params: Vec<hir_ty::Type> = Vec::new();
    ck_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains_key", "hashmap_contains_key", ck_params, hir_ty::Type::bool_ty(), false, interner);

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "hashmap_len", Vec::new(), hir_ty::Type::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "hashmap_is_empty", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // remove(&mut self, &K) -> Option<V>
    let mut remove_params: Vec<hir_ty::Type> = Vec::new();
    remove_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<hir_ty::Type> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "remove", "hashmap_remove", remove_params, make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "remove", "hashmap_remove", remove_params, make_param(1), true, interner);
        }
    }

    // clone(&self) -> HashMap<K, V>
    let mut clone_args: Vec<hir_ty::Type> = Vec::new();
    clone_args.push(make_param(0));
    clone_args.push(make_param(1));
    add_method(checker, &mut methods, "clone", "hashmap_clone", Vec::new(), make_adt(hashmap_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers Result<T, E> methods: is_ok, is_err, unwrap, unwrap_or, expect.
fn register_result_methods(checker: &mut typeck::TypeChecker, result_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<hir_ty::Type> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(result_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_ok(&self) -> bool
    add_method(checker, &mut methods, "is_ok", "result_is_ok", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // is_err(&self) -> bool
    add_method(checker, &mut methods, "is_err", "result_is_err", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", "result_unwrap", Vec::new(), make_param(0), false, interner);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<hir_ty::Type> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", "result_unwrap_or", unwrap_or_params, make_param(0), false, interner);

    // expect(self, &str) -> T
    let mut expect_params: Vec<hir_ty::Type> = Vec::new();
    expect_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "expect", "result_expect", expect_params, make_param(0), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers builtin enum definitions (Option, Result) for exhaustiveness checking.
/// These enums may come from external modules and not be present in the HIR items list.
fn register_builtin_enums(
    checker: &mut typeck::TypeChecker,
    interner: &interner::StringInterner,
    option_some_def: &Option<hir_def::DefId>,
    option_none_def: &Option<hir_def::DefId>,
    result_ok_def: &Option<hir_def::DefId>,
    result_err_def: &Option<hir_def::DefId>,
) {
    // Register Option<T> enum: Some(T), None
    match checker.builtin_option_def {
        Option::Some(option_def) => {
            // Only register if not already registered from HIR items
            let def_idx = option_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                let name_sym = interner.find("Option").unwrap();
                let some_sym = interner.find("Some").unwrap();
                let none_sym = interner.find("None").unwrap();
                let mut variant_names: Vec<common::Symbol> = Vec::new();
                variant_names.push(some_sym);
                variant_names.push(none_sym);

                let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                // Some(T) - has one field of type Param(0)
                let mut some_fields: Vec<hir_ty::Type> = Vec::new();
                some_fields.push(make_param(0));
                // Use actual DefId for Some variant if available
                match option_some_def {
                    &Option::Some(some_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(some_sym, some_fields, 0, some_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(some_sym, some_fields, 0));
                    }
                }
                // None - no fields
                match option_none_def {
                    &Option::Some(none_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(none_sym, Vec::new(), 1, none_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(none_sym, Vec::new(), 1));
                    }
                }

                let info = typeck::EnumInfo::new(option_def, name_sym, 1, variant_names, variants);
                while checker.enums.len() <= def_idx {
                    checker.enums.push(Option::None);
                }
                checker.enums[def_idx] = Some(info);
            }
        }
        Option::None => {}
    }

    // Register Result<T, E> enum: Ok(T), Err(E)
    match checker.builtin_result_def {
        Option::Some(result_def) => {
            let def_idx = result_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                let name_sym = interner.find("Result").unwrap();
                let ok_sym = interner.find("Ok").unwrap();
                let err_sym = interner.find("Err").unwrap();
                let mut variant_names: Vec<common::Symbol> = Vec::new();
                variant_names.push(ok_sym);
                variant_names.push(err_sym);

                let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                // Ok(T) - one field of type Param(0)
                let mut ok_fields: Vec<hir_ty::Type> = Vec::new();
                ok_fields.push(make_param(0));
                match result_ok_def {
                    &Option::Some(ok_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(ok_sym, ok_fields, 0, ok_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(ok_sym, ok_fields, 0));
                    }
                }
                // Err(E) - one field of type Param(1)
                let mut err_fields: Vec<hir_ty::Type> = Vec::new();
                err_fields.push(make_param(1));
                match result_err_def {
                    &Option::Some(err_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(err_sym, err_fields, 1, err_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(err_sym, err_fields, 1));
                    }
                }

                let info = typeck::EnumInfo::new(result_def, name_sym, 2, variant_names, variants);
                while checker.enums.len() <= def_idx {
                    checker.enums.push(Option::None);
                }
                checker.enums[def_idx] = Some(info);
            }
        }
        Option::None => {}
    }
}

/// Registers primitive str methods: len, is_empty, as_bytes, contains,
/// starts_with, ends_with.
fn register_str_methods(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    let self_ty = hir_ty::Type::str_ty();
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "str_len", Vec::new(), hir_ty::Type::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "str_is_empty", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // as_bytes(&self) -> &[u8]
    let u8_slice = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(hir_ty::Type::u8_ty()),
    });
    add_method(checker, &mut methods, "as_bytes", "str_as_bytes", Vec::new(), make_ref_ty(u8_slice), false, interner);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<hir_ty::Type> = Vec::new();
    contains_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "contains", "str_contains", contains_params, hir_ty::Type::bool_ty(), false, interner);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<hir_ty::Type> = Vec::new();
    sw_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "starts_with", "str_starts_with", sw_params, hir_ty::Type::bool_ty(), false, interner);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<hir_ty::Type> = Vec::new();
    ew_params.push(make_ref_ty(hir_ty::Type::str_ty()));
    add_method(checker, &mut methods, "ends_with", "str_ends_with", ew_params, hir_ty::Type::bool_ty(), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers slice [T] methods: len, is_empty.
fn register_slice_methods(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    let self_ty = hir_ty::Type::new(hir_ty::TypeKind::Slice {
        element: Box::new(make_param(0)),
    });
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "slice_len", Vec::new(), hir_ty::Type::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "slice_is_empty", Vec::new(), hir_ty::Type::bool_ty(), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers function signatures for builtin constructors (String::new, Vec::new, etc.).
/// This enables type inference to work correctly for calls like `let s = String::new()`.
fn register_builtin_constructor_signatures(
    checker: &mut typeck::TypeChecker,
    builtin_fn_defs: &Vec<hir_lower_ctx::BuiltinFnDef>,
) {
    let mut i: usize = 0;
    while i < builtin_fn_defs.len() {
        let entry = &builtin_fn_defs[i];
        let def_id = hir_def::DefId::new(entry.def_id_index);
        let name = &entry.runtime_name;

        // Match on runtime name to determine signature
        if string_eq(name, "string_new") {
            // String::new() -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "string_from") {
            // String::from(&str) -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let mut params: Vec<hir_ty::Type> = Vec::new();
                    params.push(make_ref_ty(hir_ty::Type::str_ty()));
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "string_with_capacity") {
            // String::with_capacity(usize) -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let mut params: Vec<hir_ty::Type> = Vec::new();
                    params.push(hir_ty::Type::usize_ty());
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "vec_new") {
            // Vec::new() -> Vec<T> (generic, 1 type param)
            match checker.builtin_vec_def {
                Option::Some(vec_def) => {
                    let mut type_args: Vec<hir_ty::Type> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(vec_def, type_args);
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "vec_with_capacity") {
            // Vec::with_capacity(usize) -> Vec<T> (generic, 1 type param)
            match checker.builtin_vec_def {
                Option::Some(vec_def) => {
                    let mut params: Vec<hir_ty::Type> = Vec::new();
                    params.push(hir_ty::Type::usize_ty());
                    let mut type_args: Vec<hir_ty::Type> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(vec_def, type_args);
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "box_new") {
            // Box::new(T) -> Box<T> (generic, 1 type param)
            match checker.builtin_box_def {
                Option::Some(box_def) => {
                    let mut params: Vec<hir_ty::Type> = Vec::new();
                    params.push(make_param(0));
                    let mut type_args: Vec<hir_ty::Type> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(box_def, type_args);
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "hashmap_new") {
            // HashMap::new() -> HashMap<K, V> (generic, 2 type params)
            match checker.builtin_hashmap_def {
                Option::Some(hashmap_def) => {
                    let mut type_args: Vec<hir_ty::Type> = Vec::new();
                    type_args.push(make_param(0));
                    type_args.push(make_param(1));
                    let ret_ty = make_adt(hashmap_def, type_args);
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 2);
                }
                Option::None => {}
            }
        }
        // Note: option_some_ctor, option_none_ctor, result_ok_ctor, result_err_ctor
        // are handled as enum variants, not function signatures

        i = i + 1;
    }
}

/// Compares two strings for equality.
fn string_eq(a: &String, b: &str) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let bytes_a = a.as_bytes();
    let bytes_b = b.as_bytes();
    let mut i: usize = 0;
    while i < a.len() {
        if bytes_a[i] != bytes_b[i] {
            return false;
        }
        i = i + 1;
    }
    true
}
