// Blood Self-Hosted Compiler - Type Checking Driver
//
// This module provides the entry point for type checking a lowered HIR.
// It coordinates the TypeChecker from typeck.blood with the expression
// checking from typeck_expr.blood to check all function bodies.
//
// Pipeline integration:
//   AST -> lower_program() -> LoweringCtx -> check_types() -> TypeCheckResult
//
// The type checking driver:
// 1. Collects type information from all items (structs, enums, functions)
// 2. Type checks each function body
// 3. Returns type errors or success

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod unify;
mod typeck;
mod typeck_expr;

// ============================================================
// Type Check Result
// ============================================================

/// Result of type checking a crate.
pub struct TypeCheckResult {
    /// Whether type checking succeeded.
    pub success: bool,
    /// Type errors encountered.
    pub errors: Vec<typeck::TypeError>,
    /// The substitution table from type inference.
    /// Contains resolved type variables that must be applied during MIR lowering.
    pub subst_table: unify::SubstTable,
}

impl TypeCheckResult {
    /// Creates a successful result with a substitution table.
    pub fn ok(subst_table: unify::SubstTable) -> TypeCheckResult {
        TypeCheckResult {
            success: true,
            errors: Vec::new(),
            subst_table: subst_table,
        }
    }

    /// Creates a failed result with errors and a substitution table.
    pub fn failed(errors: Vec<typeck::TypeError>, subst_table: unify::SubstTable) -> TypeCheckResult {
        TypeCheckResult {
            success: false,
            errors: errors,
            subst_table: subst_table,
        }
    }

    /// Returns true if type checking passed.
    pub fn is_ok(self: &Self) -> bool {
        self.success
    }

    /// Returns the number of errors.
    pub fn error_count(self: &Self) -> usize {
        self.errors.len()
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Type check a lowered HIR crate.
///
/// Takes the lowering context which contains all items and bodies,
/// and returns a TypeCheckResult indicating success or failure.
pub fn check_types(ctx: &hir_lower_ctx::LoweringCtx) -> TypeCheckResult {
    let mut checker = typeck::TypeChecker::new();

    // Phase 1: Collect type information from items
    // (For now, we skip this since we don't have item signatures stored separately)

    // Phase 2: Type check all function bodies
    let mut i: usize = 0;
    while i < ctx.bodies.len() {
        let body_entry = &ctx.bodies[i];
        let return_ty = find_return_type_for_body(&ctx.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table)
    } else {
        TypeCheckResult::ok(checker.subst_table)
    }
}

/// Type check using a LowerResult (for driver integration).
///
/// This is the preferred entry point when integrating with the driver,
/// since the driver has LowerResult not LoweringCtx.
pub fn check_lower_result(result: &hir_lower_ctx::LowerResult) -> TypeCheckResult {
    // Start the type checker's TyVarId counter where HIR lowering left off
    // to avoid collisions between HIR inference variables and type checker variables.
    let mut checker = typeck::TypeChecker::new_from(result.next_ty_var);

    // Phase 1: Collect type information from items
    collect_item_signatures(&mut checker, &result.items);

    // Phase 2: Type check all function bodies
    let mut i: usize = 0;
    while i < result.bodies.len() {
        let body_entry = &result.bodies[i];
        // Find the return type from the function signature for this body
        let return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, &return_ty);
        i = i + 1;
    }

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table)
    } else {
        TypeCheckResult::ok(checker.subst_table)
    }
}

/// Collects type signatures from HIR items.
///
/// This populates the type checker with information about struct, enum,
/// and function definitions so it can resolve types during body checking.
fn collect_item_signatures(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                // Register function signature
                checker.register_fn_sig(entry.def_id, &fn_def.sig);
            }
            &hir_item::ItemKind::Struct(ref struct_def) => {
                // Register struct definition
                checker.register_struct(entry.def_id, entry.item.name.symbol, struct_def);
            }
            &hir_item::ItemKind::Enum(ref enum_def) => {
                // Register enum definition
                checker.register_enum(entry.def_id, entry.item.name.symbol, enum_def);
            }
            &hir_item::ItemKind::Const(ref const_def) => {
                // Register constant definition
                checker.register_const(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&const_def.ty));
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                // Register static definition
                checker.register_static(entry.def_id, entry.item.name.symbol, hir_ty::copy_type(&static_def.ty), static_def.mutable);
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Register impl block for method resolution
                register_impl(checker, entry.def_id, impl_def);
            }
            // Other items don't need registration for basic type checking
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
}

/// Registers an impl block for method resolution.
fn register_impl(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    impl_def: &hir_item::ImplDef,
) {
    // Extract method info from associated items
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();
    let mut i: usize = 0;
    while i < impl_def.items.len() {
        match &impl_def.items[i] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                // Extract parameter types from signature (skipping self param)
                let mut param_tys: Vec<hir_ty::Type> = Vec::new();
                let mut takes_self_ref = false;
                let mut takes_self_mut = false;

                // Check if first param is self
                if assoc_fn.sig.params.len() > 0 {
                    // Check first param for self pattern
                    // For now, assume first param might be self and check params
                    let mut j: usize = 0;
                    while j < assoc_fn.sig.params.len() {
                        // Skip self parameter (index 0) if this looks like a method
                        // In HIR, self is encoded in the first parameter
                        if j == 0 && assoc_fn.sig.params[j].is_self {
                            takes_self_ref = true;
                            takes_self_mut = assoc_fn.sig.params[j].mutable;
                        } else {
                            param_tys.push(hir_ty::copy_type(&assoc_fn.sig.params[j].ty));
                        }
                        j = j + 1;
                    }
                }

                let method_info = typeck::MethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    param_tys,
                    hir_ty::copy_type(&assoc_fn.sig.return_ty),
                    takes_self_ref,
                    takes_self_mut,
                );
                methods.push(method_info);
            }
            &hir_item::AssocItem::Type(_) => {
                // Associated types don't need registration for basic method resolution
            }
            &hir_item::AssocItem::Const(_) => {
                // Associated consts don't need registration for basic method resolution
            }
        }
        i = i + 1;
    }

    // Create and register impl info
    let num_generics = impl_def.generics.params.len() as u32;
    let impl_info = typeck::ImplInfo::new(
        def_id,
        hir_ty::copy_type(&impl_def.self_ty),
        num_generics,
        methods,
    );
    checker.register_impl(impl_info);
}

// ============================================================
// Body Return Type Lookup
// ============================================================

/// Finds the return type for a body by looking up the corresponding function item.
///
/// Searches the items list for a function whose body_id matches the target,
/// and returns its signature's return type. Falls back to unit type if no
/// matching function is found.
fn find_return_type_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> hir_ty::Type {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return hir_ty::copy_type(&fn_def.sig.return_ty);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return hir_ty::copy_type(&assoc_fn.sig.return_ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(_) => {}
            &hir_item::ItemKind::Static(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to unit type if no matching function found
    hir_ty::Type::unit()
}

// ============================================================
// Body Type Checking
// ============================================================

/// Type checks a single function body.
///
/// The return_ty comes from the function signature (not from body locals).
fn check_body(checker: &mut typeck::TypeChecker, body: &hir_expr::Body, return_ty: &hir_ty::Type) {
    // Clear locals for this body
    checker.clear_locals();

    // Register all locals from the body
    let mut i: usize = 0;
    while i < body.locals.len() {
        let local = &body.locals[i];
        // Add local with its declared type
        checker.add_local(
            hir_ty::copy_type(&local.ty),
            local.mutable,
            local.span,
        );
        i = i + 1;
    }

    // Set return type from the function signature
    checker.set_return_ty(hir_ty::copy_type(return_ty));

    // Type check the body expression
    let body_ty = typeck_expr::infer_expr(checker, &body.expr);

    // Unify body type with return type
    match &checker.return_ty {
        &Some(ref ret_ty) => {
            checker.unify(&body_ty, ret_ty, body.expr.span);
        }
        &None => {}
    }

    // Clear return type
    checker.clear_return_ty();
}
