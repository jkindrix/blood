// Blood Self-Hosted Compiler - Type Checking Driver
//
// This module provides the entry point for type checking a lowered HIR.
// It coordinates the TypeChecker from typeck.blood with the expression
// checking from typeck_expr.blood to check all function bodies.
//
// Pipeline integration:
//   AST -> lower_program() -> LoweringCtx -> check_types() -> TypeCheckResult
//
// The type checking driver:
// 1. Collects type information from all items (structs, enums, functions)
// 2. Type checks each function body
// 3. Returns type errors or success

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod unify;
mod typeck;
mod typeck_expr;
mod typeck_info;
mod typeck_linearity;
mod interner;
mod type_intern;
mod typeck_types;

// ============================================================
// Type Check Result
// ============================================================

/// Result of type checking a crate.
pub struct TypeCheckResult {
    /// Whether type checking succeeded.
    pub success: bool,
    /// Type errors encountered.
    pub errors: Vec<typeck::TypeError>,
    /// The substitution table from type inference.
    /// Contains resolved type variables that must be applied during MIR lowering.
    pub subst_table: unify::SubstTable,
    /// Builtin DefId-to-runtime-name mapping for codegen.
    /// Maps synthetic type checker DefIds to runtime function names.
    pub builtin_def_names: Vec<typeck::BuiltinDefName>,
    /// Method resolution side table from type checking.
    /// Maps expression span starts to resolved method DefIds for MIR lowering.
    pub method_resolutions: Vec<common::MethodResEntry>,
    /// Field resolution side table from type checking.
    /// Maps field access expression span starts to resolved field indices.
    pub field_resolutions: Vec<common::FieldResEntry>,
    /// Trait default method remappings for codegen.
    /// When a trait default method is used by an impl, calls within the body
    /// targeting abstract trait methods must be redirected to concrete impl methods.
    pub default_method_remaps: Vec<common::DefaultMethodRemap>,
}

impl TypeCheckResult {
    /// Creates a successful result with a substitution table, builtin name mappings,
    /// and method resolution side table.
    pub fn ok(
        subst_table: unify::SubstTable,
        builtin_def_names: Vec<typeck::BuiltinDefName>,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
        default_method_remaps: Vec<common::DefaultMethodRemap>,
    ) -> TypeCheckResult {
        TypeCheckResult {
            success: true,
            errors: Vec::new(),
            subst_table: subst_table,
            builtin_def_names: builtin_def_names,
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
            default_method_remaps: default_method_remaps,
        }
    }

    /// Creates a failed result with errors, a substitution table, and method resolutions.
    pub fn failed(
        errors: Vec<typeck::TypeError>,
        subst_table: unify::SubstTable,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
    ) -> TypeCheckResult {
        TypeCheckResult {
            success: false,
            errors: errors,
            subst_table: subst_table,
            builtin_def_names: Vec::new(),
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
            default_method_remaps: Vec::new(),
        }
    }

    /// Returns true if type checking passed.
    pub fn is_ok(self: &Self) -> bool {
        self.success
    }

    /// Returns the number of errors.
    pub fn error_count(self: &Self) -> usize {
        self.errors.len()
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Type check a lowered HIR crate.
///
/// Takes the lowering context which contains all items and bodies,
/// and returns a TypeCheckResult indicating success or failure.
pub fn check_types(ctx: &hir_lower_ctx::LoweringCtx) -> TypeCheckResult {
    let mut checker = typeck::TypeChecker::new();

    // Phase 1: Collect type information from items
    // (For now, we skip this since we don't have item signatures stored separately)

    // Phase 2: Type check all function bodies
    let mut i: usize = 0;
    while i < ctx.bodies.len() {
        let body_entry = &ctx.bodies[i];
        let mut return_ty = find_return_type_for_body(&ctx.items, body_entry.body_id);
        if is_handler_return_body(&ctx.items, body_entry.body_id) {
            return_ty = checker.fresh_infer();
        }
        checker.current_body_def_id = find_def_id_for_body(&ctx.items, body_entry.body_id);
        checker.current_effect_row = find_effect_row_for_body(&ctx.items, body_entry.body_id);
        unify_handler_op_params(&mut checker, &ctx.items, &body_entry.body, body_entry.body_id);
        setup_handler_op_context(&mut checker, &ctx.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, return_ty);
        i = i + 1;
    }

    // Phase 3: Deferred method resolution for Infer-receiver calls
    resolve_pending_methods(&mut checker);

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table, checker.method_resolutions, checker.field_resolutions)
    } else {
        TypeCheckResult::ok(checker.subst_table, checker.builtin_def_names, checker.method_resolutions, checker.field_resolutions, checker.default_method_remaps)
    }
}

/// Type check using a LowerResult (for driver integration).
///
/// This is the preferred entry point when integrating with the driver,
/// since the driver has LowerResult not LoweringCtx.
pub fn check_lower_result(result: &hir_lower_ctx::LowerResult) -> TypeCheckResult {
    // Start the type checker's TyVarId counter where HIR lowering left off
    // to avoid collisions between HIR inference variables and type checker variables.
    let mut checker = typeck::TypeChecker::new_from(result.next_ty_var);

    // Pass builtin type info from HIR lowering
    checker.next_def_id = result.next_def_id;
    checker.builtin_string_def = copy_opt_def_id(&result.builtin_string_def);
    checker.builtin_vec_def = copy_opt_def_id(&result.builtin_vec_def);
    checker.builtin_option_def = copy_opt_def_id(&result.builtin_option_def);
    checker.builtin_box_def = copy_opt_def_id(&result.builtin_box_def);
    checker.builtin_hashmap_def = copy_opt_def_id(&result.builtin_hashmap_def);
    checker.builtin_result_def = copy_opt_def_id(&result.builtin_result_def);

    // Phase 1: Collect type information from items
    collect_item_signatures(&mut checker, &result.items);

    // Phase 1b: Register builtin method signatures for String, Vec, Option, etc.
    // Pass the interner from HIR lowering so method name symbols match.
    register_builtin_signatures(&mut checker, &result.interner);

    // Phase 1b2: Register builtin constructor signatures (String::new, Vec::new, etc.)
    // This enables type inference to resolve return types for constructor calls.
    register_builtin_constructor_signatures(&mut checker, &result.builtin_fn_defs);

    // Phase 1c: Register builtin enum info (Option, Result) for exhaustiveness checking
    register_builtin_enums(
        &mut checker,
        &result.interner,
        &result.builtin_option_some_def,
        &result.builtin_option_none_def,
        &result.builtin_result_ok_def,
        &result.builtin_result_err_def,
    );

    // Phase 2: Type check main file bodies (determines success/failure).
    let body_limit = result.main_body_count;
    let mut i: usize = 0;
    while i < body_limit {
        let body_entry = &result.bodies[i];
        let mut return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        if is_handler_return_body(&result.items, body_entry.body_id) {
            return_ty = checker.fresh_infer();
        }
        let found_def_id = find_def_id_for_body(&result.items, body_entry.body_id);
        checker.current_body_def_id = found_def_id;
        checker.current_effect_row = find_effect_row_for_body(&result.items, body_entry.body_id);
        unify_handler_op_params(&mut checker, &result.items, &body_entry.body, body_entry.body_id);
        setup_handler_op_context(&mut checker, &result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, return_ty);
        i = i + 1;
    }

    // Capture main-file error count before checking external bodies.
    let main_error_count = checker.errors.len();

    // Phase 2b: Type check external module bodies to record method resolutions.
    // These bodies are MIR-lowered and code-generated, so their method calls
    // must be resolved. Errors from external bodies are discarded since each
    // module is authoritative only when compiled as the main file.
    let mut j: usize = body_limit;
    while j < result.bodies.len() {
        let body_entry = &result.bodies[j];
        let mut return_ty = find_return_type_for_body(&result.items, body_entry.body_id);
        if is_handler_return_body(&result.items, body_entry.body_id) {
            return_ty = checker.fresh_infer();
        }
        let found_def_id = find_def_id_for_body(&result.items, body_entry.body_id);
        checker.current_body_def_id = found_def_id;
        checker.current_effect_row = find_effect_row_for_body(&result.items, body_entry.body_id);
        unify_handler_op_params(&mut checker, &result.items, &body_entry.body, body_entry.body_id);
        setup_handler_op_context(&mut checker, &result.items, body_entry.body_id);
        check_body(&mut checker, &body_entry.body, return_ty);
        j = j + 1;
    }

    // Discard errors from external bodies by truncating back to main error count.
    while checker.errors.len() > main_error_count {
        checker.errors.pop();
    }

    // Phase 3: Deferred method resolution for Infer-receiver calls
    resolve_pending_methods(&mut checker);

    // Return result with substitution table for type resolution in MIR lowering
    if checker.has_errors() {
        TypeCheckResult::failed(checker.errors, checker.subst_table, checker.method_resolutions, checker.field_resolutions)
    } else {
        TypeCheckResult::ok(checker.subst_table, checker.builtin_def_names, checker.method_resolutions, checker.field_resolutions, checker.default_method_remaps)
    }
}

/// Collects type signatures from HIR items.
///
/// This populates the type checker with information about struct, enum,
/// and function definitions so it can resolve types during body checking.
fn collect_item_signatures(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                // Register function signature
                checker.register_fn_sig(entry.def_id, &fn_def.sig);
            }
            &hir_item::ItemKind::Struct(ref struct_def) => {
                // Register struct definition
                checker.register_struct(entry.def_id, entry.item.name.symbol, struct_def);
            }
            &hir_item::ItemKind::Enum(ref enum_def) => {
                // Register enum definition
                checker.register_enum(entry.def_id, entry.item.name.symbol, enum_def);
            }
            &hir_item::ItemKind::Const(ref const_def) => {
                // Register constant definition
                checker.register_const(entry.def_id, entry.item.name.symbol, type_intern::type_to_ty_id(&const_def.ty));
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                // Register static definition
                checker.register_static(entry.def_id, entry.item.name.symbol, type_intern::type_to_ty_id(&static_def.ty), static_def.mutable);
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Register impl block for method resolution
                register_impl(checker, entry.def_id, impl_def, items);
            }
            // Other items don't need registration for basic type checking
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Trait(ref trait_def) => {
                register_trait(checker, entry.def_id, entry.item.name.symbol, trait_def);
            }
            &hir_item::ItemKind::Effect(ref effect_def) => {
                register_effect(checker, entry.def_id, entry.item.name.symbol, effect_def);
            }
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                register_foreign_fns(checker, foreign_def);
            }
        }
        i = i + 1;
    }
}

/// Registers function signatures from a foreign (bridge) definition.
///
/// This processes ForeignFn items and registers their typed signatures
/// so the type checker can validate calls to builtin/FFI functions.
fn register_foreign_fns(
    checker: &mut typeck::TypeChecker,
    foreign_def: &hir_item::ForeignDef,
) {
    let mut i: usize = 0;
    while i < foreign_def.items.len() {
        match &foreign_def.items[i] {
            &hir_item::ForeignItem::Fn(ref foreign_fn) => {
                let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                let mut j: usize = 0;
                while j < foreign_fn.param_tys.len() {
                    param_tys.push(type_intern::type_to_ty_id(&foreign_fn.param_tys[j]));
                    j = j + 1;
                }
                checker.register_fn_sig_direct(
                    foreign_fn.def_id,
                    param_tys,
                    type_intern::type_to_ty_id(&foreign_fn.return_ty),
                    0,
                );
            }
            &hir_item::ForeignItem::Static(ref foreign_static) => {
                checker.register_static(
                    foreign_static.def_id,
                    foreign_static.name.symbol,
                    type_intern::type_to_ty_id(&foreign_static.ty),
                    foreign_static.mutable,
                );
            }
            &hir_item::ForeignItem::OpaqueType(_) => {}
        }
        i = i + 1;
    }
}

/// Registers a trait definition for type checking.
fn register_trait(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    name: common::Symbol,
    trait_def: &hir_item::TraitDef,
) {
    let num_generics = count_type_params(&trait_def.generics.params);
    let mut methods: Vec<typeck::TraitMethodInfo> = Vec::new();
    let mut assoc_types: Vec<common::Symbol> = Vec::new();

    let mut i: usize = 0;
    while i < trait_def.items.len() {
        match &trait_def.items[i] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                let mut takes_self_ref = false;
                let mut takes_self_mut = false;

                let mut j: usize = 0;
                while j < assoc_fn.sig.params.len() {
                    if j == 0 && assoc_fn.sig.params[j].is_self {
                        takes_self_ref = true;
                        takes_self_mut = assoc_fn.sig.params[j].mutable;
                    } else {
                        param_tys.push(type_intern::type_to_ty_id(&assoc_fn.sig.params[j].ty));
                    }
                    j = j + 1;
                }

                let method_info = typeck::TraitMethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    param_tys,
                    type_intern::type_to_ty_id(&assoc_fn.sig.return_ty),
                    takes_self_ref,
                    takes_self_mut,
                    assoc_fn.has_default,
                );
                methods.push(method_info);

                // Register fn signature for default methods so type checker
                // can resolve calls inside the default body.
                if assoc_fn.has_default {
                    checker.register_fn_sig(assoc_fn.def_id, &assoc_fn.sig);
                }
            }
            &hir_item::AssocItem::Type(ref assoc_type) => {
                assoc_types.push(assoc_type.name.symbol);
            }
            &hir_item::AssocItem::Const(_) => {}
        }
        i = i + 1;
    }

    let trait_info = typeck::TraitInfo::new(def_id, name, num_generics, methods, assoc_types);
    checker.register_trait(def_id, trait_info);

    // Register a synthetic ImplInfo for the trait's Self type so that
    // default method bodies can resolve calls to other trait methods.
    // Within a trait, Self = Adt { def_id: trait_def_id, args: [] }.
    let interner = type_intern::type_interner();
    let empty_args = interner.intern_ty_list(&Vec::new());
    let trait_self_ty = interner.mk_adt(hir_def::DefId::new(def_id.index), empty_args);
    let mut impl_methods: Vec<typeck::MethodInfo> = Vec::new();
    let mut k: usize = 0;
    while k < trait_def.items.len() {
        match &trait_def.items[k] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                let mut pm_tys: Vec<type_intern::TyId> = Vec::new();
                let mut takes_sr = false;
                let mut takes_sm = false;
                let mut pj: usize = 0;
                while pj < assoc_fn.sig.params.len() {
                    if pj == 0 && assoc_fn.sig.params[pj].is_self {
                        takes_sr = true;
                        takes_sm = assoc_fn.sig.params[pj].mutable;
                    } else {
                        pm_tys.push(type_intern::type_to_ty_id(&assoc_fn.sig.params[pj].ty));
                    }
                    pj = pj + 1;
                }
                let mi = typeck::MethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    pm_tys,
                    type_intern::type_to_ty_id(&assoc_fn.sig.return_ty),
                    takes_sr,
                    takes_sm,
                );
                impl_methods.push(mi);
            }
            &hir_item::AssocItem::Type(_) => {}
            &hir_item::AssocItem::Const(_) => {}
        }
        k = k + 1;
    }
    let trait_impl = typeck::ImplInfo::new(
        def_id,
        trait_self_ty,
        num_generics,
        impl_methods,
    );
    checker.register_impl(trait_impl);
}

/// Registers an impl block for method resolution.
fn register_impl(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    impl_def: &hir_item::ImplDef,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    // Extract method info from associated items
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();
    let mut i: usize = 0;
    while i < impl_def.items.len() {
        match &impl_def.items[i] {
            &hir_item::AssocItem::Fn(ref assoc_fn) => {
                // Extract parameter types from signature (skipping self param)
                let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                let mut takes_self_ref = false;
                let mut takes_self_mut = false;

                // Check if first param is self
                if assoc_fn.sig.params.len() > 0 {
                    // Check first param for self pattern
                    // For now, assume first param might be self and check params
                    let mut j: usize = 0;
                    while j < assoc_fn.sig.params.len() {
                        // Skip self parameter (index 0) if this looks like a method
                        // In HIR, self is encoded in the first parameter
                        if j == 0 && assoc_fn.sig.params[j].is_self {
                            takes_self_ref = true;
                            takes_self_mut = assoc_fn.sig.params[j].mutable;
                        } else {
                            param_tys.push(type_intern::type_to_ty_id(&assoc_fn.sig.params[j].ty));
                        }
                        j = j + 1;
                    }
                }

                let method_info = typeck::MethodInfo::new(
                    assoc_fn.def_id,
                    assoc_fn.name.symbol,
                    param_tys,
                    type_intern::type_to_ty_id(&assoc_fn.sig.return_ty),
                    takes_self_ref,
                    takes_self_mut,
                );
                methods.push(method_info);

                // Also register the full function signature in fn_sigs so that
                // infer_path can find associated functions by DefId. Without this,
                // calls like Counter::new(10) would fail to resolve the return type,
                // leaving downstream method call receivers as Infer variables.
                checker.register_fn_sig(assoc_fn.def_id, &assoc_fn.sig);
            }
            &hir_item::AssocItem::Type(_) => {
                // Associated types don't need registration for basic method resolution
            }
            &hir_item::AssocItem::Const(_) => {
                // Associated consts don't need registration for basic method resolution
            }
        }
        i = i + 1;
    }

    // If this impl is for a trait, inject default methods not overridden in the impl
    match &impl_def.trait_ref {
        &Option::Some(ref trait_ref) => {
            inject_default_methods(checker, &mut methods, trait_ref, items);
        }
        &Option::None => {}
    }

    // Create and register impl info
    let num_generics = count_type_params(&impl_def.generics.params);
    let impl_info = typeck::ImplInfo::new(
        def_id,
        type_intern::type_to_ty_id(&impl_def.self_ty),
        num_generics,
        methods,
    );
    checker.register_impl(impl_info);
}

/// Injects default methods from a trait into an impl's method list.
/// For each default method in the trait that is not overridden in the impl,
/// a MethodInfo entry is created so lookup_method() can find it.
///
/// Also builds a call remapping table: when a default method body calls
/// other trait methods (e.g. self.name()), those calls resolve to the
/// trait's abstract method DefId. At codegen time, these must be redirected
/// to the concrete impl's method DefIds.
fn inject_default_methods(
    checker: &mut typeck::TypeChecker,
    methods: &mut Vec<typeck::MethodInfo>,
    trait_ref: &hir_ty::TraitRef,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    // Look up the trait definition
    match checker.get_trait(trait_ref.def_id) {
        Option::Some(trait_info) => {
            // For each trait method with a default implementation
            let mut ti: usize = 0;
            while ti < trait_info.methods.len() {
                let trait_method = &trait_info.methods[ti];
                if trait_method.has_default {
                    // Check if this method is already overridden in the impl
                    let mut already_overridden = false;
                    let mut mi: usize = 0;
                    while mi < methods.len() {
                        if methods[mi].name.index == trait_method.name.index {
                            already_overridden = true;
                        }
                        mi = mi + 1;
                    }

                    if !already_overridden {
                        // Copy parameter types (TyId — trivial u32 copy)
                        let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                        let mut pi: usize = 0;
                        while pi < trait_method.param_tys.len() {
                            param_tys.push(type_intern::TyId::new(trait_method.param_tys[pi].index));
                            pi = pi + 1;
                        }

                        // Create a MethodInfo for the default method
                        let method_info = typeck::MethodInfo::new(
                            trait_method.def_id,
                            trait_method.name,
                            param_tys,
                            type_intern::TyId::new(trait_method.return_ty.index),
                            trait_method.takes_self_ref,
                            trait_method.takes_self_mut,
                        );
                        methods.push(method_info);

                        // Build call remapping table for this default method.
                        // For each trait method that IS overridden in the impl,
                        // map the trait method DefId to the impl method DefId.
                        let mut call_remaps: Vec<common::CallRemapEntry> = Vec::new();
                        let mut ri: usize = 0;
                        while ri < trait_info.methods.len() {
                            let other_trait_method = &trait_info.methods[ri];
                            // Find the impl method that overrides this trait method
                            let mut imi: usize = 0;
                            while imi < methods.len() {
                                if methods[imi].name.index == other_trait_method.name.index
                                    && methods[imi].def_id.index != other_trait_method.def_id.index
                                {
                                    // This impl method overrides the trait method
                                    call_remaps.push(common::CallRemapEntry::new(
                                        other_trait_method.def_id.index,
                                        methods[imi].def_id.index,
                                    ));
                                }
                                imi = imi + 1;
                            }
                            ri = ri + 1;
                        }

                        if call_remaps.len() > 0 {
                            checker.default_method_remaps.push(
                                common::DefaultMethodRemap::new(
                                    trait_method.def_id.index,
                                    call_remaps,
                                ),
                            );
                        }
                    }
                }
                ti = ti + 1;
            }
        }
        Option::None => {
            // Trait not found — can happen if trait is in external module
        }
    }
}

/// Registers an effect definition for type checking.
fn register_effect(
    checker: &mut typeck::TypeChecker,
    def_id: hir_def::DefId,
    name: common::Symbol,
    effect_def: &hir_item::EffectDef,
) {
    let num_generics = count_type_params(&effect_def.generics.params);

    // Collect operation names
    let mut op_names: Vec<common::Symbol> = Vec::new();
    let mut operations: Vec<typeck::EffectOpInfo> = Vec::new();

    let mut i: usize = 0;
    while i < effect_def.operations.len() {
        let effect_op = &effect_def.operations[i];
        op_names.push(effect_op.name.symbol);

        // Convert parameter types at HIR boundary
        let mut param_tys: Vec<type_intern::TyId> = Vec::new();
        let mut j: usize = 0;
        while j < effect_op.param_tys.len() {
            param_tys.push(type_intern::type_to_ty_id(&effect_op.param_tys[j]));
            j = j + 1;
        }

        let op_info = typeck::EffectOpInfo::new(
            effect_op.def_id,
            effect_op.name.symbol,
            param_tys,
            type_intern::type_to_ty_id(&effect_op.return_ty),
        );
        operations.push(op_info);
        i = i + 1;
    }

    let info = typeck::EffectInfo::new(
        def_id,
        name,
        num_generics,
        op_names,
        operations,
    );
    checker.register_effect(def_id, info);
}

// ============================================================
// Generic Parameter Counting
// ============================================================

/// Counts only type parameters in a generics param list, excluding
/// lifetime parameters and const parameters.
fn count_type_params(params: &Vec<hir_ty::GenericParam>) -> u32 {
    let mut count: u32 = 0;
    let mut i: usize = 0;
    while i < params.len() {
        match &params[i] {
            &hir_ty::GenericParam::TypeParam(_) => {
                count = count + 1;
            }
            &hir_ty::GenericParam::LifetimeParam(_) => {}
            &hir_ty::GenericParam::ConstParam(_) => {}
        }
        i = i + 1;
    }
    count
}

// ============================================================
// Body Return Type Lookup
// ============================================================

/// Finds the return type for a body by looking up the corresponding function item.
///
/// Searches the items list for a function whose body_id matches the target,
/// and returns its signature's return type directly (no substitution needed —
/// TypeParam nodes unify naturally through the type checker).
/// Falls back to unit type if no matching function is found.
fn find_return_type_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> type_intern::TyId {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return type_intern::type_to_ty_id(&fn_def.sig.return_ty);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return type_intern::type_to_ty_id(&assoc_fn.sig.return_ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return type_intern::type_to_ty_id(&assoc_const.ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(ref const_def) => {
                if const_def.body_id.index == target_body_id.index {
                    return type_intern::type_to_ty_id(&const_def.ty);
                }
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                if static_def.body_id.index == target_body_id.index {
                    return type_intern::type_to_ty_id(&static_def.ty);
                }
            }
            &hir_item::ItemKind::Trait(ref trait_def) => {
                // Check default method bodies in trait definitions
                let mut j: usize = 0;
                while j < trait_def.items.len() {
                    match &trait_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return type_intern::type_to_ty_id(&assoc_fn.sig.return_ty);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(ref handler_def) => {
                // Check return clause body
                match &handler_def.return_clause {
                    &Option::Some(ref rc) => {
                        if rc.body_id.index == target_body_id.index {
                            return type_intern::CommonTypes::unit();
                        }
                    }
                    &Option::None => {}
                }
                // Check op implementation bodies — look up effect op return type
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        let op_def_id = handler_def.op_impls[j].op_def_id;
                        return find_effect_op_return_type(items, op_def_id);
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to unit type if no matching function found
    type_intern::CommonTypes::unit()
}

/// Looks up the return type of an effect operation by its DefId.
fn find_effect_op_return_type(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    op_def_id: hir_def::DefId,
) -> type_intern::TyId {
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Effect(ref effect_def) => {
                let mut j: usize = 0;
                while j < effect_def.operations.len() {
                    let effect_op = &effect_def.operations[j];
                    if effect_op.def_id.index == op_def_id.index {
                        return type_intern::type_to_ty_id(&effect_op.return_ty);
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    type_intern::CommonTypes::unit()
}

/// Looks up the parameter types of an effect operation for a handler op body.
/// Returns None if not a handler op body, or Some(Vec of param types).
fn find_op_param_types_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> Option<Vec<type_intern::TyId>> {
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Handler(ref handler_def) => {
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        let op_def_id = handler_def.op_impls[j].op_def_id;
                        // Find the effect op param types
                        let mut ei: usize = 0;
                        while ei < items.len() {
                            match &items[ei].item.kind {
                                &hir_item::ItemKind::Effect(ref effect_def) => {
                                    let mut k: usize = 0;
                                    while k < effect_def.operations.len() {
                                        let effect_op = &effect_def.operations[k];
                                        if effect_op.def_id.index == op_def_id.index {
                                            let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                                            let mut p: usize = 0;
                                            while p < effect_op.param_tys.len() {
                                                param_tys.push(type_intern::type_to_ty_id(&effect_op.param_tys[p]));
                                                p = p + 1;
                                            }
                                            return Option::Some(param_tys);
                                        }
                                        k = k + 1;
                                    }
                                }
                                _ => {}
                            }
                            ei = ei + 1;
                        }
                        return Option::None;
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    Option::None
}

/// Returns the number of handler state fields for a handler op body.
fn find_handler_state_count_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> usize {
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Handler(ref handler_def) => {
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        return handler_def.state.len();
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    0
}

/// Unify handler op parameter types with their effect-declared types.
/// This resolves the `Type::infer()` variables created in `lower_op_impl`
/// so that the op body's parameter locals have correct types during type checking.
fn unify_handler_op_params(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
    body: &hir_expr::Body,
    body_id: hir_def::BodyId,
) {
    match find_op_param_types_for_body(items, body_id) {
        Option::Some(ref param_tys) => {
            let state_count = find_handler_state_count_for_body(items, body_id);
            let mut k: usize = 0;
            while k < param_tys.len() {
                let local_idx = state_count + k;
                if local_idx < body.locals.len() {
                    let span = body.locals[local_idx].span;
                    // body.locals[].ty is still hir_ty::Type (until A.4), convert at boundary
                    let local_ty_id = type_intern::type_to_ty_id(&body.locals[local_idx].ty);
                    let ok = checker.unify(local_ty_id, type_intern::TyId::new(param_tys[k].index), span);
                    let _ = ok;
                }
                k = k + 1;
            }
        }
        Option::None => {}
    }
}

/// Returns true if the given body belongs to a handler return clause.
/// Handler return clause bodies should not be constrained to return unit —
/// they determine the overall type of the `with ... handle` expression.
fn is_handler_return_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> bool {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Handler(ref handler_def) => {
                match &handler_def.return_clause {
                    &Option::Some(ref rc) => {
                        if rc.body_id.index == target_body_id.index {
                            return true;
                        }
                    }
                    &Option::None => {}
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    false
}

/// Finds the effect row DefIds for the function containing a given body.
/// Returns a Vec<u32> of effect DefIds declared in the function's effect row.
fn find_effect_row_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> Vec<u32> {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return collect_effect_def_ids(&fn_def.sig.effects);
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return collect_effect_def_ids(&assoc_fn.sig.effects);
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    Vec::new()
}

/// Sets up the type checker's resume context for a handler op body.
/// For handler op bodies, this sets:
///   - resume_ty: the effect op's return type (what resume() should produce)
///   - in_shallow_handler: true if the handler is shallow
///   - resume_count: 0 (reset for each body)
/// For non-handler bodies, this resets all three fields.
fn setup_handler_op_context(
    checker: &mut typeck::TypeChecker,
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) {
    // Reset to defaults
    checker.resume_ty = Option::None;
    checker.in_shallow_handler = false;
    checker.resume_count = 0;

    // Search for handler that owns this body
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Handler(ref handler_def) => {
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        // Found the handler op body — set shallow flag
                        match &handler_def.kind {
                            &common::HandlerKind::Shallow => {
                                checker.in_shallow_handler = true;
                            }
                            &common::HandlerKind::Deep => {
                                checker.in_shallow_handler = false;
                            }
                        }

                        // Find the effect op return type via op_def_id
                        let op_def_id = handler_def.op_impls[j].op_def_id;
                        let mut ei: usize = 0;
                        while ei < items.len() {
                            match &items[ei].item.kind {
                                &hir_item::ItemKind::Effect(ref effect_def) => {
                                    let mut k: usize = 0;
                                    while k < effect_def.operations.len() {
                                        let effect_op = &effect_def.operations[k];
                                        if effect_op.def_id.index == op_def_id.index {
                                            checker.resume_ty = Option::Some(type_intern::type_to_ty_id(&effect_op.return_ty));
                                            return;
                                        }
                                        k = k + 1;
                                    }
                                }
                                _ => {}
                            }
                            ei = ei + 1;
                        }
                        // op_def_id not found in any effect — leave resume_ty as None
                        return;
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    // Not a handler op body — defaults already set
}

/// Helper to extract effect DefIds from an EffectRow.
fn collect_effect_def_ids(row: &hir_ty::EffectRow) -> Vec<u32> {
    let mut result: Vec<u32> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        result.push(row.effects[i].def_id.index);
        i = i + 1;
    }
    result
}

/// Finds the DefId for the function containing a given body.
/// Returns 0 if no matching function found.
fn find_def_id_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> u32 {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return entry.item.def_id.index;
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return assoc_fn.def_id.index;
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return assoc_const.def_id.index;
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(ref const_def) => {
                if const_def.body_id.index == target_body_id.index {
                    return entry.item.def_id.index;
                }
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                if static_def.body_id.index == target_body_id.index {
                    return entry.item.def_id.index;
                }
            }
            &hir_item::ItemKind::Trait(ref trait_def) => {
                // Check default method bodies in trait definitions
                let mut j: usize = 0;
                while j < trait_def.items.len() {
                    match &trait_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return assoc_fn.def_id.index;
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(_) => {}
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(ref handler_def) => {
                // Check return clause body
                match &handler_def.return_clause {
                    &Option::Some(ref rc) => {
                        if rc.body_id.index == target_body_id.index {
                            return entry.item.def_id.index;
                        }
                    }
                    &Option::None => {}
                }
                // Check op implementation bodies
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    if handler_def.op_impls[j].body_id.index == target_body_id.index {
                        return handler_def.op_impls[j].op_def_id.index;
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    // Default to body_id's index if no matching function found.
    // This must match the fallback in driver.blood's MIR lowering
    // to ensure method resolution lookups use consistent keys.
    target_body_id.index
}

// ============================================================
// Linearity Checking
// ============================================================

/// Tracks ownership qualifier and usage count for a local variable.
struct LinearEntry {
    local_idx: u32,
    is_linear: bool,
    is_affine: bool,
    use_count: u32,
    def_span: common::Span,
}

/// Checks linearity constraints on a function body after type checking.
fn check_linearity(checker: &mut typeck::TypeChecker, body: &hir_expr::Body) {
    // Collect locals with ownership qualifiers
    let mut entries: Vec<LinearEntry> = Vec::new();
    let mut li: usize = 0;
    while li < body.locals.len() {
        let local = &body.locals[li];
        let local_ty_id = type_intern::type_to_ty_id(&local.ty);
        let resolved_id = checker.resolve(local_ty_id);
        let resolved_ty = type_intern::ty_id_to_type(resolved_id);
        match &resolved_ty.kind {
            &hir_ty::TypeKind::Ownership { ref qualifier, inner: _ } => {
                let is_lin = match qualifier {
                    &hir_ty::OwnershipQualifier::Linear => true,
                    &hir_ty::OwnershipQualifier::Affine => false,
                };
                let is_aff = match qualifier {
                    &hir_ty::OwnershipQualifier::Linear => false,
                    &hir_ty::OwnershipQualifier::Affine => true,
                };
                let entry = LinearEntry {
                    local_idx: local.id.index,
                    is_linear: is_lin,
                    is_affine: is_aff,
                    use_count: 0,
                    def_span: local.span,
                };
                entries.push(entry);
            }
            _ => {}
        }
        li = li + 1;
    }

    // If no ownership-qualified locals, skip usage scanning
    if entries.len() == 0 {
        return;
    }

    // Count usages by scanning the body expression
    count_usages_expr(&mut entries, &body.expr);

    // Report violations
    let mut ei: usize = 0;
    while ei < entries.len() {
        let entry = &entries[ei];
        if entry.is_linear {
            if entry.use_count == 0 {
                checker.error(typeck::TypeErrorKind::LinearNotUsed, entry.def_span);
            } else if entry.use_count > 1 {
                checker.error(typeck::TypeErrorKind::LinearUsedMultipleTimes, entry.def_span);
            }
        } else if entry.is_affine {
            if entry.use_count > 1 {
                checker.error(typeck::TypeErrorKind::AffineUsedMultipleTimes, entry.def_span);
            }
        }
        ei = ei + 1;
    }
}

/// Increments use_count for a local if it's tracked.
fn record_linear_use(entries: &mut Vec<LinearEntry>, local_idx: u32) {
    let mut i: usize = 0;
    while i < entries.len() {
        if entries[i].local_idx == local_idx {
            entries[i].use_count = entries[i].use_count + 1;
            return;
        }
        i = i + 1;
    }
}

/// Counts usages of tracked locals in an expression.
fn count_usages_expr(entries: &mut Vec<LinearEntry>, expr: &hir_expr::Expr) {
    match &expr.kind {
        &hir_expr::ExprKind::Local(ref local_id) => {
            record_linear_use(entries, local_id.index);
        }
        &hir_expr::ExprKind::Binary { ref left, ref right, op: _ } => {
            count_usages_expr(entries, left.as_ref());
            count_usages_expr(entries, right.as_ref());
        }
        &hir_expr::ExprKind::Unary { ref operand, op: _ } => {
            count_usages_expr(entries, operand.as_ref());
        }
        &hir_expr::ExprKind::Call { ref callee, ref args } => {
            count_usages_expr(entries, callee.as_ref());
            let mut i: usize = 0;
            while i < args.len() {
                count_usages_expr(entries, &args[i]);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::MethodCall { ref receiver, method: _, method_def: _, type_args: _, ref args } => {
            count_usages_expr(entries, receiver.as_ref());
            let mut i: usize = 0;
            while i < args.len() {
                count_usages_expr(entries, &args[i]);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            count_usages_expr(entries, condition.as_ref());
            count_usages_expr(entries, then_branch.as_ref());
            match else_branch {
                &Option::Some(ref eb) => {
                    count_usages_expr(entries, eb.as_ref());
                }
                &Option::None => {}
            }
        }
        &hir_expr::ExprKind::Block(ref block) => {
            count_usages_block(entries, block);
        }
        &hir_expr::ExprKind::Match { ref scrutinee, ref arms } => {
            count_usages_expr(entries, scrutinee.as_ref());
            let mut i: usize = 0;
            while i < arms.len() {
                count_usages_expr(entries, &arms[i].body);
                i = i + 1;
            }
        }
        &hir_expr::ExprKind::Assign { ref target, ref val } => {
            count_usages_expr(entries, target.as_ref());
            count_usages_expr(entries, val.as_ref());
        }
        &hir_expr::ExprKind::Return(ref opt_val) => {
            match opt_val {
                &Option::Some(ref v) => {
                    count_usages_expr(entries, v.as_ref());
                }
                &Option::None => {}
            }
        }
        &hir_expr::ExprKind::Field { ref base, field: _ } => {
            count_usages_expr(entries, base.as_ref());
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            count_usages_expr(entries, base.as_ref());
            count_usages_expr(entries, idx.as_ref());
        }
        &hir_expr::ExprKind::AddrOf { mutable: _, ref expr } => {
            count_usages_expr(entries, expr.as_ref());
        }
        &hir_expr::ExprKind::Cast { ref expr, ty: _ } => {
            count_usages_expr(entries, expr.as_ref());
        }
        &hir_expr::ExprKind::Loop { label: _, ref body } => {
            count_usages_expr(entries, body.as_ref());
        }
        _ => {
            // Literal, Path, Error, etc. — no local usage to track
        }
    }
}

/// Counts usages of tracked locals in a block.
fn count_usages_block(entries: &mut Vec<LinearEntry>, block: &hir_expr::Block) {
    let mut i: usize = 0;
    while i < block.stmts.len() {
        match &block.stmts[i] {
            &hir_expr::Stmt::Expr { ref expr, has_semi: _ } => {
                count_usages_expr(entries, expr);
            }
            &hir_expr::Stmt::Let { pattern: _, ty: _, ref init, span: _ } => {
                match init {
                    &Option::Some(ref init_expr) => {
                        count_usages_expr(entries, init_expr);
                    }
                    &Option::None => {}
                }
            }
            &hir_expr::Stmt::Item(_) => {}
        }
        i = i + 1;
    }
    match &block.expr {
        &Option::Some(ref e) => {
            count_usages_expr(entries, e.as_ref());
        }
        &Option::None => {}
    }
}

// ============================================================
// Body Type Checking
// ============================================================

/// Type checks a single function body.
///
/// The return_ty comes from the function signature (not from body locals).
fn check_body(checker: &mut typeck::TypeChecker, body: &hir_expr::Body, return_ty: type_intern::TyId) {
    // Clear locals for this body
    checker.clear_locals();

    // Register all locals from the body at their actual LocalId positions.
    // HIR lowering allocates LocalIds globally (not per-body), so a body's
    // locals may have non-zero starting indices. We must grow the locals
    // vector to accommodate the highest LocalId, then place each local at
    // its actual index.
    let mut i: usize = 0;
    while i < body.locals.len() {
        let local = &body.locals[i];
        let target_idx = local.id.index as usize;
        // Grow the locals vector to accommodate this index
        while checker.locals.len() <= target_idx {
            // Pad with dummy locals (will not be accessed for valid programs)
            checker.add_local(
                type_intern::CommonTypes::error(),
                false,
                common::Span::new(0, 0, 1, 1),
            );
        }
        // Overwrite with the real local's type (convert at HIR boundary)
        checker.locals[target_idx] = typeck::LocalInfo::new(
            type_intern::type_to_ty_id(&local.ty),
            local.mutable,
            local.span,
        );
        i = i + 1;
    }

    // Set return type from the function signature
    checker.set_return_ty(return_ty);

    // Type check the body expression
    let body_ty = typeck_expr::infer_expr(checker, &body.expr);

    // Unify body type with return type
    match &checker.return_ty {
        &Some(ret_ty) => {
            let ok = checker.unify(body_ty, type_intern::TyId::new(ret_ty.index), body.expr.span);
            let _ = ok;
        }
        &None => {}
    }

    // Check for unresolved inference variables in non-generic function let-bindings.
    // Only runs for bodies that belong to a known non-generic function.
    // Only checks explicit let-bindings (not pattern bindings from match/handler
    // which may have lazily-resolved inference vars).
    // A local is a let-binding if its name is non-empty and not a temporary.
    let fn_generic_status = get_fn_generic_status(checker);
    // fn_generic_status: 0 = not a function (handler/unknown), 1 = non-generic fn, 2 = generic fn
    if fn_generic_status == 1 {
        let mut li: usize = 0;
        while li < body.locals.len() {
            let local = &body.locals[li];
            let target_idx = local.id.index as usize;
            if target_idx < checker.locals.len() {
                // checker.locals[].ty is now TyId; resolve and bridge to hir_ty for diagnostic
                let resolved_id = checker.resolve(type_intern::TyId::new(checker.locals[target_idx].ty.index));
                let resolved = type_intern::ty_id_to_type(resolved_id);
                if type_contains_infer(&resolved) {
                    // Only flag let-bindings, not pattern/handler op params.
                    // Let-bindings have a name in their span and are assigned
                    // from the result of a call expression — check if the
                    // resolved type is a function type (fn pointer that couldn't
                    // be monomorphized).
                    if type_is_unresolved_fn(&resolved) {
                        checker.error(typeck_types::TypeErrorKind::CannotInfer, local.span);
                        // Only report once per body
                        li = body.locals.len();
                    }
                }
            }
            li = li + 1;
        }
    }

    // Run linearity checking: scan locals for ownership qualifiers,
    // count usages in body expression, report violations.
    // Inline implementation to avoid potential codegen issues with the module.
    check_linearity(checker, body);

    // Clear return type
    checker.clear_return_ty();
}

/// Returns the generic status of the current function being type-checked.
/// 0 = not a known function (handler body, unknown body — skip check)
/// 1 = non-generic function (check for unresolved infer vars)
/// 2 = generic function (skip check — infer vars expected)
fn get_fn_generic_status(checker: &mut typeck::TypeChecker) -> i32 {
    let def_idx = checker.current_body_def_id as usize;
    if def_idx < checker.fn_sigs.len() {
        match &checker.fn_sigs[def_idx] {
            &Option::Some(ref sig) => {
                if sig.num_generics > 0 {
                    return 2;
                } else {
                    return 1;
                }
            }
            &Option::None => {}
        }
    }
    // No fn_sig found — this is a handler body, const body, or other non-function body
    0
}

/// Checks if a resolved type still contains Infer variables.
fn type_contains_infer(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Infer(_) => true,
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => type_contains_infer(inner.as_ref()),
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            let mut i: usize = 0;
            while i < args.len() {
                if type_contains_infer(&args[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if type_contains_infer(&types[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                if type_contains_infer(&params[i]) {
                    return true;
                }
                i = i + 1;
            }
            type_contains_infer(ret.as_ref())
        }
        _ => false,
    }
}

/// Checks if a type is an unresolved function type (fn with Infer params/return).
/// This is the specific pattern from `id(id)` where T in fn(T)->T can't be inferred.
fn type_is_unresolved_fn(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                if type_contains_infer(&params[i]) {
                    return true;
                }
                i = i + 1;
            }
            type_contains_infer(ret.as_ref())
        }
        _ => false,
    }
}

// ============================================================
// Deferred Method Resolution
// ============================================================

/// Resolves pending method calls whose receivers were Infer variables.
/// Uses a fixpoint loop: resolving one call may produce a return type
/// that allows another receiver to become concrete.
fn resolve_pending_methods(checker: &mut typeck::TypeChecker) {
    let mut resolved_count: usize = 1;
    while resolved_count > 0 {
        resolved_count = 0;
        let mut i: usize = 0;
        while i < checker.pending_method_calls.len() {
            let body_def_id = checker.pending_method_calls[i].body_def_id;
            let span_start = checker.pending_method_calls[i].span_start;
            let receiver_var = checker.pending_method_calls[i].receiver_var;
            let method_symbol = checker.pending_method_calls[i].method_symbol;
            let return_ty_var = checker.pending_method_calls[i].return_ty_var;

            // Skip if already resolved in a previous iteration
            if is_already_resolved(checker, body_def_id, span_start) {
                i = i + 1;
                continue;
            }

            // Try to resolve the receiver type variable
            // Create TyId for the Infer variable
            let interner = type_intern::type_interner();
            let infer_ty_id = interner.intern(type_intern::InternedTypeKind::Infer(
                hir_def::TyVarId::new(receiver_var)
            ));
            let receiver_ty_id = checker.resolve(infer_ty_id);
            let stripped_id = typeck_expr::strip_refs_id(receiver_ty_id);

            // Check if still an Infer variable
            let stripped_kind = interner.get(stripped_id);
            let still_infer = match stripped_kind {
                &type_intern::InternedTypeKind::Infer(_) => true,
                _ => false,
            };

            if !still_infer {
                // Receiver is now concrete - look up the method
                match checker.lookup_method(stripped_id, method_symbol) {
                    Option::Some(ref lookup_result) => {
                        let method_def_id_index = checker.get_method_from_lookup(lookup_result).def_id.index;
                        let method_return_ty_id = type_intern::TyId::new(checker.get_method_from_lookup(lookup_result).return_ty.index);
                        let impl_num_generics = checker.get_impl_from_lookup(lookup_result).num_generics;
                        let impl_self_ty_id = type_intern::TyId::new(checker.get_impl_from_lookup(lookup_result).self_ty.index);

                        // Record the resolution with the body's DefId for scoping
                        checker.current_body_def_id = body_def_id;
                        checker.record_method_resolution(span_start, method_def_id_index);

                        // Unify return type with actual method return type
                        let mut subst = unify::TypeParamSubst::new();
                        if impl_num_generics > 0 {
                            // Bridge: extract_type_params_from_self_ty still takes &hir_ty::Type
                            let impl_self_type = type_intern::ty_id_to_type(impl_self_ty_id);
                            let stripped_type = type_intern::ty_id_to_type(stripped_id);
                            unify::extract_type_params_from_self_ty(
                                &impl_self_type, &stripped_type, &mut subst
                            );
                        }
                        let actual_ret_id = unify::substitute_type_params_id(
                            method_return_ty_id, &subst
                        );
                        let return_infer_id = interner.intern(type_intern::InternedTypeKind::Infer(
                            hir_def::TyVarId::new(return_ty_var)
                        ));
                        checker.unify(return_infer_id, actual_ret_id, common::Span::dummy());

                        resolved_count = resolved_count + 1;
                    }
                    Option::None => {
                        // Method not found even with concrete receiver — skip
                    }
                }
            }
            i = i + 1;
        }
    }
    // Count unresolved pending calls
    let mut unresolved: usize = 0;
    let mut j: usize = 0;
    while j < checker.pending_method_calls.len() {
        let body_def_id = checker.pending_method_calls[j].body_def_id;
        let span_start = checker.pending_method_calls[j].span_start;
        if !is_already_resolved(checker, body_def_id, span_start) {
            unresolved = unresolved + 1;
        }
        j = j + 1;
    }
    // Pending methods resolved
}

/// Checks if a method call at the given span_start has already been resolved.
fn is_already_resolved(checker: &mut typeck::TypeChecker, body_def_id: u32, span_start: usize) -> bool {
    let mut i: usize = 0;
    while i < checker.method_resolutions.len() {
        if checker.method_resolutions[i].body_def_id == body_def_id &&
           checker.method_resolutions[i].span_start == span_start {
            return true;
        }
        i = i + 1;
    }
    false
}

// ============================================================
// Builtin Method Registration
// ============================================================

/// Copies an Option<DefId> by value (for passing through references).
fn copy_opt_def_id(opt: &Option<hir_def::DefId>) -> Option<hir_def::DefId> {
    match opt {
        &Option::Some(ref d) => Option::Some(hir_def::DefId::new(d.index)),
        &Option::None => Option::None,
    }
}

/// Helper: create a reference type &T.
fn make_ref_ty(inner: type_intern::TyId) -> type_intern::TyId {
    let interner = type_intern::type_interner();
    interner.intern(type_intern::InternedTypeKind::Ref { inner: inner, mutable: false })
}

/// Helper: create an ADT type with the given DefId and type args.
fn make_adt(def_id: hir_def::DefId, args: Vec<type_intern::TyId>) -> type_intern::TyId {
    let interner = type_intern::type_interner();
    let args_list = interner.intern_ty_list(&args);
    interner.intern(type_intern::InternedTypeKind::Adt { def_id: def_id, args: args_list })
}

/// Helper: create a type parameter Param(n).
fn make_param(n: u32) -> type_intern::TyId {
    let interner = type_intern::type_interner();
    interner.intern(type_intern::InternedTypeKind::Param(hir_def::TyVarId::new(n)))
}

/// Helper: add a method to the methods list and record its runtime function name.
/// The interner must be the same interner used during HIR lowering so that
/// method name symbols match.
fn add_method(
    checker: &mut typeck::TypeChecker,
    methods: &mut Vec<typeck::MethodInfo>,
    name: &str,
    runtime_name: &str,
    params: Vec<type_intern::TyId>,
    ret: type_intern::TyId,
    self_mut: bool,
    interner: &interner::StringInterner,
) {
    let def_id = checker.alloc_def_id();
    // Use the same interner as HIR lowering to get matching Symbol indices.
    // All builtin method names are pre-interned, so find() will always succeed.
    let sym = interner.find(name).unwrap();
    methods.push(typeck::MethodInfo::new(def_id, sym, params, ret, true, self_mut));
    // Record mapping from synthetic DefId to runtime function name for codegen
    checker.builtin_def_names.push(
        typeck::BuiltinDefName::new(def_id.index, common::make_string(runtime_name)),
    );
}

/// Registers builtin method signatures for all builtin types.
/// The interner parameter must be the same interner used during HIR lowering
/// so that method name symbols match between HIR and type checking.
fn register_builtin_signatures(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    // String methods
    match checker.builtin_string_def {
        Option::Some(def_id) => {
            register_string_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Vec methods
    match checker.builtin_vec_def {
        Option::Some(def_id) => {
            register_vec_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Option methods
    match checker.builtin_option_def {
        Option::Some(def_id) => {
            register_option_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Box methods
    match checker.builtin_box_def {
        Option::Some(def_id) => {
            register_box_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // HashMap methods
    match checker.builtin_hashmap_def {
        Option::Some(def_id) => {
            register_hashmap_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Result methods
    match checker.builtin_result_def {
        Option::Some(def_id) => {
            register_result_methods(checker, def_id, interner);
        }
        Option::None => {}
    }

    // Primitive str methods
    register_str_methods(checker, interner);

    // Slice methods
    register_slice_methods(checker, interner);
}

/// Registers String methods: len, is_empty, push_str, push, as_str, clone,
/// contains, starts_with, ends_with, as_bytes.
fn register_string_methods(checker: &mut typeck::TypeChecker, string_def: hir_def::DefId, interner: &interner::StringInterner) {
    let self_ty = make_adt(string_def, Vec::new());
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "string_len", Vec::new(), type_intern::CommonTypes::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "string_is_empty", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // push_str(&mut self, &str) -> ()
    let mut push_str_params: Vec<type_intern::TyId> = Vec::new();
    push_str_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "push_str", "string_push_str", push_str_params, type_intern::CommonTypes::unit(), true, interner);

    // push(&mut self, char) -> ()
    let mut push_params: Vec<type_intern::TyId> = Vec::new();
    push_params.push(type_intern::CommonTypes::char_ty());
    add_method(checker, &mut methods, "push", "string_push", push_params, type_intern::CommonTypes::unit(), true, interner);

    // as_str(&self) -> &str
    add_method(checker, &mut methods, "as_str", "string_as_str", Vec::new(), make_ref_ty(type_intern::CommonTypes::str_ty()), false, interner);

    // clone(&self) -> String
    add_method(checker, &mut methods, "clone", "string_clone", Vec::new(), make_adt(string_def, Vec::new()), false, interner);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<type_intern::TyId> = Vec::new();
    contains_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "contains", "string_contains", contains_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<type_intern::TyId> = Vec::new();
    sw_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "starts_with", "string_starts_with", sw_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<type_intern::TyId> = Vec::new();
    ew_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "ends_with", "string_ends_with", ew_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // as_bytes(&self) -> &[u8]
    let ty_interner = type_intern::type_interner();
    let u8_slice = ty_interner.intern(type_intern::InternedTypeKind::Slice { element: type_intern::CommonTypes::u8_ty() });
    add_method(checker, &mut methods, "as_bytes", "string_as_bytes", Vec::new(), make_ref_ty(u8_slice), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers Vec<T> methods: push, pop, len, is_empty, get, last, clear,
/// remove, insert, contains, clone.
fn register_vec_methods(checker: &mut typeck::TypeChecker, vec_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<type_intern::TyId> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(vec_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // push(&mut self, T) -> ()
    let mut push_params: Vec<type_intern::TyId> = Vec::new();
    push_params.push(make_param(0));
    add_method(checker, &mut methods, "push", "vec_push", push_params, type_intern::CommonTypes::unit(), true, interner);

    // pop(&mut self) -> Option<T>
    let option_def = checker.builtin_option_def;
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_param(0));
            add_method(checker, &mut methods, "pop", "vec_pop", Vec::new(), make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "pop", "vec_pop", Vec::new(), make_param(0), true, interner);
        }
    }

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "vec_len", Vec::new(), type_intern::CommonTypes::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "vec_is_empty", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // get(&self, usize) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut get_params: Vec<type_intern::TyId> = Vec::new();
            get_params.push(type_intern::CommonTypes::usize_ty());
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "get", "vec_get", get_params, make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            let mut get_params: Vec<type_intern::TyId> = Vec::new();
            get_params.push(type_intern::CommonTypes::usize_ty());
            add_method(checker, &mut methods, "get", "vec_get", get_params, make_ref_ty(make_param(0)), false, interner);
        }
    }

    // last(&self) -> Option<&T>
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_ref_ty(make_param(0)));
            add_method(checker, &mut methods, "last", "vec_last", Vec::new(), make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "last", "vec_last", Vec::new(), make_ref_ty(make_param(0)), false, interner);
        }
    }

    // clear(&mut self) -> ()
    add_method(checker, &mut methods, "clear", "vec_clear", Vec::new(), type_intern::CommonTypes::unit(), true, interner);

    // remove(&mut self, usize) -> T
    let mut remove_params: Vec<type_intern::TyId> = Vec::new();
    remove_params.push(type_intern::CommonTypes::usize_ty());
    add_method(checker, &mut methods, "remove", "vec_remove", remove_params, make_param(0), true, interner);

    // insert(&mut self, usize, T) -> ()
    let mut insert_params: Vec<type_intern::TyId> = Vec::new();
    insert_params.push(type_intern::CommonTypes::usize_ty());
    insert_params.push(make_param(0));
    add_method(checker, &mut methods, "insert", "vec_insert", insert_params, type_intern::CommonTypes::unit(), true, interner);

    // contains(&self, &T) -> bool
    let mut contains_params: Vec<type_intern::TyId> = Vec::new();
    contains_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains", "vec_contains", contains_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // clone(&self) -> Vec<T>
    let mut clone_args: Vec<type_intern::TyId> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", "vec_clone", Vec::new(), make_adt(vec_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Option<T> methods: is_some, is_none, unwrap, unwrap_or, expect, as_ref, clone.
fn register_option_methods(checker: &mut typeck::TypeChecker, option_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<type_intern::TyId> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(option_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_some(&self) -> bool
    add_method(checker, &mut methods, "is_some", "option_is_some", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // is_none(&self) -> bool
    add_method(checker, &mut methods, "is_none", "option_is_none", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", "option_unwrap", Vec::new(), make_param(0), false, interner);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<type_intern::TyId> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", "option_unwrap_or", unwrap_or_params, make_param(0), false, interner);

    // expect(self, &str) -> T
    let mut expect_params: Vec<type_intern::TyId> = Vec::new();
    expect_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "expect", "option_expect", expect_params, make_param(0), false, interner);

    // as_ref(&self) -> Option<&T>
    let mut as_ref_args: Vec<type_intern::TyId> = Vec::new();
    as_ref_args.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "as_ref", "option_as_ref", Vec::new(), make_adt(option_def, as_ref_args), false, interner);

    // clone(&self) -> Option<T>
    let mut clone_args: Vec<type_intern::TyId> = Vec::new();
    clone_args.push(make_param(0));
    add_method(checker, &mut methods, "clone", "option_clone", Vec::new(), make_adt(option_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers Box<T> methods: as_ref.
fn register_box_methods(checker: &mut typeck::TypeChecker, box_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<type_intern::TyId> = Vec::new();
    self_args.push(make_param(0));
    let self_ty = make_adt(box_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // as_ref(&self) -> &T
    add_method(checker, &mut methods, "as_ref", "box_as_ref", Vec::new(), make_ref_ty(make_param(0)), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers HashMap<K, V> methods: insert, get, contains_key, len, is_empty, remove, clone.
fn register_hashmap_methods(checker: &mut typeck::TypeChecker, hashmap_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<type_intern::TyId> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(hashmap_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // insert(&mut self, K, V) -> Option<V>
    let option_def = checker.builtin_option_def;
    let mut insert_params: Vec<type_intern::TyId> = Vec::new();
    insert_params.push(make_param(0));
    insert_params.push(make_param(1));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "insert", "hashmap_insert", insert_params, make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "insert", "hashmap_insert", insert_params, make_param(1), true, interner);
        }
    }

    // get(&self, &K) -> Option<&V>
    let mut get_params: Vec<type_intern::TyId> = Vec::new();
    get_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_ref_ty(make_param(1)));
            add_method(checker, &mut methods, "get", "hashmap_get", get_params, make_adt(opt_def, opt_args), false, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "get", "hashmap_get", get_params, make_ref_ty(make_param(1)), false, interner);
        }
    }

    // contains_key(&self, &K) -> bool
    let mut ck_params: Vec<type_intern::TyId> = Vec::new();
    ck_params.push(make_ref_ty(make_param(0)));
    add_method(checker, &mut methods, "contains_key", "hashmap_contains_key", ck_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "hashmap_len", Vec::new(), type_intern::CommonTypes::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "hashmap_is_empty", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // remove(&mut self, &K) -> Option<V>
    let mut remove_params: Vec<type_intern::TyId> = Vec::new();
    remove_params.push(make_ref_ty(make_param(0)));
    match option_def {
        Option::Some(opt_def) => {
            let mut opt_args: Vec<type_intern::TyId> = Vec::new();
            opt_args.push(make_param(1));
            add_method(checker, &mut methods, "remove", "hashmap_remove", remove_params, make_adt(opt_def, opt_args), true, interner);
        }
        Option::None => {
            add_method(checker, &mut methods, "remove", "hashmap_remove", remove_params, make_param(1), true, interner);
        }
    }

    // clone(&self) -> HashMap<K, V>
    let mut clone_args: Vec<type_intern::TyId> = Vec::new();
    clone_args.push(make_param(0));
    clone_args.push(make_param(1));
    add_method(checker, &mut methods, "clone", "hashmap_clone", Vec::new(), make_adt(hashmap_def, clone_args), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers Result<T, E> methods: is_ok, is_err, unwrap, unwrap_or, expect.
fn register_result_methods(checker: &mut typeck::TypeChecker, result_def: hir_def::DefId, interner: &interner::StringInterner) {
    let mut self_args: Vec<type_intern::TyId> = Vec::new();
    self_args.push(make_param(0));
    self_args.push(make_param(1));
    let self_ty = make_adt(result_def, self_args);
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // is_ok(&self) -> bool
    add_method(checker, &mut methods, "is_ok", "result_is_ok", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // is_err(&self) -> bool
    add_method(checker, &mut methods, "is_err", "result_is_err", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // unwrap(self) -> T
    add_method(checker, &mut methods, "unwrap", "result_unwrap", Vec::new(), make_param(0), false, interner);

    // unwrap_or(self, T) -> T
    let mut unwrap_or_params: Vec<type_intern::TyId> = Vec::new();
    unwrap_or_params.push(make_param(0));
    add_method(checker, &mut methods, "unwrap_or", "result_unwrap_or", unwrap_or_params, make_param(0), false, interner);

    // expect(self, &str) -> T
    let mut expect_params: Vec<type_intern::TyId> = Vec::new();
    expect_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "expect", "result_expect", expect_params, make_param(0), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 2, methods);
    checker.register_impl(impl_info);
}

/// Registers builtin enum definitions (Option, Result) for exhaustiveness checking.
/// These enums may come from external modules and not be present in the HIR items list.
fn register_builtin_enums(
    checker: &mut typeck::TypeChecker,
    interner: &interner::StringInterner,
    option_some_def: &Option<hir_def::DefId>,
    option_none_def: &Option<hir_def::DefId>,
    result_ok_def: &Option<hir_def::DefId>,
    result_err_def: &Option<hir_def::DefId>,
) {
    // Register Option<T> enum: Some(T), None
    match checker.builtin_option_def {
        Option::Some(option_def) => {
            // Only register if not already registered from HIR items
            let def_idx = option_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                // Guard: skip if "Option"/"Some"/"None" aren't interned
                // (can happen when compiling programs that don't use Option)
                let name_opt = interner.find("Option");
                let some_opt = interner.find("Some");
                let none_opt = interner.find("None");
                match &name_opt {
                    &Option::Some(name_sym) => {
                        let some_sym = match &some_opt {
                            &Option::Some(s) => s,
                            &Option::None => name_sym, // fallback, won't be used
                        };
                        let none_sym = match &none_opt {
                            &Option::Some(s) => s,
                            &Option::None => name_sym, // fallback, won't be used
                        };
                        let mut variant_names: Vec<common::Symbol> = Vec::new();
                        variant_names.push(some_sym);
                        variant_names.push(none_sym);

                        let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                        // Some(T) - has one field of type Param(0)
                        let mut some_fields: Vec<type_intern::TyId> = Vec::new();
                        some_fields.push(make_param(0));
                        // Use actual DefId for Some variant if available
                        match option_some_def {
                            &Option::Some(some_def) => {
                                variants.push(typeck::VariantInfo::with_def_id(some_sym, some_fields, 0, some_def));
                            }
                            &Option::None => {
                                variants.push(typeck::VariantInfo::new(some_sym, some_fields, 0));
                            }
                        }
                        // None - no fields
                        match option_none_def {
                            &Option::Some(none_def) => {
                                variants.push(typeck::VariantInfo::with_def_id(none_sym, Vec::new(), 1, none_def));
                            }
                            &Option::None => {
                                variants.push(typeck::VariantInfo::new(none_sym, Vec::new(), 1));
                            }
                        }

                        let info = typeck::EnumInfo::new(option_def, name_sym, 1, variant_names, variants);
                        while checker.enums.len() <= def_idx {
                            checker.enums.push(Option::None);
                        }
                        checker.enums[def_idx] = Some(info);
                    }
                    &Option::None => {
                        // "Option" not interned — skip builtin enum registration
                    }
                }
            }
        }
        Option::None => {}
    }

    // Register Result<T, E> enum: Ok(T), Err(E)
    match checker.builtin_result_def {
        Option::Some(result_def) => {
            let def_idx = result_def.index as usize;
            let already = if def_idx < checker.enums.len() {
                match &checker.enums[def_idx] {
                    &Option::Some(_) => true,
                    &Option::None => false,
                }
            } else {
                false
            };
            if !already {
                let name_result = interner.find("Result");
                let ok_result = interner.find("Ok");
                let err_result = interner.find("Err");
                let name_sym = match &name_result {
                    &Option::Some(s) => s,
                    &Option::None => { return; } // "Result" not interned, skip
                };
                let ok_sym = match &ok_result {
                    &Option::Some(s) => s,
                    &Option::None => { return; }
                };
                let err_sym = match &err_result {
                    &Option::Some(s) => s,
                    &Option::None => { return; }
                };
                let mut variant_names: Vec<common::Symbol> = Vec::new();
                variant_names.push(ok_sym);
                variant_names.push(err_sym);

                let mut variants: Vec<typeck::VariantInfo> = Vec::new();
                // Ok(T) - one field of type Param(0)
                let mut ok_fields: Vec<type_intern::TyId> = Vec::new();
                ok_fields.push(make_param(0));
                match result_ok_def {
                    &Option::Some(ok_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(ok_sym, ok_fields, 0, ok_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(ok_sym, ok_fields, 0));
                    }
                }
                // Err(E) - one field of type Param(1)
                let mut err_fields: Vec<type_intern::TyId> = Vec::new();
                err_fields.push(make_param(1));
                match result_err_def {
                    &Option::Some(err_def) => {
                        variants.push(typeck::VariantInfo::with_def_id(err_sym, err_fields, 1, err_def));
                    }
                    &Option::None => {
                        variants.push(typeck::VariantInfo::new(err_sym, err_fields, 1));
                    }
                }

                let info = typeck::EnumInfo::new(result_def, name_sym, 2, variant_names, variants);
                while checker.enums.len() <= def_idx {
                    checker.enums.push(Option::None);
                }
                checker.enums[def_idx] = Some(info);
            }
        }
        Option::None => {}
    }
}

/// Registers primitive str methods: len, is_empty, as_bytes, contains,
/// starts_with, ends_with.
fn register_str_methods(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    let self_ty = type_intern::CommonTypes::str_ty();
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "str_len", Vec::new(), type_intern::CommonTypes::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "str_is_empty", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // as_bytes(&self) -> &[u8]
    let ty_interner = type_intern::type_interner();
    let u8_slice = ty_interner.intern(type_intern::InternedTypeKind::Slice { element: type_intern::CommonTypes::u8_ty() });
    add_method(checker, &mut methods, "as_bytes", "str_as_bytes", Vec::new(), make_ref_ty(u8_slice), false, interner);

    // contains(&self, &str) -> bool
    let mut contains_params: Vec<type_intern::TyId> = Vec::new();
    contains_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "contains", "str_contains", contains_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // starts_with(&self, &str) -> bool
    let mut sw_params: Vec<type_intern::TyId> = Vec::new();
    sw_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "starts_with", "str_starts_with", sw_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // ends_with(&self, &str) -> bool
    let mut ew_params: Vec<type_intern::TyId> = Vec::new();
    ew_params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
    add_method(checker, &mut methods, "ends_with", "str_ends_with", ew_params, type_intern::CommonTypes::bool_ty(), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 0, methods);
    checker.register_impl(impl_info);
}

/// Registers slice [T] methods: len, is_empty.
fn register_slice_methods(checker: &mut typeck::TypeChecker, interner: &interner::StringInterner) {
    let ty_interner = type_intern::type_interner();
    let self_ty = ty_interner.intern(type_intern::InternedTypeKind::Slice { element: make_param(0) });
    let mut methods: Vec<typeck::MethodInfo> = Vec::new();

    // len(&self) -> usize
    add_method(checker, &mut methods, "len", "slice_len", Vec::new(), type_intern::CommonTypes::usize_ty(), false, interner);

    // is_empty(&self) -> bool
    add_method(checker, &mut methods, "is_empty", "slice_is_empty", Vec::new(), type_intern::CommonTypes::bool_ty(), false, interner);

    // Register the impl
    let impl_def = checker.alloc_def_id();
    let impl_info = typeck::ImplInfo::new(impl_def, self_ty, 1, methods);
    checker.register_impl(impl_info);
}

/// Registers function signatures for builtin constructors (String::new, Vec::new, etc.).
/// This enables type inference to work correctly for calls like `let s = String::new()`.
fn register_builtin_constructor_signatures(
    checker: &mut typeck::TypeChecker,
    builtin_fn_defs: &Vec<hir_lower_ctx::BuiltinFnDef>,
) {
    let mut i: usize = 0;
    while i < builtin_fn_defs.len() {
        let entry = &builtin_fn_defs[i];
        let def_id = hir_def::DefId::new(entry.def_id_index);
        let name = &entry.runtime_name;

        // Match on runtime name to determine signature
        if string_eq(name, "string_new") {
            // String::new() -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "string_from") {
            // String::from(&str) -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let mut params: Vec<type_intern::TyId> = Vec::new();
                    params.push(make_ref_ty(type_intern::CommonTypes::str_ty()));
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "string_with_capacity") {
            // String::with_capacity(usize) -> String
            match checker.builtin_string_def {
                Option::Some(string_def) => {
                    let mut params: Vec<type_intern::TyId> = Vec::new();
                    params.push(type_intern::CommonTypes::usize_ty());
                    let ret_ty = make_adt(string_def, Vec::new());
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 0);
                }
                Option::None => {}
            }
        } else if string_eq(name, "vec_new") {
            // Vec::new() -> Vec<T> (generic, 1 type param)
            match checker.builtin_vec_def {
                Option::Some(vec_def) => {
                    let mut type_args: Vec<type_intern::TyId> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(vec_def, type_args);
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "vec_with_capacity") {
            // Vec::with_capacity(usize) -> Vec<T> (generic, 1 type param)
            match checker.builtin_vec_def {
                Option::Some(vec_def) => {
                    let mut params: Vec<type_intern::TyId> = Vec::new();
                    params.push(type_intern::CommonTypes::usize_ty());
                    let mut type_args: Vec<type_intern::TyId> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(vec_def, type_args);
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "box_new") {
            // Box::new(T) -> Box<T> (generic, 1 type param)
            match checker.builtin_box_def {
                Option::Some(box_def) => {
                    let mut params: Vec<type_intern::TyId> = Vec::new();
                    params.push(make_param(0));
                    let mut type_args: Vec<type_intern::TyId> = Vec::new();
                    type_args.push(make_param(0));
                    let ret_ty = make_adt(box_def, type_args);
                    checker.register_fn_sig_direct(def_id, params, ret_ty, 1);
                }
                Option::None => {}
            }
        } else if string_eq(name, "hashmap_new") {
            // HashMap::new() -> HashMap<K, V> (generic, 2 type params)
            match checker.builtin_hashmap_def {
                Option::Some(hashmap_def) => {
                    let mut type_args: Vec<type_intern::TyId> = Vec::new();
                    type_args.push(make_param(0));
                    type_args.push(make_param(1));
                    let ret_ty = make_adt(hashmap_def, type_args);
                    checker.register_fn_sig_direct(def_id, Vec::new(), ret_ty, 2);
                }
                Option::None => {}
            }
        }
        // Note: option_some_ctor, option_none_ctor, result_ok_ctor, result_err_ctor
        // are handled as enum variants, not function signatures

        i = i + 1;
    }
}

/// Compares two strings for equality.
fn string_eq(a: &String, b: &str) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let bytes_a = a.as_bytes();
    let bytes_b = b.as_bytes();
    let mut i: usize = 0;
    while i < a.len() {
        if bytes_a[i] != bytes_b[i] {
            return false;
        }
        i = i + 1;
    }
    true
}
