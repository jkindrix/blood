//! # Diagnostic Suggestions (Fix-Its)
//!
//! Suggestions provide actionable code changes to fix diagnostics.
//!
//! ## Design Principles (from Clang/rustc)
//!
//! - Suggestions must be **obvious, singular, and highly likely correct**
//! - Suggestions on warnings **must not change code meaning**
//! - Include **applicability levels** for tool integration
//!
//! ## Applicability Levels
//!
//! ```text
//! MachineApplicable → Safe for automated tools to apply
//! HasPlaceholders   → Contains <placeholders> requiring user input
//! MaybeIncorrect    → Might not be the right fix
//! Unspecified       → Unknown applicability
//! ```

module std.compiler.diagnostics.suggestion;

use std.compiler.diagnostics.span.Span;
use std.collections.Vec;
use std.option.Option;

// ============================================================================
// Applicability
// ============================================================================

/// How confident we are in a suggestion's correctness.
///
/// This guides tools in deciding whether to auto-apply suggestions.
pub enum Applicability {
    /// Safe for automated tools to apply without human review.
    ///
    /// Use this when:
    /// - The fix is unambiguous
    /// - Applying it cannot make things worse
    /// - The resulting code will definitely compile
    ///
    /// Examples:
    /// - Adding a missing semicolon
    /// - Removing unused imports
    /// - Fixing obvious typos in keywords
    MachineApplicable,

    /// Contains placeholders requiring user input.
    ///
    /// The suggestion uses `<placeholder>` syntax where the user
    /// must fill in specific values.
    ///
    /// Examples:
    /// - `let x: <type> = ...`
    /// - `impl <Trait> for ...`
    HasPlaceholders,

    /// Might not be the correct fix.
    ///
    /// Use this when:
    /// - The fix addresses the error but might not be what the user wants
    /// - There are multiple valid fixes
    /// - The fix might change code behavior
    ///
    /// Examples:
    /// - Suggesting `.unwrap()` for an Option
    /// - Adding a type annotation that might not be the intended type
    MaybeIncorrect,

    /// Applicability is unknown.
    ///
    /// Conservative default. Tools should prompt for confirmation.
    Unspecified,
}

impl Applicability {
    /// Check if this suggestion is safe for automated application.
    pub fn is_machine_applicable(self) -> Bool {
        match self {
            Applicability::MachineApplicable => true,
            Applicability::HasPlaceholders => false,
            Applicability::MaybeIncorrect => false,
            Applicability::Unspecified => false,
        }
    }

    /// Check if this suggestion has placeholders.
    pub fn has_placeholders(self) -> Bool {
        match self {
            Applicability::HasPlaceholders => true,
            Applicability::MachineApplicable => false,
            Applicability::MaybeIncorrect => false,
            Applicability::Unspecified => false,
        }
    }

    /// Check if this suggestion might be incorrect.
    pub fn might_be_incorrect(self) -> Bool {
        match self {
            Applicability::MaybeIncorrect => true,
            Applicability::Unspecified => true,  // Unknown = might be incorrect
            Applicability::MachineApplicable => false,
            Applicability::HasPlaceholders => false,
        }
    }

    /// Get a description of this applicability level.
    pub fn description(self) -> String {
        match self {
            Applicability::MachineApplicable => "safe to apply automatically",
            Applicability::HasPlaceholders => "contains placeholders",
            Applicability::MaybeIncorrect => "might not be correct",
            Applicability::Unspecified => "applicability unknown",
        }
    }
}

// ============================================================================
// Substitution
// ============================================================================

/// A code change to apply.
///
/// Substitutions represent the actual text edits that a suggestion makes.
pub enum Substitution {
    /// Insert text at a position.
    ///
    /// The text is inserted before the given offset.
    Insert {
        /// Byte offset where to insert.
        position: USize,
        /// Text to insert.
        text: String,
    },

    /// Remove a span of text.
    Remove {
        /// The span to remove.
        span: Span,
    },

    /// Replace a span with new text.
    Replace {
        /// The span to replace.
        span: Span,
        /// The replacement text.
        replacement: String,
    },
}

impl Substitution {
    /// Create an insertion.
    pub fn insert(position: USize, text: String) -> Substitution {
        Substitution::Insert { position, text }
    }

    /// Create an insertion at a span's start.
    pub fn insert_before(span: Span, text: String) -> Substitution {
        Substitution::Insert {
            position: span.start_offset(),
            text,
        }
    }

    /// Create an insertion at a span's end.
    pub fn insert_after(span: Span, text: String) -> Substitution {
        Substitution::Insert {
            position: span.end_offset(),
            text,
        }
    }

    /// Create a removal.
    pub fn remove(span: Span) -> Substitution {
        Substitution::Remove { span }
    }

    /// Create a replacement.
    pub fn replace(span: Span, replacement: String) -> Substitution {
        Substitution::Replace { span, replacement }
    }

    /// Check if this is an insertion.
    pub fn is_insert(self) -> Bool {
        match self {
            Substitution::Insert { .. } => true,
            Substitution::Remove { .. } => false,
            Substitution::Replace { .. } => false,
        }
    }

    /// Check if this is a removal.
    pub fn is_remove(self) -> Bool {
        match self {
            Substitution::Remove { .. } => true,
            Substitution::Insert { .. } => false,
            Substitution::Replace { .. } => false,
        }
    }

    /// Check if this is a replacement.
    pub fn is_replace(self) -> Bool {
        match self {
            Substitution::Replace { .. } => true,
            Substitution::Insert { .. } => false,
            Substitution::Remove { .. } => false,
        }
    }

    /// Get the affected span (or a point span for insertions).
    pub fn span(self) -> Span {
        match self {
            Substitution::Insert { position, .. } => {
                // Return a point span at the insertion position
                Span::from_offsets(
                    std.compiler.diagnostics.span.FileId::dummy(),
                    position,
                    position,
                )
            }
            Substitution::Remove { span } => span,
            Substitution::Replace { span, .. } => span,
        }
    }

    /// Get the new text (empty for removals).
    pub fn new_text(self) -> String {
        match self {
            Substitution::Insert { text, .. } => text,
            Substitution::Remove { .. } => "",
            Substitution::Replace { replacement, .. } => replacement,
        }
    }

    /// Apply this substitution to source text.
    ///
    /// Returns the modified source text.
    pub fn apply(self, source: String) -> String {
        match self {
            Substitution::Insert { position, text } => {
                let before = source.substring(0, position)
                let after = source.substring(position, source.len())
                before ++ text ++ after
            }
            Substitution::Remove { span } => {
                let before = source.substring(0, span.start_offset())
                let after = source.substring(span.end_offset(), source.len())
                before ++ after
            }
            Substitution::Replace { span, replacement } => {
                let before = source.substring(0, span.start_offset())
                let after = source.substring(span.end_offset(), source.len())
                before ++ replacement ++ after
            }
        }
    }
}

// ============================================================================
// Suggestion
// ============================================================================

/// A suggested fix for a diagnostic.
///
/// ## Example
///
/// ```text
/// error[E0308]: type mismatch
///   --> src/main.blood:10:12
///    |
/// 10 |     let x: Int = "hello"
///    |                  ^^^^^^^ expected `Int`, found `String`
///    |
/// help: consider using `parse` to convert the string
///    |
/// 10 |     let x: Int = "hello".parse()
///    |                         ++++++++
/// ```
pub struct Suggestion {
    /// Human-readable description of what this suggestion does.
    message: String,

    /// The code changes to apply.
    substitutions: Vec<Substitution>,

    /// How confident we are in this suggestion.
    applicability: Applicability,

    /// Whether this is the primary suggestion (shown inline) or alternative.
    primary: Bool,
}

impl Suggestion {
    /// Create a new suggestion with a single substitution.
    pub fn new(message: String, substitution: Substitution, applicability: Applicability) -> Suggestion {
        let mut substitutions = Vec::new()
        substitutions.push(substitution)

        Suggestion {
            message,
            substitutions,
            applicability,
            primary: true,
        }
    }

    /// Create a suggestion with multiple substitutions.
    pub fn with_substitutions(message: String, substitutions: Vec<Substitution>, applicability: Applicability) -> Suggestion {
        Suggestion {
            message,
            substitutions,
            applicability,
            primary: true,
        }
    }

    // === Convenience Constructors ===

    /// Create an insertion suggestion.
    pub fn insert(message: String, position: USize, text: String, applicability: Applicability) -> Suggestion {
        Suggestion::new(message, Substitution::insert(position, text), applicability)
    }

    /// Create an insertion-after suggestion.
    pub fn insert_after(message: String, span: Span, text: String, applicability: Applicability) -> Suggestion {
        Suggestion::new(message, Substitution::insert_after(span, text), applicability)
    }

    /// Create an insertion-before suggestion.
    pub fn insert_before(message: String, span: Span, text: String, applicability: Applicability) -> Suggestion {
        Suggestion::new(message, Substitution::insert_before(span, text), applicability)
    }

    /// Create a removal suggestion.
    pub fn remove(message: String, span: Span, applicability: Applicability) -> Suggestion {
        Suggestion::new(message, Substitution::remove(span), applicability)
    }

    /// Create a replacement suggestion.
    pub fn replace(message: String, span: Span, replacement: String, applicability: Applicability) -> Suggestion {
        Suggestion::new(message, Substitution::replace(span, replacement), applicability)
    }

    // === Builder Methods ===

    /// Mark this as an alternative (not primary) suggestion.
    pub fn as_alternative(mut self) -> Suggestion {
        self.primary = false
        self
    }

    /// Add another substitution to this suggestion.
    pub fn and_substitute(mut self, substitution: Substitution) -> Suggestion {
        self.substitutions.push(substitution)
        self
    }

    // === Accessors ===

    /// Get the suggestion message.
    pub fn message(self) -> String {
        self.message.clone()
    }

    /// Get the substitutions.
    pub fn substitutions(self) -> Vec<Substitution> {
        self.substitutions.clone()
    }

    /// Get the applicability level.
    pub fn applicability(self) -> Applicability {
        self.applicability
    }

    /// Check if this is the primary suggestion.
    pub fn is_primary(self) -> Bool {
        self.primary
    }

    /// Check if this suggestion is machine-applicable.
    pub fn is_machine_applicable(self) -> Bool {
        self.applicability.is_machine_applicable()
    }

    /// Check if this suggestion has placeholders.
    pub fn has_placeholders(self) -> Bool {
        self.applicability.has_placeholders()
    }

    // === Application ===

    /// Apply all substitutions to source text.
    ///
    /// Note: Substitutions are applied in reverse order by position
    /// to avoid offset invalidation.
    pub fn apply(self, source: String) -> String {
        // Sort substitutions by position (descending) to apply from end to start
        let mut sorted = self.substitutions.clone()
        sorted.sort_by(|a, b| {
            let a_pos = match a {
                Substitution::Insert { position, .. } => *position,
                Substitution::Remove { span } => span.start_offset(),
                Substitution::Replace { span, .. } => span.start_offset(),
            }
            let b_pos = match b {
                Substitution::Insert { position, .. } => *position,
                Substitution::Remove { span } => span.start_offset(),
                Substitution::Replace { span, .. } => span.start_offset(),
            }
            // Reverse order (higher positions first)
            b_pos.cmp(a_pos)
        })

        let mut result = source
        for sub in sorted {
            result = sub.apply(result)
        }
        result
    }
}

// ============================================================================
// Help Text (Simple String Suggestions)
// ============================================================================

/// A simple text-only help message.
///
/// Unlike Suggestion, Help doesn't have code changes - just advice.
pub struct Help {
    /// The help message.
    message: String,
}

impl Help {
    /// Create a new help message.
    pub fn new(message: String) -> Help {
        Help { message }
    }

    /// Get the message.
    pub fn message(self) -> String {
        self.message.clone()
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_applicability_machine_applicable() {
    let app = Applicability::MachineApplicable

    assert(app.is_machine_applicable())
    assert(!app.has_placeholders())
    assert(!app.might_be_incorrect())
}

#[test]
fn test_applicability_has_placeholders() {
    let app = Applicability::HasPlaceholders

    assert(!app.is_machine_applicable())
    assert(app.has_placeholders())
    assert(!app.might_be_incorrect())
}

#[test]
fn test_applicability_maybe_incorrect() {
    let app = Applicability::MaybeIncorrect

    assert(!app.is_machine_applicable())
    assert(!app.has_placeholders())
    assert(app.might_be_incorrect())
}

#[test]
fn test_applicability_unspecified() {
    let app = Applicability::Unspecified

    assert(!app.is_machine_applicable())
    assert(!app.has_placeholders())
    assert(app.might_be_incorrect())  // Unknown = might be incorrect
}

#[test]
fn test_substitution_insert() {
    let sub = Substitution::insert(5, " world")
    let result = sub.apply("hello!")

    assert(result == "hello world!")
}

#[test]
fn test_substitution_remove() {
    let span = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        5,
        11,
    )
    let sub = Substitution::remove(span)
    let result = sub.apply("hello world!")

    assert(result == "hello!")
}

#[test]
fn test_substitution_replace() {
    let span = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        6,
        11,
    )
    let sub = Substitution::replace(span, "Blood")
    let result = sub.apply("hello world!")

    assert(result == "hello Blood!")
}

#[test]
fn test_substitution_is_checks() {
    let insert = Substitution::insert(0, "x")
    let remove = Substitution::remove(Span::dummy())
    let replace = Substitution::replace(Span::dummy(), "x")

    assert(insert.is_insert())
    assert(!insert.is_remove())
    assert(!insert.is_replace())

    assert(remove.is_remove())
    assert(!remove.is_insert())

    assert(replace.is_replace())
    assert(!replace.is_remove())
}

#[test]
fn test_suggestion_insert_after() {
    let span = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        0,
        5,
    )
    let suggestion = Suggestion::insert_after(
        "add `.unwrap()`",
        span,
        ".unwrap()",
        Applicability::MaybeIncorrect,
    )

    assert(suggestion.message() == "add `.unwrap()`")
    assert(suggestion.applicability() == Applicability::MaybeIncorrect)
    assert(!suggestion.is_machine_applicable())
}

#[test]
fn test_suggestion_replace() {
    let span = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        4,
        5,
    )
    let suggestion = Suggestion::replace(
        "use `==` for comparison",
        span,
        "==",
        Applicability::MachineApplicable,
    )

    assert(suggestion.is_machine_applicable())
    assert(suggestion.is_primary())
}

#[test]
fn test_suggestion_as_alternative() {
    let span = Span::dummy()
    let suggestion = Suggestion::remove("remove unused code", span, Applicability::MachineApplicable)
        .as_alternative()

    assert(!suggestion.is_primary())
}

#[test]
fn test_suggestion_apply_multiple() {
    // Source: "let x = foo"
    // Change to: "let x: Int = foo()"
    let span1 = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        5,
        5,  // After "let x"
    )
    let span2 = Span::from_offsets(
        std.compiler.diagnostics.span.FileId::dummy(),
        11,
        11,  // After "foo"
    )

    let suggestion = Suggestion::with_substitutions(
        "add type annotation and call",
        vec![
            Substitution::insert(5, ": Int"),
            Substitution::insert(14, "()"),  // Adjusted for insertion
        ],
        Applicability::HasPlaceholders,
    )

    // Note: positions need careful handling in real usage
    assert(suggestion.substitutions().len() == 2)
}

#[test]
fn test_help_message() {
    let help = Help::new("consider using `match` instead")
    assert(help.message() == "consider using `match` instead")
}
