//! # Module Resolution Diagnostic Conversion
//!
//! Converts module resolution errors into rich diagnostics.
//!
//! ## Error Code Mapping
//!
//! Resolution errors map to E0200-E0299 range:
//! - E0200: Unresolved module
//! - E0201: Unresolved import
//! - E0202: Ambiguous import
//! - E0203: Cyclic import
//! - E0204: Private import

module std.compiler.diagnostics.resolve;

use std.option.Option;
use std.collections.Vec;
use std.compiler.diagnostics.diagnostic.Diagnostic;
use std.compiler.diagnostics.severity.Severity;
use std.compiler.diagnostics.code.ErrorCode;
use std.compiler.diagnostics.span.Span as DiagSpan;
use std.compiler.diagnostics.label.Label;
use std.compiler.diagnostics.suggestion.Suggestion;
use std.compiler.diagnostics.suggestion.Applicability;
use std.compiler.diagnostics.convert.DiagnosticConverter;
use std.compiler.diagnostics.convert.IntoDiagnostic;
use std.compiler.diagnostics.convert.SimpleSpan;

// ============================================================================
// Resolve Error Adapter
// ============================================================================

/// Adapter for module resolution errors.
///
/// Mirrors ResolveError from `module/resolve.blood`.
pub enum ResolveErrorAdapter {
    /// Module file not found.
    ModuleNotFound {
        name: String,
        searched: Vec<String>,
    },

    /// Invalid module path.
    InvalidPath {
        message: String,
    },

    /// I/O error.
    IoError {
        message: String,
    },
}

impl ResolveErrorAdapter {
    /// Create a module not found error.
    pub fn module_not_found(name: String, searched: Vec<String>) -> ResolveErrorAdapter {
        ResolveErrorAdapter::ModuleNotFound { name, searched }
    }

    /// Create an invalid path error.
    pub fn invalid_path(message: String) -> ResolveErrorAdapter {
        ResolveErrorAdapter::InvalidPath { message }
    }

    /// Create an I/O error.
    pub fn io_error(message: String) -> ResolveErrorAdapter {
        ResolveErrorAdapter::IoError { message }
    }

    /// Get the error code.
    pub fn error_code(self) -> ErrorCode {
        match self {
            ResolveErrorAdapter::ModuleNotFound { .. } => ErrorCode::UnresolvedModule,
            ResolveErrorAdapter::InvalidPath { .. } => ErrorCode::UnresolvedModule,
            ResolveErrorAdapter::IoError { .. } => ErrorCode::UnresolvedModule,
        }
    }

    /// Get the error message.
    pub fn message(self) -> String {
        match self {
            ResolveErrorAdapter::ModuleNotFound { name, searched } => {
                "cannot find module `" ++ name ++ "`"
            }
            ResolveErrorAdapter::InvalidPath { message } => {
                "invalid module path: " ++ message
            }
            ResolveErrorAdapter::IoError { message } => {
                "I/O error while resolving module: " ++ message
            }
        }
    }
}

// ============================================================================
// Spanned Resolve Error
// ============================================================================

/// A resolve error with source location.
pub struct SpannedResolveError {
    /// The error.
    error: ResolveErrorAdapter,

    /// Source location where the error occurred.
    span: SimpleSpan,
}

impl SpannedResolveError {
    /// Create a new spanned resolve error.
    pub fn new(error: ResolveErrorAdapter, span: SimpleSpan) -> SpannedResolveError {
        SpannedResolveError { error, span }
    }

    /// Get the error.
    pub fn error(self) -> ResolveErrorAdapter {
        self.error.clone()
    }

    /// Get the span.
    pub fn span(self) -> SimpleSpan {
        self.span
    }
}

// ============================================================================
// IntoDiagnostic Implementation
// ============================================================================

impl IntoDiagnostic for SpannedResolveError {
    fn into_diagnostic(self, ctx: DiagnosticConverter) -> Diagnostic {
        let diag_span = ctx.convert_span(self.span)
        let error = self.error.clone()
        let message = error.message()
        let code = error.error_code()

        let mut diagnostic = Diagnostic::error(message)
            .with_span(diag_span.clone())
            .with_code(code)

        match error {
            ResolveErrorAdapter::ModuleNotFound { name, searched } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "not found"))

                // Add help showing searched paths
                if !searched.is_empty() {
                    let mut help_msg = "searched locations:"
                    for path in searched {
                        help_msg = help_msg ++ "\n  - " ++ path
                    }
                    diagnostic = diagnostic.with_help_message(help_msg)
                }

                // Suggest creating the module file
                diagnostic = diagnostic.with_help_message(
                    "create the file `" ++ name.clone() ++ ".blood` or `" ++ name.clone() ++ "/mod.blood`"
                )
            }

            ResolveErrorAdapter::InvalidPath { message } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "invalid path"))
            }

            ResolveErrorAdapter::IoError { message } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "I/O error"))
                    .with_help_message("check file permissions and disk availability")
            }
        }

        diagnostic
    }
}

// ============================================================================
// Import Error Adapter
// ============================================================================

/// Adapter for import-related errors.
pub enum ImportErrorAdapter {
    /// Unresolved import.
    UnresolvedImport {
        path: String,
    },

    /// Ambiguous import (multiple candidates).
    AmbiguousImport {
        name: String,
        candidates: Vec<String>,
    },

    /// Cyclic import detected.
    CyclicImport {
        cycle: Vec<String>,
    },

    /// Importing private item.
    PrivateImport {
        item: String,
        module: String,
    },

    /// Glob import without star.
    InvalidGlobImport {
        path: String,
    },
}

impl ImportErrorAdapter {
    /// Get the error code.
    pub fn error_code(self) -> ErrorCode {
        match self {
            ImportErrorAdapter::UnresolvedImport { .. } => ErrorCode::UnresolvedImport,
            ImportErrorAdapter::AmbiguousImport { .. } => ErrorCode::AmbiguousImport,
            ImportErrorAdapter::CyclicImport { .. } => ErrorCode::CyclicImport,
            ImportErrorAdapter::PrivateImport { .. } => ErrorCode::PrivateInPublicInterface,
            ImportErrorAdapter::InvalidGlobImport { .. } => ErrorCode::UnresolvedImport,
        }
    }

    /// Get the error message.
    pub fn message(self) -> String {
        match self {
            ImportErrorAdapter::UnresolvedImport { path } => {
                "unresolved import `" ++ path ++ "`"
            }
            ImportErrorAdapter::AmbiguousImport { name, candidates } => {
                "ambiguous import: `" ++ name ++ "` could refer to multiple items"
            }
            ImportErrorAdapter::CyclicImport { cycle } => {
                "cyclic import detected: " ++ cycle.join(" -> ")
            }
            ImportErrorAdapter::PrivateImport { item, module } => {
                "cannot import private item `" ++ item ++ "` from module `" ++ module ++ "`"
            }
            ImportErrorAdapter::InvalidGlobImport { path } => {
                "invalid glob import: `" ++ path ++ "`"
            }
        }
    }
}

/// Spanned import error.
pub struct SpannedImportError {
    error: ImportErrorAdapter,
    span: SimpleSpan,
}

impl SpannedImportError {
    pub fn new(error: ImportErrorAdapter, span: SimpleSpan) -> SpannedImportError {
        SpannedImportError { error, span }
    }
}

impl IntoDiagnostic for SpannedImportError {
    fn into_diagnostic(self, ctx: DiagnosticConverter) -> Diagnostic {
        let diag_span = ctx.convert_span(self.span)
        let error = self.error.clone()
        let message = error.message()
        let code = error.error_code()

        let mut diagnostic = Diagnostic::error(message)
            .with_span(diag_span.clone())
            .with_code(code)

        match error {
            ImportErrorAdapter::UnresolvedImport { path } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "not found"))
                    .with_help_message("check the module path or add the missing dependency")
            }

            ImportErrorAdapter::AmbiguousImport { name, candidates } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "ambiguous"))

                let mut help_msg = "possible candidates:"
                for candidate in candidates {
                    help_msg = help_msg ++ "\n  - " ++ candidate
                }
                diagnostic = diagnostic.with_help_message(help_msg)
            }

            ImportErrorAdapter::CyclicImport { cycle } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "cyclic import"))
                    .with_help_message("break the cycle by restructuring module dependencies")
            }

            ImportErrorAdapter::PrivateImport { item, module } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "private item"))
                    .with_help_message("make the item public with `pub` or access it through a public API")
            }

            ImportErrorAdapter::InvalidGlobImport { path } => {
                diagnostic = diagnostic
                    .with_label(Label::primary(diag_span.clone(), "invalid glob"))
                    .with_help_message("glob imports should end with `.*` or specify explicit items")
            }
        }

        diagnostic
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_module_not_found_diagnostic() {
    let error = SpannedResolveError::new(
        ResolveErrorAdapter::module_not_found(
            "utils",
            vec!["src/utils.blood", "src/utils/mod.blood"],
        ),
        SimpleSpan::new(5, 10),
    )

    let ctx = DiagnosticConverter::empty()
    let diagnostic = error.into_diagnostic(ctx)

    assert(diagnostic.severity() == Severity::Error)
    assert(diagnostic.message().contains("utils"))
}

#[test]
fn test_invalid_path_diagnostic() {
    let error = SpannedResolveError::new(
        ResolveErrorAdapter::invalid_path("path contains invalid characters"),
        SimpleSpan::new(0, 20),
    )

    let ctx = DiagnosticConverter::empty()
    let diagnostic = error.into_diagnostic(ctx)

    assert(diagnostic.message().contains("invalid"))
}

#[test]
fn test_io_error_diagnostic() {
    let error = SpannedResolveError::new(
        ResolveErrorAdapter::io_error("permission denied"),
        SimpleSpan::new(0, 10),
    )

    let ctx = DiagnosticConverter::empty()
    let diagnostic = error.into_diagnostic(ctx)

    assert(diagnostic.message().contains("I/O error"))
}

#[test]
fn test_cyclic_import_diagnostic() {
    let error = SpannedImportError::new(
        ImportErrorAdapter::CyclicImport {
            cycle: vec!["a", "b", "c", "a"],
        },
        SimpleSpan::new(0, 5),
    )

    let ctx = DiagnosticConverter::empty()
    let diagnostic = error.into_diagnostic(ctx)

    assert(diagnostic.message().contains("cyclic"))
}

#[test]
fn test_ambiguous_import_diagnostic() {
    let error = SpannedImportError::new(
        ImportErrorAdapter::AmbiguousImport {
            name: "Error",
            candidates: vec!["std.io.Error", "std.result.Error"],
        },
        SimpleSpan::new(10, 15),
    )

    let ctx = DiagnosticConverter::empty()
    let diagnostic = error.into_diagnostic(ctx)

    assert(diagnostic.message().contains("ambiguous"))
}
