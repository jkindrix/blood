//! # Diagnostic Labels
//!
//! Labels annotate source code spans within a diagnostic.
//!
//! ## Label Types
//!
//! - **Primary**: The main span causing the error (highlighted prominently)
//! - **Secondary**: Supporting context (less prominent)
//!
//! ## Design Guidelines
//!
//! - Primary labels should be **self-explanatory** without the main message
//! - Labels should point to the **smallest relevant span**
//! - Use secondary labels to show related code (type definitions, etc.)

module std.compiler.diagnostics.label;

use std.compiler.diagnostics.span.Span;
use std.compiler.diagnostics.severity.AnsiColor;
use std.collections.Vec;
use std.core.Option;

// ============================================================================
// Label Kind
// ============================================================================

/// The kind of label (primary or secondary).
pub enum LabelKind {
    /// Primary label - the main span causing the diagnostic.
    ///
    /// Primary labels are:
    /// - Highlighted in the severity color (red for errors, etc.)
    /// - Shown with prominent underlines (^^^)
    /// - Should be self-explanatory for IDE display
    Primary,

    /// Secondary label - supporting context.
    ///
    /// Secondary labels are:
    /// - Highlighted in a neutral color (blue)
    /// - Shown with less prominent underlines (---)
    /// - Used to point to related code
    Secondary,
}

impl LabelKind {
    /// Check if this is a primary label.
    pub fn is_primary(self) -> bool {
        match self {
            LabelKind::Primary => true,
            LabelKind::Secondary => false,
        }
    }

    /// Check if this is a secondary label.
    pub fn is_secondary(self) -> bool {
        match self {
            LabelKind::Primary => false,
            LabelKind::Secondary => true,
        }
    }

    /// Get the underline character for this label kind.
    pub fn underline_char(self) -> char {
        match self {
            LabelKind::Primary => '^',
            LabelKind::Secondary => '-',
        }
    }

    /// Get the default color for this label kind.
    pub fn default_color(self) -> AnsiColor {
        match self {
            LabelKind::Primary => AnsiColor::Red,  // Overridden by severity
            LabelKind::Secondary => AnsiColor::Blue,
        }
    }
}

// ============================================================================
// Label
// ============================================================================

/// A label that annotates a source span within a diagnostic.
///
/// ## Example Output
///
/// ```text
/// error[E0308]: type mismatch
///   --> src/main.blood:10:12
///    |
/// 10 |     let x: Int = "hello"
///    |            ---   ^^^^^^^ expected `Int`, found `String`
///    |            |
///    |            expected due to this
/// ```
///
/// In this example:
/// - "expected `Int`, found `String`" is the primary label
/// - "expected due to this" is a secondary label
pub struct Label {
    /// The source span this label annotates.
    span: Span,

    /// The message to display at this location.
    /// If None, the label is shown without text (just underline).
    message: Option<String>,

    /// The kind of label (primary or secondary).
    kind: LabelKind,

    /// Priority for ordering when labels overlap.
    /// Lower values = higher priority (shown first).
    priority: u32,

    /// Optional override color.
    color: Option<AnsiColor>,
}

impl Label {
    /// Create a new primary label.
    ///
    /// Primary labels highlight the main span causing the diagnostic.
    /// They should be self-explanatory for IDE display.
    pub fn primary(span: Span, message: String) -> Label {
        Label {
            span,
            message: Option::Some(message),
            kind: LabelKind::Primary,
            priority: 0,
            color: Option::None,
        }
    }

    /// Create a new secondary label.
    ///
    /// Secondary labels provide supporting context.
    pub fn secondary(span: Span, message: String) -> Label {
        Label {
            span,
            message: Option::Some(message),
            kind: LabelKind::Secondary,
            priority: 100,
            color: Option::None,
        }
    }

    /// Create a primary label without a message.
    ///
    /// The span will be underlined but no text will be shown.
    pub fn primary_span(span: Span) -> Label {
        Label {
            span,
            message: Option::None,
            kind: LabelKind::Primary,
            priority: 0,
            color: Option::None,
        }
    }

    /// Create a secondary label without a message.
    pub fn secondary_span(span: Span) -> Label {
        Label {
            span,
            message: Option::None,
            kind: LabelKind::Secondary,
            priority: 100,
            color: Option::None,
        }
    }

    // === Builder Methods ===

    /// Set the priority (lower = shown first when overlapping).
    pub fn with_priority(mut self, priority: u32) -> Label {
        self.priority = priority;
        self
    }

    /// Set a custom color for this label.
    pub fn with_color(mut self, color: AnsiColor) -> Label {
        self.color = Option::Some(color);
        self
    }

    /// Set the message.
    pub fn with_message(mut self, message: String) -> Label {
        self.message = Option::Some(message);
        self
    }

    /// Clear the message (show just the underline).
    pub fn without_message(mut self) -> Label {
        self.message = Option::None;
        self
    }

    // === Accessors ===

    /// Get the span.
    pub fn span(self) -> Span {
        self.span
    }

    /// Get the message.
    pub fn message(self) -> Option<String> {
        self.message.clone();
    }

    /// Get the label kind.
    pub fn kind(self) -> LabelKind {
        self.kind
    }

    /// Get the priority.
    pub fn priority(self) -> u32 {
        self.priority
    }

    /// Check if this is a primary label.
    pub fn is_primary(self) -> bool {
        self.kind.is_primary();
    }

    /// Check if this is a secondary label.
    pub fn is_secondary(self) -> bool {
        self.kind.is_secondary();
    }

    /// Check if this label has a message.
    pub fn has_message(self) -> bool {
        self.message.is_some();
    }

    /// Get the color for this label (custom or default).
    pub fn effective_color(self) -> AnsiColor {
        match self.color {
            Option::Some(c) => c,
            Option::None => self.kind.default_color(),
        }
    }

    /// Get the underline character for this label.
    pub fn underline_char(self) -> char {
        self.kind.underline_char();
    }

    // === Span Properties ===

    /// Get the start line of this label's span.
    pub fn start_line(self) -> u32 {
        self.span.start_line();
    }

    /// Get the end line of this label's span.
    pub fn end_line(self) -> u32 {
        self.span.end_line();
    }

    /// Check if this label spans multiple lines.
    pub fn is_multiline(self) -> bool {
        self.span.is_multiline();
    }
}

// ============================================================================
// Label Collection
// ============================================================================

/// A collection of labels with ordering and grouping utilities.
pub struct LabelCollection {
    /// The labels.
    labels: Vec<Label>,
}

impl LabelCollection {
    /// Create a new empty collection.
    pub fn new() -> LabelCollection {
        LabelCollection {
            labels: Vec::new(),
        }
    }

    /// Create a collection from a vector of labels.
    pub fn from_vec(labels: Vec<Label>) -> LabelCollection {
        LabelCollection { labels }
    }

    /// Add a label to the collection.
    pub fn add(mut self, label: Label) -> Unit {
        self.labels.push(label);
    }

    /// Get the number of labels.
    pub fn len(self) -> usize {
        self.labels.len();
    }

    /// Check if the collection is empty.
    pub fn is_empty(self) -> bool {
        self.labels.is_empty();
    }

    /// Get all labels.
    pub fn labels(self) -> Vec<Label> {
        self.labels.clone();
    }

    /// Get primary labels only.
    pub fn primary_labels(self) -> Vec<Label> {
        let mut result = Vec::new();
        for label in self.labels.clone() {
            if label.is_primary() {
                result.push(label);
            }
        }
        result
    }

    /// Get secondary labels only.
    pub fn secondary_labels(self) -> Vec<Label> {
        let mut result = Vec::new();
        for label in self.labels.clone() {
            if label.is_secondary() {
                result.push(label);
            }
        }
        result
    }

    /// Sort labels by priority (lower first), then by span start.
    pub fn sorted(mut self) -> LabelCollection {
        self.labels.sort_by(|a, b| {
            if a.priority != b.priority {
                a.priority.cmp(b.priority);
            } else {
                a.span.start_offset().cmp(b.span.start_offset());
            }
        });
        self
    }

    /// Get labels that overlap with a given line.
    pub fn labels_on_line(self, line: u32) -> Vec<Label> {
        let mut result = Vec::new();
        for label in self.labels.clone() {
            if label.start_line() <= line && label.end_line() >= line {
                result.push(label);
            }
        }
        result
    }

    /// Get the range of lines covered by all labels.
    ///
    /// Returns (min_line, max_line) or None if empty.
    pub fn line_range(self) -> Option[(u32, u32)] {
        if self.labels.is_empty() {
            return Option::None;
        };

        let mut min_line = u32::MAX;
        let mut max_line: u32 = 0;

        for label in self.labels.clone() {
            let start = label.start_line();
            let end = label.end_line();

            if start < min_line {
                min_line = start;
            };
            if end > max_line {
                max_line = end;
            }
        }

        Option::Some((min_line, max_line))
    }

    /// Check if any label is multiline.
    pub fn has_multiline(self) -> bool {
        for label in self.labels.clone() {
            if label.is_multiline() {
                return true;
            }
        }
        false
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_label_kind_properties() {
    assert(LabelKind::Primary.is_primary());
    assert(!LabelKind::Primary.is_secondary());
    assert(!LabelKind::Secondary.is_primary());
    assert(LabelKind::Secondary.is_secondary());
}

#[test]
fn test_label_kind_underline() {
    assert(LabelKind::Primary.underline_char() == '^');
    assert(LabelKind::Secondary.underline_char() == '-');
}

#[test]
fn test_label_primary() {
    let span = Span::dummy();
    let label = Label::primary(span, "expected `Int`");

    assert(label.is_primary());
    assert(!label.is_secondary());
    assert(label.has_message());
    assert(label.message().unwrap() == "expected `Int`");
    assert(label.priority() == 0);
}

#[test]
fn test_label_secondary() {
    let span = Span::dummy();
    let label = Label::secondary(span, "defined here");

    assert(!label.is_primary());
    assert(label.is_secondary());
    assert(label.has_message());
    assert(label.priority() == 100);
}

#[test]
fn test_label_without_message() {
    let span = Span::dummy();
    let label = Label::primary_span(span);

    assert(label.is_primary());
    assert(!label.has_message());
}

#[test]
fn test_label_builder() {
    let span = Span::dummy();
    let label = Label::secondary(span, "note")
        .with_priority(50)
        .with_color(AnsiColor::Green);

    assert(label.priority() == 50);
    assert(label.effective_color().code() == AnsiColor::Green.code());
}

#[test]
fn test_label_collection_empty() {
    let collection = LabelCollection::new();

    assert(collection.is_empty());
    assert(collection.len() == 0);
}

#[test]
fn test_label_collection_add() {
    let mut collection = LabelCollection::new();
    collection.add(Label::primary(Span::dummy(), "error"));
    collection.add(Label::secondary(Span::dummy(), "note"));

    assert(collection.len() == 2);
    assert(!collection.is_empty());
}

#[test]
fn test_label_collection_filter() {
    let mut collection = LabelCollection::new();
    collection.add(Label::primary(Span::dummy(), "error 1"));
    collection.add(Label::secondary(Span::dummy(), "note 1"));
    collection.add(Label::primary(Span::dummy(), "error 2"));

    let primary = collection.primary_labels();
    let secondary = collection.secondary_labels();

    assert(primary.len() == 2);
    assert(secondary.len() == 1);
}
