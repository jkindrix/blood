//! # Source Span and Location Tracking
//!
//! Provides types for tracking source locations throughout the compilation pipeline.
//!
//! ## Design Principles
//!
//! - Spans should be **minimal**: the smallest region that signifies the issue
//! - Primary spans should be **self-explanatory** for IDE display
//! - Support **multi-line spans** for complex constructs
//! - O(log n) line/column lookup via precomputed line indices

module std.compiler.diagnostics.span;

use std.collections.Vec;

// ============================================================================
// File Identification
// ============================================================================

/// Unique identifier for a source file.
///
/// File IDs are assigned by the SourceMap and used to reference files
/// without storing the full path in every span.
pub struct FileId {
    /// The internal file index.
    id: U32,
}

impl FileId {
    /// Create a new file ID.
    pub fn new(id: U32) -> FileId {
        FileId { id }
    }

    /// Get the raw ID value.
    pub fn raw(self) -> U32 {
        self.id
    }

    /// A dummy file ID for synthetic code.
    pub fn dummy() -> FileId {
        FileId { id: 0 }
    }

    /// Check if this is a dummy file ID.
    pub fn is_dummy(self) -> Bool {
        self.id == 0;
    }
}

// ============================================================================
// Line Index
// ============================================================================

/// A precomputed index of line start positions for O(log n) line/column lookup.
///
/// This avoids O(nÂ²) behavior when looking up many positions in the same file.
///
/// ## Example
///
/// ```blood
/// let source = "fn main() {\n    let x = 1;\n}"
/// let index = LineIndex::new(source)
/// let (line, col) = index.line_col(12)  // Position of first char on line 2
/// assert(line == 2 && col == 1)
/// ```
pub struct LineIndex {
    /// Byte offsets where each line starts.
    /// line_starts[0] = 0 (line 1 starts at byte 0).
    line_starts: Vec<USize>,
}

impl LineIndex {
    /// Build a line index from source code.
    ///
    /// This is an O(n) operation that should be done once per file.
    pub fn new(source: String) -> LineIndex {
        let mut line_starts = Vec::new();
        line_starts.push(0);  // Line 1 starts at byte 0

        let mut offset: USize = 0;
        for ch in source.chars() {
            if ch == '\n' {
                line_starts.push(offset + 1);  // Next line starts after newline
            };
            offset = offset + ch.len_utf8();
        }

        LineIndex { line_starts }
    }

    /// Look up line and column for a byte offset.
    ///
    /// Returns 1-indexed (line, column) pair.
    /// Uses binary search for O(log n) lookup.
    pub fn line_col(self, offset: USize) -> (U32, U32) {
        // Binary search for the line containing this offset
        let line_idx = self.binary_search_line(offset);
        let line = (line_idx + 1) as U32;  // 1-indexed
        let col = (offset - self.line_starts.get(line_idx).unwrap_or(0) + 1) as U32;  // 1-indexed
        (line, col)
    }

    /// Binary search for the line index containing offset.
    fn binary_search_line(self, offset: USize) -> USize {
        let mut low: USize = 0;
        let mut high = self.line_starts.len();

        while low < high {
            let mid = low + (high - low) / 2;
            let start = self.line_starts.get(mid).unwrap_or(0);

            if start <= offset {
                // Check if this is the right line (offset < next line start);
                let next_start = self.line_starts.get(mid + 1);
                match next_start {
                    Option::Some(ns) if offset < *ns => {
                        return mid;
                    }
                    Option::Some(_) => {
                        low = mid + 1;
                    }
                    Option::None => {
                        return mid;  // Last line
                    }
                }
            } else {
                high = mid;
            }
        }

        // Fallback to first line
        0
    }

    /// Get the byte offset where a line starts.
    ///
    /// Line numbers are 1-indexed.
    pub fn line_start(self, line: U32) -> Option<USize> {
        if line == 0 {
            return Option::None;
        };
        self.line_starts.get((line - 1) as USize).map(|s| *s);
    }

    /// Get the number of lines in the source.
    pub fn line_count(self) -> USize {
        self.line_starts.len();
    }
}

// ============================================================================
// Source Position
// ============================================================================

/// A position within a source file.
///
/// Positions are byte offsets with cached line/column information.
pub struct Position {
    /// Byte offset from start of file.
    offset: USize,
    /// 1-indexed line number.
    line: U32,
    /// 1-indexed column number.
    column: U32,
}

impl Position {
    /// Create a new position.
    pub fn new(offset: USize, line: U32, column: U32) -> Position {
        Position { offset, line, column }
    }

    /// Create a position from just an offset (line/column will be 0).
    ///
    /// Use `with_line_info` to compute line/column from a LineIndex.
    pub fn from_offset(offset: USize) -> Position {
        Position {
            offset,
            line: 0,
            column: 0,
        }
    }

    /// Create a position with line info from a LineIndex.
    pub fn from_offset_with_index(offset: USize, index: LineIndex) -> Position {
        let (line, column) = index.line_col(offset);
        Position { offset, line, column }
    }

    /// Create a dummy position (for synthetic code).
    pub fn dummy() -> Position {
        Position {
            offset: 0,
            line: 0,
            column: 0,
        }
    }

    /// Get the byte offset.
    pub fn offset(self) -> USize {
        self.offset
    }

    /// Get the 1-indexed line number.
    pub fn line(self) -> U32 {
        self.line
    }

    /// Get the 1-indexed column number.
    pub fn column(self) -> U32 {
        self.column
    }

    /// Check if this is a dummy position.
    pub fn is_dummy(self) -> Bool {
        self.line == 0 && self.column == 0;
    }

    /// Format as "line:column".
    pub fn display(self) -> String {
        self.line.to_string() ++ ":" ++ self.column.to_string();
    }
}

// ============================================================================
// Source Span
// ============================================================================

/// A span representing a contiguous region in source code.
///
/// Spans are half-open intervals: [start, end) where start is inclusive
/// and end is exclusive.
///
/// ## Design Guidelines
///
/// - Spans should be **minimal**: smallest region that signifies the issue
/// - Primary spans should be **self-explanatory** for IDE display
/// - Use `merge` to combine related spans when needed
pub struct Span {
    /// File this span is in.
    file: FileId,
    /// Start position (inclusive).
    start: Position,
    /// End position (exclusive).
    end: Position,
}

impl Span {
    /// Create a new span.
    pub fn new(file: FileId, start: Position, end: Position) -> Span {
        Span { file, start, end }
    }

    /// Create a span from byte offsets (without line info).
    pub fn from_offsets(file: FileId, start: USize, end: USize) -> Span {
        Span {
            file,
            start: Position::from_offset(start),
            end: Position::from_offset(end),
        }
    }

    /// Create a span from byte offsets with a LineIndex for position info.
    pub fn from_offsets_with_index(file: FileId, start: USize, end: USize, index: LineIndex) -> Span {
        Span {
            file,
            start: Position::from_offset_with_index(start, index.clone()),
            end: Position::from_offset_with_index(end, index),
        }
    }

    /// Create a dummy span for synthesized code.
    pub fn dummy() -> Span {
        Span {
            file: FileId::dummy(),
            start: Position::dummy(),
            end: Position::dummy(),
        }
    }

    /// Create a point span (zero-width, for insertions).
    pub fn point(file: FileId, position: Position) -> Span {
        Span {
            file,
            start: position.clone(),
            end: position,
        }
    }

    // === Accessors ===

    /// Get the file ID.
    pub fn file(self) -> FileId {
        self.file
    }

    /// Get the start position.
    pub fn start(self) -> Position {
        self.start
    }

    /// Get the end position.
    pub fn end(self) -> Position {
        self.end
    }

    /// Get the start byte offset.
    pub fn start_offset(self) -> USize {
        self.start.offset
    }

    /// Get the end byte offset.
    pub fn end_offset(self) -> USize {
        self.end.offset
    }

    /// Get the start line (1-indexed).
    pub fn start_line(self) -> U32 {
        self.start.line
    }

    /// Get the start column (1-indexed).
    pub fn start_column(self) -> U32 {
        self.start.column
    }

    /// Get the end line (1-indexed).
    pub fn end_line(self) -> U32 {
        self.end.line
    }

    /// Get the end column (1-indexed).
    pub fn end_column(self) -> U32 {
        self.end.column
    }

    // === Properties ===

    /// Get the length of the span in bytes.
    pub fn len(self) -> USize {
        if self.end.offset >= self.start.offset {
            self.end.offset - self.start.offset
        } else {
            0
        }
    }

    /// Check if the span is empty (zero length).
    pub fn is_empty(self) -> Bool {
        self.start.offset == self.end.offset;
    }

    /// Check if this is a dummy span.
    pub fn is_dummy(self) -> Bool {
        self.file.is_dummy() && self.start.is_dummy() && self.end.is_dummy();
    }

    /// Check if this span covers multiple lines.
    pub fn is_multiline(self) -> Bool {
        self.start.line != self.end.line && self.start.line != 0 && self.end.line != 0
    }

    /// Check if this span contains a byte offset.
    pub fn contains_offset(self, offset: USize) -> Bool {
        offset >= self.start.offset && offset < self.end.offset
    }

    /// Check if this span contains another span.
    pub fn contains(self, other: Span) -> Bool {
        self.file.id == other.file.id &&
        self.start.offset <= other.start.offset &&
        self.end.offset >= other.end.offset
    }

    /// Check if this span overlaps with another.
    pub fn overlaps(self, other: Span) -> Bool {
        self.file.id == other.file.id &&
        self.start.offset < other.end.offset &&
        self.end.offset > other.start.offset
    }

    // === Operations ===

    /// Merge two spans into one that covers both.
    ///
    /// The spans must be in the same file. Returns a span from the
    /// earlier start to the later end.
    pub fn merge(self, other: Span) -> Span {
        // Use the earlier start
        let start = if self.start.offset <= other.start.offset {
            self.start
        } else {
            other.start
        };

        // Use the later end
        let end = if self.end.offset >= other.end.offset {
            self.end
        } else {
            other.end
        }

        Span {
            file: self.file,
            start,
            end,
        }
    }

    /// Shrink the span to just the first N bytes.
    pub fn shrink_to_start(self, len: USize) -> Span {
        let new_end_offset = (self.start.offset + len).min(self.end.offset);
        Span {
            file: self.file,
            start: self.start,
            end: Position::from_offset(new_end_offset),
        }
    }

    /// Shrink the span to just the last N bytes.
    pub fn shrink_to_end(self, len: USize) -> Span {
        let new_start_offset = if len >= self.len() {
            self.start.offset
        } else {
            self.end.offset - len
        }
        Span {
            file: self.file,
            start: Position::from_offset(new_start_offset),
            end: self.end,
        }
    }

    // === Display ===

    /// Format as "line:column" (start position only).
    pub fn display_short(self) -> String {
        self.start.display();
    }

    /// Format as "line:column-line:column" for multi-line spans.
    pub fn display_range(self) -> String {
        if self.is_multiline() {
            self.start.display() ++ "-" ++ self.end.display();
        } else {
            self.start.display();
        }
    }
}

// ============================================================================
// Spanned Wrapper
// ============================================================================

/// A value with an associated source span.
///
/// This is useful for attaching location information to AST nodes and
/// other compiler data structures.
pub struct Spanned<T> {
    /// The wrapped value.
    node: T,
    /// The source span.
    span: Span,
}

impl<T> Spanned<T> {
    /// Create a new spanned value.
    pub fn new(node: T, span: Span) -> Spanned<T> {
        Spanned { node, span }
    }

    /// Create a spanned value with a dummy span.
    pub fn dummy(node: T) -> Spanned<T> {
        Spanned {
            node,
            span: Span::dummy(),
        }
    }

    /// Get a reference to the wrapped value.
    pub fn value(self) -> T {
        self.node
    }

    /// Get the span.
    pub fn span(self) -> Span {
        self.span
    }

    /// Map the wrapped value while preserving the span.
    pub fn map<U>(self, f: fn(T) -> U) -> Spanned<U> {
        Spanned {
            node: f(self.node),
            span: self.span,
        }
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Calculate line and column from byte offset by scanning.
///
/// This is O(n) and should only be used for occasional lookups.
/// For many lookups in the same file, use LineIndex instead.
pub fn line_col_scan(source: String, offset: USize) -> (U32, U32) {
    let mut line: U32 = 1;
    let mut col: U32 = 1;
    let mut current: USize = 0;

    for ch in source.chars() {
        if current >= offset {
            break
        };
        if ch == '\n' {
            line = line + 1;
            col = 1;
        } else {
            col = col + 1;
        };
        current = current + ch.len_utf8();
    }

    (line, col)
}

/// Extract the source text covered by a span.
pub fn extract_span_text(source: String, span: Span) -> String {
    source.substring(span.start_offset(), span.end_offset());
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_line_index_creation() {
    let source = "line1\nline2\nline3"
    let index = LineIndex::new(source);

    assert(index.line_count() == 3);
    assert(index.line_start(1) == Option::Some(0));
    assert(index.line_start(2) == Option::Some(6));
    assert(index.line_start(3) == Option::Some(12));
}

#[test]
fn test_line_index_lookup() {
    let source = "fn main() {\n    let x = 1;\n}"
    let index = LineIndex::new(source);

    // First character
    let (line, col) = index.line_col(0);
    assert(line == 1 && col == 1);

    // Middle of first line
    let (line, col) = index.line_col(3);
    assert(line == 1 && col == 4);

    // First character of second line
    let (line, col) = index.line_col(12);
    assert(line == 2 && col == 1);
}

#[test]
fn test_position_display() {
    let pos = Position::new(0, 10, 5);
    assert(pos.display() == "10:5");
}

#[test]
fn test_span_len() {
    let span = Span::from_offsets(FileId::dummy(), 5, 15);
    assert(span.len() == 10);
}

#[test]
fn test_span_is_empty() {
    let empty = Span::from_offsets(FileId::dummy(), 5, 5);
    let non_empty = Span::from_offsets(FileId::dummy(), 5, 10);

    assert(empty.is_empty());
    assert(!non_empty.is_empty());
}

#[test]
fn test_span_contains_offset() {
    let span = Span::from_offsets(FileId::dummy(), 10, 20);

    assert(!span.contains_offset(5));   // Before
    assert(span.contains_offset(10));   // Start (inclusive);
    assert(span.contains_offset(15));   // Middle
    assert(!span.contains_offset(20));  // End (exclusive);
    assert(!span.contains_offset(25));  // After
}

#[test]
fn test_span_merge() {
    let file = FileId::new(1);
    let span1 = Span::from_offsets(file, 5, 10);
    let span2 = Span::from_offsets(file, 15, 20);

    let merged = span1.merge(span2);
    assert(merged.start_offset() == 5);
    assert(merged.end_offset() == 20);
}

#[test]
fn test_span_overlaps() {
    let file = FileId::new(1);
    let span1 = Span::from_offsets(file, 5, 15);
    let span2 = Span::from_offsets(file, 10, 20);
    let span3 = Span::from_offsets(file, 20, 25);

    assert(span1.overlaps(span2));   // Overlapping
    assert(span2.overlaps(span1));   // Symmetric
    assert(!span1.overlaps(span3));  // Non-overlapping
}

#[test]
fn test_span_contains() {
    let file = FileId::new(1);
    let outer = Span::from_offsets(file, 5, 25);
    let inner = Span::from_offsets(file, 10, 20);
    let partial = Span::from_offsets(file, 20, 30);

    assert(outer.contains(inner));
    assert(!inner.contains(outer));
    assert(!outer.contains(partial));
}

#[test]
fn test_spanned_map() {
    let spanned = Spanned::new(42, Span::dummy());
    let doubled = spanned.map(|x| x * 2);

    assert(doubled.value() == 84);
    assert(doubled.span().is_dummy());
}

#[test]
fn test_line_col_scan() {
    let source = "abc\ndef\nghi"

    let (line, col) = line_col_scan(source, 0);
    assert(line == 1 && col == 1);

    let (line, col) = line_col_scan(source, 4);
    assert(line == 2 && col == 1);

    let (line, col) = line_col_scan(source, 6);
    assert(line == 2 && col == 3);
}

#[test]
fn test_extract_span_text() {
    let source = "hello world"
    let span = Span::from_offsets(FileId::dummy(), 0, 5);

    let text = extract_span_text(source, span);
    assert(text == "hello");
}
