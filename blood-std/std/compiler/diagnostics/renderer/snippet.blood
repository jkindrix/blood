//! # Source Code Snippets
//!
//! Extracts and formats source code snippets for diagnostic display.
//!
//! ## Example Output
//!
//! ```text
//!    |
//! 10 |     let x: Int = "hello"
//!    |            ---   ^^^^^^^ expected `Int`, found `String`
//!    |            |
//!    |            expected due to this
//! ```

module std.compiler.diagnostics.renderer.snippet;

use std.collections.Vec;
use std.core.Option;
use std.compiler.diagnostics.span.Span;
use std.compiler.diagnostics.label.Label;
use std.compiler.diagnostics.label.LabelCollection;
use std.compiler.diagnostics.renderer.source.SourceFile;
use std.compiler.diagnostics.renderer.source.SourceMap;

// ============================================================================
// Configuration
// ============================================================================

/// Configuration for snippet rendering.
pub struct SnippetConfig {
    /// Number of context lines before the highlighted region.
    context_lines_before: u32,

    /// Number of context lines after the highlighted region.
    context_lines_after: u32,

    /// Tab width for rendering.
    tab_width: u32,

    /// Whether to show line numbers.
    show_line_numbers: bool,

    /// Whether to show the column indicator character (│).
    show_column_indicator: bool,

    /// Whether to use Unicode characters.
    use_unicode: bool,
}

impl SnippetConfig {
    /// Create default configuration.
    pub fn default() -> SnippetConfig {
        SnippetConfig {
            context_lines_before: 1,
            context_lines_after: 1,
            tab_width: 4,
            show_line_numbers: true,
            show_column_indicator: true,
            use_unicode: true,
        }
    }

    /// Create configuration for ASCII-only output.
    pub fn ascii() -> SnippetConfig {
        SnippetConfig {
            context_lines_before: 1,
            context_lines_after: 1,
            tab_width: 4,
            show_line_numbers: true,
            show_column_indicator: true,
            use_unicode: false,
        }
    }

    /// Create compact configuration (no context lines).
    pub fn compact() -> SnippetConfig {
        SnippetConfig {
            context_lines_before: 0,
            context_lines_after: 0,
            tab_width: 4,
            show_line_numbers: true,
            show_column_indicator: true,
            use_unicode: true,
        }
    }

    // === Builder Methods ===

    /// Set context lines.
    pub fn with_context(mut self, before: u32, after: u32) -> SnippetConfig {
        self.context_lines_before = before;
        self.context_lines_after = after;
        self
    }

    /// Set tab width.
    pub fn with_tab_width(mut self, width: u32) -> SnippetConfig {
        self.tab_width = width;
        self
    }

    /// Enable/disable line numbers.
    pub fn with_line_numbers(mut self, show: bool) -> SnippetConfig {
        self.show_line_numbers = show;
        self
    }

    /// Enable/disable Unicode.
    pub fn with_unicode(mut self, use_unicode: bool) -> SnippetConfig {
        self.use_unicode = use_unicode;
        self
    }

    // === Character Accessors ===

    /// Get the vertical line character.
    pub fn vertical_line(self) -> String {
        if self.use_unicode { "│" } else { "|" }
    }

    /// Get the horizontal line character.
    pub fn horizontal_line(self) -> String {
        if self.use_unicode { "─" } else { "-" }
    }

    /// Get the corner character (top-left).
    pub fn corner_tl(self) -> String {
        if self.use_unicode { "╭" } else { "+" }
    }

    /// Get the corner character (bottom-left).
    pub fn corner_bl(self) -> String {
        if self.use_unicode { "╰" } else { "+" }
    }

    /// Get the arrow character.
    pub fn arrow(self) -> String {
        if self.use_unicode { "→" } else { "->" }
    }

    /// Get the underline character for primary labels.
    pub fn primary_underline(self) -> String {
        "^"
    }

    /// Get the underline character for secondary labels.
    pub fn secondary_underline(self) -> String {
        "-"
    }
}

// ============================================================================
// Snippet Line
// ============================================================================

/// A line within a snippet.
pub enum SnippetLine {
    /// A source code line.
    Source {
        line_number: u32,
        content: String,
        is_highlighted: bool,
    },

    /// An annotation line (underlines and labels).
    Annotation {
        content: String,
    },

    /// A fold indicator (for omitted lines).
    Fold {
        count: u32,
    },

    /// An empty separator line.
    Empty,
}

impl SnippetLine {
    /// Create a source line.
    pub fn source(line_number: u32, content: String, highlighted: bool) -> SnippetLine {
        SnippetLine::Source {
            line_number,
            content,
            is_highlighted: highlighted,
        }
    }

    /// Create an annotation line.
    pub fn annotation(content: String) -> SnippetLine {
        SnippetLine::Annotation { content }
    }

    /// Create a fold line.
    pub fn fold(count: u32) -> SnippetLine {
        SnippetLine::Fold { count }
    }

    /// Create an empty line.
    pub fn empty() -> SnippetLine {
        SnippetLine::Empty
    }

    /// Check if this is a source line.
    pub fn is_source(self) -> bool {
        match self {
            SnippetLine::Source { .. } => true,
            SnippetLine::Annotation { .. } => false,
            SnippetLine::Fold { .. } => false,
            SnippetLine::Empty => false,
        }
    }
}

// ============================================================================
// Snippet
// ============================================================================

/// A source code snippet with annotations.
pub struct Snippet {
    /// The file this snippet is from.
    file_name: String,

    /// Lines in the snippet.
    lines: Vec<SnippetLine>,

    /// The primary span location (for the header).
    primary_location: String,
}

impl Snippet {
    /// Create a new empty snippet.
    pub fn new(file_name: String, primary_location: String) -> Snippet {
        Snippet {
            file_name,
            lines: Vec::new(),
            primary_location,
        }
    }

    /// Add a line to the snippet.
    pub fn add_line(mut self, line: SnippetLine) -> Unit {
        self.lines.push(line);
    }

    /// Get the file name.
    pub fn file_name(self) -> String {
        self.file_name.clone();
    }

    /// Get the primary location string.
    pub fn primary_location(self) -> String {
        self.primary_location.clone();
    }

    /// Get all lines.
    pub fn lines(self) -> Vec<SnippetLine> {
        self.lines.clone();
    }

    /// Check if empty.
    pub fn is_empty(self) -> bool {
        self.lines.is_empty();
    }
}

// ============================================================================
// Snippet Builder
// ============================================================================

/// Builds snippets from source files and spans.
pub struct SnippetBuilder {
    config: SnippetConfig,
}

impl SnippetBuilder {
    /// Create a new snippet builder with default config.
    pub fn new() -> SnippetBuilder {
        SnippetBuilder {
            config: SnippetConfig::default(),
        }
    }

    /// Create a snippet builder with custom config.
    pub fn with_config(config: SnippetConfig) -> SnippetBuilder {
        SnippetBuilder { config }
    }

    /// Build a snippet for a single span.
    pub fn build_for_span(self, file: SourceFile, span: Span) -> Snippet {
        let primary_location = file.name() ++ ":" ++ span.display_short();
        let mut snippet = Snippet::new(file.name(), primary_location);

        // Get the line range
        let start_line = span.start_line();
        let end_line = span.end_line();

        // Add context before
        let context_start = if start_line > self.config.context_lines_before {
            start_line - self.config.context_lines_before
        } else {
            1
        };

        // Add context after
        let context_end = end_line + self.config.context_lines_after;

        // Add source lines
        let mut line = context_start;
        while line <= context_end {
            match file.get_line(line) {
                Option::Some(content) => {
                    let is_highlighted = line >= start_line && line <= end_line;
                    snippet.add_line(SnippetLine::source(line, content, is_highlighted));
                }
                Option::None => break,
            };
            line = line + 1;
        }

        snippet
    }

    /// Build a snippet with labels.
    pub fn build_with_labels(self, file: SourceFile, labels: LabelCollection) -> Snippet {
        // Get the line range from labels
        let range = labels.line_range();
        match range {
            Option::None => {
                return Snippet::new(file.name(), file.name());
            }
            Option::Some((min_line, max_line)) => {
                let primary_location = file.name() ++ ":" ++ min_line.to_string();
                let mut snippet = Snippet::new(file.name(), primary_location);

                // Add context before
                let context_start = if min_line > self.config.context_lines_before {
                    min_line - self.config.context_lines_before
                } else {
                    1
                };

                // Add context after
                let context_end = max_line + self.config.context_lines_after;

                // Add source lines with annotations
                let mut line = context_start;
                while line <= context_end {
                    match file.get_line(line) {
                        Option::Some(content) => {
                            let is_highlighted = line >= min_line && line <= max_line;
                            snippet.add_line(SnippetLine::source(line, content, is_highlighted));

                            // Add annotation lines for labels on this line
                            let line_labels = labels.labels_on_line(line);
                            if !line_labels.is_empty() {
                                let annotation = self.build_annotation_line(content, line_labels, line);
                                snippet.add_line(SnippetLine::annotation(annotation));
                            }
                        }
                        Option::None => break,
                    };
                    line = line + 1;
                }

                snippet
            }
        }
    }

    /// Build an annotation line for labels.
    fn build_annotation_line(self, source_line: String, labels: Vec<Label>, line_number: u32) -> String {
        // For now, create a simple annotation
        // A full implementation would handle overlapping labels, multi-line, etc.
        let mut annotation = String::new();

        // Sort labels by start column
        let mut sorted_labels = labels.clone();
        sorted_labels.sort_by(|a, b| a.span().start_column().cmp(b.span().start_column()));

        let mut current_col: u32 = 1;
        for label in sorted_labels {
            let start_col = label.span().start_column();
            let end_col = label.span().end_column();

            // Add spaces to reach this label
            while current_col < start_col {
                annotation = annotation ++ " "
                current_col = current_col + 1;
            };

            // Add underline characters
            let underline_char = label.underline_char();
            let label_width = if end_col > start_col { end_col - start_col } else { 1 };
            let mut i: u32 = 0;
            while i < label_width {
                annotation = annotation ++ underline_char.to_string();
                i = i + 1;
            };
            current_col = current_col + label_width;

            // Add message if present
            match label.message() {
                Option::Some(msg) => {
                    annotation = annotation ++ " " ++ msg;
                }
                Option::None => {}
            }
        }

        annotation
    }

    /// Get the configuration.
    pub fn config(self) -> SnippetConfig {
        self.config.clone();
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Expand tabs in a string to spaces.
pub fn expand_tabs(line: String, tab_width: u32) -> String {
    let mut result = String::new();
    let mut col: u32 = 0;

    for ch in line.chars() {
        if ch == '\t' {
            // Add spaces to next tab stop
            let spaces_to_add = tab_width - (col % tab_width);
            let mut i: u32 = 0;
            while i < spaces_to_add {
                result = result ++ " "
                i = i + 1;
            };
            col = col + spaces_to_add;
        } else {
            result = result ++ ch.to_string();
            col = col + 1;
        }
    }

    result
}

/// Calculate the display width of a string (handling tabs).
pub fn display_width(line: String, tab_width: u32) -> usize {
    expand_tabs(line, tab_width).len()
}

/// Pad a number with spaces on the left.
pub fn pad_number(n: u32, width: usize) -> String {
    let s = n.to_string();
    let pad = if width > s.len() { width - s.len() } else { 0 };

    let mut result = String::new();
    let mut i: usize = 0;
    while i < pad {
        result = result ++ " "
        i = i + 1;
    }
    result ++ s
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_snippet_config_default() {
    let config = SnippetConfig::default();

    assert(config.context_lines_before == 1);
    assert(config.context_lines_after == 1);
    assert(config.tab_width == 4);
    assert(config.show_line_numbers);
    assert(config.use_unicode);
}

#[test]
fn test_snippet_config_ascii() {
    let config = SnippetConfig::ascii();

    assert(!config.use_unicode);
    assert(config.vertical_line() == "|");
}

#[test]
fn test_snippet_config_unicode() {
    let config = SnippetConfig::default();

    assert(config.vertical_line() == "│");
    assert(config.arrow() == "→");
}

#[test]
fn test_snippet_line_variants() {
    let source = SnippetLine::source(10, "let x = 42", true);
    let annotation = SnippetLine::annotation("    ^^^^^^");
    let fold = SnippetLine::fold(5);
    let empty = SnippetLine::empty();

    assert(source.is_source());
    assert(!annotation.is_source());
    assert(!fold.is_source());
    assert(!empty.is_source());
}

#[test]
fn test_snippet_creation() {
    let snippet = Snippet::new("test.blood", "test.blood:10:5");

    assert(snippet.file_name() == "test.blood");
    assert(snippet.primary_location() == "test.blood:10:5");
    assert(snippet.is_empty());
}

#[test]
fn test_snippet_add_line() {
    let mut snippet = Snippet::new("test.blood", "test.blood:1:1");
    snippet.add_line(SnippetLine::source(1, "fn main() {}", false));

    assert(!snippet.is_empty());
    assert(snippet.lines().len() == 1);
}

#[test]
fn test_expand_tabs() {
    let line = "a\tb\tc";
    let expanded = expand_tabs(line, 4);

    // 'a' at col 0, tab to col 4, 'b' at col 4, tab to col 8, 'c' at col 8
    assert(expanded == "a   b   c");
}

#[test]
fn test_expand_tabs_at_start() {
    let line = "\thello";
    let expanded = expand_tabs(line, 4);

    assert(expanded == "    hello");
}

#[test]
fn test_display_width() {
    let line = "hello\tworld";
    let width = display_width(line, 4);

    // "hello" (5) + spaces to tab (3) + "world" (5) = 13
    assert(width == 13);
}

#[test]
fn test_pad_number() {
    assert(pad_number(5, 3) == "  5");
    assert(pad_number(42, 3) == " 42");
    assert(pad_number(123, 3) == "123");
    assert(pad_number(1234, 3) == "1234");
}

#[test]
fn test_snippet_builder_creation() {
    let builder = SnippetBuilder::new();
    assert(builder.config().context_lines_before == 1);
}

#[test]
fn test_snippet_builder_with_config() {
    let config = SnippetConfig::compact();
    let builder = SnippetBuilder::with_config(config);

    assert(builder.config().context_lines_before == 0);
}
