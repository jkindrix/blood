//! # Source File Management
//!
//! Manages source files for diagnostic rendering.
//!
//! ## Features
//!
//! - O(log n) line/column lookup via LineIndex
//! - Efficient source text extraction
//! - File caching with SourceMap

module std.compiler.diagnostics.renderer.source

use std.collections.HashMap
use std.collections.Vec
use std.option.Option
use std.result.Result
use std.io.IoError
use std.compiler.diagnostics.span.FileId
use std.compiler.diagnostics.span.Span
use std.compiler.diagnostics.span.LineIndex
use std.compiler.diagnostics.span.Position

// ============================================================================
// Source File
// ============================================================================

/// A source file with its content and metadata.
pub struct SourceFile {
    /// File identifier.
    id: FileId,

    /// File name or path.
    name: String,

    /// Full source content.
    content: String,

    /// Precomputed line index for O(log n) lookup.
    line_index: LineIndex,
}

impl SourceFile {
    /// Create a new source file.
    pub fn new(id: FileId, name: String, content: String) -> SourceFile {
        let line_index = LineIndex::new(content.clone())
        SourceFile {
            id,
            name,
            content,
            line_index,
        }
    }

    /// Get the file ID.
    pub fn id(self) -> FileId {
        self.id
    }

    /// Get the file name.
    pub fn name(self) -> String {
        self.name.clone()
    }

    /// Get the full content.
    pub fn content(self) -> String {
        self.content.clone()
    }

    /// Get the line index.
    pub fn line_index(self) -> LineIndex {
        self.line_index.clone()
    }

    /// Get the number of lines.
    pub fn line_count(self) -> USize {
        self.line_index.line_count()
    }

    /// Get (line, column) for a byte offset.
    pub fn line_col(self, offset: USize) -> (U32, U32) {
        self.line_index.line_col(offset)
    }

    /// Get a specific line (1-indexed).
    ///
    /// Returns None if line is out of range.
    pub fn get_line(self, line_number: U32) -> Option[String] {
        if line_number == 0 || line_number > self.line_count() as U32 {
            return Option::None
        }

        let start = self.line_index.line_start(line_number)?
        let end = match self.line_index.line_start(line_number + 1) {
            Option::Some(e) => e,
            Option::None => self.content.len(),
        }

        // Remove trailing newline if present
        let line = self.content.substring(start, end)
        if line.ends_with("\n") {
            Option::Some(line.substring(0, line.len() - 1))
        } else {
            Option::Some(line)
        }
    }

    /// Get multiple lines (1-indexed, inclusive range).
    pub fn get_lines(self, start_line: U32, end_line: U32) -> Vec[String] {
        let mut lines = Vec::new()
        let mut line = start_line

        while line <= end_line {
            match self.get_line(line) {
                Option::Some(l) => lines.push(l),
                Option::None => break,
            }
            line = line + 1
        }

        lines
    }

    /// Get the text for a span.
    pub fn get_span_text(self, span: Span) -> String {
        self.content.substring(span.start_offset(), span.end_offset())
    }

    /// Get a Position with line/column info for a byte offset.
    pub fn position_at(self, offset: USize) -> Position {
        let (line, col) = self.line_col(offset)
        Position::new(offset, line, col)
    }
}

// ============================================================================
// Source Map
// ============================================================================

/// A collection of source files for a compilation.
pub struct SourceMap {
    /// Files indexed by ID.
    files: HashMap[U32, SourceFile],

    /// Files indexed by name (for lookup by path).
    by_name: HashMap[String, FileId],

    /// Next file ID to assign.
    next_id: U32,
}

impl SourceMap {
    /// Create a new empty source map.
    pub fn new() -> SourceMap {
        SourceMap {
            files: HashMap::new(),
            by_name: HashMap::new(),
            next_id: 1,  // 0 is reserved for dummy
        }
    }

    /// Add a source file.
    ///
    /// Returns the assigned FileId.
    pub fn add(mut self, name: String, content: String) -> FileId {
        let id = FileId::new(self.next_id)
        self.next_id = self.next_id + 1

        let file = SourceFile::new(id, name.clone(), content)
        self.files.insert(id.raw(), file)
        self.by_name.insert(name, id)

        id
    }

    /// Add a source file with a specific ID.
    ///
    /// Use this when you need to control the file ID assignment.
    pub fn add_with_id(mut self, id: FileId, name: String, content: String) -> Unit {
        let file = SourceFile::new(id, name.clone(), content)
        self.files.insert(id.raw(), file)
        self.by_name.insert(name, id)

        // Update next_id if needed
        if id.raw() >= self.next_id {
            self.next_id = id.raw() + 1
        }
    }

    /// Get a source file by ID.
    pub fn get(self, id: FileId) -> Option[SourceFile] {
        self.files.get(id.raw()).map(|f| f.clone())
    }

    /// Get a source file by name.
    pub fn get_by_name(self, name: String) -> Option[SourceFile] {
        match self.by_name.get(name) {
            Option::Some(id) => self.get(*id),
            Option::None => Option::None,
        }
    }

    /// Get the file name for an ID.
    pub fn get_filename(self, id: FileId) -> Option[String] {
        self.files.get(id.raw()).map(|f| f.name())
    }

    /// Check if a file exists.
    pub fn contains(self, id: FileId) -> Bool {
        self.files.contains_key(id.raw())
    }

    /// Check if a file exists by name.
    pub fn contains_name(self, name: String) -> Bool {
        self.by_name.contains_key(name)
    }

    /// Get the number of files.
    pub fn len(self) -> USize {
        self.files.len()
    }

    /// Check if empty.
    pub fn is_empty(self) -> Bool {
        self.files.is_empty()
    }

    /// Get all file IDs.
    pub fn file_ids(self) -> Vec[FileId] {
        let mut ids = Vec::new()
        for (id, _) in self.files {
            ids.push(FileId::new(*id))
        }
        ids
    }

    /// Get text for a span.
    ///
    /// Returns None if the file is not found.
    pub fn get_span_text(self, span: Span) -> Option[String] {
        match self.get(span.file()) {
            Option::Some(file) => Option::Some(file.get_span_text(span)),
            Option::None => Option::None,
        }
    }

    /// Get a line from a file.
    pub fn get_line(self, file_id: FileId, line_number: U32) -> Option[String] {
        match self.get(file_id) {
            Option::Some(file) => file.get_line(line_number),
            Option::None => Option::None,
        }
    }
}

// ============================================================================
// Line Info
// ============================================================================

/// Information about a source line.
pub struct LineInfo {
    /// Line number (1-indexed).
    line_number: U32,

    /// Line content.
    content: String,

    /// Byte offset where the line starts.
    start_offset: USize,

    /// Byte offset where the line ends.
    end_offset: USize,
}

impl LineInfo {
    /// Create new line info.
    pub fn new(line_number: U32, content: String, start_offset: USize, end_offset: USize) -> LineInfo {
        LineInfo {
            line_number,
            content,
            start_offset,
            end_offset,
        }
    }

    /// Get the line number.
    pub fn line_number(self) -> U32 {
        self.line_number
    }

    /// Get the content.
    pub fn content(self) -> String {
        self.content.clone()
    }

    /// Get the start offset.
    pub fn start_offset(self) -> USize {
        self.start_offset
    }

    /// Get the end offset.
    pub fn end_offset(self) -> USize {
        self.end_offset
    }

    /// Get the length.
    pub fn len(self) -> USize {
        self.content.len()
    }

    /// Check if empty.
    pub fn is_empty(self) -> Bool {
        self.content.is_empty()
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_source_file_creation() {
    let file = SourceFile::new(
        FileId::new(1),
        "test.blood",
        "line 1\nline 2\nline 3",
    )

    assert(file.name() == "test.blood")
    assert(file.line_count() == 3)
}

#[test]
fn test_source_file_get_line() {
    let file = SourceFile::new(
        FileId::new(1),
        "test.blood",
        "fn main() {\n    println(\"hello\")\n}",
    )

    let line1 = file.get_line(1)
    assert(line1 == Option::Some("fn main() {"))

    let line2 = file.get_line(2)
    assert(line2 == Option::Some("    println(\"hello\")"))

    let line3 = file.get_line(3)
    assert(line3 == Option::Some("}"))

    // Out of range
    let line4 = file.get_line(4)
    assert(line4.is_none())

    let line0 = file.get_line(0)
    assert(line0.is_none())
}

#[test]
fn test_source_file_get_lines() {
    let file = SourceFile::new(
        FileId::new(1),
        "test.blood",
        "a\nb\nc\nd\ne",
    )

    let lines = file.get_lines(2, 4)
    assert(lines.len() == 3)
    assert(lines.get(0).unwrap() == "b")
    assert(lines.get(1).unwrap() == "c")
    assert(lines.get(2).unwrap() == "d")
}

#[test]
fn test_source_file_line_col() {
    let file = SourceFile::new(
        FileId::new(1),
        "test.blood",
        "abc\ndef\nghi",
    )

    let (line, col) = file.line_col(0)
    assert(line == 1 && col == 1)

    let (line, col) = file.line_col(4)
    assert(line == 2 && col == 1)

    let (line, col) = file.line_col(5)
    assert(line == 2 && col == 2)
}

#[test]
fn test_source_file_get_span_text() {
    let file = SourceFile::new(
        FileId::new(1),
        "test.blood",
        "hello world",
    )

    let span = Span::from_offsets(file.id(), 0, 5)
    assert(file.get_span_text(span) == "hello")
}

#[test]
fn test_source_map_add_and_get() {
    let mut map = SourceMap::new()

    let id = map.add("main.blood", "fn main() {}")
    assert(!id.is_dummy())

    let file = map.get(id)
    assert(file.is_some())
    assert(file.unwrap().name() == "main.blood")
}

#[test]
fn test_source_map_get_by_name() {
    let mut map = SourceMap::new()
    map.add("test.blood", "content here")

    let file = map.get_by_name("test.blood")
    assert(file.is_some())

    let missing = map.get_by_name("other.blood")
    assert(missing.is_none())
}

#[test]
fn test_source_map_contains() {
    let mut map = SourceMap::new()
    let id = map.add("test.blood", "content")

    assert(map.contains(id))
    assert(!map.contains(FileId::new(999)))

    assert(map.contains_name("test.blood"))
    assert(!map.contains_name("other.blood"))
}

#[test]
fn test_source_map_len() {
    let mut map = SourceMap::new()

    assert(map.is_empty())
    assert(map.len() == 0)

    map.add("a.blood", "a")
    map.add("b.blood", "b")

    assert(!map.is_empty())
    assert(map.len() == 2)
}

#[test]
fn test_source_map_get_span_text() {
    let mut map = SourceMap::new()
    let id = map.add("test.blood", "hello world")

    let span = Span::from_offsets(id, 6, 11)
    let text = map.get_span_text(span)

    assert(text == Option::Some("world"))
}

#[test]
fn test_source_map_get_line() {
    let mut map = SourceMap::new()
    let id = map.add("test.blood", "line 1\nline 2")

    let line = map.get_line(id, 2)
    assert(line == Option::Some("line 2"))
}

#[test]
fn test_line_info() {
    let info = LineInfo::new(5, "let x = 42", 100, 110)

    assert(info.line_number() == 5)
    assert(info.content() == "let x = 42")
    assert(info.start_offset() == 100)
    assert(info.end_offset() == 110)
    assert(info.len() == 10)
    assert(!info.is_empty())
}
