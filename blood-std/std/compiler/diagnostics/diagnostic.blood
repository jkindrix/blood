//! # Core Diagnostic Type
//!
//! The main `Diagnostic` struct represents a compiler diagnostic message.
//!
//! ## Usage
//!
//! ```blood
//! let diagnostic = Diagnostic::error("type mismatch", span)
//!     .with_code(ErrorCode::TypeMismatch)
//!     .with_label(Label::primary(span, "expected `Int`, found `String`"))
//!     .with_label(Label::secondary(type_span, "expected due to this"))
//!     .with_suggestion(Suggestion::replace(
//!         span, "42", Applicability::MachineApplicable
//!     ))
//! ```

module std.compiler.diagnostics.diagnostic;

use std.collections.Vec;
use std.core.Option;
use std.compiler.diagnostics.severity.Severity;
use std.compiler.diagnostics.span.Span;
use std.compiler.diagnostics.span.FileId;
use std.compiler.diagnostics.label.Label;
use std.compiler.diagnostics.label.LabelCollection;
use std.compiler.diagnostics.suggestion.Suggestion;
use std.compiler.diagnostics.suggestion.Help;
use std.compiler.diagnostics.code.ErrorCode;
use std.compiler.diagnostics.code.DiagnosticGroup;

// ============================================================================
// Diagnostic
// ============================================================================

/// A compiler diagnostic message.
///
/// Diagnostics can be errors, warnings, notes, or other severity levels.
/// They contain:
/// - A primary message
/// - A primary span (where the issue occurred)
/// - Optional error code
/// - Optional labels (annotations on source code)
/// - Optional suggestions (fix-its)
/// - Optional related diagnostics (sub-errors, notes)
pub struct Diagnostic {
    /// The severity level.
    severity: Severity,

    /// The primary message.
    message: String,

    /// The primary span where the issue occurred.
    span: Span,

    /// Optional error code.
    code: Option<ErrorCode>,

    /// Labels annotating source code.
    labels: Vec<Label>,

    /// Suggestions for fixing the issue.
    suggestions: Vec<Suggestion>,

    /// Help messages (text-only suggestions).
    help_messages: Vec<Help>,

    /// Related diagnostics (notes, sub-errors).
    related: Vec<Diagnostic>,

    /// Optional diagnostic group override.
    group: Option<DiagnosticGroup>,
}

impl Diagnostic {
    // ========================================================================
    // Constructors
    // ========================================================================

    /// Create a new error diagnostic.
    pub fn error(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            severity: Severity::Error,
            message,
            span,
            code: Option::None,
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::None,
        }
    }

    /// Create a new warning diagnostic.
    pub fn warning(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            severity: Severity::Warning,
            message,
            span,
            code: Option::None,
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::None,
        }
    }

    /// Create a new note diagnostic.
    pub fn note(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            severity: Severity::Note,
            message,
            span,
            code: Option::None,
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::None,
        }
    }

    /// Create a new help diagnostic.
    pub fn help(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            severity: Severity::Help,
            message,
            span,
            code: Option::None,
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::None,
        }
    }

    /// Create a new remark diagnostic.
    pub fn remark(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            severity: Severity::Remark,
            message,
            span,
            code: Option::None,
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::None,
        }
    }

    /// Create a diagnostic from an error code.
    ///
    /// The message and help are automatically populated from the error code.
    pub fn from_code(code: ErrorCode, span: Span) -> Diagnostic {
        let severity = if code.is_warning() {
            Severity::Warning
        } else {
            Severity::Error
        };

        let mut diag = Diagnostic {
            severity,
            message: code.description(),
            span,
            code: Option::Some(code),
            labels: Vec::new(),
            suggestions: Vec::new(),
            help_messages: Vec::new(),
            related: Vec::new(),
            group: Option::Some(code.group()),
        };

        // Add help message if available
        match code.help() {
            Option::Some(help_text) => {
                diag.help_messages.push(Help::new(help_text));
            }
            Option::None => {}
        }

        diag
    }

    // ========================================================================
    // Builder Methods
    // ========================================================================

    /// Set the error code.
    pub fn with_code(mut self, code: ErrorCode) -> Diagnostic {
        self.code = Option::Some(code);

        // Set group from code if not already set
        if self.group.is_none() {
            self.group = Option::Some(code.group());
        };

        // Add help from code if not already present
        if self.help_messages.is_empty() {
            match code.help() {
                Option::Some(help_text) => {
                    self.help_messages.push(Help::new(help_text));
                }
                Option::None => {}
            }
        }

        self
    }

    /// Add a label.
    pub fn with_label(mut self, label: Label) -> Diagnostic {
        self.labels.push(label);
        self
    }

    /// Add a primary label with a message.
    pub fn with_primary_label(mut self, span: Span, message: String) -> Diagnostic {
        self.labels.push(Label::primary(span, message));
        self
    }

    /// Add a secondary label with a message.
    pub fn with_secondary_label(mut self, span: Span, message: String) -> Diagnostic {
        self.labels.push(Label::secondary(span, message));
        self
    }

    /// Add a suggestion.
    pub fn with_suggestion(mut self, suggestion: Suggestion) -> Diagnostic {
        self.suggestions.push(suggestion);
        self
    }

    /// Add a help message.
    pub fn with_help(mut self, message: String) -> Diagnostic {
        self.help_messages.push(Help::new(message));
        self
    }

    /// Add a related diagnostic (note, sub-error).
    pub fn with_related(mut self, related: Diagnostic) -> Diagnostic {
        self.related.push(related);
        self
    }

    /// Add a note as a related diagnostic.
    pub fn with_note(mut self, message: String, span: Span) -> Diagnostic {
        self.related.push(Diagnostic::note(message, span));
        self
    }

    /// Set the diagnostic group.
    pub fn with_group(mut self, group: DiagnosticGroup) -> Diagnostic {
        self.group = Option::Some(group);
        self
    }

    /// Override the message.
    pub fn with_message(mut self, message: String) -> Diagnostic {
        self.message = message;
        self
    }

    /// Override the severity.
    pub fn with_severity(mut self, severity: Severity) -> Diagnostic {
        self.severity = severity;
        self
    }

    // ========================================================================
    // Accessors
    // ========================================================================

    /// Get the severity.
    pub fn severity(self) -> Severity {
        self.severity
    }

    /// Get the message.
    pub fn message(self) -> String {
        self.message.clone();
    }

    /// Get the primary span.
    pub fn span(self) -> Span {
        self.span
    }

    /// Get the error code.
    pub fn code(self) -> Option<ErrorCode> {
        self.code
    }

    /// Get the code as a string (e.g., "E0100").
    pub fn code_str(self) -> Option<String> {
        self.code.map(|c| c.as_str());
    }

    /// Get all labels.
    pub fn labels(self) -> Vec<Label> {
        self.labels.clone();
    }

    /// Get all suggestions.
    pub fn suggestions(self) -> Vec<Suggestion> {
        self.suggestions.clone();
    }

    /// Get all help messages.
    pub fn help_messages(self) -> Vec<Help> {
        self.help_messages.clone();
    }

    /// Get related diagnostics.
    pub fn related(self) -> Vec<Diagnostic> {
        self.related.clone();
    }

    /// Get the diagnostic group.
    pub fn group(self) -> Option<DiagnosticGroup> {
        self.group
    }

    // ========================================================================
    // Properties
    // ========================================================================

    /// Check if this is an error.
    pub fn is_error(self) -> bool {
        self.severity.is_error();
    }

    /// Check if this is a warning.
    pub fn is_warning(self) -> bool {
        self.severity.is_warning();
    }

    /// Check if this is fatal.
    pub fn is_fatal(self) -> bool {
        self.severity.is_fatal();
    }

    /// Check if this has an error code.
    pub fn has_code(self) -> bool {
        self.code.is_some();
    }

    /// Check if this has labels.
    pub fn has_labels(self) -> bool {
        !self.labels.is_empty()
    }

    /// Check if this has suggestions.
    pub fn has_suggestions(self) -> bool {
        !self.suggestions.is_empty()
    }

    /// Check if this has help messages.
    pub fn has_help(self) -> bool {
        !self.help_messages.is_empty()
    }

    /// Check if this has related diagnostics.
    pub fn has_related(self) -> bool {
        !self.related.is_empty()
    }

    /// Get the file ID from the primary span.
    pub fn file(self) -> FileId {
        self.span.file();
    }

    /// Get the start line from the primary span.
    pub fn start_line(self) -> u32 {
        self.span.start_line();
    }

    /// Get a label collection for rendering.
    pub fn label_collection(self) -> LabelCollection {
        LabelCollection::from_vec(self.labels.clone())
    }

    // ========================================================================
    // Formatting
    // ========================================================================

    /// Format the diagnostic header (severity + code + message).
    ///
    /// Example: "error[E0308]: type mismatch"
    pub fn format_header(self) -> String {
        let severity_str = self.severity.name();

        match self.code {
            Option::Some(code) => {
                severity_str ++ "[" ++ code.as_str() ++ "]: " ++ self.message
            }
            Option::None => {
                severity_str ++ ": " ++ self.message
            }
        }
    }

    /// Format the location (file:line:column).
    ///
    /// Example: "src/main.blood:10:12"
    pub fn format_location(self, filename: String) -> String {
        filename ++ ":" ++ self.span.display_short()
    }
}

// ============================================================================
// Diagnostic Builder (Alternative API)
// ============================================================================

/// A builder for constructing diagnostics.
///
/// This provides an alternative to the method chaining API.
pub struct DiagnosticBuilder {
    diagnostic: Diagnostic,
}

impl DiagnosticBuilder {
    /// Start building an error diagnostic.
    pub fn error(message: String, span: Span) -> DiagnosticBuilder {
        DiagnosticBuilder {
            diagnostic: Diagnostic::error(message, span),
        }
    }

    /// Start building a warning diagnostic.
    pub fn warning(message: String, span: Span) -> DiagnosticBuilder {
        DiagnosticBuilder {
            diagnostic: Diagnostic::warning(message, span),
        }
    }

    /// Start building from an error code.
    pub fn from_code(code: ErrorCode, span: Span) -> DiagnosticBuilder {
        DiagnosticBuilder {
            diagnostic: Diagnostic::from_code(code, span),
        }
    }

    /// Set the error code.
    pub fn code(mut self, code: ErrorCode) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_code(code);
        self
    }

    /// Add a label.
    pub fn label(mut self, label: Label) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_label(label);
        self
    }

    /// Add a primary label.
    pub fn primary(mut self, span: Span, message: String) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_primary_label(span, message);
        self
    }

    /// Add a secondary label.
    pub fn secondary(mut self, span: Span, message: String) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_secondary_label(span, message);
        self
    }

    /// Add a suggestion.
    pub fn suggest(mut self, suggestion: Suggestion) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_suggestion(suggestion);
        self
    }

    /// Add a help message.
    pub fn help(mut self, message: String) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_help(message);
        self
    }

    /// Add a related diagnostic.
    pub fn related(mut self, diagnostic: Diagnostic) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_related(diagnostic);
        self
    }

    /// Add a note.
    pub fn note(mut self, message: String, span: Span) -> DiagnosticBuilder {
        self.diagnostic = self.diagnostic.with_note(message, span);
        self
    }

    /// Finish building and return the diagnostic.
    pub fn build(self) -> Diagnostic {
        self.diagnostic
    }

    /// Finish building and emit the diagnostic.
    ///
    /// Note: Requires a DiagnosticContext (defined in context.blood).
    pub fn emit(self, ctx: DiagnosticContext) -> Unit {
        ctx.emit(self.diagnostic);
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_diagnostic_error() {
    let span = Span::dummy();
    let diag = Diagnostic::error("something went wrong", span);

    assert(diag.is_error());
    assert(!diag.is_warning());
    assert(diag.message() == "something went wrong");
}

#[test]
fn test_diagnostic_warning() {
    let span = Span::dummy();
    let diag = Diagnostic::warning("potential issue", span);

    assert(!diag.is_error());
    assert(diag.is_warning());
}

#[test]
fn test_diagnostic_with_code() {
    let span = Span::dummy();
    let diag = Diagnostic::error("type mismatch", span)
        .with_code(ErrorCode::TypeMismatch);

    assert(diag.has_code());
    assert(diag.code_str() == Option::Some("E0300"));
}

#[test]
fn test_diagnostic_from_code() {
    let span = Span::dummy();
    let diag = Diagnostic::from_code(ErrorCode::TypeMismatch, span);

    assert(diag.has_code());
    assert(diag.message() == "type mismatch");
    // Should have group set
    assert(diag.group().is_some());
}

#[test]
fn test_diagnostic_with_labels() {
    let span = Span::dummy();
    let diag = Diagnostic::error("type mismatch", span)
        .with_primary_label(span, "expected `Int`")
        .with_secondary_label(span, "found `String`");

    assert(diag.has_labels());
    assert(diag.labels().len() == 2);
}

#[test]
fn test_diagnostic_with_suggestion() {
    let span = Span::dummy();
    let suggestion = Suggestion::replace(
        "use `==` instead",
        span,
        "==",
        std.compiler.diagnostics.suggestion.Applicability::MachineApplicable,
    );
    let diag = Diagnostic::error("invalid operator", span)
        .with_suggestion(suggestion);

    assert(diag.has_suggestions());
    assert(diag.suggestions().len() == 1);
}

#[test]
fn test_diagnostic_with_help() {
    let span = Span::dummy();
    let diag = Diagnostic::error("missing semicolon", span)
        .with_help("add `;` at the end of the statement");

    assert(diag.has_help());
    assert(diag.help_messages().len() == 1);
}

#[test]
fn test_diagnostic_with_related() {
    let span = Span::dummy();
    let note = Diagnostic::note("type defined here", span);
    let diag = Diagnostic::error("type mismatch", span)
        .with_related(note);

    assert(diag.has_related());
    assert(diag.related().len() == 1);
}

#[test]
fn test_diagnostic_with_note() {
    let span = Span::dummy();
    let diag = Diagnostic::error("undefined variable", span)
        .with_note("did you mean `foo`?", span);

    assert(diag.has_related());
    let notes = diag.related();
    assert(notes.len() == 1);
    assert(notes.get(0).unwrap().severity() == Severity::Note);
}

#[test]
fn test_diagnostic_format_header() {
    let span = Span::dummy();
    let diag = Diagnostic::error("type mismatch", span)
        .with_code(ErrorCode::TypeMismatch);

    let header = diag.format_header();
    assert(header.contains("error"));
    assert(header.contains("E0300"));
    assert(header.contains("type mismatch"));
}

#[test]
fn test_diagnostic_format_header_no_code() {
    let span = Span::dummy();
    let diag = Diagnostic::error("something wrong", span);

    let header = diag.format_header();
    assert(header == "error: something wrong");
}

#[test]
fn test_diagnostic_builder() {
    let span = Span::dummy();
    let diag = DiagnosticBuilder::error("type mismatch", span)
        .code(ErrorCode::TypeMismatch)
        .primary(span, "expected `Int`")
        .help("check your types")
        .build();

    assert(diag.is_error());
    assert(diag.has_code());
    assert(diag.has_labels());
    assert(diag.has_help());
}

#[test]
fn test_diagnostic_builder_from_code() {
    let span = Span::dummy();
    let diag = DiagnosticBuilder::from_code(ErrorCode::UnusedVariable, span)
        .primary(span, "this variable is never used")
        .build();

    assert(diag.is_warning());
    assert(diag.code_str() == Option::Some("W0100"));
}

#[test]
fn test_warning_from_code() {
    let span = Span::dummy();
    let diag = Diagnostic::from_code(ErrorCode::UnusedVariable, span);

    // Warning code should create a warning, not an error
    assert(diag.is_warning());
    assert(!diag.is_error());
}
