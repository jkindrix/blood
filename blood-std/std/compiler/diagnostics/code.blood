//! # Error Code Registry
//!
//! Defines all compiler error and warning codes with their metadata.
//!
//! ## Error Code Organization
//!
//! ```text
//! E0001-E0099   Lexer errors
//! E0100-E0199   Parser/syntax errors
//! E0200-E0299   Name resolution errors
//! E0300-E0399   Type errors
//! E0400-E0499   Effect/handler errors
//! E0500-E0599   Pattern matching errors
//! E0600-E0699   Codegen errors
//! E9000-E9999   Internal compiler errors (ICE)
//!
//! W0001-W0099   Memory/pointer warnings
//! W0100-W0199   Style/convention warnings
//! W0200-W0299   Performance warnings
//! W0300-W0399   Deprecation warnings
//! ```

module std.compiler.diagnostics.code;

use std.core.Option;

// ============================================================================
// Error Code
// ============================================================================

/// A compiler error or warning code.
///
/// Error codes uniquely identify diagnostic types and are used for:
/// - Documentation lookup (`blood --explain E0100`)
/// - Filtering and suppression
/// - Tooling integration
#[repr(u16)]
pub enum ErrorCode {
    // ========================================================================
    // Lexer Errors (E0001-E0099)
    // ========================================================================

    /// E0001: Unexpected character in source.
    UnexpectedCharacter = 1,

    /// E0002: Unclosed block comment.
    UnclosedBlockComment = 2,

    /// E0003: Unclosed string literal.
    UnclosedString = 3,

    /// E0004: Invalid escape sequence.
    InvalidEscape = 4,

    /// E0005: Invalid integer literal.
    InvalidInteger = 5,

    /// E0006: Invalid float literal.
    InvalidFloat = 6,

    /// E0007: Unclosed character literal.
    UnclosedChar = 7,

    /// E0008: Empty character literal.
    EmptyChar = 8,

    /// E0009: Invalid character literal (multiple characters).
    MultiCharLiteral = 9,

    /// E0010: Invalid Unicode escape.
    InvalidUnicodeEscape = 10,

    /// E0011: Number literal too large.
    NumberTooLarge = 11,

    // ========================================================================
    // Parser Errors (E0100-E0199)
    // ========================================================================

    /// E0100: Unexpected token.
    UnexpectedToken = 100,

    /// E0101: Unexpected end of file.
    UnexpectedEof = 101,

    /// E0102: Missing expected item.
    MissingItem = 102,

    /// E0103: Invalid item in this context.
    InvalidItem = 103,

    /// E0104: Unclosed delimiter.
    UnclosedDelimiter = 104,

    /// E0105: Missing type annotation.
    MissingType = 105,

    /// E0106: Invalid pattern.
    InvalidPattern = 106,

    /// E0107: Invalid expression.
    InvalidExpression = 107,

    /// E0108: Expected identifier.
    ExpectedIdentifier = 108,

    /// E0109: Expected type.
    ExpectedType = 109,

    /// E0110: Expected expression.
    ExpectedExpression = 110,

    /// E0111: Expected pattern.
    ExpectedPattern = 111,

    /// E0112: Duplicate modifier.
    DuplicateModifier = 112,

    /// E0113: Invalid visibility specifier.
    InvalidVisibility = 113,

    /// E0114: Missing function body.
    MissingFunctionBody = 114,

    /// E0115: Invalid match arm.
    InvalidMatchArm = 115,

    /// E0116: Unsupported macro.
    UnsupportedMacro = 116,

    /// E0117: Syntax from another language not supported.
    UnsupportedSyntax = 117,

    /// E0118: Invalid macro fragment specifier.
    InvalidMacroFragment = 118,

    /// E0119: Missing comma or separator.
    MissingSeparator = 119,

    /// E0120: Trailing separator not allowed.
    TrailingSeparator = 120,

    /// E0121: Invalid attribute.
    InvalidAttribute = 121,

    /// E0122: Attribute not allowed here.
    AttributeNotAllowed = 122,

    // ========================================================================
    // Name Resolution Errors (E0200-E0299)
    // ========================================================================

    /// E0200: Undefined identifier.
    UndefinedIdentifier = 200,

    /// E0201: Undefined type.
    UndefinedType = 201,

    /// E0202: Undefined module.
    UndefinedModule = 202,

    /// E0203: Ambiguous name (multiple definitions match).
    AmbiguousName = 203,

    /// E0204: Name already defined.
    DuplicateDefinition = 204,

    /// E0205: Private item not accessible.
    PrivateItem = 205,

    /// E0206: Circular dependency.
    CircularDependency = 206,

    /// E0207: Import not found.
    ImportNotFound = 207,

    /// E0208: Cannot import from self.
    SelfImport = 208,

    /// E0209: Module path too deep.
    ModulePathTooDeep = 209,

    /// E0210: Glob import conflict.
    GlobImportConflict = 210,

    // ========================================================================
    // Type Errors (E0300-E0399)
    // ========================================================================

    /// E0300: Type mismatch.
    TypeMismatch = 300,

    /// E0301: Expected function type.
    ExpectedFunction = 301,

    /// E0302: Wrong number of arguments.
    WrongArgCount = 302,

    /// E0303: Wrong number of type arguments.
    WrongTypeArgCount = 303,

    /// E0304: Type annotation required.
    TypeAnnotationRequired = 304,

    /// E0305: Cannot infer type.
    CannotInferType = 305,

    /// E0306: Infinite type (occurs check).
    InfiniteType = 306,

    /// E0307: Field not found.
    FieldNotFound = 307,

    /// E0308: Method not found.
    MethodNotFound = 308,

    /// E0309: Variant not found.
    VariantNotFound = 309,

    /// E0310: Invalid cast.
    InvalidCast = 310,

    /// E0311: Trait not implemented.
    TraitNotImplemented = 311,

    /// E0312: Duplicate trait implementation.
    DuplicateTraitImpl = 312,

    /// E0313: Conflicting trait implementations.
    ConflictingTraitImpl = 313,

    /// E0314: Missing trait method.
    MissingTraitMethod = 314,

    /// E0315: Extra trait method.
    ExtraTraitMethod = 315,

    /// E0316: Invalid return type.
    InvalidReturnType = 316,

    /// E0317: Cannot return value from unit function.
    UnexpectedReturn = 317,

    /// E0318: Missing return value.
    MissingReturn = 318,

    /// E0319: Invalid operator for types.
    InvalidOperator = 319,

    /// E0320: Cannot mutate immutable binding.
    CannotMutate = 320,

    /// E0321: Borrowing violation.
    BorrowViolation = 321,

    /// E0322: Use after move.
    UseAfterMove = 322,

    // ========================================================================
    // Effect Errors (E0400-E0499)
    // ========================================================================

    /// E0400: Unhandled effect.
    UnhandledEffect = 400,

    /// E0401: Effect not in scope.
    EffectNotInScope = 401,

    /// E0402: Invalid effect handler.
    InvalidHandler = 402,

    /// E0403: Handler does not match effect.
    HandlerMismatch = 403,

    /// E0404: Missing effect operation.
    MissingOperation = 404,

    /// E0405: Extra effect operation.
    ExtraOperation = 405,

    /// E0406: Effect operation type mismatch.
    OperationTypeMismatch = 406,

    /// E0407: Cannot resume after effect.
    CannotResume = 407,

    /// E0408: Resume type mismatch.
    ResumeTypeMismatch = 408,

    /// E0409: Effect row mismatch.
    EffectRowMismatch = 409,

    /// E0410: Cannot perform effect in pure context.
    EffectInPureContext = 410,

    // ========================================================================
    // Pattern Errors (E0500-E0599)
    // ========================================================================

    /// E0500: Non-exhaustive patterns.
    NonExhaustivePatterns = 500,

    /// E0501: Unreachable pattern.
    UnreachablePattern = 501,

    /// E0502: Invalid pattern for type.
    InvalidPatternForType = 502,

    /// E0503: Binding used multiple times in pattern.
    DuplicateBinding = 503,

    /// E0504: Missing fields in pattern.
    MissingFields = 504,

    /// E0505: Unknown field in pattern.
    UnknownField = 505,

    /// E0506: Rest pattern not allowed here.
    InvalidRestPattern = 506,

    /// E0507: Or-pattern binding mismatch.
    OrPatternBindingMismatch = 507,

    // ========================================================================
    // Codegen Errors (E0600-E0699)
    // ========================================================================

    /// E0600: Invalid FFI signature.
    InvalidFfiSignature = 600,

    /// E0601: Unsupported target.
    UnsupportedTarget = 601,

    /// E0602: Link error.
    LinkError = 602,

    /// E0603: Invalid inline assembly.
    InvalidAsm = 603,

    /// E0604: Stack overflow during compilation.
    StackOverflow = 604,

    /// E0605: Resource limit exceeded.
    ResourceLimitExceeded = 605,

    // ========================================================================
    // Internal Compiler Errors (E9000-E9999)
    // ========================================================================

    /// E9000: Internal compiler error.
    InternalError = 9000,

    /// E9001: Assertion failed.
    AssertionFailed = 9001,

    /// E9002: Unreachable code reached.
    UnreachableReached = 9002,

    /// E9003: Invalid compiler state.
    InvalidState = 9003,

    // ========================================================================
    // Memory/Pointer Warnings (W0001-W0099)
    // Warning codes use 10000+ to distinguish from errors
    // ========================================================================

    /// W0001: Deeply nested box types.
    DeeplyNestedBox = 10001,

    /// W0002: Struct with high pointer density.
    PointerHeavyStruct = 10002,

    /// W0003: Linked list pattern detected.
    LinkedListPattern = 10003,

    /// W0004: Array of pointers detected.
    PointerArrayPattern = 10004,

    /// W0005: Excessive indirection.
    ExcessiveIndirection = 10005,

    // ========================================================================
    // Style Warnings (W0100-W0199)
    // ========================================================================

    /// W0100: Unused variable.
    UnusedVariable = 10100,

    /// W0101: Unused import.
    UnusedImport = 10101,

    /// W0102: Unused function.
    UnusedFunction = 10102,

    /// W0103: Unused type.
    UnusedType = 10103,

    /// W0104: Unused field.
    UnusedField = 10104,

    /// W0105: Dead code.
    DeadCode = 10105,

    /// W0106: Naming convention violation.
    NamingConvention = 10106,

    /// W0107: Redundant code.
    RedundantCode = 10107,

    // ========================================================================
    // Performance Warnings (W0200-W0299)
    // ========================================================================

    /// W0200: Unnecessary allocation.
    UnnecessaryAllocation = 10200,

    /// W0201: Expensive clone.
    ExpensiveClone = 10201,

    /// W0202: Inefficient iteration.
    InefficientIteration = 10202,

    // ========================================================================
    // Effect/Handler Warnings (W0300-W0399)
    // ========================================================================

    /// W0300: Deeply nested effect handlers.
    DeeplyNestedHandlers = 10300,

    /// W0301: Handler with many operations.
    LargeHandler = 10301,

    // ========================================================================
    // Deprecation Warnings (W0400-W0499)
    // ========================================================================

    /// W0400: Deprecated item.
    Deprecated = 10400,

    /// W0401: Deprecated syntax.
    DeprecatedSyntax = 10401,
}

impl ErrorCode {
    /// Get the formatted code string (e.g., "E0001" or "W0001").
    pub fn as_str(self) -> String {
        let code = self as u16;
        if code >= 10000 {
            // Warnings: W prefix, subtract 10000
            let warning_code = code - 10000;
            "W" ++ Self::format_number(warning_code)
        } else {
            // Errors: E prefix
            "E" ++ Self::format_number(code)
        }
    }

    /// Format a number as 4 digits with leading zeros.
    fn format_number(n: u16) -> String {
        if n < 10 {
            "000" ++ n.to_string()
        } else if n < 100 {
            "00" ++ n.to_string()
        } else if n < 1000 {
            "0" ++ n.to_string()
        } else {
            n.to_string();
        }
    }

    /// Check if this is a warning code.
    pub fn is_warning(self) -> bool {
        (self as u16) >= 10000
    }

    /// Check if this is an error code.
    pub fn is_error(self) -> bool {
        !self.is_warning()
    }

    /// Check if this is an internal compiler error.
    pub fn is_ice(self) -> bool {
        let code = self as u16;
        code >= 9000 && code < 10000
    }

    /// Get the short description of this error.
    pub fn description(self) -> String {
        match self {
            // Lexer errors
            ErrorCode::UnexpectedCharacter => "unexpected character in source",
            ErrorCode::UnclosedBlockComment => "unclosed block comment",
            ErrorCode::UnclosedString => "unclosed string literal",
            ErrorCode::InvalidEscape => "invalid escape sequence",
            ErrorCode::InvalidInteger => "invalid integer literal",
            ErrorCode::InvalidFloat => "invalid float literal",
            ErrorCode::UnclosedChar => "unclosed character literal",
            ErrorCode::EmptyChar => "empty character literal",
            ErrorCode::MultiCharLiteral => "character literal contains multiple characters",
            ErrorCode::InvalidUnicodeEscape => "invalid Unicode escape sequence",
            ErrorCode::NumberTooLarge => "number literal is too large",

            // Parser errors
            ErrorCode::UnexpectedToken => "unexpected token",
            ErrorCode::UnexpectedEof => "unexpected end of file",
            ErrorCode::MissingItem => "missing required item",
            ErrorCode::InvalidItem => "invalid item in this context",
            ErrorCode::UnclosedDelimiter => "unclosed delimiter",
            ErrorCode::MissingType => "missing type annotation",
            ErrorCode::InvalidPattern => "invalid pattern",
            ErrorCode::InvalidExpression => "invalid expression",
            ErrorCode::ExpectedIdentifier => "expected identifier",
            ErrorCode::ExpectedType => "expected type",
            ErrorCode::ExpectedExpression => "expected expression",
            ErrorCode::ExpectedPattern => "expected pattern",
            ErrorCode::DuplicateModifier => "duplicate modifier",
            ErrorCode::InvalidVisibility => "invalid visibility specifier",
            ErrorCode::MissingFunctionBody => "missing function body",
            ErrorCode::InvalidMatchArm => "invalid match arm",
            ErrorCode::UnsupportedMacro => "unsupported or undefined macro",
            ErrorCode::UnsupportedSyntax => "unsupported syntax",
            ErrorCode::InvalidMacroFragment => "invalid macro fragment specifier",
            ErrorCode::MissingSeparator => "missing comma or separator",
            ErrorCode::TrailingSeparator => "trailing separator not allowed",
            ErrorCode::InvalidAttribute => "invalid attribute",
            ErrorCode::AttributeNotAllowed => "attribute not allowed here",

            // Name resolution errors
            ErrorCode::UndefinedIdentifier => "undefined identifier",
            ErrorCode::UndefinedType => "undefined type",
            ErrorCode::UndefinedModule => "undefined module",
            ErrorCode::AmbiguousName => "ambiguous name",
            ErrorCode::DuplicateDefinition => "duplicate definition",
            ErrorCode::PrivateItem => "item is private",
            ErrorCode::CircularDependency => "circular dependency",
            ErrorCode::ImportNotFound => "import not found",
            ErrorCode::SelfImport => "cannot import from self",
            ErrorCode::ModulePathTooDeep => "module path too deep",
            ErrorCode::GlobImportConflict => "glob import conflict",

            // Type errors
            ErrorCode::TypeMismatch => "type mismatch",
            ErrorCode::ExpectedFunction => "expected function type",
            ErrorCode::WrongArgCount => "wrong number of arguments",
            ErrorCode::WrongTypeArgCount => "wrong number of type arguments",
            ErrorCode::TypeAnnotationRequired => "type annotation required",
            ErrorCode::CannotInferType => "cannot infer type",
            ErrorCode::InfiniteType => "infinite type",
            ErrorCode::FieldNotFound => "field not found",
            ErrorCode::MethodNotFound => "method not found",
            ErrorCode::VariantNotFound => "variant not found",
            ErrorCode::InvalidCast => "invalid cast",
            ErrorCode::TraitNotImplemented => "trait not implemented",
            ErrorCode::DuplicateTraitImpl => "duplicate trait implementation",
            ErrorCode::ConflictingTraitImpl => "conflicting trait implementations",
            ErrorCode::MissingTraitMethod => "missing trait method",
            ErrorCode::ExtraTraitMethod => "unexpected trait method",
            ErrorCode::InvalidReturnType => "invalid return type",
            ErrorCode::UnexpectedReturn => "unexpected return value",
            ErrorCode::MissingReturn => "missing return value",
            ErrorCode::InvalidOperator => "invalid operator for types",
            ErrorCode::CannotMutate => "cannot mutate immutable binding",
            ErrorCode::BorrowViolation => "borrowing violation",
            ErrorCode::UseAfterMove => "use after move",

            // Effect errors
            ErrorCode::UnhandledEffect => "unhandled effect",
            ErrorCode::EffectNotInScope => "effect not in scope",
            ErrorCode::InvalidHandler => "invalid effect handler",
            ErrorCode::HandlerMismatch => "handler does not match effect",
            ErrorCode::MissingOperation => "missing effect operation",
            ErrorCode::ExtraOperation => "unexpected effect operation",
            ErrorCode::OperationTypeMismatch => "effect operation type mismatch",
            ErrorCode::CannotResume => "cannot resume after effect",
            ErrorCode::ResumeTypeMismatch => "resume type mismatch",
            ErrorCode::EffectRowMismatch => "effect row mismatch",
            ErrorCode::EffectInPureContext => "cannot perform effect in pure context",

            // Pattern errors
            ErrorCode::NonExhaustivePatterns => "non-exhaustive patterns",
            ErrorCode::UnreachablePattern => "unreachable pattern",
            ErrorCode::InvalidPatternForType => "invalid pattern for type",
            ErrorCode::DuplicateBinding => "duplicate binding in pattern",
            ErrorCode::MissingFields => "missing fields in pattern",
            ErrorCode::UnknownField => "unknown field in pattern",
            ErrorCode::InvalidRestPattern => "rest pattern not allowed here",
            ErrorCode::OrPatternBindingMismatch => "or-pattern binding mismatch",

            // Codegen errors
            ErrorCode::InvalidFfiSignature => "invalid FFI signature",
            ErrorCode::UnsupportedTarget => "unsupported target",
            ErrorCode::LinkError => "link error",
            ErrorCode::InvalidAsm => "invalid inline assembly",
            ErrorCode::StackOverflow => "stack overflow during compilation",
            ErrorCode::ResourceLimitExceeded => "resource limit exceeded",

            // ICE
            ErrorCode::InternalError => "internal compiler error",
            ErrorCode::AssertionFailed => "assertion failed",
            ErrorCode::UnreachableReached => "unreachable code was reached",
            ErrorCode::InvalidState => "invalid compiler state",

            // Memory warnings
            ErrorCode::DeeplyNestedBox => "deeply nested box type",
            ErrorCode::PointerHeavyStruct => "struct has high pointer density",
            ErrorCode::LinkedListPattern => "linked list pattern detected",
            ErrorCode::PointerArrayPattern => "array of pointers detected",
            ErrorCode::ExcessiveIndirection => "excessive pointer indirection",

            // Style warnings
            ErrorCode::UnusedVariable => "unused variable",
            ErrorCode::UnusedImport => "unused import",
            ErrorCode::UnusedFunction => "unused function",
            ErrorCode::UnusedType => "unused type",
            ErrorCode::UnusedField => "unused field",
            ErrorCode::DeadCode => "dead code",
            ErrorCode::NamingConvention => "naming convention violation",
            ErrorCode::RedundantCode => "redundant code",

            // Performance warnings
            ErrorCode::UnnecessaryAllocation => "unnecessary allocation",
            ErrorCode::ExpensiveClone => "expensive clone operation",
            ErrorCode::InefficientIteration => "inefficient iteration",

            // Effect warnings
            ErrorCode::DeeplyNestedHandlers => "deeply nested effect handlers",
            ErrorCode::LargeHandler => "handler with many operations",

            // Deprecation warnings
            ErrorCode::Deprecated => "use of deprecated item",
            ErrorCode::DeprecatedSyntax => "use of deprecated syntax",
        }
    }

    /// Get a help message for fixing this error.
    pub fn help(self) -> Option<String> {
        match self {
            // Lexer errors
            ErrorCode::UnclosedBlockComment =>
                Option::Some("add `*/` to close the block comment"),
            ErrorCode::UnclosedString =>
                Option::Some("add a closing `\"` to complete the string"),
            ErrorCode::UnclosedChar =>
                Option::Some("add a closing `'` to complete the character literal"),
            ErrorCode::EmptyChar =>
                Option::Some("character literals must contain exactly one character"),
            ErrorCode::InvalidEscape =>
                Option::Some("valid escape sequences: \\n, \\r, \\t, \\\\, \\', \\\", \\0, \\x##, \\u{####}"),

            // Parser errors
            ErrorCode::UnclosedDelimiter =>
                Option::Some("check for matching opening and closing delimiters"),
            ErrorCode::MissingType =>
                Option::Some("add a type annotation after the `:`"),
            ErrorCode::MissingFunctionBody =>
                Option::Some("add a function body `{ ... }` or use `;` for a declaration"),

            // Type errors
            ErrorCode::TypeMismatch =>
                Option::Some("check that the types match or add an explicit conversion"),
            ErrorCode::CannotInferType =>
                Option::Some("add a type annotation to help the compiler"),

            // Memory warnings
            ErrorCode::DeeplyNestedBox =>
                Option::Some("consider using `Box<T>` directly; each nesting adds ~4 cycles per access"),
            ErrorCode::PointerHeavyStruct =>
                Option::Some("consider storing values directly or using indices; 128-bit pointers double memory"),
            ErrorCode::LinkedListPattern =>
                Option::Some("linked lists have poor cache locality; consider using Vec<T> or indices"),
            ErrorCode::PointerArrayPattern =>
                Option::Some("arrays of pointers have 2x memory overhead; consider storing values directly"),
            ErrorCode::ExcessiveIndirection =>
                Option::Some("each pointer dereference costs ~4 cycles; flatten the data structure"),

            // Effect warnings
            ErrorCode::DeeplyNestedHandlers =>
                Option::Some("each nested handler adds ~2.6 cycles lookup overhead; consider combining handlers"),
            ErrorCode::LargeHandler =>
                Option::Some("handlers with many operations may be harder to maintain; consider splitting"),

            // Style warnings
            ErrorCode::UnusedVariable =>
                Option::Some("prefix with `_` to indicate intentionally unused: `_unused`"),

            // Default: no help
            _ => Option::None,
        }
    }

    /// Get the detailed explanation for this error (for `--explain`).
    ///
    /// Returns None if no detailed explanation is available.
    pub fn explanation(self) -> Option<String> {
        // Long-form explanations would go here
        // For now, return None (to be filled in later)
        Option::None
    }
}

// ============================================================================
// Diagnostic Group
// ============================================================================

/// A group of related diagnostics.
///
/// Groups allow bulk configuration of related diagnostics:
/// - `--warn-error Types` - Treat all type warnings as errors
/// - `--allow Unused` - Suppress all unused warnings
pub enum DiagnosticGroup {
    /// Lexical analysis issues.
    Lexer,

    /// Syntax/parsing issues.
    Syntax,

    /// Name resolution issues.
    Resolution,

    /// Type checking issues.
    Types,

    /// Effect system issues.
    Effects,

    /// Pattern matching issues.
    Patterns,

    /// Code generation issues.
    Codegen,

    /// Memory/pointer warnings.
    Memory,

    /// Performance warnings.
    Performance,

    /// Style/convention warnings.
    Style,

    /// Unused code warnings.
    Unused,

    /// Deprecation warnings.
    Deprecation,
}

impl DiagnosticGroup {
    /// Get the name of this group.
    pub fn name(self) -> String {
        match self {
            DiagnosticGroup::Lexer => "Lexer",
            DiagnosticGroup::Syntax => "Syntax",
            DiagnosticGroup::Resolution => "Resolution",
            DiagnosticGroup::Types => "Types",
            DiagnosticGroup::Effects => "Effects",
            DiagnosticGroup::Patterns => "Patterns",
            DiagnosticGroup::Codegen => "Codegen",
            DiagnosticGroup::Memory => "Memory",
            DiagnosticGroup::Performance => "Performance",
            DiagnosticGroup::Style => "Style",
            DiagnosticGroup::Unused => "Unused",
            DiagnosticGroup::Deprecation => "Deprecation",
        }
    }

    /// Get the group for an error code.
    pub fn for_code(code: ErrorCode) -> DiagnosticGroup {
        let n = code as u16;
        if n < 100 {
            DiagnosticGroup::Lexer
        } else if n < 200 {
            DiagnosticGroup::Syntax
        } else if n < 300 {
            DiagnosticGroup::Resolution
        } else if n < 400 {
            DiagnosticGroup::Types
        } else if n < 500 {
            DiagnosticGroup::Effects
        } else if n < 600 {
            DiagnosticGroup::Patterns
        } else if n < 700 {
            DiagnosticGroup::Codegen
        } else if n >= 10000 && n < 10100 {
            DiagnosticGroup::Memory
        } else if n >= 10100 && n < 10200 {
            DiagnosticGroup::Style
        } else if n >= 10200 && n < 10300 {
            DiagnosticGroup::Performance
        } else if n >= 10300 && n < 10400 {
            DiagnosticGroup::Effects
        } else if n >= 10400 && n < 10500 {
            DiagnosticGroup::Deprecation
        } else {
            // Default for ICE and unknown
            DiagnosticGroup::Codegen
        }
    }
}

impl ErrorCode {
    /// Get the diagnostic group for this error code.
    pub fn group(self) -> DiagnosticGroup {
        DiagnosticGroup::for_code(self)
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_error_code_as_str() {
    assert(ErrorCode::UnexpectedCharacter.as_str() == "E0001");
    assert(ErrorCode::UnexpectedToken.as_str() == "E0100");
    assert(ErrorCode::TypeMismatch.as_str() == "E0300");
    assert(ErrorCode::InternalError.as_str() == "E9000");
}

#[test]
fn test_warning_code_as_str() {
    assert(ErrorCode::UnusedVariable.as_str() == "W0100");
    assert(ErrorCode::DeeplyNestedBox.as_str() == "W0001");
    assert(ErrorCode::Deprecated.as_str() == "W0400");
}

#[test]
fn test_is_warning() {
    assert(!ErrorCode::TypeMismatch.is_warning());
    assert(!ErrorCode::InternalError.is_warning());
    assert(ErrorCode::UnusedVariable.is_warning());
    assert(ErrorCode::DeeplyNestedBox.is_warning());
}

#[test]
fn test_is_error() {
    assert(ErrorCode::TypeMismatch.is_error());
    assert(ErrorCode::InternalError.is_error());
    assert(!ErrorCode::UnusedVariable.is_error());
}

#[test]
fn test_is_ice() {
    assert(!ErrorCode::TypeMismatch.is_ice());
    assert(ErrorCode::InternalError.is_ice());
    assert(ErrorCode::AssertionFailed.is_ice());
    assert(!ErrorCode::UnusedVariable.is_ice());
}

#[test]
fn test_description_not_empty() {
    // All error codes should have descriptions
    assert(ErrorCode::UnexpectedCharacter.description().len() > 0);
    assert(ErrorCode::TypeMismatch.description().len() > 0);
    assert(ErrorCode::UnusedVariable.description().len() > 0);
}

#[test]
fn test_help_messages() {
    // Some codes have help, some don't
    assert(ErrorCode::UnclosedString.help().is_some());
    assert(ErrorCode::EmptyChar.help().is_some());
    // Type mismatch has help
    assert(ErrorCode::TypeMismatch.help().is_some());
}

#[test]
fn test_diagnostic_group_for_code() {
    assert(ErrorCode::UnexpectedCharacter.group().name() == "Lexer");
    assert(ErrorCode::UnexpectedToken.group().name() == "Syntax");
    assert(ErrorCode::UndefinedIdentifier.group().name() == "Resolution");
    assert(ErrorCode::TypeMismatch.group().name() == "Types");
    assert(ErrorCode::UnhandledEffect.group().name() == "Effects");
    assert(ErrorCode::NonExhaustivePatterns.group().name() == "Patterns");
}

#[test]
fn test_warning_groups() {
    assert(ErrorCode::DeeplyNestedBox.group().name() == "Memory");
    assert(ErrorCode::UnusedVariable.group().name() == "Style");
    assert(ErrorCode::UnnecessaryAllocation.group().name() == "Performance");
    assert(ErrorCode::Deprecated.group().name() == "Deprecation");
}
