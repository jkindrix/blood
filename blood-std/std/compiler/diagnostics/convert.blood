//! # Diagnostic Conversion Traits
//!
//! Provides traits for converting module-specific error types into Diagnostics.
//!
//! ## Design Philosophy
//!
//! Following the patterns from rustc and miette:
//! - `IntoDiagnostic` - Converts any error type into a Diagnostic
//! - `SpanConvert` - Converts simple spans to rich diagnostic spans
//!
//! This allows each compiler phase to define its own error types while
//! still producing unified diagnostics output.
//!
//! ## Example
//!
//! ```blood
//! impl IntoDiagnostic for TypeError {
//!     fn into_diagnostic(self, ctx: DiagnosticConverter) -> Diagnostic {
//!         Diagnostic::error(self.kind.message())
//!             .with_span(ctx.convert_span(self.span))
//!             .with_code(self.error_code())
//!     }
//! }
//! ```

module std.compiler.diagnostics.convert;

use std.option.Option;
use std.compiler.diagnostics.diagnostic.Diagnostic;
use std.compiler.diagnostics.severity.Severity;
use std.compiler.diagnostics.code.ErrorCode;
use std.compiler.diagnostics.span.Span as DiagSpan;
use std.compiler.diagnostics.span.FileId;
use std.compiler.diagnostics.span.Position;
use std.compiler.diagnostics.label.Label;
use std.compiler.diagnostics.label.LabelKind;
use std.compiler.diagnostics.renderer.source.SourceMap;
use std.compiler.diagnostics.renderer.source.SourceFile;

// ============================================================================
// Simple Span (from parser/HIR)
// ============================================================================

/// A simple byte-offset span from the parser/HIR.
///
/// This mirrors the existing Span type used throughout the compiler.
/// We define it here to avoid circular dependencies.
pub struct SimpleSpan {
    /// Start byte offset.
    start: U32,
    /// End byte offset.
    end: U32,
}

impl SimpleSpan {
    /// Create a new simple span.
    pub fn new(start: U32, end: U32) -> SimpleSpan {
        SimpleSpan { start, end }
    }

    /// Get the start offset.
    pub fn start(self) -> U32 {
        self.start
    }

    /// Get the end offset.
    pub fn end(self) -> U32 {
        self.end
    }

    /// Check if this is a dummy span.
    pub fn is_dummy(self) -> Bool {
        self.start == 0 && self.end == 0;
    }

    /// Create a dummy span.
    pub fn dummy() -> SimpleSpan {
        SimpleSpan { start: 0, end: 0 }
    }
}

// ============================================================================
// Diagnostic Converter
// ============================================================================

/// Provides context for converting errors to diagnostics.
///
/// This is passed to `IntoDiagnostic::into_diagnostic` to provide:
/// - Source map for resolving spans to line/column
/// - Current file ID for the compilation unit
/// - Utility methods for span conversion
pub struct DiagnosticConverter {
    /// The source map for looking up files.
    source_map: SourceMap,

    /// The current file being processed.
    current_file: FileId,
}

impl DiagnosticConverter {
    /// Create a new diagnostic converter.
    pub fn new(source_map: SourceMap, current_file: FileId) -> DiagnosticConverter {
        DiagnosticConverter {
            source_map,
            current_file,
        }
    }

    /// Create a converter with an empty source map.
    ///
    /// Useful for testing or when source mapping is not needed.
    pub fn empty() -> DiagnosticConverter {
        DiagnosticConverter {
            source_map: SourceMap::new(),
            current_file: FileId::dummy(),
        }
    }

    /// Get the source map.
    pub fn source_map(self) -> SourceMap {
        self.source_map.clone();
    }

    /// Get the current file ID.
    pub fn current_file(self) -> FileId {
        self.current_file
    }

    /// Convert a simple span to a diagnostic span.
    ///
    /// Uses the current file and source map to resolve line/column info.
    pub fn convert_span(self, span: SimpleSpan) -> DiagSpan {
        if span.is_dummy() {
            return DiagSpan::dummy();
        };

        let file_id = self.current_file;

        // Try to get line/column info from source map
        match self.source_map.get(file_id) {
            Option::Some(file) => {
                let (start_line, start_col) = file.line_col(span.start() as USize);
                let (end_line, end_col) = file.line_col(span.end() as USize);

                DiagSpan::new(
                    file_id,
                    Position::new(span.start() as USize, start_line, start_col),
                    Position::new(span.end() as USize, end_line, end_col),
                )
            }
            Option::None => {
                // Fall back to offset-only span if source not available
                DiagSpan::from_offsets(file_id, span.start() as USize, span.end() as USize)
            }
        }
    }

    /// Convert a span with a specific file ID.
    pub fn convert_span_with_file(self, span: SimpleSpan, file_id: FileId) -> DiagSpan {
        if span.is_dummy() {
            return DiagSpan::dummy();
        };

        match self.source_map.get(file_id) {
            Option::Some(file) => {
                let (start_line, start_col) = file.line_col(span.start() as USize);
                let (end_line, end_col) = file.line_col(span.end() as USize);

                DiagSpan::new(
                    file_id,
                    Position::new(span.start() as USize, start_line, start_col),
                    Position::new(span.end() as USize, end_line, end_col),
                )
            }
            Option::None => {
                DiagSpan::from_offsets(file_id, span.start() as USize, span.end() as USize)
            }
        }
    }

    /// Create a primary label with the given message.
    pub fn primary_label(self, span: SimpleSpan, message: String) -> Label {
        Label::primary(self.convert_span(span), message)
    }

    /// Create a secondary label with the given message.
    pub fn secondary_label(self, span: SimpleSpan, message: String) -> Label {
        Label::secondary(self.convert_span(span), message)
    }

    /// Set the current file for subsequent conversions.
    pub fn with_file(mut self, file_id: FileId) -> DiagnosticConverter {
        self.current_file = file_id;
        self
    }
}

// ============================================================================
// IntoDiagnostic Trait
// ============================================================================

/// Trait for converting error types into Diagnostics.
///
/// This is the core integration point for the diagnostic system.
/// Each module's error type should implement this trait to enable
/// unified diagnostic output.
///
/// ## Implementation Guidelines
///
/// 1. Map error variants to appropriate ErrorCodes
/// 2. Use the converter to resolve spans
/// 3. Add relevant labels (primary for main error, secondary for context)
/// 4. Include suggestions when the fix is clear
/// 5. Add help messages for guidance
///
/// ## Example
///
/// ```blood
/// impl IntoDiagnostic for MyError {
///     fn into_diagnostic(self, ctx: DiagnosticConverter) -> Diagnostic {
///         match self.kind {
///             MyErrorKind::NotFound { name } => {
///                 Diagnostic::error(format!("cannot find `{}`", name))
///                     .with_span(ctx.convert_span(self.span))
///                     .with_code(ErrorCode::UnresolvedName)
///                     .with_primary_label("not found in this scope")
///             }
///             // ... other variants
///         }
///     }
/// }
/// ```
pub trait IntoDiagnostic {
    /// Convert this error into a Diagnostic.
    fn into_diagnostic(self, ctx: DiagnosticConverter) -> Diagnostic;
}

// ============================================================================
// IntoDiagnosticVec - For collections of errors
// ============================================================================

/// Extension trait for converting collections of errors.
pub trait IntoDiagnosticVec {
    /// Convert all errors to diagnostics.
    fn into_diagnostics(self, ctx: DiagnosticConverter) -> Vec<Diagnostic>;
}

// Generic implementation for Vec of IntoDiagnostic types would go here
// when Blood supports generic trait implementations

// ============================================================================
// Diagnostic Builder Extensions
// ============================================================================

/// Extension methods for building diagnostics from simple spans.
impl Diagnostic {
    /// Create an error diagnostic with a simple span.
    pub fn error_at(message: String, span: SimpleSpan, ctx: DiagnosticConverter) -> Diagnostic {
        Diagnostic::error(message).with_span(ctx.convert_span(span))
    }

    /// Create a warning diagnostic with a simple span.
    pub fn warning_at(message: String, span: SimpleSpan, ctx: DiagnosticConverter) -> Diagnostic {
        Diagnostic::warning(message).with_span(ctx.convert_span(span))
    }

    /// Create a note diagnostic with a simple span.
    pub fn note_at(message: String, span: SimpleSpan, ctx: DiagnosticConverter) -> Diagnostic {
        Diagnostic::note(message).with_span(ctx.convert_span(span))
    }

    /// Add a primary label using a simple span.
    pub fn with_simple_primary_label(mut self, span: SimpleSpan, message: String, ctx: DiagnosticConverter) -> Diagnostic {
        let diag_span = ctx.convert_span(span);
        self.with_label(Label::primary(diag_span, message));
    }

    /// Add a secondary label using a simple span.
    pub fn with_simple_secondary_label(mut self, span: SimpleSpan, message: String, ctx: DiagnosticConverter) -> Diagnostic {
        let diag_span = ctx.convert_span(span);
        self.with_label(Label::secondary(diag_span, message));
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_simple_span_creation() {
    let span = SimpleSpan::new(10, 20);

    assert(span.start() == 10);
    assert(span.end() == 20);
    assert(!span.is_dummy());
}

#[test]
fn test_simple_span_dummy() {
    let span = SimpleSpan::dummy();

    assert(span.is_dummy());
    assert(span.start() == 0);
    assert(span.end() == 0);
}

#[test]
fn test_diagnostic_converter_empty() {
    let ctx = DiagnosticConverter::empty();

    assert(ctx.current_file().is_dummy());
}

#[test]
fn test_diagnostic_converter_with_source() {
    let mut source_map = SourceMap::new();
    let file_id = source_map.add("test.blood", "fn main() {\n    let x = 42\n}");

    let ctx = DiagnosticConverter::new(source_map, file_id);

    assert(!ctx.current_file().is_dummy());
}

#[test]
fn test_convert_span_with_source() {
    let mut source_map = SourceMap::new();
    let file_id = source_map.add("test.blood", "fn main() {\n    let x = 42\n}");

    let ctx = DiagnosticConverter::new(source_map, file_id);

    // Span pointing to "main"
    let simple = SimpleSpan::new(3, 7);
    let diag_span = ctx.convert_span(simple);

    assert(diag_span.start_line() == 1);
    assert(diag_span.start_column() == 4);  // "main" starts at column 4 (1-indexed)
}

#[test]
fn test_convert_span_dummy() {
    let ctx = DiagnosticConverter::empty();

    let simple = SimpleSpan::dummy();
    let diag_span = ctx.convert_span(simple);

    assert(diag_span.is_dummy());
}

#[test]
fn test_primary_label_creation() {
    let mut source_map = SourceMap::new();
    let file_id = source_map.add("test.blood", "let x = 42");

    let ctx = DiagnosticConverter::new(source_map, file_id);
    let span = SimpleSpan::new(4, 5);

    let label = ctx.primary_label(span, "this is x");

    assert(label.kind() == LabelKind::Primary);
}

#[test]
fn test_secondary_label_creation() {
    let mut source_map = SourceMap::new();
    let file_id = source_map.add("test.blood", "let x = 42");

    let ctx = DiagnosticConverter::new(source_map, file_id);
    let span = SimpleSpan::new(8, 10);

    let label = ctx.secondary_label(span, "value here");

    assert(label.kind() == LabelKind::Secondary);
}

#[test]
fn test_with_file() {
    let mut source_map = SourceMap::new();
    let file1 = source_map.add("a.blood", "content a");
    let file2 = source_map.add("b.blood", "content b");

    let ctx = DiagnosticConverter::new(source_map, file1);
    assert(ctx.current_file() == file1);

    let ctx2 = ctx.with_file(file2);
    assert(ctx2.current_file() == file2);
}
