//! Eq/PartialEq Derive Implementation
//!
//! Generates `fn eq(&self, other: &Self) -> bool` for structs and enums.
//!
//! # Generated Code Example
//!
//! For a struct:
//! ```blood
//! #[derive(Eq)]
//! struct Point { x: i32, y: i32 }
//!
//! // Generates:
//! impl Point {
//!     fn eq(&self, other: &Point) -> bool {
//!         self.x.eq(&other.x) && self.y.eq(&other.y)
//!     }
//! }
//! ```

module std.compiler.derive.eq;

use std.collections.Vec;
use std.core.Option;

use std.compiler.hir::{
    Body, BodyId, LocalId, Expr, ExprKind, Stmt, FnSig,
    Pattern, PatternKind, MatchArm, Span, LiteralValue, BinOp,
};
use std.compiler.typeck.types::{DefId, Type, TypeKind};
use std.compiler.derive::{DeriveKind, 
    DeriveExpander, DeriveRequest, StructInfo, EnumInfo, FieldInfo, VariantInfo,
    literal_expr, local_expr, bool_literal,
};

// ============================================================================
// Eq for Structs
// ============================================================================

/// Expand Eq derive for a struct.
pub fn expand_struct(expander: &mut DeriveExpander, request: &DeriveRequest) {
    let struct_info = match expander.get_struct_info(request) {
        Option::Some(info) => info.clone(),
        Option::None => return,
    };

    // Allocate DefId and BodyId
    let method_def_id = expander.alloc_def_id();
    let body_id = expander.alloc_body_id();

    // Get Self type
    let self_ty = expander.get_self_type(request);
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    // Create function signature: fn eq(&self, other: &Self) -> bool
    let sig = FnSig {
        params: vec![self_ref_ty.clone(), self_ref_ty.clone()],
        ret: Type::bool(),
        effect: Option::None,
        is_unsafe: false,
    };

    // Create the body
    let body = generate_struct_eq_body(&struct_info, &self_ty, body_id, request.span.clone());

    // Register
    expander.register_fn_sig(method_def_id.clone(), sig);
    expander.register_body(body_id.clone(), body);
    expander.register_fn_body(method_def_id.clone(), body_id);
    expander.register_method_self_type(method_def_id.clone(), self_ty);
    expander.create_impl_block(request, method_def_id, "eq".to_string(), false);
}

/// Generate the body of a struct eq method.
fn generate_struct_eq_body(
    struct_info: &StructInfo,
    self_ty: &Type,
    body_id: BodyId,
    span: Span,
) -> Body {
    let return_local = LocalId::new(0);
    let self_local = LocalId::new(1);
    let other_local = LocalId::new(2);

    // If no fields, return true
    if struct_info.fields.len() == 0 {
        return Body {
            id: body_id,
            params: vec![self_local, other_local],
            locals: Vec::new(),
            stmts: Vec::new(),
            value: Option::Some(bool_literal(true, span.clone())),
            span,
        };
    };

    // Build field comparison: self.f0.eq(&other.f0) && self.f1.eq(&other.f1) && ...
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    // Start with first field comparison
    let first_field = &struct_info.fields[0];
    let mut result = generate_field_eq(
        &self_local, &other_local, first_field, &self_ref_ty, &span
    );

    // Chain remaining comparisons with &&
    let mut i: usize = 1;
    while i < struct_info.fields.len() {
        let field = &struct_info.fields[i];
        let field_eq = generate_field_eq(
            &self_local, &other_local, field, &self_ref_ty, &span
        );

        result = Expr::new(
            ExprKind::Binary {
                op: BinOp::And,
                lhs: Box::new(result),
                rhs: Box::new(field_eq),
            },
            Type::bool(),
            span.clone(),
        );

        i = i + 1;
    }

    Body {
        id: body_id,
        params: vec![self_local, other_local],
        locals: Vec::new(),
        stmts: Vec::new(),
        value: Option::Some(result),
        span,
    }
}

/// Generate equality check for a single field.
fn generate_field_eq(
    self_local: &LocalId,
    other_local: &LocalId,
    field: &FieldInfo,
    self_ref_ty: &Type,
    span: &Span,
) -> Expr {
    // self.field
    let self_field = Expr::new(
        ExprKind::Field {
            base: Box::new(local_expr(self_local.clone(), self_ref_ty.clone(), span.clone())),
            field: field.name.clone(),
            field_idx: field.index,
        },
        field.ty.clone(),
        span.clone(),
    );

    // other.field
    let other_field = Expr::new(
        ExprKind::Field {
            base: Box::new(local_expr(other_local.clone(), self_ref_ty.clone(), span.clone())),
            field: field.name.clone(),
            field_idx: field.index,
        },
        field.ty.clone(),
        span.clone(),
    );

    // self.field.eq(&other.field)
    Expr::new(
        ExprKind::MethodCall {
            receiver: Box::new(self_field),
            method: "eq".to_string(),
            args: vec![Expr::new(
                ExprKind::Ref {
                    inner: Box::new(other_field),
                    mutable: false,
                },
                Type::reference(field.ty.clone(), false),
                span.clone(),
            )],
        },
        Type::bool(),
        span.clone(),
    )
}

// ============================================================================
// Eq for Enums
// ============================================================================

/// Expand Eq derive for an enum.
pub fn expand_enum(expander: &mut DeriveExpander, request: &DeriveRequest) {
    let enum_info = match expander.get_enum_info(request) {
        Option::Some(info) => info.clone(),
        Option::None => return,
    };

    let method_def_id = expander.alloc_def_id();
    let body_id = expander.alloc_body_id();

    let self_ty = expander.get_self_type(request);
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    let sig = FnSig {
        params: vec![self_ref_ty.clone(), self_ref_ty.clone()],
        ret: Type::bool(),
        effect: Option::None,
        is_unsafe: false,
    };

    let body = generate_enum_eq_body(&enum_info, &self_ty, body_id, request.span.clone());

    expander.register_fn_sig(method_def_id.clone(), sig);
    expander.register_body(body_id.clone(), body);
    expander.register_fn_body(method_def_id.clone(), body_id);
    expander.register_method_self_type(method_def_id.clone(), self_ty);
    expander.create_impl_block(request, method_def_id, "eq".to_string(), false);
}

/// Generate the body of an enum eq method.
fn generate_enum_eq_body(
    enum_info: &EnumInfo,
    self_ty: &Type,
    body_id: BodyId,
    span: Span,
) -> Body {
    let return_local = LocalId::new(0);
    let self_local = LocalId::new(1);
    let other_local = LocalId::new(2);

    // Build match arms for (self, other) pairs
    let mut arms: Vec<MatchArm> = Vec::new();

    // For each variant, create matching arm
    let mut i: usize = 0;
    while i < enum_info.variants.len() {
        let variant = &enum_info.variants[i];
        let arm = generate_eq_match_arm(enum_info, variant, self_ty, &span);
        arms.push(arm);
        i = i + 1;
    };

    // Add catch-all arm that returns false (different variants)
    arms.push(MatchArm {
        pattern: Pattern::new(
            PatternKind::Wildcard,
            Type::tuple(vec![Type::reference(self_ty.clone(), false), Type::reference(self_ty.clone(), false)]),
            span.clone(),
        ),
        guard: Option::None,
        body: bool_literal(false, span.clone()),
        span: span.clone(),
    });

    // Build tuple of (self, other) to match on
    let match_tuple = Expr::new(
        ExprKind::Tuple(vec![
            local_expr(self_local.clone(), Type::reference(self_ty.clone(), false), span.clone()),
            local_expr(other_local.clone(), Type::reference(self_ty.clone(), false), span.clone()),
        ]),
        Type::tuple(vec![Type::reference(self_ty.clone(), false), Type::reference(self_ty.clone(), false)]),
        span.clone(),
    );

    let match_expr = Expr::new(
        ExprKind::Match {
            scrutinee: Box::new(match_tuple),
            arms,
        },
        Type::bool(),
        span.clone(),
    );

    Body {
        id: body_id,
        params: vec![self_local, other_local],
        locals: Vec::new(),
        stmts: Vec::new(),
        value: Option::Some(match_expr),
        span,
    }
}

/// Generate a match arm for comparing equal variants.
fn generate_eq_match_arm(
    enum_info: &EnumInfo,
    variant: &VariantInfo,
    self_ty: &Type,
    span: &Span,
) -> MatchArm {
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    if variant.fields.len() == 0 {
        // Unit variant: (Enum::Variant, Enum::Variant) => true
        let self_pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: Vec::new(),
            },
            self_ref_ty.clone(),
            span.clone(),
        );

        let other_pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: Vec::new(),
            },
            self_ref_ty.clone(),
            span.clone(),
        );

        let tuple_pattern = Pattern::new(
            PatternKind::Tuple(vec![self_pattern, other_pattern]),
            Type::tuple(vec![self_ref_ty.clone(), self_ref_ty.clone()]),
            span.clone(),
        );

        MatchArm {
            pattern: tuple_pattern,
            guard: Option::None,
            body: bool_literal(true, span.clone()),
            span: span.clone(),
        }
    } else {
        // Tuple variant with fields to compare
        let mut self_bindings: Vec<Pattern> = Vec::new();
        let mut other_bindings: Vec<Pattern> = Vec::new();
        let mut comparisons: Vec<Expr> = Vec::new();

        let mut j: usize = 0;
        while j < variant.fields.len() {
            let field_ty = &variant.fields[j];
            let self_name = format!("__a{}", j);
            let other_name = format!("__b{}", j);

            self_bindings.push(Pattern::new(
                PatternKind::Binding {
                    name: self_name.clone(),
                    mutable: false,
                    subpattern: Option::None,
                },
                field_ty.clone(),
                span.clone(),
            ));

            other_bindings.push(Pattern::new(
                PatternKind::Binding {
                    name: other_name.clone(),
                    mutable: false,
                    subpattern: Option::None,
                },
                field_ty.clone(),
                span.clone(),
            ));

            // Generate a.eq(&b) comparison
            // Note: In a real implementation, we'd use actual local IDs
            let a_local = LocalId::new((3 + j * 2) as u32);
            let b_local = LocalId::new((4 + j * 2) as u32);

            let cmp = Expr::new(
                ExprKind::MethodCall {
                    receiver: Box::new(local_expr(a_local, field_ty.clone(), span.clone())),
                    method: "eq".to_string(),
                    args: vec![Expr::new(
                        ExprKind::Ref {
                            inner: Box::new(local_expr(b_local, field_ty.clone(), span.clone())),
                            mutable: false,
                        },
                        Type::reference(field_ty.clone(), false),
                        span.clone(),
                    )],
                },
                Type::bool(),
                span.clone(),
            );

            comparisons.push(cmp);
            j = j + 1;
        };

        let self_pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: self_bindings,
            },
            self_ref_ty.clone(),
            span.clone(),
        );

        let other_pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: other_bindings,
            },
            self_ref_ty.clone(),
            span.clone(),
        );

        let tuple_pattern = Pattern::new(
            PatternKind::Tuple(vec![self_pattern, other_pattern]),
            Type::tuple(vec![self_ref_ty.clone(), self_ref_ty.clone()]),
            span.clone(),
        );

        // Chain comparisons with &&
        let mut result = comparisons[0].clone();
        let mut k: usize = 1;
        while k < comparisons.len() {
            result = Expr::new(
                ExprKind::Binary {
                    op: BinOp::And,
                    lhs: Box::new(result),
                    rhs: Box::new(comparisons[k].clone()),
                },
                Type::bool(),
                span.clone(),
            );
            k = k + 1;
        }

        MatchArm {
            pattern: tuple_pattern,
            guard: Option::None,
            body: result,
            span: span.clone(),
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_eq_method_name() {
    let kind = DeriveKind::Eq;
    assert(kind.method_name() == "eq");
}
