//! Hash Derive Implementation
//!
//! Generates `fn hash(&self) -> u64` for structs and enums.
//!
//! # Generated Code Example
//!
//! ```blood
//! #[derive(Hash)]
//! struct Point { x: i32, y: i32 }
//!
//! // Generates:
//! impl Point {
//!     fn hash(&self) -> u64 {
//!         let mut h: u64 = 0;
//!         h = hash_combine(h, self.x.hash());
//!         h = hash_combine(h, self.y.hash());
//!         h
//!     }
//! }
//! ```

module std.compiler.derive.hash;

use std.collections.Vec;
use std.core.Option;

use std.compiler.hir::{
    Body, BodyId, LocalId, Expr, ExprKind, Stmt, StmtKind, FnSig,
    Pattern, PatternKind, MatchArm, Span, LiteralValue,
};
use std.compiler.typeck.types::{DefId, Type, TypeKind};
use std.compiler.derive::{DeriveKind, 
    DeriveExpander, DeriveRequest, StructInfo, EnumInfo, FieldInfo, VariantInfo,
    literal_expr, local_expr, int_literal,
};

// ============================================================================
// Hash for Structs
// ============================================================================

/// Expand Hash derive for a struct.
pub fn expand_struct(expander: &mut DeriveExpander, request: &DeriveRequest) {
    let struct_info = match expander.get_struct_info(request) {
        Option::Some(info) => info.clone(),
        Option::None => return,
    };

    let method_def_id = expander.alloc_def_id();
    let body_id = expander.alloc_body_id();

    let self_ty = expander.get_self_type(request);
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    // fn hash(&self) -> u64
    let sig = FnSig {
        params: vec![self_ref_ty.clone()],
        ret: Type::u64(),
        effect: Option::None,
        is_unsafe: false,
    };

    let body = generate_struct_hash_body(&struct_info, &self_ty, body_id, request.span.clone());

    expander.register_fn_sig(method_def_id.clone(), sig);
    expander.register_body(body_id.clone(), body);
    expander.register_fn_body(method_def_id.clone(), body_id);
    expander.register_method_self_type(method_def_id.clone(), self_ty);
    expander.create_impl_block(request, method_def_id, "hash".to_string(), false);
}

/// Generate the body of a struct hash method.
fn generate_struct_hash_body(
    struct_info: &StructInfo,
    self_ty: &Type,
    body_id: BodyId,
    span: Span,
) -> Body {
    let return_local = LocalId::new(0);
    let self_local = LocalId::new(1);
    let hash_local = LocalId::new(2);

    let self_ref_ty = Type::reference(self_ty.clone(), false);
    let mut stmts: Vec<Stmt> = Vec::new();

    // let mut h: u64 = 0;
    stmts.push(Stmt::new(
        StmtKind::Let {
            pattern: Pattern::new(
                PatternKind::Binding {
                    name: "h".to_string(),
                    mutable: true,
                    subpattern: Option::None,
                },
                Type::u64(),
                span.clone(),
            ),
            ty: Option::Some(Type::u64()),
            init: Option::Some(int_literal(0, span.clone())),
        },
        span.clone(),
    ));

    // For each field: h = hash_combine(h, self.field.hash());
    let mut i: usize = 0;
    while i < struct_info.fields.len() {
        let field = &struct_info.fields[i];

        // self.field.hash();
        let field_access = Expr::new(
            ExprKind::Field {
                base: Box::new(local_expr(self_local.clone(), self_ref_ty.clone(), span.clone())),
                field: field.name.clone(),
                field_idx: field.index,
            },
            field.ty.clone(),
            span.clone(),
        );

        let field_hash = Expr::new(
            ExprKind::MethodCall {
                receiver: Box::new(field_access),
                method: "hash".to_string(),
                args: Vec::new(),
            },
            Type::u64(),
            span.clone(),
        );

        // hash_combine(h, field_hash);
        let combine = Expr::new(
            ExprKind::Call {
                callee: Box::new(Expr::new(
                    ExprKind::Path(vec!["hash_combine".to_string()]),
                    Type::fn_type(vec![Type::u64(), Type::u64()], Type::u64()),
                    span.clone(),
                )),
                args: vec![
                    local_expr(hash_local.clone(), Type::u64(), span.clone()),
                    field_hash,
                ],
            },
            Type::u64(),
            span.clone(),
        );

        // h = combine
        stmts.push(Stmt::new(
            StmtKind::Expr {
                expr: Expr::new(
                    ExprKind::Assign {
                        place: Box::new(local_expr(hash_local.clone(), Type::u64(), span.clone())),
                        value: Box::new(combine),
                    },
                    Type::unit(),
                    span.clone(),
                ),
            },
            span.clone(),
        ));

        i = i + 1;
    }

    Body {
        id: body_id,
        params: vec![self_local],
        locals: Vec::new(),
        stmts,
        value: Option::Some(local_expr(hash_local, Type::u64(), span.clone())),
        span,
    }
}

// ============================================================================
// Hash for Enums
// ============================================================================

/// Expand Hash derive for an enum.
pub fn expand_enum(expander: &mut DeriveExpander, request: &DeriveRequest) {
    let enum_info = match expander.get_enum_info(request) {
        Option::Some(info) => info.clone(),
        Option::None => return,
    };

    let method_def_id = expander.alloc_def_id();
    let body_id = expander.alloc_body_id();

    let self_ty = expander.get_self_type(request);
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    let sig = FnSig {
        params: vec![self_ref_ty.clone()],
        ret: Type::u64(),
        effect: Option::None,
        is_unsafe: false,
    };

    let body = generate_enum_hash_body(&enum_info, &self_ty, body_id, request.span.clone());

    expander.register_fn_sig(method_def_id.clone(), sig);
    expander.register_body(body_id.clone(), body);
    expander.register_fn_body(method_def_id.clone(), body_id);
    expander.register_method_self_type(method_def_id.clone(), self_ty);
    expander.create_impl_block(request, method_def_id, "hash".to_string(), false);
}

/// Generate the body of an enum hash method.
fn generate_enum_hash_body(
    enum_info: &EnumInfo,
    self_ty: &Type,
    body_id: BodyId,
    span: Span,
) -> Body {
    let return_local = LocalId::new(0);
    let self_local = LocalId::new(1);

    let self_ref_ty = Type::reference(self_ty.clone(), false);

    // Match on self, hash discriminant + fields
    let mut arms: Vec<MatchArm> = Vec::new();

    let mut i: usize = 0;
    while i < enum_info.variants.len() {
        let variant = &enum_info.variants[i];
        let discriminant = match variant.discriminant {
            Option::Some(d) => d,
            Option::None => i as i64,
        };

        let arm = generate_hash_match_arm(enum_info, variant, discriminant, &span);
        arms.push(arm);
        i = i + 1;
    };

    let match_expr = Expr::new(
        ExprKind::Match {
            scrutinee: Box::new(local_expr(self_local.clone(), self_ref_ty, span.clone())),
            arms,
        },
        Type::u64(),
        span.clone(),
    );

    Body {
        id: body_id,
        params: vec![self_local],
        locals: Vec::new(),
        stmts: Vec::new(),
        value: Option::Some(match_expr),
        span,
    }
}

/// Generate a match arm for hashing a variant.
fn generate_hash_match_arm(
    enum_info: &EnumInfo,
    variant: &VariantInfo,
    discriminant: i64,
    span: &Span,
) -> MatchArm {
    let self_ty = Type::adt(enum_info.def_id.clone(), Vec::new());
    let self_ref_ty = Type::reference(self_ty.clone(), false);

    if variant.fields.len() == 0 {
        // Unit variant: just return discriminant hash
        let pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: Vec::new(),
            },
            self_ref_ty,
            span.clone(),
        );

        MatchArm {
            pattern,
            guard: Option::None,
            body: int_literal(discriminant as i64, span.clone()),
            span: span.clone(),
        }
    } else {
        // Variant with fields: hash discriminant + each field
        let mut bindings: Vec<Pattern> = Vec::new();
        let mut j: usize = 0;
        while j < variant.fields.len() {
            let field_ty = &variant.fields[j];
            bindings.push(Pattern::new(
                PatternKind::Binding {
                    name: format!("__v{}", j),
                    mutable: false,
                    subpattern: Option::None,
                },
                field_ty.clone(),
                span.clone(),
            ));
            j = j + 1;
        };

        let pattern = Pattern::new(
            PatternKind::Variant {
                enum_def_id: enum_info.def_id.clone(),
                variant_name: variant.name.clone(),
                fields: bindings,
            },
            self_ref_ty,
            span.clone(),
        );

        // Build: hash_combine(discriminant, hash_combine(v0.hash(), v1.hash()...));
        let mut result = int_literal(discriminant as i64, span.clone());

        j = 0;
        while j < variant.fields.len() {
            let field_ty = &variant.fields[j];
            let binding_local = LocalId::new((2 + j) as u32);

            let field_hash = Expr::new(
                ExprKind::MethodCall {
                    receiver: Box::new(local_expr(binding_local, field_ty.clone(), span.clone())),
                    method: "hash".to_string(),
                    args: Vec::new(),
                },
                Type::u64(),
                span.clone(),
            );

            result = Expr::new(
                ExprKind::Call {
                    callee: Box::new(Expr::new(
                        ExprKind::Path(vec!["hash_combine".to_string()]),
                        Type::fn_type(vec![Type::u64(), Type::u64()], Type::u64()),
                        span.clone(),
                    )),
                    args: vec![result, field_hash],
                },
                Type::u64(),
                span.clone(),
            );

            j = j + 1;
        }

        MatchArm {
            pattern,
            guard: Option::None,
            body: result,
            span: span.clone(),
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_hash_method_name() {
    let kind = DeriveKind::Hash;
    assert(kind.method_name() == "hash");
}
