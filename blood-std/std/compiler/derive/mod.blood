//! Derive Macro Expansion for Blood
//!
//! This module implements built-in derive macros that generate method implementations
//! for types marked with `#[derive(...)]` attributes.
//!
//! # Supported Derives
//!
//! - `Debug` - Generates `fn debug(&self) -> String`
//! - `Clone` - Generates `fn clone(&self) -> Self`
//! - `Eq` - Generates `fn eq(&self, other: &Self) -> bool`
//! - `PartialEq` - Same as Eq
//! - `Default` - Generates `fn default() -> Self`
//! - `Hash` - Generates `fn hash(&self) -> u64`
//!
//! # Implementation Strategy
//!
//! Derives are expanded during type checking after type collection:
//! 1. During `collect_struct/collect_enum`, extract `#[derive(...)]` attributes
//! 2. Store pending derive requests with the type's DefId
//! 3. Expand all derives by generating synthetic impl blocks
//! 4. Register generated impl blocks with the resolver
//!
//! # Example
//!
//! ```blood
//! #[derive(Clone, Debug, Eq)]
//! pub struct Point {
//!     x: i32,
//!     y: i32,
//! }
//!
//! // Generates approximately:
//! impl Point {
//!     pub fn clone(&self) -> Point {
//!         Point { x: self.x.clone(), y: self.y.clone() }
//!     }
//!
//!     pub fn debug(&self) -> String {
//!         "Point { x: " + self.x.debug() + ", y: " + self.y.debug() + " }"
//!     }
//!
//!     pub fn eq(&self, other: &Point) -> bool {
//!         self.x.eq(&other.x) && self.y.eq(&other.y)
//!     }
//! }
//! ```

module std.compiler.derive;

use std.collections.HashMap;
use std.collections.Vec;
use std.option.Option;
use std.string.String;

use crate.compiler.hir::{
    Item, ItemKind, Body, BodyId, LocalId,
    Expr, ExprKind, Stmt, Pattern, PatternKind,
    FnDef, FnSig, StructDef, EnumDef, FieldDef, Variant,
    Generics, GenericParam, GenericParamKind,
    BinOp, UnaryOp, LiteralValue, MatchArm,
    Visibility, Span,
};
use crate.compiler.typeck.types::{DefId, Type, TypeKind, TyVarId, PrimitiveTy};

// Submodule declarations
pub mod clone;
pub mod eq;
pub mod hash;
pub mod default_derive;
pub mod debug;

// ============================================================================
// Derive Kind
// ============================================================================

/// The kind of derive macro.
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum DeriveKind {
    /// Debug trait - generates debug() -> String
    Debug,
    /// Clone trait - generates clone(&self) -> Self
    Clone,
    /// Eq trait - generates eq(&self, &Self) -> bool
    Eq,
    /// PartialEq trait - same as Eq for Blood
    PartialEq,
    /// Default trait - generates default() -> Self
    Default,
    /// Hash trait - generates hash(&self) -> u64
    Hash,
}

impl DeriveKind {
    /// Parse a derive kind from a string.
    pub fn from_str(s: &str) -> Option<DeriveKind> {
        match s {
            "Debug" => Option::Some(DeriveKind::Debug),
            "Clone" => Option::Some(DeriveKind::Clone),
            "Eq" => Option::Some(DeriveKind::Eq),
            "PartialEq" => Option::Some(DeriveKind::PartialEq),
            "Default" => Option::Some(DeriveKind::Default),
            "Hash" => Option::Some(DeriveKind::Hash),
            _ => Option::None,
        }
    }

    /// Get the method name for this derive.
    pub fn method_name(&self) -> String {
        match self {
            DeriveKind::Debug => "debug".to_string(),
            DeriveKind::Clone => "clone".to_string(),
            DeriveKind::Eq => "eq".to_string(),
            DeriveKind::PartialEq => "eq".to_string(),
            DeriveKind::Default => "default".to_string(),
            DeriveKind::Hash => "hash".to_string(),
        }
    }

    /// Check if this is a method that takes &self (vs static).
    pub fn takes_self(&self) -> bool {
        match self {
            DeriveKind::Debug => true,
            DeriveKind::Clone => true,
            DeriveKind::Eq => true,
            DeriveKind::PartialEq => true,
            DeriveKind::Default => false,  // Default::default() is static
            DeriveKind::Hash => true,
        }
    }
}

// ============================================================================
// Derive Request
// ============================================================================

/// A request to derive a trait for a type.
pub struct DeriveRequest {
    /// The DefId of the type to derive for.
    pub type_def_id: DefId,
    /// The name of the type.
    pub type_name: String,
    /// The list of derives to generate.
    pub derives: Vec<DeriveKind>,
    /// Source span of the derive attribute.
    pub span: Span,
}

impl DeriveRequest {
    /// Create a new derive request.
    pub fn new(
        type_def_id: DefId,
        type_name: String,
        derives: Vec<DeriveKind>,
        span: Span,
    ) -> DeriveRequest {
        DeriveRequest {
            type_def_id,
            type_name,
            derives,
            span,
        }
    }
}

impl Clone for DeriveRequest {
    fn clone(&self) -> DeriveRequest {
        DeriveRequest {
            type_def_id: self.type_def_id.clone(),
            type_name: self.type_name.clone(),
            derives: self.derives.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================================
// Generated Method
// ============================================================================

/// Information about a generated method for registration with the resolver.
pub struct GeneratedMethod {
    /// The DefId of the method.
    pub def_id: DefId,
    /// The name of the method.
    pub name: String,
    /// The span of the method.
    pub span: Span,
}

impl Clone for GeneratedMethod {
    fn clone(&self) -> GeneratedMethod {
        GeneratedMethod {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================================
// Struct Info (for derive expansion)
// ============================================================================

/// Information about a struct for derive expansion.
pub struct StructInfo {
    /// DefId of the struct.
    pub def_id: DefId,
    /// Name of the struct.
    pub name: String,
    /// Generic parameters.
    pub generics: Vec<TyVarId>,
    /// Field definitions.
    pub fields: Vec<FieldInfo>,
    /// Source span.
    pub span: Span,
}

impl Clone for StructInfo {
    fn clone(&self) -> StructInfo {
        StructInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            generics: self.generics.clone(),
            fields: self.fields.clone(),
            span: self.span.clone(),
        }
    }
}

/// Information about a struct field.
pub struct FieldInfo {
    /// Name of the field.
    pub name: String,
    /// Type of the field.
    pub ty: Type,
    /// Field index.
    pub index: u32,
}

impl Clone for FieldInfo {
    fn clone(&self) -> FieldInfo {
        FieldInfo {
            name: self.name.clone(),
            ty: self.ty.clone(),
            index: self.index,
        }
    }
}

// ============================================================================
// Enum Info (for derive expansion)
// ============================================================================

/// Information about an enum for derive expansion.
pub struct EnumInfo {
    /// DefId of the enum.
    pub def_id: DefId,
    /// Name of the enum.
    pub name: String,
    /// Generic parameters.
    pub generics: Vec<TyVarId>,
    /// Variant definitions.
    pub variants: Vec<VariantInfo>,
    /// Source span.
    pub span: Span,
}

impl Clone for EnumInfo {
    fn clone(&self) -> EnumInfo {
        EnumInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            generics: self.generics.clone(),
            variants: self.variants.clone(),
            span: self.span.clone(),
        }
    }
}

/// Information about an enum variant.
pub struct VariantInfo {
    /// Name of the variant.
    pub name: String,
    /// DefId of the variant.
    pub def_id: DefId,
    /// Field types (for tuple/struct variants).
    pub fields: Vec<Type>,
    /// Discriminant (if explicit).
    pub discriminant: Option<i64>,
}

impl Clone for VariantInfo {
    fn clone(&self) -> VariantInfo {
        VariantInfo {
            name: self.name.clone(),
            def_id: self.def_id.clone(),
            fields: self.fields.clone(),
            discriminant: self.discriminant.clone(),
        }
    }
}

// ============================================================================
// Impl Block Info
// ============================================================================

/// Information about an impl block being generated.
pub struct ImplBlockInfo {
    /// The Self type for this impl.
    pub self_ty: Type,
    /// Methods in this impl block.
    pub methods: Vec<ImplMethodInfo>,
    /// Associated types (not used for derives).
    pub assoc_types: Vec<DefId>,
    /// Source span.
    pub span: Span,
}

impl Clone for ImplBlockInfo {
    fn clone(&self) -> ImplBlockInfo {
        ImplBlockInfo {
            self_ty: self.self_ty.clone(),
            methods: self.methods.clone(),
            assoc_types: self.assoc_types.clone(),
            span: self.span.clone(),
        }
    }
}

/// Information about a method in an impl block.
pub struct ImplMethodInfo {
    /// DefId of the method.
    pub def_id: DefId,
    /// Name of the method.
    pub name: String,
    /// Whether this is a static method (no self).
    pub is_static: bool,
}

impl Clone for ImplMethodInfo {
    fn clone(&self) -> ImplMethodInfo {
        ImplMethodInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            is_static: self.is_static,
        }
    }
}

// ============================================================================
// Derive Expander
// ============================================================================

/// Context for derive expansion.
pub struct DeriveExpander {
    /// Struct definitions from type checking.
    struct_defs: HashMap<u32, StructInfo>,
    /// Enum definitions from type checking.
    enum_defs: HashMap<u32, EnumInfo>,
    /// Generated impl blocks.
    impl_blocks: Vec<ImplBlockInfo>,
    /// Generated function signatures.
    fn_sigs: HashMap<u32, FnSig>,
    /// Generated bodies.
    bodies: HashMap<u32, Body>,
    /// Method self types.
    method_self_types: HashMap<u32, Type>,
    /// Function body mappings.
    fn_bodies: HashMap<u32, BodyId>,
    /// Next DefId to allocate.
    next_def_id: u32,
    /// Next BodyId to allocate.
    next_body_id: u32,
    /// Generated methods (for resolver registration).
    generated_methods: Vec<GeneratedMethod>,
}

impl DeriveExpander {
    /// Create a new derive expander.
    pub fn new() -> DeriveExpander {
        DeriveExpander {
            struct_defs: HashMap::new(),
            enum_defs: HashMap::new(),
            impl_blocks: Vec::new(),
            fn_sigs: HashMap::new(),
            bodies: HashMap::new(),
            method_self_types: HashMap::new(),
            fn_bodies: HashMap::new(),
            next_def_id: 0,
            next_body_id: 0,
            generated_methods: Vec::new(),
        }
    }

    /// Create a derive expander with initial IDs.
    pub fn with_ids(next_def_id: u32, next_body_id: u32) -> DeriveExpander {
        let mut expander = DeriveExpander::new();
        expander.next_def_id = next_def_id;
        expander.next_body_id = next_body_id;
        expander
    }

    /// Register a struct definition for derive expansion.
    pub fn register_struct(&mut self, info: StructInfo) {
        self.struct_defs.insert(info.def_id.id(), info);
    }

    /// Register an enum definition for derive expansion.
    pub fn register_enum(&mut self, info: EnumInfo) {
        self.enum_defs.insert(info.def_id.id(), info);
    }

    /// Expand all pending derives and return generated method info.
    pub fn expand_all(&mut self, requests: Vec<DeriveRequest>) -> Vec<GeneratedMethod> {
        let mut i: usize = 0;
        while i < requests.len() {
            self.expand_request(&requests[i]);
            i = i + 1;
        };

        // Return a clone of generated methods
        self.generated_methods.clone();
    }

    /// Get the next body ID after expansion (for updating TypeContext).
    pub fn next_body_id(&self) -> u32 {
        self.next_body_id
    }

    /// Get the next def ID after expansion.
    pub fn next_def_id(&self) -> u32 {
        self.next_def_id
    }

    /// Get generated impl blocks.
    pub fn impl_blocks(&self) -> &Vec<ImplBlockInfo> {
        &self.impl_blocks
    }

    /// Get generated function signatures.
    pub fn fn_sigs(&self) -> &HashMap<u32, FnSig> {
        &self.fn_sigs
    }

    /// Get generated bodies.
    pub fn bodies(&self) -> &HashMap<u32, Body> {
        &self.bodies
    }

    /// Expand a single derive request.
    fn expand_request(&mut self, request: &DeriveRequest) {
        // Get type info - could be struct or enum
        let is_struct = self.struct_defs.contains_key(&request.type_def_id.id());
        let is_enum = self.enum_defs.contains_key(&request.type_def_id.id());

        if !is_struct && !is_enum {
            // Type not found - this shouldn't happen if collect phase worked correctly
            return;
        };

        // Generate impl blocks for each derive
        let mut i: usize = 0;
        while i < request.derives.len() {
            let derive_kind = &request.derives[i];
            match derive_kind {
                DeriveKind::Debug => {
                    if is_struct {
                        self.expand_debug_struct(request);
                    } else {
                        self.expand_debug_enum(request);
                    }
                }
                DeriveKind::Clone => {
                    if is_struct {
                        self.expand_clone_struct(request);
                    } else {
                        self.expand_clone_enum(request);
                    }
                }
                DeriveKind::Eq => {
                    if is_struct {
                        self.expand_eq_struct(request);
                    } else {
                        self.expand_eq_enum(request);
                    }
                }
                DeriveKind::PartialEq => {
                    if is_struct {
                        self.expand_eq_struct(request);
                    } else {
                        self.expand_eq_enum(request);
                    }
                }
                DeriveKind::Default => {
                    if is_struct {
                        self.expand_default_struct(request);
                    } else {
                        self.expand_default_enum(request);
                    }
                }
                DeriveKind::Hash => {
                    if is_struct {
                        self.expand_hash_struct(request);
                    } else {
                        self.expand_hash_enum(request);
                    }
                }
            };
            i = i + 1;
        }
    }

    /// Allocate a new DefId.
    pub fn alloc_def_id(&mut self) -> DefId {
        let id = DefId::new(self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Allocate a new BodyId.
    pub fn alloc_body_id(&mut self) -> BodyId {
        let id = BodyId::new(self.next_body_id);
        self.next_body_id = self.next_body_id + 1;
        id
    }

    /// Get the Self type for a derive request.
    pub fn get_self_type(&self, request: &DeriveRequest) -> Type {
        // Get generics from struct or enum
        let generics: Vec<Type> = match self.struct_defs.get(&request.type_def_id.id()) {
            Option::Some(struct_info) => {
                let mut types: Vec<Type> = Vec::new();
                let mut i: usize = 0;
                while i < struct_info.generics.len() {
                    types.push(Type::param(struct_info.generics[i].clone()));
                    i = i + 1;
                }
                types
            }
            Option::None => {
                match self.enum_defs.get(&request.type_def_id.id()) {
                    Option::Some(enum_info) => {
                        let mut types: Vec<Type> = Vec::new();
                        let mut i: usize = 0;
                        while i < enum_info.generics.len() {
                            types.push(Type::param(enum_info.generics[i].clone()));
                            i = i + 1;
                        }
                        types
                    }
                    Option::None => Vec::new(),
                }
            }
        };

        Type::adt(request.type_def_id.clone(), generics)
    }

    /// Get generics (TyVarIds) for a type.
    pub fn get_generics(&self, request: &DeriveRequest) -> Vec<TyVarId> {
        match self.struct_defs.get(&request.type_def_id.id()) {
            Option::Some(struct_info) => struct_info.generics.clone(),
            Option::None => {
                match self.enum_defs.get(&request.type_def_id.id()) {
                    Option::Some(enum_info) => enum_info.generics.clone(),
                    Option::None => Vec::new(),
                }
            }
        }
    }

    /// Get struct info for a request.
    pub fn get_struct_info(&self, request: &DeriveRequest) -> Option<&StructInfo> {
        self.struct_defs.get(&request.type_def_id.id());
    }

    /// Get enum info for a request.
    pub fn get_enum_info(&self, request: &DeriveRequest) -> Option<&EnumInfo> {
        self.enum_defs.get(&request.type_def_id.id());
    }

    /// Create an impl block info for a generated method.
    pub fn create_impl_block(
        &mut self,
        request: &DeriveRequest,
        method_def_id: DefId,
        method_name: String,
        is_static: bool,
    ) {
        let self_ty = self.get_self_type(request);

        let impl_block = ImplBlockInfo {
            self_ty,
            methods: vec![ImplMethodInfo {
                def_id: method_def_id.clone(),
                name: method_name.clone(),
                is_static,
            }],
            assoc_types: Vec::new(),
            span: request.span.clone(),
        };

        self.impl_blocks.push(impl_block);

        // Record the generated method for resolver registration
        self.generated_methods.push(GeneratedMethod {
            def_id: method_def_id,
            name: method_name,
            span: request.span.clone(),
        });
    }

    /// Register a function signature.
    pub fn register_fn_sig(&mut self, def_id: DefId, sig: FnSig) {
        self.fn_sigs.insert(def_id.id(), sig);
    }

    /// Register a body.
    pub fn register_body(&mut self, body_id: BodyId, body: Body) {
        self.bodies.insert(body_id.id(), body);
    }

    /// Map a function DefId to its BodyId.
    pub fn register_fn_body(&mut self, def_id: DefId, body_id: BodyId) {
        self.fn_bodies.insert(def_id.id(), body_id);
    }

    /// Register method self type.
    pub fn register_method_self_type(&mut self, def_id: DefId, self_ty: Type) {
        self.method_self_types.insert(def_id.id(), self_ty);
    }

    // ========================================================================
    // Derive Expansion Functions (delegates to submodules)
    // ========================================================================

    fn expand_debug_struct(&mut self, request: &DeriveRequest) {
        debug::expand_struct(self, request);
    }

    fn expand_debug_enum(&mut self, request: &DeriveRequest) {
        debug::expand_enum(self, request);
    }

    fn expand_clone_struct(&mut self, request: &DeriveRequest) {
        clone::expand_struct(self, request);
    }

    fn expand_clone_enum(&mut self, request: &DeriveRequest) {
        clone::expand_enum(self, request);
    }

    fn expand_eq_struct(&mut self, request: &DeriveRequest) {
        eq::expand_struct(self, request);
    }

    fn expand_eq_enum(&mut self, request: &DeriveRequest) {
        eq::expand_enum(self, request);
    }

    fn expand_default_struct(&mut self, request: &DeriveRequest) {
        default::expand_struct(self, request);
    }

    fn expand_default_enum(&mut self, request: &DeriveRequest) {
        default::expand_enum(self, request);
    }

    fn expand_hash_struct(&mut self, request: &DeriveRequest) {
        hash::expand_struct(self, request);
    }

    fn expand_hash_enum(&mut self, request: &DeriveRequest) {
        hash::expand_enum(self, request);
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Create a literal expression.
pub fn literal_expr(value: LiteralValue, ty: Type, span: Span) -> Expr {
    Expr::new(ExprKind::Literal(value), ty, span)
}

/// Create a local variable expression.
pub fn local_expr(local_id: LocalId, ty: Type, span: Span) -> Expr {
    Expr::new(ExprKind::Local(local_id), ty, span)
}

/// Create a string literal expression.
pub fn string_literal(s: String, span: Span) -> Expr {
    literal_expr(
        LiteralValue::String(s),
        Type::str(),
        span,
    )
}

/// Create a boolean literal expression.
pub fn bool_literal(b: bool, span: Span) -> Expr {
    literal_expr(LiteralValue::Bool(b), Type::bool(), span)
}

/// Create an integer literal expression.
pub fn int_literal(n: i64, span: Span) -> Expr {
    literal_expr(LiteralValue::Int(n), Type::i64(), span)
}

/// Create a unit literal expression.
pub fn unit_literal(span: Span) -> Expr {
    literal_expr(LiteralValue::Unit, Type::unit(), span)
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_derive_kind_from_str() {
    assert(DeriveKind::from_str("Clone").is_some());
    assert(DeriveKind::from_str("Debug").is_some());
    assert(DeriveKind::from_str("Unknown").is_none());
}

#[test]
fn test_derive_kind_method_name() {
    assert(DeriveKind::Clone.method_name() == "clone");
    assert(DeriveKind::Eq.method_name() == "eq");
    assert(DeriveKind::Default.method_name() == "default");
}

#[test]
fn test_derive_kind_takes_self() {
    assert(DeriveKind::Clone.takes_self());
    assert(DeriveKind::Eq.takes_self());
    assert(!DeriveKind::Default.takes_self());
}
