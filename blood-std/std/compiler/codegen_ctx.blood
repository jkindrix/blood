// Blood Self-Hosted Compiler - Codegen Context
//
// This module defines the context used during MIR to LLVM IR codegen.
// It manages register allocation, local variable tracking, and IR emission.

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;

// ============================================================
// Codegen Context
// ============================================================

/// Context for generating LLVM IR from MIR.
pub struct CodegenCtx {
    /// The output buffer for LLVM IR.
    pub output: String,
    /// Current indentation level.
    indent_level: u32,
    /// Counter for generating unique SSA value names.
    value_counter: u32,
    /// Counter for generating unique labels.
    label_counter: u32,
    /// Mapping from MIR locals to LLVM value names.
    local_names: Vec<LocalName>,
    /// Mapping from MIR locals to their LLVM type strings.
    local_types: Vec<LocalType>,
    /// The current function being generated.
    current_fn: Option<String>,
    /// String constants table for global string literals.
    string_table: Vec<StringConstant>,
    /// Counter for generating unique string constant names.
    string_counter: u32,
}

/// Mapping from a MIR local to its LLVM type.
struct LocalType {
    local_id: u32,
    llvm_type: String,
}

/// Entry in the string constant table.
struct StringConstant {
    /// The global label for this string constant.
    label: String,
    /// The string content.
    content: String,
    /// The length of the string (including null terminator).
    length: usize,
}

/// Mapping from a MIR local to its LLVM name.
struct LocalName {
    local_id: u32,
    name: String,
}

impl CodegenCtx {
    /// Creates a new codegen context.
    pub fn new() -> CodegenCtx {
        CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::new(),
            local_types: Vec::new(),
            current_fn: Option::None,
            string_table: Vec::new(),
            string_counter: 0,
        }
    }

    // ======== Output Management ========

    /// Writes a string to the output.
    pub fn write(self: &mut CodegenCtx, s: &str) {
        self.output.push_str(s);
    }

    /// Writes a String to the output.
    pub fn write_string(self: &mut CodegenCtx, s: &String) {
        let bytes = s.as_bytes();
        let mut i: usize = 0;
        while i < bytes.len() {
            self.output.push(bytes[i] as char);
            i = i + 1;
        }
    }

    /// Writes a newline with current indentation.
    pub fn writeln(self: &mut CodegenCtx, s: &str) {
        self.write_indent();
        self.write(s);
        self.write("\n");
    }

    /// Writes a newline.
    pub fn newline(self: &mut CodegenCtx) {
        self.write("\n");
    }

    /// Writes current indentation.
    fn write_indent(self: &mut CodegenCtx) {
        let mut i: u32 = 0;
        while i < self.indent_level {
            self.write("    ");
            i = i + 1;
        }
    }

    /// Increases indentation level.
    pub fn indent(self: &mut CodegenCtx) {
        self.indent_level = self.indent_level + 1;
    }

    /// Decreases indentation level.
    pub fn dedent(self: &mut CodegenCtx) {
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;
        }
    }

    // ======== Value Names ========

    /// Generates a new unique temporary value name.
    pub fn fresh_temp(self: &mut CodegenCtx) -> String {
        let n = self.value_counter;
        self.value_counter = self.value_counter + 1;
        let mut name = common::make_string("%tmp");
        let num_str = codegen_types::format_u64(n as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Generates a new unique label name.
    pub fn fresh_label(self: &mut CodegenCtx) -> String {
        let n = self.label_counter;
        self.label_counter = self.label_counter + 1;
        let mut name = common::make_string("label");
        let num_str = codegen_types::format_u64(n as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Gets the LLVM name for a MIR local.
    pub fn local_name(self: &CodegenCtx, local: mir_def::MirLocalId) -> String {
        let mut i: usize = 0;
        while i < self.local_names.len() {
            if self.local_names[i].local_id == local.index {
                return clone_string(&self.local_names[i].name);
            }
            i = i + 1;
        }
        // Fallback: generate name from index
        let mut name = common::make_string("%_");
        let num_str = codegen_types::format_u64(local.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Registers a local with its LLVM name.
    pub fn register_local(self: &mut CodegenCtx, local: mir_def::MirLocalId, name: String) {
        self.local_names.push(LocalName {
            local_id: local.index,
            name: name,
        });
    }

    /// Registers a local with its LLVM type.
    pub fn register_local_type(self: &mut CodegenCtx, local: mir_def::MirLocalId, llvm_type: String) {
        self.local_types.push(LocalType {
            local_id: local.index,
            llvm_type: llvm_type,
        });
    }

    /// Gets the LLVM type for a MIR local.
    pub fn get_local_type(self: &CodegenCtx, local: mir_def::MirLocalId) -> String {
        let mut i: usize = 0;
        while i < self.local_types.len() {
            if self.local_types[i].local_id == local.index {
                return clone_string(&self.local_types[i].llvm_type);
            }
            i = i + 1;
        }
        // Fallback: return i64 if type not found
        common::make_string("i64")
    }

    /// Clears all local names and types (for reuse between functions).
    pub fn clear_locals(self: &mut CodegenCtx) {
        self.local_names.clear();
        self.local_types.clear();
    }

    /// Generates the name for a MIR local alloca.
    pub fn local_alloca_name(self: &mut CodegenCtx, local: mir_def::MirLocalId) -> String {
        let mut name = common::make_string("%_");
        let num_str = codegen_types::format_u64(local.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    // ======== Block Labels ========

    /// Gets the LLVM label for a basic block.
    pub fn block_label(self: &CodegenCtx, block: mir_def::BasicBlockId) -> String {
        let mut name = common::make_string("bb");
        let num_str = codegen_types::format_u64(block.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    // ======== Function Management ========

    /// Begins generating a new function.
    pub fn begin_function(self: &mut CodegenCtx, name: String) {
        self.current_fn = Option::Some(clone_string(&name));
        self.value_counter = 0;
        self.local_names.clear();
    }

    /// Ends the current function.
    pub fn end_function(self: &mut CodegenCtx) {
        self.current_fn = Option::None;
    }

    /// Returns the current function name, or empty string if none.
    pub fn current_function(self: &CodegenCtx) -> String {
        match &self.current_fn {
            &Option::Some(ref name) => clone_string(name),
            &Option::None => common::make_string(""),
        }
    }

    // ======== String Constants ========

    /// Adds a string constant to the table and returns its global label.
    pub fn add_string_constant(self: &mut CodegenCtx, content: &String) -> String {
        // Check if this string is already in the table
        let mut i: usize = 0;
        while i < self.string_table.len() {
            if string_equal(&self.string_table[i].content, content) {
                return clone_string(&self.string_table[i].label);
            }
            i = i + 1;
        }

        // Create a new entry
        let n = self.string_counter;
        self.string_counter = self.string_counter + 1;
        let mut label = common::make_string("@.str.");
        let num_str = codegen_types::format_u64(n as u64);
        label.push_str(num_str.as_str());

        let length = content.len() + 1; // +1 for null terminator

        self.string_table.push(StringConstant {
            label: clone_string(&label),
            content: clone_string(content),
            length: length,
        });

        label
    }

    /// Emits all string constants as global declarations.
    /// Should be called at the beginning of the module.
    pub fn emit_string_constants(self: &mut CodegenCtx) {
        let mut i: usize = 0;
        while i < self.string_table.len() {
            let entry = &self.string_table[i];
            // Emit: @.str.N = private unnamed_addr constant [M x i8] c"...\00"
            self.write_string(&entry.label);
            self.write(" = private unnamed_addr constant [");
            let len_str = codegen_types::format_u64(entry.length as u64);
            self.write_string(&len_str);
            self.write(" x i8] c\"");
            self.emit_string_literal_bytes(&entry.content);
            self.write("\\00\"\n");
            i = i + 1;
        }
        if self.string_table.len() > 0 {
            self.newline();
        }
    }

    /// Emits a string literal as LLVM string bytes (escaping special chars).
    fn emit_string_literal_bytes(self: &mut CodegenCtx, s: &String) {
        let bytes = s.as_bytes();
        let mut i: usize = 0;
        while i < bytes.len() {
            let b = bytes[i];
            if b == 34 {
                // Quote "
                self.write("\\22");
            } else if b == 92 {
                // Backslash
                self.write("\\5C");
            } else if b == 10 {
                // Newline
                self.write("\\0A");
            } else if b == 13 {
                // Carriage return
                self.write("\\0D");
            } else if b == 9 {
                // Tab
                self.write("\\09");
            } else if b < 32 || b > 126 {
                // Non-printable - emit as hex
                self.write("\\");
                let hex = byte_to_hex(b);
                self.write_string(&hex);
            } else {
                // Printable character
                self.output.push(b as char);
            }
            i = i + 1;
        }
    }

    // ======== LLVM IR Emission Helpers ========

    /// Emits a function definition header.
    pub fn emit_fn_header(
        self: &mut CodegenCtx,
        name: &str,
        params: &Vec<(String, String)>,
        return_ty: &str,
    ) {
        self.write("define ");
        self.write(return_ty);
        self.write(" @");
        self.write(name);
        self.write("(");

        let mut i: usize = 0;
        while i < params.len() {
            if i > 0 {
                self.write(", ");
            }
            let param = &params[i];
            self.write_string(&param.0);
            self.write(" ");
            self.write_string(&param.1);
            i = i + 1;
        }

        self.write(") {\n");
    }

    /// Emits a function definition footer.
    pub fn emit_fn_footer(self: &mut CodegenCtx) {
        self.write("}\n\n");
    }

    /// Emits an alloca instruction.
    pub fn emit_alloca(self: &mut CodegenCtx, result: &str, ty: &str) {
        self.write_indent();
        self.write(result);
        self.write(" = alloca ");
        self.write(ty);
        self.write("\n");
    }

    /// Emits a load instruction.
    pub fn emit_load(self: &mut CodegenCtx, result: &str, ty: &str, ptr: &str) {
        self.write_indent();
        self.write(result);
        self.write(" = load ");
        self.write(ty);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a store instruction.
    pub fn emit_store(self: &mut CodegenCtx, ty: &str, val: &str, ptr: &str) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a binary operation.
    pub fn emit_binop(
        self: &mut CodegenCtx,
        result: &str,
        opcode: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an icmp instruction.
    pub fn emit_icmp(
        self: &mut CodegenCtx,
        result: &str,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = icmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an fcmp instruction.
    pub fn emit_fcmp(
        self: &mut CodegenCtx,
        result: &str,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = fcmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits a cast instruction (trunc, zext, sext, fptrunc, fpext, etc).
    pub fn emit_cast(
        self: &mut CodegenCtx,
        result: &str,
        opcode: &str,
        src_ty: &str,
        val: &str,
        tgt_ty: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(src_ty);
        self.write(" ");
        self.write(val);
        self.write(" to ");
        self.write(tgt_ty);
        self.write("\n");
    }

    /// Emits a call instruction.
    pub fn emit_call(
        self: &mut CodegenCtx,
        result: Option<&str>,
        return_ty: &str,
        func: &str,
        args: &Vec<(String, String)>,
    ) {
        self.write_indent();
        match result {
            Option::Some(r) => {
                self.write(r);
                self.write(" = ");
            }
            Option::None => {}
        }
        self.write("call ");
        self.write(return_ty);
        self.write(" ");
        self.write(func);
        self.write("(");

        let mut i: usize = 0;
        while i < args.len() {
            if i > 0 {
                self.write(", ");
            }
            let arg = &args[i];
            self.write_string(&arg.0);
            self.write(" ");
            self.write_string(&arg.1);
            i = i + 1;
        }

        self.write(")\n");
    }

    /// Emits a getelementptr instruction.
    pub fn emit_gep(
        self: &mut CodegenCtx,
        result: &str,
        base_ty: &str,
        ptr: &str,
        indices: &Vec<String>,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = getelementptr ");
        self.write(base_ty);
        self.write(", ptr ");
        self.write(ptr);

        let mut i: usize = 0;
        while i < indices.len() {
            self.write(", i64 ");
            self.write_string(&indices[i]);
            i = i + 1;
        }

        self.write("\n");
    }

    /// Emits a br instruction (unconditional).
    pub fn emit_br(self: &mut CodegenCtx, label: &str) {
        self.write_indent();
        self.write("br label %");
        self.write(label);
        self.write("\n");
    }

    /// Emits a conditional br instruction.
    pub fn emit_cond_br(
        self: &mut CodegenCtx,
        cond: &str,
        true_label: &str,
        false_label: &str,
    ) {
        self.write_indent();
        self.write("br i1 ");
        self.write(cond);
        self.write(", label %");
        self.write(true_label);
        self.write(", label %");
        self.write(false_label);
        self.write("\n");
    }

    /// Emits a ret instruction.
    pub fn emit_ret(self: &mut CodegenCtx, ty: &str, val: Option<&str>) {
        self.write_indent();
        self.write("ret ");
        self.write(ty);
        match val {
            Option::Some(v) => {
                self.write(" ");
                self.write(v);
            }
            Option::None => {}
        }
        self.write("\n");
    }

    /// Emits a label.
    pub fn emit_label(self: &mut CodegenCtx, label: &str) {
        self.write(label);
        self.write(":\n");
    }

    /// Emits an unreachable instruction.
    pub fn emit_unreachable(self: &mut CodegenCtx) {
        self.write_indent();
        self.write("unreachable\n");
    }

    /// Emits a switch instruction.
    pub fn emit_switch(
        self: &mut CodegenCtx,
        ty: &str,
        val: &str,
        default_label: &str,
        cases: &Vec<(String, String)>,
    ) {
        self.write_indent();
        self.write("switch ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", label %");
        self.write(default_label);
        self.write(" [\n");

        self.indent();
        let mut i: usize = 0;
        while i < cases.len() {
            let case_val = &cases[i];
            self.write_indent();
            self.write(ty);
            self.write(" ");
            self.write_string(&case_val.0);
            self.write(", label %");
            self.write_string(&case_val.1);
            self.write("\n");
            i = i + 1;
        }
        self.dedent();

        self.write_indent();
        self.write("]\n");
    }
}

// ============================================================
// String Helpers
// ============================================================

/// Clones a String.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    let bytes = s.as_bytes();
    let mut i: usize = 0;
    while i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Compares two strings for equality.
fn string_equal(a: &String, b: &String) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Converts a byte to a two-character hex string.
fn byte_to_hex(b: u8) -> String {
    let mut result = String::new();
    let high = (b >> 4) & 0xF;
    let low = b & 0xF;
    result.push(nibble_to_hex(high));
    result.push(nibble_to_hex(low));
    result
}

/// Converts a nibble (0-15) to a hex character.
fn nibble_to_hex(n: u8) -> char {
    if n < 10 {
        (48u8 + n) as char
    } else {
        (55u8 + n) as char
    }
}
