// Blood Self-Hosted Compiler - Codegen Context
//
// This module defines the context used during MIR to LLVM IR codegen.
// It manages register allocation, local variable tracking, and IR emission.

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod hashmap;

// ============================================================
// ADT Layout Types
// ============================================================

/// Information about a single field's type (LLVM and optionally HIR).
pub struct AdtFieldInfo {
    /// The LLVM type string for this field (e.g., "i32", "ptr", "{ i32, i64 }").
    pub llvm_type: String,
    /// The HIR type for this field, if known. Used for computing element sizes during indexing.
    pub hir_type: Option<hir_ty::Type>,
}

/// Layout of a struct type.
pub struct StructLayout {
    /// The DefId of the struct.
    pub def_id: u32,
    /// The fields in declaration order.
    pub fields: Vec<AdtFieldInfo>,
    /// The complete LLVM type string (e.g., "{ i32, i64, ptr }").
    pub llvm_type: String,
}

/// Layout of a single enum variant.
pub struct VariantLayout {
    /// The variant's discriminant index.
    pub variant_idx: u32,
    /// The fields/payload types for this variant.
    pub fields: Vec<AdtFieldInfo>,
    /// The LLVM type for this variant's payload (e.g., "{ i32, ptr }"), or "{}" for unit.
    pub payload_llvm_type: String,
}

/// Layout of an enum type.
pub struct EnumLayout {
    /// The DefId of the enum.
    pub def_id: u32,
    /// The LLVM type of the discriminant tag (e.g., "i8", "i32", "i64").
    pub discriminant_type: String,
    /// Layouts for each variant.
    pub variants: Vec<VariantLayout>,
    /// The complete LLVM type string (e.g., "{ i64, [16 x i8] }").
    pub llvm_type: String,
    /// The maximum payload size in bytes across all variants.
    pub max_payload_size: u64,
}

/// An ADT registry entry: either a struct or an enum.
pub enum AdtEntry {
    Struct(StructLayout),
    Enum(EnumLayout),
}

// ============================================================
// Codegen Context
// ============================================================

/// Context for generating LLVM IR from MIR.
pub struct CodegenCtx {
    /// The output buffer for LLVM IR.
    pub output: String,
    /// Current indentation level.
    indent_level: u32,
    /// Counter for generating unique SSA value names.
    value_counter: u32,
    /// Counter for generating unique labels.
    label_counter: u32,
    /// Mapping from MIR locals to LLVM value names.
    local_names: Vec<LocalName>,
    /// Mapping from MIR locals to their LLVM type strings.
    local_types: Vec<LocalType>,
    /// Mapping from MIR locals to their signedness (true = signed).
    local_signedness: Vec<LocalSignedness>,
    /// Mapping from MIR locals to their HIR types (for ADT lookups during projection).
    local_hir_types: Vec<LocalHirType>,
    /// Locals allocated via region allocator (freed on StorageDead).
    region_locals: Vec<RegionLocalEntry>,
    /// Locals allocated via persistent (ref-counted) allocator (decremented on StorageDead).
    persistent_locals: Vec<PersistentLocalEntry>,
    /// The current function being generated.
    current_fn: Option<String>,
    /// String constants table for global string literals.
    string_table: Vec<StringConstant>,
    /// Counter for generating unique string constant names.
    string_counter: u32,
    /// Mapping from DefIds to their global names (functions, consts, statics).
    def_names: Vec<DefNameEntry>,
    /// ADT type registry: maps DefIds to their layout information.
    pub adt_registry: Vec<AdtEntry>,
    // Hash indexes for O(1) lookups
    /// Hash index for def_names: def_id -> index in def_names vec
    def_names_hash: hashmap::HashMapU64U32,
    /// Hash index for local_names: local_id -> index in local_names vec
    local_names_hash: hashmap::HashMapU64U32,
    /// Hash index for local_types: local_id -> index in local_types vec
    local_types_hash: hashmap::HashMapU64U32,
    /// Hash index for local_signedness: local_id -> index in local_signedness vec
    local_signedness_hash: hashmap::HashMapU64U32,
    /// Hash index for local_hir_types: local_id -> index in local_hir_types vec
    local_hir_types_hash: hashmap::HashMapU64U32,
    /// Hash set for region_locals: local_id -> 1 if present
    region_locals_hash: hashmap::HashMapU64U32,
    /// Hash set for persistent_locals: local_id -> 1 if present
    persistent_locals_hash: hashmap::HashMapU64U32,
    /// Hash index for generation allocas: local_id -> index in local_generations vec
    local_generations_hash: hashmap::HashMapU64U32,
    /// Generation alloca SSA names for region-allocated locals.
    local_generations: Vec<LocalGeneration>,
    /// Hash index for string_table: string content hash -> index in string_table vec
    string_table_hash: hashmap::HashMapU64U32,
    /// Hash set for static def_ids: def_id -> 1 if static
    static_defs_hash: hashmap::HashMapU64U32,
    /// LLVM types for static variables: def_id -> index in static_types vec
    static_types_hash: hashmap::HashMapU64U32,
    /// LLVM type strings for static variables.
    static_types: Vec<String>,
    /// Hash set for const def_ids: def_id -> 1 if const
    const_defs_hash: hashmap::HashMapU64U32,
    /// Write buffer for batching file I/O during streaming codegen.
    write_buffer: String,
    /// Output file path for streaming codegen.
    output_path: String,
    /// Whether to emit MIR annotations as comments in LLVM IR.
    pub trace_codegen: bool,
}

/// Mapping from a MIR local to its LLVM type.
struct LocalType {
    local_id: u32,
    llvm_type: String,
}

/// Mapping from a MIR local to its HIR type (for ADT layout lookups).
struct LocalHirType {
    local_id: u32,
    hir_type: hir_ty::Type,
}

/// Mapping from a MIR local to its signedness.
struct LocalSignedness {
    local_id: u32,
    is_signed: bool,
}

/// Entry in the string constant table.
struct StringConstant {
    /// The global label for this string constant.
    label: String,
    /// The string content.
    content: String,
    /// The length of the string (including null terminator).
    length: usize,
}

/// Mapping from a MIR local to its LLVM name.
struct LocalName {
    local_id: u32,
    name: String,
}

/// Tracks a local that was allocated via a region allocator.
struct RegionLocalEntry {
    local_id: u32,
}

/// Tracks a local that was allocated via persistent (ref-counted) allocation.
struct PersistentLocalEntry {
    local_id: u32,
}

/// Mapping from a MIR local to its generation alloca SSA name.
struct LocalGeneration {
    local_id: u32,
    gen_name: String,
}

/// Mapping from a DefId to its global name (for functions, consts, statics).
pub struct DefNameEntry {
    pub def_id: u32,
    pub name: String,
}

impl DefNameEntry {
    /// Creates a new DefNameEntry.
    pub fn new(def_id: u32, name: String) -> DefNameEntry {
        DefNameEntry { def_id, name }
    }
}

impl CodegenCtx {
    /// Creates a new codegen context.
    pub fn new() -> CodegenCtx {
        CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::new(),
            local_types: Vec::new(),
            local_signedness: Vec::new(),
            local_hir_types: Vec::new(),
            region_locals: Vec::new(),
            persistent_locals: Vec::new(),
            current_fn: Option::None,
            string_table: Vec::new(),
            string_counter: 0,
            def_names: Vec::new(),
            adt_registry: Vec::new(),
            def_names_hash: hashmap::HashMapU64U32::new(),
            local_names_hash: hashmap::HashMapU64U32::new(),
            local_types_hash: hashmap::HashMapU64U32::new(),
            local_signedness_hash: hashmap::HashMapU64U32::new(),
            local_hir_types_hash: hashmap::HashMapU64U32::new(),
            region_locals_hash: hashmap::HashMapU64U32::new(),
            persistent_locals_hash: hashmap::HashMapU64U32::new(),
            local_generations_hash: hashmap::HashMapU64U32::new(),
            local_generations: Vec::new(),
            string_table_hash: hashmap::HashMapU64U32::new(),
            static_defs_hash: hashmap::HashMapU64U32::new(),
            static_types_hash: hashmap::HashMapU64U32::new(),
            static_types: Vec::new(),
            const_defs_hash: hashmap::HashMapU64U32::new(),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: false,
        }
    }

    /// Creates a new codegen context with pre-populated def names.
    pub fn with_def_names(def_names: Vec<DefNameEntry>) -> CodegenCtx {
        // Build hash index for def_names
        let mut def_names_hash = hashmap::HashMapU64U32::with_capacity(def_names.len());
        let mut i: usize = 0;
        while i < def_names.len() {
            def_names_hash.insert(def_names[i].def_id as u64, i as u32);
            i = i + 1;
        }

        CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::new(),
            local_types: Vec::new(),
            local_signedness: Vec::new(),
            local_hir_types: Vec::new(),
            region_locals: Vec::new(),
            persistent_locals: Vec::new(),
            current_fn: Option::None,
            string_table: Vec::new(),
            string_counter: 0,
            def_names: def_names,
            adt_registry: Vec::new(),
            def_names_hash: def_names_hash,
            local_names_hash: hashmap::HashMapU64U32::new(),
            local_types_hash: hashmap::HashMapU64U32::new(),
            local_signedness_hash: hashmap::HashMapU64U32::new(),
            local_hir_types_hash: hashmap::HashMapU64U32::new(),
            region_locals_hash: hashmap::HashMapU64U32::new(),
            persistent_locals_hash: hashmap::HashMapU64U32::new(),
            local_generations_hash: hashmap::HashMapU64U32::new(),
            local_generations: Vec::new(),
            string_table_hash: hashmap::HashMapU64U32::new(),
            static_defs_hash: hashmap::HashMapU64U32::new(),
            static_types_hash: hashmap::HashMapU64U32::new(),
            static_types: Vec::new(),
            const_defs_hash: hashmap::HashMapU64U32::new(),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: false,
        }
    }

    /// Registers a DefId with its global name.
    pub fn register_def_name(self: &mut CodegenCtx, def_id: u32, name: String) {
        let idx = self.def_names.len() as u32;
        self.def_names.push(DefNameEntry { def_id, name });
        self.def_names_hash.insert(def_id as u64, idx);
    }

    /// Looks up the global name for a DefId.
    pub fn lookup_def_name(self: &CodegenCtx, def_id: u32) -> Option<String> {
        // Fast path: hash lookup
        match self.def_names_hash.get(def_id as u64) {
            Option::Some(idx) => {
                return Option::Some(clone_string(&self.def_names[idx as usize].name));
            }
            Option::None => {}
        }
        // Fallback: linear scan (should not happen)
        let mut i: usize = 0;
        while i < self.def_names.len() {
            if self.def_names[i].def_id == def_id {
                return Option::Some(clone_string(&self.def_names[i].name));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Returns the number of registered def_names.
    pub fn def_names_count(self: &CodegenCtx) -> usize {
        self.def_names.len()
    }

    /// Returns the def_id and name for a def_name entry at the given index.
    pub fn def_name_at(self: &CodegenCtx, index: usize) -> (u32, String) {
        let entry = &self.def_names[index];
        (entry.def_id, clone_string(&entry.name))
    }

    /// Registers a DefId as a static variable.
    pub fn register_static(self: &mut CodegenCtx, def_id: u32) {
        self.static_defs_hash.insert(def_id as u64, 1);
    }

    /// Registers the LLVM type for a static variable.
    pub fn register_static_type(self: &mut CodegenCtx, def_id: u32, llvm_type: String) {
        let idx = self.static_types.len() as u32;
        self.static_types.push(llvm_type);
        self.static_types_hash.insert(def_id as u64, idx);
    }

    /// Returns the LLVM type for a static variable, if registered.
    pub fn get_static_type(self: &CodegenCtx, def_id: u32) -> Option<String> {
        match self.static_types_hash.get(def_id as u64) {
            Option::Some(idx) => {
                Option::Some(clone_string(&self.static_types[idx as usize]))
            }
            Option::None => Option::None,
        }
    }

    /// Returns true if the given DefId is a static variable.
    pub fn is_static(self: &CodegenCtx, def_id: u32) -> bool {
        match self.static_defs_hash.get(def_id as u64) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Registers a DefId as a const item.
    pub fn register_const(self: &mut CodegenCtx, def_id: u32) {
        self.const_defs_hash.insert(def_id as u64, 1);
    }

    /// Returns true if the given DefId is a const item.
    pub fn is_const(self: &CodegenCtx, def_id: u32) -> bool {
        match self.const_defs_hash.get(def_id as u64) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Resets per-function state while keeping global state (def_names).
    pub fn reset_function_state(self: &mut CodegenCtx) {
        self.output = String::new();
        self.indent_level = 0;
        self.value_counter = 0;
        self.label_counter = 0;
        self.local_names = Vec::new();
        self.local_types = Vec::new();
        self.local_signedness = Vec::new();
        self.current_fn = Option::None;
        // Note: string_table and def_names are preserved
    }

    // ======== Output Management ========

    /// Writes a string to the output.
    pub fn write(self: &mut CodegenCtx, s: &str) {
        self.output.push_str(s);
    }

    /// Writes a String to the output.
    pub fn write_string(self: &mut CodegenCtx, s: &String) {
        self.output.push_str(s.as_str());
    }

    /// Writes a newline with current indentation.
    pub fn writeln(self: &mut CodegenCtx, s: &str) {
        self.write_indent();
        self.write(s);
        self.write("\n");
    }

    /// Writes a newline.
    pub fn newline(self: &mut CodegenCtx) {
        self.write("\n");
    }

    /// Writes current indentation.
    fn write_indent(self: &mut CodegenCtx) {
        let mut i: u32 = 0;
        while i < self.indent_level {
            self.write("    ");
            i = i + 1;
        }
    }

    /// Increases indentation level.
    pub fn indent(self: &mut CodegenCtx) {
        self.indent_level = self.indent_level + 1;
    }

    /// Decreases indentation level.
    pub fn dedent(self: &mut CodegenCtx) {
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;
        }
    }

    // ======== Buffered File I/O ========

    /// Sets the output file path for buffered streaming writes.
    pub fn set_output_path(self: &mut CodegenCtx, path: &str) {
        self.output_path = String::new();
        self.output_path.push_str(path);
    }

    /// Appends text to the write buffer. Flushes to disk when buffer exceeds 65536 bytes.
    pub fn buffer_write(self: &mut CodegenCtx, s: &str) {
        self.write_buffer.push_str(s);
        if self.write_buffer.len() > 65536 {
            self.flush_write_buffer();
        }
    }

    /// Flushes the write buffer to the output file.
    pub fn flush_write_buffer(self: &mut CodegenCtx) {
        if self.write_buffer.len() > 0 {
            file_append_string(self.output_path.as_str(), self.write_buffer.as_str());
            self.write_buffer = String::new();
        }
    }

    // ======== Value Names ========

    /// Generates a new unique temporary value name.
    pub fn fresh_temp(self: &mut CodegenCtx) -> String {
        let n = self.value_counter;
        self.value_counter = self.value_counter + 1;
        let mut name = common::make_string("%tmp");
        let num_str = codegen_types::format_u64(n as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Generates a new unique label name.
    pub fn fresh_label(self: &mut CodegenCtx) -> String {
        let n = self.label_counter;
        self.label_counter = self.label_counter + 1;
        let mut name = common::make_string("label");
        let num_str = codegen_types::format_u64(n as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Gets the LLVM name for a MIR local.
    pub fn local_name(self: &CodegenCtx, local: mir_def::MirLocalId) -> String {
        // Fast path: hash lookup
        match self.local_names_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return clone_string(&self.local_names[idx as usize].name);
            }
            Option::None => {}
        }
        // Fallback: generate name from index
        let mut name = common::make_string("%_");
        let num_str = codegen_types::format_u64(local.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    /// Registers a local with its LLVM name.
    pub fn register_local(self: &mut CodegenCtx, local: mir_def::MirLocalId, name: String) {
        let idx = self.local_names.len() as u32;
        self.local_names.push(LocalName {
            local_id: local.index,
            name: name,
        });
        self.local_names_hash.insert(local.index as u64, idx);
    }

    /// Registers a local with its LLVM type.
    pub fn register_local_type(self: &mut CodegenCtx, local: mir_def::MirLocalId, llvm_type: String) {
        let idx = self.local_types.len() as u32;
        self.local_types.push(LocalType {
            local_id: local.index,
            llvm_type: llvm_type,
        });
        self.local_types_hash.insert(local.index as u64, idx);
    }

    /// Gets the LLVM type for a MIR local.
    pub fn get_local_type(self: &CodegenCtx, local: mir_def::MirLocalId) -> String {
        // Fast path: hash lookup
        match self.local_types_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return clone_string(&self.local_types[idx as usize].llvm_type);
            }
            Option::None => {}
        }
        // Fallback: return i64 if type not found
        common::make_string("i64")
    }

    /// Registers a local with its signedness (true = signed, false = unsigned).
    pub fn register_local_signedness(self: &mut CodegenCtx, local: mir_def::MirLocalId, is_signed: bool) {
        let idx = self.local_signedness.len() as u32;
        self.local_signedness.push(LocalSignedness {
            local_id: local.index,
            is_signed: is_signed,
        });
        self.local_signedness_hash.insert(local.index as u64, idx);
    }

    /// Returns whether a local is signed. Defaults to true if not found.
    pub fn is_local_signed(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        // Fast path: hash lookup
        match self.local_signedness_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return self.local_signedness[idx as usize].is_signed;
            }
            Option::None => {}
        }
        // Default to signed if not found
        true
    }

    /// Registers a local with its HIR type.
    pub fn register_local_hir_type(self: &mut CodegenCtx, local: mir_def::MirLocalId, hir_type: hir_ty::Type) {
        let idx = self.local_hir_types.len() as u32;
        self.local_hir_types.push(LocalHirType {
            local_id: local.index,
            hir_type: hir_type,
        });
        self.local_hir_types_hash.insert(local.index as u64, idx);
    }

    /// Gets the HIR type for a MIR local.
    pub fn get_local_hir_type(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<&hir_ty::Type> {
        // Fast path: hash lookup
        match self.local_hir_types_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return Option::Some(&self.local_hir_types[idx as usize].hir_type);
            }
            Option::None => {}
        }
        Option::None
    }

    /// Marks a local as region-allocated (will be unregistered on StorageDead).
    pub fn mark_region_allocated(self: &mut CodegenCtx, local: mir_def::MirLocalId) {
        self.region_locals.push(RegionLocalEntry { local_id: local.index });
        self.region_locals_hash.insert(local.index as u64, 1);
    }

    /// Marks a local as persistent-allocated (will be decremented on StorageDead).
    pub fn mark_persistent_allocated(self: &mut CodegenCtx, local: mir_def::MirLocalId) {
        self.persistent_locals.push(PersistentLocalEntry { local_id: local.index });
        self.persistent_locals_hash.insert(local.index as u64, 1);
    }

    /// Returns true if a local is region-allocated.
    pub fn is_region_allocated(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        self.region_locals_hash.contains_key(local.index as u64)
    }

    /// Returns true if a local is persistent-allocated.
    pub fn is_persistent_allocated(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        self.persistent_locals_hash.contains_key(local.index as u64)
    }

    /// Records the generation alloca SSA name for a region-allocated local.
    pub fn set_local_generation(self: &mut CodegenCtx, local: mir_def::MirLocalId, gen_name: String) {
        let idx = self.local_generations.len() as u32;
        self.local_generations.push(LocalGeneration {
            local_id: local.index,
            gen_name: gen_name,
        });
        self.local_generations_hash.insert(local.index as u64, idx);
    }

    /// Gets the generation alloca SSA name for a local, if it has one.
    pub fn get_local_generation(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<String> {
        match self.local_generations_hash.get(local.index as u64) {
            Option::Some(idx) => {
                Option::Some(clone_string(&self.local_generations[idx as usize].gen_name))
            }
            Option::None => Option::None,
        }
    }

    /// Clears all local names, types, and signedness (for reuse between functions).
    pub fn clear_locals(self: &mut CodegenCtx) {
        self.local_names.clear();
        self.local_types.clear();
        self.local_signedness.clear();
        self.local_hir_types.clear();
        self.region_locals.clear();
        self.persistent_locals.clear();
        // Clear hash indexes too
        self.local_names_hash = hashmap::HashMapU64U32::new();
        self.local_types_hash = hashmap::HashMapU64U32::new();
        self.local_signedness_hash = hashmap::HashMapU64U32::new();
        self.local_hir_types_hash = hashmap::HashMapU64U32::new();
        self.region_locals_hash = hashmap::HashMapU64U32::new();
        self.persistent_locals_hash = hashmap::HashMapU64U32::new();
        self.local_generations.clear();
        self.local_generations_hash = hashmap::HashMapU64U32::new();
    }

    // ======== ADT Registry ========

    /// Registers a struct layout in the ADT registry.
    pub fn register_struct(self: &mut CodegenCtx, layout: StructLayout) {
        self.adt_registry.push(AdtEntry::Struct(layout));
    }

    /// Registers an enum layout in the ADT registry.
    pub fn register_enum(self: &mut CodegenCtx, layout: EnumLayout) {
        self.adt_registry.push(AdtEntry::Enum(layout));
    }

    /// Looks up a struct layout by DefId.
    /// Scans from the end so that later registrations (e.g., pass 2 with resolved
    /// nested ADT types) take precedence over earlier ones.
    pub fn lookup_struct(self: &CodegenCtx, def_id: u32) -> Option<&StructLayout> {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(ref layout) => {
                    if layout.def_id == def_id {
                        return Option::Some(layout);
                    }
                }
                &AdtEntry::Enum(_) => {}
            }
        }
        Option::None
    }

    /// Looks up an enum layout by DefId.
    /// Scans from the end so that later registrations take precedence.
    pub fn lookup_enum(self: &CodegenCtx, def_id: u32) -> Option<&EnumLayout> {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(_) => {}
                &AdtEntry::Enum(ref layout) => {
                    if layout.def_id == def_id {
                        return Option::Some(layout);
                    }
                }
            }
        }
        Option::None
    }

    /// Looks up a struct field's HIR type by struct DefId and field index.
    pub fn lookup_field_hir_type(self: &CodegenCtx, def_id: u32, field_idx: u32) -> Option<&hir_ty::Type> {
        match self.lookup_struct(def_id) {
            Option::Some(layout) => {
                if (field_idx as usize) < layout.fields.len() {
                    match &layout.fields[field_idx as usize].hir_type {
                        &Option::Some(ref ty) => Option::Some(ty),
                        &Option::None => Option::None,
                    }
                } else {
                    Option::None
                }
            }
            Option::None => Option::None,
        }
    }

    /// Gets the LLVM type for an ADT (struct or enum) by DefId.
    /// Returns "ptr" as fallback if not found in the registry.
    /// Scans from the end so that pass 2 entries (with resolved nested types)
    /// take precedence over pass 1 entries.
    pub fn adt_llvm_type(self: &CodegenCtx, def_id: u32) -> String {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(ref layout) => {
                    if layout.def_id == def_id {
                        return clone_string(&layout.llvm_type);
                    }
                }
                &AdtEntry::Enum(ref layout) => {
                    if layout.def_id == def_id {
                        return clone_string(&layout.llvm_type);
                    }
                }
            }
        }
        // Fallback: check if this is a known builtin ADT
        match self.lookup_def_name(def_id) {
            Option::Some(name) => {
                let name_bytes = name.as_bytes();
                // Vec -> { ptr, i64, i64 }
                if name_bytes.len() == 3 && name_bytes[0] == 86 && name_bytes[1] == 101 && name_bytes[2] == 99 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // String -> { ptr, i64, i64 }
                if name_bytes.len() == 6 && name_bytes[0] == 83 && name_bytes[1] == 116 && name_bytes[2] == 114 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // HashMap -> { ptr, i64, i64 }
                if name_bytes.len() == 7 && name_bytes[0] == 72 && name_bytes[1] == 97 && name_bytes[2] == 115 && name_bytes[3] == 104 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // Box -> ptr
                if name_bytes.len() == 3 && name_bytes[0] == 66 && name_bytes[1] == 111 && name_bytes[2] == 120 {
                    return common::make_string("ptr");
                }
                common::make_string("ptr")
            }
            Option::None => common::make_string("ptr"),
        }
    }

    /// Converts a type to LLVM IR, using the ADT registry for struct/enum types.
    /// This is the context-aware version that properly resolves ADT types.
    /// Falls back to `codegen_types::type_to_llvm` for non-ADT types.
    pub fn type_to_llvm_with_ctx(self: &CodegenCtx, ty: &hir_ty::Type) -> String {
        match &ty.kind {
            &hir_ty::TypeKind::Adt { def_id, args: _ } => {
                self.adt_llvm_type(def_id.index)
            }
            _ => codegen_types::type_to_llvm(ty),
        }
    }

    /// Generates the name for a MIR local alloca.
    pub fn local_alloca_name(self: &mut CodegenCtx, local: mir_def::MirLocalId) -> String {
        let mut name = common::make_string("%_");
        let num_str = codegen_types::format_u64(local.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    // ======== Block Labels ========

    /// Gets the LLVM label for a basic block.
    pub fn block_label(self: &CodegenCtx, block: mir_def::BasicBlockId) -> String {
        let mut name = common::make_string("bb");
        let num_str = codegen_types::format_u64(block.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    // ======== Function Management ========

    /// Begins generating a new function.
    pub fn begin_function(self: &mut CodegenCtx, name: String) {
        self.current_fn = Option::Some(clone_string(&name));
        self.value_counter = 0;
        self.local_names.clear();
    }

    /// Ends the current function.
    pub fn end_function(self: &mut CodegenCtx) {
        self.current_fn = Option::None;
    }

    /// Returns the current function name, or empty string if none.
    pub fn current_function(self: &CodegenCtx) -> String {
        match &self.current_fn {
            &Option::Some(ref name) => clone_string(name),
            &Option::None => common::make_string(""),
        }
    }

    // ======== String Constants ========

    /// Adds a string constant to the table and returns its global label.
    pub fn add_string_constant(self: &mut CodegenCtx, content: &String) -> String {
        // Fast path: check hash index
        let hash = hashmap::hash_string(content);
        match self.string_table_hash.get(hash) {
            Option::Some(idx) => {
                // Verify it's the same string (handle hash collisions)
                if string_equal(&self.string_table[idx as usize].content, content) {
                    return clone_string(&self.string_table[idx as usize].label);
                }
                // Hash collision - fall through to linear scan
            }
            Option::None => {
                // Definitely new, add it
                let n = self.string_counter;
                self.string_counter = self.string_counter + 1;
                let mut label = common::make_string("@.str.");
                let num_str = codegen_types::format_u64(n as u64);
                label.push_str(num_str.as_str());

                let length = content.len() + 1; // +1 for null terminator
                let idx = self.string_table.len() as u32;

                self.string_table.push(StringConstant {
                    label: clone_string(&label),
                    content: clone_string(content),
                    length: length,
                });
                self.string_table_hash.insert(hash, idx);

                return label;
            }
        }

        // Hash collision case: linear scan
        let mut i: usize = 0;
        while i < self.string_table.len() {
            if string_equal(&self.string_table[i].content, content) {
                return clone_string(&self.string_table[i].label);
            }
            i = i + 1;
        }

        // Not found, add new (collision case)
        let n = self.string_counter;
        self.string_counter = self.string_counter + 1;
        let mut label = common::make_string("@.str.");
        let num_str = codegen_types::format_u64(n as u64);
        label.push_str(num_str.as_str());

        let length = content.len() + 1;

        self.string_table.push(StringConstant {
            label: clone_string(&label),
            content: clone_string(content),
            length: length,
        });

        label
    }

    /// Emits all string constants as global declarations.
    /// Should be called at the beginning of the module.
    pub fn emit_string_constants(self: &mut CodegenCtx) {
        let mut i: usize = 0;
        while i < self.string_table.len() {
            let entry = &self.string_table[i];
            // Emit: @.str.N = private unnamed_addr constant [M x i8] c"...\00"
            self.write_string(&entry.label);
            self.write(" = private unnamed_addr constant [");
            let len_str = codegen_types::format_u64(entry.length as u64);
            self.write_string(&len_str);
            self.write(" x i8] c\"");
            self.emit_string_literal_bytes(&entry.content);
            self.write("\\00\"\n");
            i = i + 1;
        }
        if self.string_table.len() > 0 {
            self.newline();
        }
    }

    /// Emits a string literal as LLVM string bytes (escaping special chars).
    fn emit_string_literal_bytes(self: &mut CodegenCtx, s: &String) {
        let bytes = s.as_bytes();
        let mut i: usize = 0;
        while i < bytes.len() {
            let b = bytes[i];
            if b == 34 {
                // Quote "
                self.write("\\22");
            } else if b == 92 {
                // Backslash
                self.write("\\5C");
            } else if b == 10 {
                // Newline
                self.write("\\0A");
            } else if b == 13 {
                // Carriage return
                self.write("\\0D");
            } else if b == 9 {
                // Tab
                self.write("\\09");
            } else if b < 32 || b > 126 {
                // Non-printable - emit as hex
                self.write("\\");
                let hex = byte_to_hex(b);
                self.write_string(&hex);
            } else {
                // Printable character
                self.output.push(b as char);
            }
            i = i + 1;
        }
    }

    // ======== LLVM IR Emission Helpers ========

    /// Emits a function definition header.
    pub fn emit_fn_header(
        self: &mut CodegenCtx,
        name: &str,
        params: &Vec<(String, String)>,
        return_ty: &str,
    ) {
        self.write("define ");
        self.write(return_ty);
        self.write(" @");
        self.write(name);
        self.write("(");

        let mut i: usize = 0;
        while i < params.len() {
            if i > 0 {
                self.write(", ");
            }
            let param = &params[i];
            self.write_string(&param.0);
            self.write(" ");
            self.write_string(&param.1);
            i = i + 1;
        }

        self.write(") {\n");
    }

    /// Emits a function definition footer.
    pub fn emit_fn_footer(self: &mut CodegenCtx) {
        self.write("}\n\n");
    }

    /// Emits an alloca instruction.
    pub fn emit_alloca(self: &mut CodegenCtx, result: &str, ty: &str) {
        self.write_indent();
        self.write(result);
        self.write(" = alloca ");
        self.write(ty);
        self.write("\n");
    }

    /// Emits a load instruction.
    pub fn emit_load(self: &mut CodegenCtx, result: &str, ty: &str, ptr: &str) {
        self.write_indent();
        self.write(result);
        self.write(" = load ");
        self.write(ty);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a store instruction.
    pub fn emit_store(self: &mut CodegenCtx, ty: &str, val: &str, ptr: &str) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a binary operation.
    pub fn emit_binop(
        self: &mut CodegenCtx,
        result: &str,
        opcode: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an icmp instruction.
    pub fn emit_icmp(
        self: &mut CodegenCtx,
        result: &str,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = icmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an fcmp instruction.
    pub fn emit_fcmp(
        self: &mut CodegenCtx,
        result: &str,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = fcmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits a cast instruction (trunc, zext, sext, fptrunc, fpext, etc).
    pub fn emit_cast(
        self: &mut CodegenCtx,
        result: &str,
        opcode: &str,
        src_ty: &str,
        val: &str,
        tgt_ty: &str,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(src_ty);
        self.write(" ");
        self.write(val);
        self.write(" to ");
        self.write(tgt_ty);
        self.write("\n");
    }

    /// Emits a call instruction.
    pub fn emit_call(
        self: &mut CodegenCtx,
        result: Option<&str>,
        return_ty: &str,
        func: &str,
        args: &Vec<(String, String)>,
    ) {
        self.write_indent();
        match result {
            Option::Some(r) => {
                self.write(r);
                self.write(" = ");
            }
            Option::None => {}
        }
        self.write("call ");
        self.write(return_ty);
        self.write(" ");
        self.write(func);
        self.write("(");

        let mut i: usize = 0;
        while i < args.len() {
            if i > 0 {
                self.write(", ");
            }
            let arg = &args[i];
            self.write_string(&arg.0);
            self.write(" ");
            self.write_string(&arg.1);
            i = i + 1;
        }

        self.write(")\n");
    }

    /// Emits a getelementptr instruction.
    pub fn emit_gep(
        self: &mut CodegenCtx,
        result: &str,
        base_ty: &str,
        ptr: &str,
        indices: &Vec<String>,
    ) {
        self.write_indent();
        self.write(result);
        self.write(" = getelementptr ");
        self.write(base_ty);
        self.write(", ptr ");
        self.write(ptr);

        let mut i: usize = 0;
        while i < indices.len() {
            if i == 0 {
                // First index is always a pointer offset — must be i64
                self.write(", i64 ");
            } else {
                // Subsequent indices: SSA registers (%...) are array indices (i64),
                // numeric constants are struct field indices (must be i32 per LLVM spec)
                let ref idx = indices[i];
                let bytes = idx.as_bytes();
                if bytes.len() > 0 && bytes[0] == 37 {
                    // 37 == '%' — SSA register, used for array indexing
                    self.write(", i64 ");
                } else {
                    // Numeric constant — struct field index, must be i32
                    self.write(", i32 ");
                }
            }
            self.write_string(&indices[i]);
            i = i + 1;
        }

        self.write("\n");
    }

    /// Emits a br instruction (unconditional).
    pub fn emit_br(self: &mut CodegenCtx, label: &str) {
        self.write_indent();
        self.write("br label %");
        self.write(label);
        self.write("\n");
    }

    /// Emits a conditional br instruction.
    pub fn emit_cond_br(
        self: &mut CodegenCtx,
        cond: &str,
        true_label: &str,
        false_label: &str,
    ) {
        self.write_indent();
        self.write("br i1 ");
        self.write(cond);
        self.write(", label %");
        self.write(true_label);
        self.write(", label %");
        self.write(false_label);
        self.write("\n");
    }

    /// Emits a ret instruction.
    pub fn emit_ret(self: &mut CodegenCtx, ty: &str, val: Option<&str>) {
        self.write_indent();
        self.write("ret ");
        self.write(ty);
        match val {
            Option::Some(v) => {
                self.write(" ");
                self.write(v);
            }
            Option::None => {}
        }
        self.write("\n");
    }

    /// Emits a label.
    pub fn emit_label(self: &mut CodegenCtx, label: &str) {
        self.write(label);
        self.write(":\n");
    }

    /// Emits an unreachable instruction.
    pub fn emit_unreachable(self: &mut CodegenCtx) {
        self.write_indent();
        self.write("unreachable\n");
    }

    /// Emits a switch instruction.
    pub fn emit_switch(
        self: &mut CodegenCtx,
        ty: &str,
        val: &str,
        default_label: &str,
        cases: &Vec<(String, String)>,
    ) {
        self.write_indent();
        self.write("switch ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", label %");
        self.write(default_label);
        self.write(" [\n");

        self.indent();
        let mut i: usize = 0;
        while i < cases.len() {
            let case_val = &cases[i];
            self.write_indent();
            self.write(ty);
            self.write(" ");
            self.write_string(&case_val.0);
            self.write(", label %");
            self.write_string(&case_val.1);
            self.write("\n");
            i = i + 1;
        }
        self.dedent();

        self.write_indent();
        self.write("]\n");
    }
    // ======== Worker Context for Parallel Codegen ========

    /// Creates an isolated worker context that clones read-only state from the parent.
    /// Worker contexts have their own string table, counters, and per-function state.
    /// Used for parallel codegen: each thread gets a worker ctx, produces IR independently,
    /// then string tables are merged back into the parent.
    pub fn create_worker_ctx(self: &CodegenCtx) -> CodegenCtx {
        // Clone def_names (read-only during codegen)
        let mut worker_def_names: Vec<DefNameEntry> = Vec::new();
        let mut worker_def_hash = hashmap::HashMapU64U32::with_capacity(self.def_names.len());
        let mut i: usize = 0;
        while i < self.def_names.len() {
            let entry = &self.def_names[i];
            worker_def_names.push(DefNameEntry::new(entry.def_id, clone_string(&entry.name)));
            worker_def_hash.insert(entry.def_id as u64, i as u32);
            i = i + 1;
        }

        // Deep-clone adt_registry (read-only during codegen, but each thread needs its own copy)
        let mut worker_adt_registry: Vec<AdtEntry> = Vec::new();
        let mut ai: usize = 0;
        while ai < self.adt_registry.len() {
            match &self.adt_registry[ai] {
                &AdtEntry::Struct(ref sl) => {
                    let mut cloned_fields: Vec<AdtFieldInfo> = Vec::new();
                    let mut fi: usize = 0;
                    while fi < sl.fields.len() {
                        let field = &sl.fields[fi];
                        let cloned_hir = match &field.hir_type {
                            &Option::Some(ref ty) => Option::Some(hir_ty::copy_type(ty)),
                            &Option::None => Option::None,
                        };
                        cloned_fields.push(AdtFieldInfo {
                            llvm_type: clone_string(&field.llvm_type),
                            hir_type: cloned_hir,
                        });
                        fi = fi + 1;
                    }
                    worker_adt_registry.push(AdtEntry::Struct(StructLayout {
                        def_id: sl.def_id,
                        fields: cloned_fields,
                        llvm_type: clone_string(&sl.llvm_type),
                    }));
                }
                &AdtEntry::Enum(ref el) => {
                    let mut cloned_variants: Vec<VariantLayout> = Vec::new();
                    let mut vi: usize = 0;
                    while vi < el.variants.len() {
                        let variant = &el.variants[vi];
                        let mut cloned_vfields: Vec<AdtFieldInfo> = Vec::new();
                        let mut vfi: usize = 0;
                        while vfi < variant.fields.len() {
                            let vf = &variant.fields[vfi];
                            let cloned_hir = match &vf.hir_type {
                                &Option::Some(ref ty) => Option::Some(hir_ty::copy_type(ty)),
                                &Option::None => Option::None,
                            };
                            cloned_vfields.push(AdtFieldInfo {
                                llvm_type: clone_string(&vf.llvm_type),
                                hir_type: cloned_hir,
                            });
                            vfi = vfi + 1;
                        }
                        cloned_variants.push(VariantLayout {
                            variant_idx: variant.variant_idx,
                            fields: cloned_vfields,
                            payload_llvm_type: clone_string(&variant.payload_llvm_type),
                        });
                        vi = vi + 1;
                    }
                    worker_adt_registry.push(AdtEntry::Enum(EnumLayout {
                        def_id: el.def_id,
                        discriminant_type: clone_string(&el.discriminant_type),
                        variants: cloned_variants,
                        llvm_type: clone_string(&el.llvm_type),
                        max_payload_size: el.max_payload_size,
                    }));
                }
            }
            ai = ai + 1;
        }

        let mut worker = CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::new(),
            local_types: Vec::new(),
            local_signedness: Vec::new(),
            local_hir_types: Vec::new(),
            region_locals: Vec::new(),
            persistent_locals: Vec::new(),
            current_fn: Option::None,
            string_table: Vec::new(),
            string_counter: 0,
            def_names: worker_def_names,
            adt_registry: worker_adt_registry,
            def_names_hash: worker_def_hash,
            local_names_hash: hashmap::HashMapU64U32::new(),
            local_types_hash: hashmap::HashMapU64U32::new(),
            local_signedness_hash: hashmap::HashMapU64U32::new(),
            local_hir_types_hash: hashmap::HashMapU64U32::new(),
            region_locals_hash: hashmap::HashMapU64U32::new(),
            persistent_locals_hash: hashmap::HashMapU64U32::new(),
            local_generations_hash: hashmap::HashMapU64U32::new(),
            local_generations: Vec::new(),
            string_table_hash: hashmap::HashMapU64U32::new(),
            static_defs_hash: hashmap::HashMapU64U32::new(),
            static_types_hash: hashmap::HashMapU64U32::new(),
            static_types: Vec::new(),
            const_defs_hash: hashmap::HashMapU64U32::new(),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: self.trace_codegen,
        };

        // Copy static and const defs hashes (read-only)
        let mut si: usize = 0;
        while si < self.def_names.len() {
            let entry = &self.def_names[si];
            if self.is_static(entry.def_id) {
                worker.register_static(entry.def_id);
                match self.get_static_type(entry.def_id) {
                    Option::Some(ty) => {
                        worker.register_static_type(entry.def_id, ty);
                    }
                    Option::None => {}
                }
            }
            if self.is_const(entry.def_id) {
                worker.register_const(entry.def_id);
            }
            si = si + 1;
        }

        worker
    }

    /// Returns the number of string constants in the string table.
    pub fn string_table_len(self: &CodegenCtx) -> usize {
        self.string_table.len()
    }

    /// Returns the content of the string constant at the given index.
    pub fn string_content_at(self: &CodegenCtx, index: usize) -> &String {
        &self.string_table[index].content
    }

    /// Returns the label of the string constant at the given index.
    pub fn string_label_at(self: &CodegenCtx, index: usize) -> &String {
        &self.string_table[index].label
    }
}

/// A string label remapping entry (from worker-local to final label).
pub struct StringRemap {
    /// The worker-local label (e.g., "@.str.0").
    pub from: String,
    /// The final label in the merged table (e.g., "@.str.42").
    pub to: String,
}

/// Merges a worker's string table into the main context's string table.
/// Returns a list of remappings (worker label -> final label) for any labels that changed.
/// String constants that already exist in the main table are deduplicated.
pub fn merge_string_tables(
    main_ctx: &mut CodegenCtx,
    worker_ctx: &CodegenCtx,
) -> Vec<StringRemap> {
    let mut remaps: Vec<StringRemap> = Vec::new();

    let mut i: usize = 0;
    while i < worker_ctx.string_table_len() {
        let content = worker_ctx.string_content_at(i);
        let worker_label = worker_ctx.string_label_at(i);

        // Add to main (deduplicates internally)
        let final_label = main_ctx.add_string_constant(content);

        // If the label changed, record the remapping
        if !string_equal(worker_label, &final_label) {
            remaps.push(StringRemap {
                from: clone_string(worker_label),
                to: final_label,
            });
        }

        i = i + 1;
    }

    remaps
}

/// Applies string label remappings to an IR string.
/// Replaces each occurrence of remap.from with remap.to.
/// Only needed when parallel codegen produces worker-local string labels.
pub fn remap_string_labels(ir: &String, remaps: &Vec<StringRemap>) -> String {
    if remaps.len() == 0 {
        return clone_string(ir);
    }

    let mut result = clone_string(ir);

    // Apply remappings. Since labels are unique (@.str.N), simple replacement is safe.
    // Process in reverse order of label number to avoid @.str.1 replacing part of @.str.10.
    let mut i: usize = remaps.len();
    while i > 0 {
        i = i - 1;
        let remap = &remaps[i];
        result = string_replace(&result, &remap.from, &remap.to);
    }

    result
}

/// Replaces all occurrences of `from` with `to` in `s`.
fn string_replace(s: &String, from: &String, to: &String) -> String {
    let s_bytes = s.as_bytes();
    let from_bytes = from.as_bytes();
    let to_bytes = to.as_bytes();
    let s_len = s_bytes.len();
    let from_len = from_bytes.len();

    if from_len == 0 || from_len > s_len {
        return clone_string(s);
    }

    let mut result = String::new();
    let mut i: usize = 0;

    while i < s_len {
        // Check if `from` starts at position i
        if i + from_len <= s_len {
            let mut matches = true;
            let mut j: usize = 0;
            while j < from_len {
                if s_bytes[i + j] != from_bytes[j] {
                    matches = false;
                    j = from_len; // break
                }
                j = j + 1;
            }
            if matches {
                // Append replacement
                let mut k: usize = 0;
                while k < to_bytes.len() {
                    result.push(to_bytes[k] as char);
                    k = k + 1;
                }
                i = i + from_len;
                continue;
            }
        }
        result.push(s_bytes[i] as char);
        i = i + 1;
    }

    result
}

// ============================================================
// String Helpers
// ============================================================

/// Clones a String.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    result.push_str(s.as_str());
    result
}

/// Compares two strings for equality.
fn string_equal(a: &String, b: &String) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Converts a byte to a two-character hex string.
fn byte_to_hex(b: u8) -> String {
    let mut result = String::new();
    let high = (b >> 4) & 0xF;
    let low = b & 0xF;
    result.push(nibble_to_hex(high));
    result.push(nibble_to_hex(low));
    result
}

/// Converts a nibble (0-15) to a hex character.
fn nibble_to_hex(n: u8) -> char {
    if n < 10 {
        (48u8 + n) as char
    } else {
        (55u8 + n) as char
    }
}
