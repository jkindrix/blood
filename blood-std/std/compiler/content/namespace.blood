/// Namespace Management Module
///
/// Maps human-readable names to content hashes.
///
/// In Blood, names are metadata—the true identity of code is its content hash.
/// Namespaces provide a human-friendly way to refer to definitions.
///
/// # Example
///
/// ```text
/// namespace main {
///     add       → #a7f2k9m3xp
///     subtract  → #b3c1xp5jht
///     multiply  → #c4d2yr6kiu
///
///     type Point  → #e5f3zs7lmn
///     type Vector → #f6g4at8mop
///
///     effect IO    → #g7h5bu9npq
///     effect State → #h8i6cv0oqr
/// }
/// ```

use std.collections::HashMap;
use super.hash::ContentHash;

// ============================================================================
// Binding Kind
// ============================================================================

/// The kind of a name binding.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum BindingKind {
    /// A function or value definition.
    Value,
    /// A type definition.
    Type,
    /// An effect definition.
    Effect,
    /// A type alias.
    TypeAlias,
    /// A module.
    Module,
}

impl BindingKind {
    /// Check if this is a value binding.
    pub fn is_value(&self) -> bool {
        matches!(self, BindingKind::Value)
    }

    /// Check if this is a type binding.
    pub fn is_type(&self) -> bool {
        matches!(self, BindingKind::Type)
    }

    /// Check if this is an effect binding.
    pub fn is_effect(&self) -> bool {
        matches!(self, BindingKind::Effect)
    }

    /// Check if this is a type alias binding.
    pub fn is_type_alias(&self) -> bool {
        matches!(self, BindingKind::TypeAlias)
    }

    /// Check if this is a module binding.
    pub fn is_module(&self) -> bool {
        matches!(self, BindingKind::Module)
    }
}

impl std.fmt::Debug for BindingKind {
    fn fmt(&self, f: &mut std.fmt::Formatter) -> std.fmt::Result {
        match self {
            BindingKind::Value => write!(f, "Value"),
            BindingKind::Type => write!(f, "Type"),
            BindingKind::Effect => write!(f, "Effect"),
            BindingKind::TypeAlias => write!(f, "TypeAlias"),
            BindingKind::Module => write!(f, "Module"),
        }
    }
}

impl std.fmt::Display for BindingKind {
    fn fmt(&self, f: &mut std.fmt::Formatter) -> std.fmt::Result {
        match self {
            BindingKind::Value => write!(f, "value"),
            BindingKind::Type => write!(f, "type"),
            BindingKind::Effect => write!(f, "effect"),
            BindingKind::TypeAlias => write!(f, "type alias"),
            BindingKind::Module => write!(f, "module"),
        }
    }
}

// ============================================================================
// Name Binding
// ============================================================================

/// A binding from a name to a content hash.
#[derive(Clone, PartialEq, Eq)]
pub struct NameBinding {
    /// The content hash this name refers to.
    pub hash: ContentHash,
    /// The kind of binding.
    pub kind: BindingKind,
    /// Whether this binding is public.
    pub is_public: bool,
    /// Optional documentation.
    pub doc: Option<String>,
}

impl NameBinding {
    /// Create a new value binding.
    pub fn value(hash: ContentHash) -> NameBinding {
        NameBinding {
            hash,
            kind: BindingKind::Value,
            is_public: true,
            doc: None,
        }
    }

    /// Create a new type binding.
    pub fn ty(hash: ContentHash) -> NameBinding {
        NameBinding {
            hash,
            kind: BindingKind::Type,
            is_public: true,
            doc: None,
        }
    }

    /// Create a new effect binding.
    pub fn effect(hash: ContentHash) -> NameBinding {
        NameBinding {
            hash,
            kind: BindingKind::Effect,
            is_public: true,
            doc: None,
        }
    }

    /// Create a new type alias binding.
    pub fn type_alias(hash: ContentHash) -> NameBinding {
        NameBinding {
            hash,
            kind: BindingKind::TypeAlias,
            is_public: true,
            doc: None,
        }
    }

    /// Create a new module binding.
    pub fn module(hash: ContentHash) -> NameBinding {
        NameBinding {
            hash,
            kind: BindingKind::Module,
            is_public: true,
            doc: None,
        }
    }

    /// Set visibility.
    pub fn with_visibility(mut self, is_public: bool) -> NameBinding {
        self.is_public = is_public;
        self
    }

    /// Make this binding private.
    pub fn private(mut self) -> NameBinding {
        self.is_public = false;
        self
    }

    /// Set documentation.
    pub fn with_doc(mut self, doc: String) -> NameBinding {
        self.doc = Some(doc);
        self
    }
}

impl std.fmt::Debug for NameBinding {
    fn fmt(&self, f: &mut std.fmt::Formatter) -> std.fmt::Result {
        f.debug_struct("NameBinding")
            .field("hash", &self.hash.short_display())
            .field("kind", &self.kind)
            .field("is_public", &self.is_public)
            .field("doc", &self.doc)
            .finish();
    }
}

// ============================================================================
// Namespace
// ============================================================================

/// A namespace containing name-to-hash mappings.
#[derive(Clone, Default)]
pub struct Namespace {
    /// The name of this namespace.
    name: String,
    /// Name bindings in this namespace.
    bindings: HashMap<String, NameBinding>,
    /// Child namespaces.
    children: HashMap<String, Namespace>,
    /// Parent namespace name (for qualified names).
    parent: Option<String>,
}

impl Namespace {
    /// Create a new root namespace.
    pub fn new(name: &str) -> Namespace {
        Namespace {
            name: name.to_string(),
            bindings: HashMap::new(),
            children: HashMap::new(),
            parent: None,
        }
    }

    /// Create a child namespace.
    pub fn child(name: &str, parent: &str) -> Namespace {
        Namespace {
            name: name.to_string(),
            bindings: HashMap::new(),
            children: HashMap::new(),
            parent: Some(parent.to_string()),
        }
    }

    /// Get the name of this namespace.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the fully qualified name of this namespace.
    pub fn qualified_name(&self) -> String {
        match &self.parent {
            Some(parent) => format!("{}.{}", parent, self.name),
            None => self.name.clone(),
        }
    }

    /// Check if this is a root namespace.
    pub fn is_root(&self) -> bool {
        self.parent.is_none();
    }

    /// Bind a name to a hash.
    pub fn bind(&mut self, name: &str, binding: NameBinding) {
        self.bindings.insert(name.to_string(), binding);
    }

    /// Bind a value.
    pub fn bind_value(&mut self, name: &str, hash: ContentHash) {
        self.bind(name, NameBinding::value(hash));
    }

    /// Bind a type.
    pub fn bind_type(&mut self, name: &str, hash: ContentHash) {
        self.bind(name, NameBinding::ty(hash));
    }

    /// Bind an effect.
    pub fn bind_effect(&mut self, name: &str, hash: ContentHash) {
        self.bind(name, NameBinding::effect(hash));
    }

    /// Look up a name in this namespace.
    pub fn lookup(&self, name: &str) -> Option<&NameBinding> {
        self.bindings.get(name);
    }

    /// Look up a name mutably.
    pub fn lookup_mut(&mut self, name: &str) -> Option<&mut NameBinding> {
        self.bindings.get_mut(name);
    }

    /// Look up a name by kind.
    pub fn lookup_kind(&self, name: &str, kind: BindingKind) -> Option<&NameBinding> {
        self.bindings.get(name).filter(|b| b.kind == kind);
    }

    /// Look up a value.
    pub fn lookup_value(&self, name: &str) -> Option<ContentHash> {
        self.lookup_kind(name, BindingKind::Value).map(|b| b.hash);
    }

    /// Look up a type.
    pub fn lookup_type(&self, name: &str) -> Option<ContentHash> {
        self.lookup_kind(name, BindingKind::Type).map(|b| b.hash);
    }

    /// Look up an effect.
    pub fn lookup_effect(&self, name: &str) -> Option<ContentHash> {
        self.lookup_kind(name, BindingKind::Effect).map(|b| b.hash);
    }

    /// Check if a name exists in this namespace.
    pub fn contains(&self, name: &str) -> bool {
        self.bindings.contains_key(name);
    }

    /// Get or create a child namespace.
    pub fn get_or_create_child(&mut self, name: &str) -> &mut Namespace {
        let qualified = self.qualified_name();
        self.children
            .entry(name.to_string())
            .or_insert_with(|| Namespace::child(name, &qualified));
    }

    /// Get a child namespace.
    pub fn get_child(&self, name: &str) -> Option<&Namespace> {
        self.children.get(name);
    }

    /// Get a child namespace mutably.
    pub fn get_child_mut(&mut self, name: &str) -> Option<&mut Namespace> {
        self.children.get_mut(name);
    }

    /// Check if a child namespace exists.
    pub fn has_child(&self, name: &str) -> bool {
        self.children.contains_key(name);
    }

    /// Iterate over all bindings.
    pub fn bindings(&self) -> impl Iterator<Item = (&str, &NameBinding)> {
        self.bindings.iter().map(|(k, v)| (k.as_str(), v));
    }

    /// Iterate over all public bindings.
    pub fn public_bindings(&self) -> impl Iterator<Item = (&str, &NameBinding)> {
        self.bindings
            .iter()
            .filter(|(_, v)| v.is_public)
            .map(|(k, v)| (k.as_str(), v));
    }

    /// Iterate over all private bindings.
    pub fn private_bindings(&self) -> impl Iterator<Item = (&str, &NameBinding)> {
        self.bindings
            .iter()
            .filter(|(_, v)| !v.is_public)
            .map(|(k, v)| (k.as_str(), v));
    }

    /// Iterate over child namespaces.
    pub fn children(&self) -> impl Iterator<Item = (&str, &Namespace)> {
        self.children.iter().map(|(k, v)| (k.as_str(), v));
    }

    /// Remove a binding.
    pub fn unbind(&mut self, name: &str) -> Option<NameBinding> {
        self.bindings.remove(name);
    }

    /// Rename a binding (doesn't change the hash, only the name).
    pub fn rename(&mut self, old_name: &str, new_name: &str) -> bool {
        if let Some(binding) = self.bindings.remove(old_name) {
            self.bindings.insert(new_name.to_string(), binding);
            true
        } else {
            false
        }
    }

    /// Find all names that map to a given hash.
    pub fn find_names(&self, hash: ContentHash) -> Vec<&str> {
        self.bindings
            .iter()
            .filter(|(_, b)| b.hash == hash)
            .map(|(name, _)| name.as_str())
            .collect();
    }

    /// Get the number of bindings in this namespace.
    pub fn len(&self) -> usize {
        self.bindings.len();
    }

    /// Check if the namespace is empty.
    pub fn is_empty(&self) -> bool {
        self.bindings.is_empty();
    }

    /// Get the number of child namespaces.
    pub fn child_count(&self) -> usize {
        self.children.len();
    }

    /// Get the total count of all bindings including children.
    pub fn total_binding_count(&self) -> usize {
        let mut count = self.bindings.len();
        for (_, child) in &self.children {
            count += child.total_binding_count();
        }
        count
    }

    /// Merge another namespace into this one.
    /// Overwrites existing bindings with the same name.
    pub fn merge(&mut self, other: Namespace) {
        self.bindings.extend(other.bindings);
        for (name, child) in other.children {
            self.children.insert(name, child);
        }
    }

    /// Clear all bindings.
    pub fn clear(&mut self) {
        self.bindings.clear();
        self.children.clear();
    }

    /// Look up a qualified name (e.g., "std.io.println").
    pub fn lookup_qualified(&self, path: &str) -> Option<&NameBinding> {
        let parts: Vec<&str> = path.split('.').collect();
        self.lookup_path(&parts);
    }

    /// Look up a path of names.
    fn lookup_path(&self, path: &[&str]) -> Option<&NameBinding> {
        match path {
            [] => None,
            [name] => self.lookup(name),
            [child, rest @ ..] => self.children.get(*child)?.lookup_path(rest),
        }
    }
}

impl std.fmt::Debug for Namespace {
    fn fmt(&self, f: &mut std.fmt::Formatter) -> std.fmt::Result {
        f.debug_struct("Namespace")
            .field("name", &self.name)
            .field("bindings", &self.bindings.len())
            .field("children", &self.children.len())
            .finish();
    }
}

// ============================================================================
// Name Registry
// ============================================================================

/// A collection of namespaces forming a codebase's name registry.
#[derive(Clone, Default)]
pub struct NameRegistry {
    /// Root namespaces.
    roots: HashMap<String, Namespace>,
    /// The current/default namespace.
    current: String,
}

impl NameRegistry {
    /// Create a new name registry with a default namespace.
    pub fn new() -> NameRegistry {
        let mut roots = HashMap::new();
        roots.insert("main".to_string(), Namespace::new("main"));
        NameRegistry {
            roots,
            current: "main".to_string(),
        }
    }

    /// Create an empty name registry.
    pub fn empty() -> NameRegistry {
        NameRegistry {
            roots: HashMap::new(),
            current: "main".to_string(),
        }
    }

    /// Get or create a root namespace.
    pub fn get_or_create(&mut self, name: &str) -> &mut Namespace {
        self.roots
            .entry(name.to_string())
            .or_insert_with(|| Namespace::new(name));
    }

    /// Get a root namespace.
    pub fn get(&self, name: &str) -> Option<&Namespace> {
        self.roots.get(name);
    }

    /// Get a root namespace mutably.
    pub fn get_mut(&mut self, name: &str) -> Option<&mut Namespace> {
        self.roots.get_mut(name);
    }

    /// Check if a root namespace exists.
    pub fn has(&self, name: &str) -> bool {
        self.roots.contains_key(name);
    }

    /// Get the current namespace.
    pub fn current(&self) -> Option<&Namespace> {
        self.get(&self.current);
    }

    /// Get the current namespace mutably.
    pub fn current_mut(&mut self) -> &mut Namespace {
        let current = self.current.clone();
        self.get_or_create(&current);
    }

    /// Get the name of the current namespace.
    pub fn current_name(&self) -> &str {
        &self.current
    }

    /// Set the current namespace.
    pub fn set_current(&mut self, name: &str) {
        self.current = name.to_string();
    }

    /// Look up a name in the current namespace.
    pub fn lookup(&self, name: &str) -> Option<&NameBinding> {
        self.current()?.lookup(name);
    }

    /// Look up a qualified name across all namespaces.
    pub fn lookup_qualified(&self, path: &str) -> Option<&NameBinding> {
        let parts: Vec<&str> = path.split('.').collect();
        match parts.as_slice() {
            [] => None,
            [single] => self.lookup(single),
            [root, rest @ ..] => {
                let ns = self.roots.get(*root)?;
                ns.lookup_path(rest);
            }
        }
    }

    /// Iterate over all root namespaces.
    pub fn roots(&self) -> impl Iterator<Item = (&str, &Namespace)> {
        self.roots.iter().map(|(k, v)| (k.as_str(), v));
    }

    /// Get the number of root namespaces.
    pub fn len(&self) -> usize {
        self.roots.len();
    }

    /// Check if empty.
    pub fn is_empty(&self) -> bool {
        self.roots.is_empty();
    }

    /// Get total count of all bindings across all namespaces.
    pub fn total_binding_count(&self) -> usize {
        self.roots.values().map(|ns| ns.total_binding_count()).sum();
    }

    /// Clear all namespaces.
    pub fn clear(&mut self) {
        self.roots.clear();
    }
}

impl std.fmt::Debug for NameRegistry {
    fn fmt(&self, f: &mut std.fmt::Formatter) -> std.fmt::Result {
        f.debug_struct("NameRegistry")
            .field("roots", &self.roots.len())
            .field("current", &self.current)
            .finish();
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_namespace_bind_lookup() {
        let mut ns = Namespace::new("test");
        let hash = ContentHash::compute(b"add");

        ns.bind("add", NameBinding::value(hash));

        let binding = ns.lookup("add").unwrap();
        assert_eq!(binding.hash, hash);
        assert_eq!(binding.kind, BindingKind::Value);
    }

    #[test]
    fn test_namespace_lookup_by_kind() {
        let mut ns = Namespace::new("test");
        let hash = ContentHash::compute(b"Int");

        ns.bind("Int", NameBinding::ty(hash));

        assert!(ns.lookup_kind("Int", BindingKind::Type).is_some());
        assert!(ns.lookup_kind("Int", BindingKind::Value).is_none());
    }

    #[test]
    fn test_namespace_rename() {
        let mut ns = Namespace::new("test");
        let hash = ContentHash::compute(b"add");

        ns.bind("add", NameBinding::value(hash));
        assert!(ns.rename("add", "addition"));

        assert!(ns.lookup("add").is_none());
        assert_eq!(ns.lookup("addition").unwrap().hash, hash);
    }

    #[test]
    fn test_namespace_find_names() {
        let mut ns = Namespace::new("test");
        let hash = ContentHash::compute(b"add");

        ns.bind("add", NameBinding::value(hash));
        ns.bind("plus", NameBinding::value(hash));

        let names = ns.find_names(hash);
        assert!(names.contains(&"add"));
        assert!(names.contains(&"plus"));
    }

    #[test]
    fn test_child_namespace() {
        let mut ns = Namespace::new("std");
        {
            let io = ns.get_or_create_child("io");
            io.bind("println", NameBinding::value(ContentHash::compute(b"println")));
        };

        let io = ns.get_child("io").unwrap();
        assert!(io.lookup("println").is_some());
    }

    #[test]
    fn test_qualified_lookup() {
        let mut ns = Namespace::new("std");
        {
            let io = ns.get_or_create_child("io");
            io.bind("println", NameBinding::value(ContentHash::compute(b"println")));
        };

        assert!(ns.lookup_qualified("io.println").is_some());
    }

    #[test]
    fn test_name_registry() {
        let mut registry = NameRegistry::new();
        let hash = ContentHash::compute(b"main");

        registry.current_mut().bind("main", NameBinding::value(hash));

        assert!(registry.lookup("main").is_some());
    }

    #[test]
    fn test_binding_with_doc() {
        let binding = NameBinding::value(ContentHash::ZERO)
            .with_doc("Adds two numbers".to_string());

        assert_eq!(binding.doc.as_deref(), Some("Adds two numbers"));
    }

    #[test]
    fn test_public_bindings() {
        let mut ns = Namespace::new("test");
        ns.bind("public_fn", NameBinding::value(ContentHash::ZERO));
        ns.bind(
            "private_fn",
            NameBinding::value(ContentHash::ZERO).with_visibility(false),
        );

        let public: Vec<_> = ns.public_bindings().collect();
        assert_eq!(public.len(), 1);
        assert_eq!(public[0].0, "public_fn");
    }

    #[test]
    fn test_binding_kind_methods() {
        assert!(BindingKind::Value.is_value());
        assert!(BindingKind::Type.is_type());
        assert!(BindingKind::Effect.is_effect());
        assert!(BindingKind::TypeAlias.is_type_alias());
        assert!(BindingKind::Module.is_module());

        assert!(!BindingKind::Value.is_type());
        assert!(!BindingKind::Type.is_value());
    }

    #[test]
    fn test_namespace_qualified_name() {
        let mut parent = Namespace::new("std");
        let child = parent.get_or_create_child("io");

        assert_eq!(parent.qualified_name(), "std");
        assert_eq!(child.qualified_name(), "std.io");
    }

    #[test]
    fn test_registry_qualified_lookup() {
        let mut registry = NameRegistry::new();

        // Create std.io.println
        let std_ns = registry.get_or_create("std");
        let io_ns = std_ns.get_or_create_child("io");
        io_ns.bind("println", NameBinding::value(ContentHash::compute(b"println")));

        // Look up qualified
        let binding = registry.lookup_qualified("std.io.println");
        assert!(binding.is_some());
    }
}
