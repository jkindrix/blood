//! # Virtual Function Table (VFT)
//!
//! Maps content hashes to runtime entry points.
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────┐
//! │                    VIRTUAL FUNCTION TABLE                    │
//! ├─────────────────────────────────────────────────────────────┤
//! │ Hash                    │ Entry Point    │ Metadata          │
//! ├─────────────────────────┼────────────────┼───────────────────┤
//! │ #a7f2k9m3xp...          │ 0x00401000     │ { arity: 2 }      │
//! │ #b3c1xp5jht...          │ 0x00401050     │ { arity: 2 }      │
//! │ #c4d2yr6kiu...          │ 0x004010A0     │ { arity: 2 }      │
//! └─────────────────────────────────────────────────────────────┘
//! ```
//!
//! ## Key Features
//!
//! - **Hash-indexed lookup**: O(1) entry point resolution
//! - **Hot-swap support**: Live code replacement without restart
//! - **Effect tracking**: Bit flags for effect categories
//! - **Multiple dispatch**: Type-based dispatch tables
//! - **Epoch management**: Scheduled updates for safe transitions

module std.compiler.content.vft;

use std.collections.HashMap;
use std.collections.Vec;
use std.result.Result;
use std.option.Option;
use std.compiler.content.hash.ContentHash;

// ============================================================================
// Calling Convention
// ============================================================================

/// Calling convention for VFT entries.
///
/// Different calling conventions enable different runtime optimizations
/// and interaction patterns.
pub enum CallingConvention {
    /// Standard Blood calling convention.
    ///
    /// Arguments passed via registers/stack per platform ABI.
    /// Return values in designated registers.
    Blood,

    /// Tail-call optimized convention.
    ///
    /// Enables TCO by reusing the caller's stack frame.
    /// The callee jumps directly to the next function.
    Tail,

    /// Effect-aware calling convention.
    ///
    /// Captures the continuation for effect handling.
    /// Used when functions may perform algebraic effects.
    Effect,

    /// Foreign function interface convention.
    ///
    /// Follows the platform's C calling convention for FFI.
    /// Used for callbacks and external library integration.
    Foreign,
}

impl CallingConvention {
    /// Returns the default calling convention (Blood).
    pub fn default() -> CallingConvention {
        CallingConvention::Blood
    }

    /// Check if this is the standard Blood convention.
    pub fn is_standard(self) -> Bool {
        match self {
            CallingConvention::Blood => true,
            CallingConvention::Tail => false,
            CallingConvention::Effect => false,
            CallingConvention::Foreign => false,
        }
    }

    /// Check if this convention supports tail-call optimization.
    pub fn supports_tco(self) -> Bool {
        match self {
            CallingConvention::Blood => false,
            CallingConvention::Tail => true,
            CallingConvention::Effect => false,
            CallingConvention::Foreign => false,
        }
    }

    /// Check if this convention captures continuations.
    pub fn captures_continuation(self) -> Bool {
        match self {
            CallingConvention::Blood => false,
            CallingConvention::Tail => false,
            CallingConvention::Effect => true,
            CallingConvention::Foreign => false,
        }
    }

    /// Check if this is an FFI convention.
    pub fn is_foreign(self) -> Bool {
        match self {
            CallingConvention::Blood => false,
            CallingConvention::Tail => false,
            CallingConvention::Effect => false,
            CallingConvention::Foreign => true,
        }
    }

    /// Get a human-readable name for this convention.
    pub fn name(self) -> String {
        match self {
            CallingConvention::Blood => "blood",
            CallingConvention::Tail => "tail",
            CallingConvention::Effect => "effect",
            CallingConvention::Foreign => "foreign",
        }
    }
}

// ============================================================================
// Effect Mask
// ============================================================================

/// Bit flags for effect categories.
///
/// EffectMask tracks which categories of effects a function may perform.
/// This enables efficient effect checking at runtime and during hot-swap
/// validation.
///
/// ## Layout
///
/// ```text
/// Bit 0: IO        (file, network, console)
/// Bit 1: STATE     (mutable state, references)
/// Bit 2: EXCEPTION (exceptions, panics)
/// Bit 3: ASYNC     (async/await, futures)
/// Bits 4-31: Reserved for future use
/// ```
pub struct EffectMask {
    /// The underlying bit field.
    bits: U32,
}

impl EffectMask {
    /// No effects (pure function).
    pub const NONE: EffectMask = EffectMask { bits: 0 };

    /// IO effects (file, network, console).
    pub const IO: EffectMask = EffectMask { bits: 1 };

    /// State effects (mutable state, references).
    pub const STATE: EffectMask = EffectMask { bits: 2 };

    /// Exception effects (exceptions, panics).
    pub const EXCEPTION: EffectMask = EffectMask { bits: 4 };

    /// Async effects (async/await, futures).
    pub const ASYNC: EffectMask = EffectMask { bits: 8 };

    /// Create an effect mask with the given bits.
    pub fn from_bits(bits: U32) -> EffectMask {
        EffectMask { bits }
    }

    /// Get the raw bit representation.
    pub fn to_bits(self) -> U32 {
        self.bits
    }

    /// Check if this mask contains all effects from another mask.
    ///
    /// Returns true if every effect bit set in `other` is also set in `self`.
    pub fn contains(self, other: EffectMask) -> Bool {
        (self.bits & other.bits) == other.bits
    }

    /// Compute the union of two effect masks.
    ///
    /// Returns a mask with all effects from both masks.
    pub fn union(self, other: EffectMask) -> EffectMask {
        EffectMask { bits: self.bits | other.bits }
    }

    /// Compute the intersection of two effect masks.
    ///
    /// Returns a mask with only effects present in both masks.
    pub fn intersection(self, other: EffectMask) -> EffectMask {
        EffectMask { bits: self.bits & other.bits }
    }

    /// Check if this function is pure (no effects).
    pub fn is_pure(self) -> Bool {
        self.bits == 0;
    }

    /// Check if this mask has IO effects.
    pub fn has_io(self) -> Bool {
        self.contains(EffectMask::IO);
    }

    /// Check if this mask has state effects.
    pub fn has_state(self) -> Bool {
        self.contains(EffectMask::STATE);
    }

    /// Check if this mask has exception effects.
    pub fn has_exception(self) -> Bool {
        self.contains(EffectMask::EXCEPTION);
    }

    /// Check if this mask has async effects.
    pub fn has_async(self) -> Bool {
        self.contains(EffectMask::ASYNC);
    }

    /// Check if the new mask is a valid replacement for this mask.
    ///
    /// For hot-swap safety, the new mask must be a subset of the old mask.
    /// This ensures callers that expected certain effects won't be surprised
    /// by new effects being added.
    pub fn is_compatible_replacement(self, new_mask: EffectMask) -> Bool {
        // New effects must be subset of old (can remove effects, not add)
        (new_mask.bits & !self.bits) == 0
    }

    /// Get a human-readable description of the effects.
    pub fn describe(self) -> String {
        if self.is_pure() {
            return "pure"
        };

        let mut parts = Vec::new();
        if self.has_io() {
            parts.push("IO");
        };
        if self.has_state() {
            parts.push("State");
        };
        if self.has_exception() {
            parts.push("Exception");
        };
        if self.has_async() {
            parts.push("Async");
        };

        parts.join(", ");
    }
}

// ============================================================================
// VFT Entry
// ============================================================================

/// An entry in the Virtual Function Table.
///
/// Each entry maps a content hash to its runtime entry point,
/// along with metadata needed for safe invocation and hot-swapping.
pub struct VFTEntry {
    /// The content hash this entry is for.
    hash: ContentHash,

    /// Pointer to native code (as USize for cross-platform).
    entry_point: USize,

    /// Number of arguments expected by the function.
    arity: U8,

    /// Calling convention for this function.
    calling_convention: CallingConvention,

    /// Effect categories used by this function.
    effects: EffectMask,

    /// Size of compiled code in bytes.
    compiled_size: U32,

    /// Generation number for hot-swap tracking.
    generation: U64,
}

impl VFTEntry {
    /// Create a new VFT entry with default metadata.
    ///
    /// Uses Blood calling convention, no effects, and generation 0.
    pub fn new(hash: ContentHash, entry_point: USize, arity: U8) -> VFTEntry {
        VFTEntry {
            hash,
            entry_point,
            arity,
            calling_convention: CallingConvention::Blood,
            effects: EffectMask::NONE,
            compiled_size: 0,
            generation: 0,
        }
    }

    /// Get the content hash.
    pub fn hash(self) -> ContentHash {
        self.hash
    }

    /// Get the entry point address.
    pub fn entry_point(self) -> USize {
        self.entry_point
    }

    /// Get the function arity.
    pub fn arity(self) -> U8 {
        self.arity
    }

    /// Get the calling convention.
    pub fn calling_convention(self) -> CallingConvention {
        self.calling_convention
    }

    /// Get the effect mask.
    pub fn effects(self) -> EffectMask {
        self.effects
    }

    /// Get the compiled code size.
    pub fn compiled_size(self) -> U32 {
        self.compiled_size
    }

    /// Get the generation number.
    pub fn generation(self) -> U64 {
        self.generation
    }

    // === Builder Methods ===

    /// Set the calling convention.
    pub fn with_convention(mut self, convention: CallingConvention) -> VFTEntry {
        self.calling_convention = convention;
        self
    }

    /// Set the effect mask.
    pub fn with_effects(mut self, effects: EffectMask) -> VFTEntry {
        self.effects = effects;
        self
    }

    /// Set the compiled code size.
    pub fn with_size(mut self, size: U32) -> VFTEntry {
        self.compiled_size = size;
        self
    }

    /// Set the generation number.
    pub fn with_generation(mut self, generation: U64) -> VFTEntry {
        self.generation = generation;
        self
    }

    // === Query Methods ===

    /// Check if this function is pure (no effects).
    pub fn is_pure(self) -> Bool {
        self.effects.is_pure();
    }

    /// Check if this function uses tail-call optimization.
    pub fn is_tail_call(self) -> Bool {
        match self.calling_convention {
            CallingConvention::Tail => true,
            CallingConvention::Blood => false,
            CallingConvention::Effect => false,
            CallingConvention::Foreign => false,
        }
    }

    /// Check if this function uses the effect calling convention.
    pub fn is_effectful(self) -> Bool {
        match self.calling_convention {
            CallingConvention::Effect => true,
            CallingConvention::Blood => false,
            CallingConvention::Tail => false,
            CallingConvention::Foreign => false,
        }
    }

    /// Check if this function is an FFI callback.
    pub fn is_foreign(self) -> Bool {
        self.calling_convention.is_foreign();
    }
}

// ============================================================================
// Hot-Swap Types
// ============================================================================

/// Swap mode for hot-swapping code.
///
/// Different modes provide different safety guarantees and latency characteristics.
pub enum SwapMode {
    /// Immediate swap: new calls use new code, in-flight continue with old.
    ///
    /// Lowest latency but may have multiple versions running simultaneously.
    Immediate,

    /// Barrier swap: wait for in-flight calls to complete, then swap.
    ///
    /// Guarantees only one version runs at a time but may block.
    Barrier,

    /// Epoch swap: swap at next epoch boundary.
    ///
    /// Scheduled for a future point, allowing batch updates.
    Epoch,
}

impl SwapMode {
    /// Get a human-readable name for this mode.
    pub fn name(self) -> String {
        match self {
            SwapMode::Immediate => "immediate",
            SwapMode::Barrier => "barrier",
            SwapMode::Epoch => "epoch",
        }
    }
}

/// Result of a hot-swap operation.
pub enum HotSwapResult {
    /// Swap completed successfully.
    Success {
        /// The old hash that was replaced.
        old_hash: ContentHash,
        /// The new hash now active.
        new_hash: ContentHash,
        /// New generation number.
        generation: U64,
    },

    /// Swap was scheduled for later (Epoch mode).
    Scheduled {
        /// Target epoch for the swap.
        target_epoch: U64,
    },

    /// Swap failed with an error.
    Error(HotSwapError),
}

impl HotSwapResult {
    /// Check if the swap was successful.
    pub fn is_success(self) -> Bool {
        match self {
            HotSwapResult::Success { .. } => true,
            HotSwapResult::Scheduled { .. } => false,
            HotSwapResult::Error(_) => false,
        }
    }

    /// Check if the swap was scheduled.
    pub fn is_scheduled(self) -> Bool {
        match self {
            HotSwapResult::Success { .. } => false,
            HotSwapResult::Scheduled { .. } => true,
            HotSwapResult::Error(_) => false,
        }
    }

    /// Check if the swap failed.
    pub fn is_error(self) -> Bool {
        match self {
            HotSwapResult::Success { .. } => false,
            HotSwapResult::Scheduled { .. } => false,
            HotSwapResult::Error(_) => true,
        }
    }

    /// Get the error if present.
    pub fn error(self) -> Option<HotSwapError> {
        match self {
            HotSwapResult::Error(e) => Option::Some(e),
            HotSwapResult::Success { .. } => Option::None,
            HotSwapResult::Scheduled { .. } => Option::None,
        }
    }
}

/// Errors that can occur during hot-swap.
pub enum HotSwapError {
    /// Old hash not found in VFT.
    OldHashNotFound,

    /// New hash not registered yet.
    NewHashNotRegistered,

    /// Arity mismatch between old and new.
    ArityMismatch {
        old_arity: U8,
        new_arity: U8,
    },

    /// Effect mismatch (new effects not subset of old).
    EffectMismatch {
        old_effects: EffectMask,
        new_effects: EffectMask,
    },

    /// Calling convention mismatch.
    ConventionMismatch {
        old: CallingConvention,
        new: CallingConvention,
    },

    /// In-flight calls blocking barrier swap.
    InFlightCallsBlocking {
        count: U64,
    },
}

impl HotSwapError {
    /// Get a human-readable description of the error.
    pub fn describe(self) -> String {
        match self {
            HotSwapError::OldHashNotFound =>
                "old hash not found in VFT",
            HotSwapError::NewHashNotRegistered =>
                "new hash not registered in VFT",
            HotSwapError::ArityMismatch { old_arity, new_arity } =>
                "arity mismatch: old=" ++ old_arity.to_string() ++ ", new=" ++ new_arity.to_string(),
            HotSwapError::EffectMismatch { old_effects, new_effects } =>
                "effect mismatch: new effects not subset of old",
            HotSwapError::ConventionMismatch { old, new } =>
                "calling convention mismatch: old=" ++ old.name() ++ ", new=" ++ new.name(),
            HotSwapError::InFlightCallsBlocking { count } =>
                "in-flight calls blocking: " ++ count.to_string() ++ " calls active",
        }
    }
}

/// A pending VFT update.
pub struct VFTUpdate {
    /// Old hash being replaced.
    old_hash: ContentHash,
    /// New hash to use.
    new_hash: ContentHash,
    /// Swap mode.
    mode: SwapMode,
    /// Scheduled epoch (for Epoch mode).
    target_epoch: Option<U64>,
}

impl VFTUpdate {
    /// Create a new update.
    pub fn new(old_hash: ContentHash, new_hash: ContentHash, mode: SwapMode) -> VFTUpdate {
        VFTUpdate {
            old_hash,
            new_hash,
            mode,
            target_epoch: Option::None,
        }
    }

    /// Create an epoch-scheduled update.
    pub fn for_epoch(old_hash: ContentHash, new_hash: ContentHash, epoch: U64) -> VFTUpdate {
        VFTUpdate {
            old_hash,
            new_hash,
            mode: SwapMode::Epoch,
            target_epoch: Option::Some(epoch),
        }
    }
}

// ============================================================================
// Virtual Function Table
// ============================================================================

/// Maximum redirect chain depth to prevent infinite loops.
const MAX_REDIRECT_DEPTH: USize = 10;

/// The Virtual Function Table.
///
/// Maps content hashes to runtime entry points with support for:
/// - O(1) lookup by hash
/// - Hot-swapping with multiple modes
/// - Epoch-based scheduled updates
/// - Redirect chains for live code replacement
pub struct VFT {
    /// Hash-indexed lookup.
    entries: HashMap<ContentHash, VFTEntry>,

    /// All entries for iteration (maintains insertion order).
    all_entries: Vec<ContentHash>,

    /// Current version/generation.
    version: U64,

    /// Pending updates (for batch/epoch swaps).
    pending_updates: Vec<VFTUpdate>,

    /// Redirects for hot-swap (old hash → new hash).
    redirects: HashMap<ContentHash, ContentHash>,
}

impl VFT {
    /// Create a new empty VFT.
    pub fn new() -> VFT {
        VFT {
            entries: HashMap::new(),
            all_entries: Vec::new(),
            version: 0,
            pending_updates: Vec::new(),
            redirects: HashMap::new(),
        }
    }

    // === Registration ===

    /// Register a new entry in the VFT.
    ///
    /// If an entry with the same hash already exists, it is replaced.
    pub fn register(mut self, entry: VFTEntry) -> Unit {
        let hash = entry.hash;

        // Track in all_entries if new
        if !self.entries.contains_key(hash) {
            self.all_entries.push(hash);
        };

        self.entries.insert(hash, entry);
    }

    /// Unregister an entry from the VFT.
    ///
    /// Also removes any redirects pointing to or from this hash.
    pub fn unregister(mut self, hash: ContentHash) -> Unit {
        self.entries.remove(hash);
        self.all_entries.retain(|h| *h != hash);
        self.redirects.remove(hash);
    }

    // === Lookup ===

    /// Look up an entry by hash, following redirects.
    ///
    /// Returns None if the hash is not found (even after following redirects).
    pub fn lookup(self, hash: ContentHash) -> Option<VFTEntry> {
        let actual_hash = self.resolve_redirect(hash);
        self.entries.get(actual_hash);
    }

    /// Resolve redirects to find the actual hash.
    ///
    /// Follows the redirect chain up to MAX_REDIRECT_DEPTH to prevent
    /// infinite loops from circular redirects.
    fn resolve_redirect(self, hash: ContentHash) -> ContentHash {
        let mut current = hash;
        let mut depth: USize = 0;

        while depth < MAX_REDIRECT_DEPTH {
            match self.redirects.get(current) {
                Option::Some(next) => {
                    current = *next;
                    depth = depth + 1;
                }
                Option::None => {
                    return current;
                }
            }
        }

        // Max depth reached, return what we have
        current
    }

    /// Check if an entry exists (directly or via redirect).
    pub fn contains(self, hash: ContentHash) -> Bool {
        self.entries.contains_key(hash) || self.redirects.contains_key(hash);
    }

    /// Get the entry point address for a hash.
    pub fn get_entry_point(self, hash: ContentHash) -> Option<USize> {
        match self.lookup(hash) {
            Option::Some(entry) => Option::Some(entry.entry_point),
            Option::None => Option::None,
        }
    }

    /// Get the arity for a hash.
    pub fn get_arity(self, hash: ContentHash) -> Option<U8> {
        match self.lookup(hash) {
            Option::Some(entry) => Option::Some(entry.arity),
            Option::None => Option::None,
        }
    }

    // === Version/Epoch ===

    /// Get the current version/epoch.
    pub fn version(self) -> U64 {
        self.version
    }

    /// Get the current epoch (alias for version).
    pub fn current_epoch(self) -> U64 {
        self.version
    }

    /// Advance to the next epoch, executing any scheduled updates.
    pub fn advance_epoch(mut self) -> Unit {
        let next_epoch = self.version + 1;

        // Partition updates: those for this epoch vs. remaining
        let mut to_execute = Vec::new();
        let mut remaining = Vec::new();

        for update in self.pending_updates {
            match update.target_epoch {
                Option::Some(epoch) if epoch == next_epoch => {
                    to_execute.push(update);
                }
                _ => {
                    remaining.push(update);
                }
            }
        };

        self.pending_updates = remaining;

        // Execute scheduled updates
        for update in to_execute {
            self.immediate_swap_internal(update.old_hash, update.new_hash);
        };

        // Bump the epoch
        self.version = next_epoch;
    }

    // === Hot-Swap ===

    /// Prepare a hot-swap update (adds to pending queue).
    pub fn prepare_swap(mut self, old_hash: ContentHash, new_hash: ContentHash, mode: SwapMode) -> Unit {
        self.pending_updates.push(VFTUpdate::new(old_hash, new_hash, mode));
    }

    /// Execute all pending swaps.
    pub fn commit_pending_swaps(mut self) -> Unit {
        let updates = self.pending_updates;
        self.pending_updates = Vec::new();

        for update in updates {
            match update.mode {
                SwapMode::Immediate => {
                    self.immediate_swap_internal(update.old_hash, update.new_hash);
                }
                SwapMode::Barrier => {
                    // In a full implementation, would wait for in-flight calls
                    self.immediate_swap_internal(update.old_hash, update.new_hash);
                }
                SwapMode::Epoch => {
                    // Already handled by advance_epoch
                    self.immediate_swap_internal(update.old_hash, update.new_hash);
                }
            }
        }
    }

    /// Execute an immediate swap (internal helper).
    fn immediate_swap_internal(mut self, old_hash: ContentHash, new_hash: ContentHash) -> Unit {
        self.redirects.insert(old_hash, new_hash);
        self.version = self.version + 1;
    }

    /// Execute an immediate swap (public API).
    pub fn immediate_swap(mut self, old_hash: ContentHash, new_hash: ContentHash) -> Unit {
        self.immediate_swap_internal(old_hash, new_hash);
    }

    /// Validate compatibility between old and new entries for hot-swap.
    ///
    /// Returns Ok(()) if compatible, or an error describing the mismatch.
    pub fn validate_swap_compatibility(self, old_hash: ContentHash, new_hash: ContentHash)
        -> Result<Unit, HotSwapError>
    {
        // Get both entries
        let old_entry = match self.entries.get(old_hash) {
            Option::Some(e) => e,
            Option::None => return Result::Err(HotSwapError::OldHashNotFound),
        };

        let new_entry = match self.entries.get(new_hash) {
            Option::Some(e) => e,
            Option::None => return Result::Err(HotSwapError::NewHashNotRegistered),
        };

        // Check arity (must match exactly)
        if old_entry.arity != new_entry.arity {
            return Result::Err(HotSwapError::ArityMismatch {
                old_arity: old_entry.arity,
                new_arity: new_entry.arity,
            })
        };

        // Check effects: new must be subset of old
        if !old_entry.effects.is_compatible_replacement(new_entry.effects) {
            return Result::Err(HotSwapError::EffectMismatch {
                old_effects: old_entry.effects,
                new_effects: new_entry.effects,
            })
        };

        // Check calling convention (must match)
        // Compare using names since we can't directly compare enum variants
        if old_entry.calling_convention.name() != new_entry.calling_convention.name() {
            return Result::Err(HotSwapError::ConventionMismatch {
                old: old_entry.calling_convention,
                new: new_entry.calling_convention,
            })
        }

        Result::Ok(())
    }

    /// Perform a validated hot-swap with compatibility checking.
    ///
    /// This is the primary API for safe hot-swapping. It validates
    /// compatibility before performing the swap.
    pub fn hot_swap(mut self, old_hash: ContentHash, new_hash: ContentHash, mode: SwapMode)
        -> HotSwapResult
    {
        // Validate compatibility first
        match self.validate_swap_compatibility(old_hash, new_hash) {
            Result::Err(e) => return HotSwapResult::Error(e),
            Result::Ok(_) => {}
        };

        match mode {
            SwapMode::Immediate => {
                self.immediate_swap_internal(old_hash, new_hash);
                HotSwapResult::Success {
                    old_hash,
                    new_hash,
                    generation: self.version,
                }
            }
            SwapMode::Barrier => {
                // In a full implementation:
                // 1. Mark entry as "draining"
                // 2. Wait for in-flight calls
                // 3. Then swap
                // For now, treat as immediate
                self.immediate_swap_internal(old_hash, new_hash);
                HotSwapResult::Success {
                    old_hash,
                    new_hash,
                    generation: self.version,
                }
            }
            SwapMode::Epoch => {
                let target_epoch = self.version + 1;
                self.pending_updates.push(VFTUpdate::for_epoch(old_hash, new_hash, target_epoch));
                HotSwapResult::Scheduled { target_epoch }
            }
        }
    }

    // === Statistics ===

    /// Get the number of entries.
    pub fn len(self) -> USize {
        self.entries.len();
    }

    /// Check if empty.
    pub fn is_empty(self) -> Bool {
        self.entries.is_empty();
    }

    /// Get the number of pending updates.
    pub fn pending_count(self) -> USize {
        self.pending_updates.len();
    }

    /// Get the number of active redirects.
    pub fn redirect_count(self) -> USize {
        self.redirects.len();
    }

    // === Maintenance ===

    /// Clear stale redirects (redirects pointing to non-existent entries).
    pub fn cleanup_redirects(mut self) -> Unit {
        self.redirects.retain(|_, target| self.entries.contains_key(*target));
    }

    /// Get all entry hashes.
    pub fn all_hashes(self) -> Vec<ContentHash> {
        self.all_entries.clone();
    }

    /// Iterate over all entries.
    pub fn iter(self) -> impl Iterator[Item = VFTEntry] {
        self.entries.values();
    }
}

// ============================================================================
// Multiple Dispatch Support
// ============================================================================

/// A type pattern for dispatch matching.
///
/// Type patterns describe what types a dispatch entry can handle,
/// with varying levels of specificity.
pub enum TypePattern {
    /// Match any type (least specific).
    Any,

    /// Match a specific concrete type.
    Concrete(ContentHash),

    /// Match a type constructor with arguments.
    Applied {
        constructor: ContentHash,
        args: Vec<TypePattern>,
    },
}

impl TypePattern {
    /// Check if this pattern matches the given type hash.
    pub fn matches(self, type_hash: ContentHash) -> Bool {
        match self {
            TypePattern::Any => true,
            TypePattern::Concrete(h) => h == type_hash,
            TypePattern::Applied { constructor, .. } => {
                // Simplified: just check constructor
                constructor == type_hash;
            }
        }
    }

    /// Calculate the specificity of this pattern.
    ///
    /// Higher specificity means more specific match.
    /// Used to resolve ambiguous dispatches.
    pub fn specificity(self) -> U32 {
        match self {
            TypePattern::Any => 0,
            TypePattern::Concrete(_) => 10,
            TypePattern::Applied { args, .. } => {
                let mut sum: U32 = 10;
                for arg in args {
                    sum = sum + arg.specificity();
                }
                sum
            }
        }
    }
}

/// An entry in the dispatch table.
pub struct DispatchEntry {
    /// Type pattern for matching.
    type_pattern: TypePattern,
    /// Specialization specificity (higher = more specific).
    specificity: U32,
    /// Implementation hash.
    impl_hash: ContentHash,
}

impl DispatchEntry {
    /// Create a new dispatch entry.
    pub fn new(type_pattern: TypePattern, impl_hash: ContentHash) -> DispatchEntry {
        let specificity = type_pattern.specificity();
        DispatchEntry {
            type_pattern,
            specificity,
            impl_hash,
        }
    }

    /// Create a dispatch entry with explicit specificity.
    pub fn with_specificity(type_pattern: TypePattern, specificity: U32, impl_hash: ContentHash)
        -> DispatchEntry
    {
        DispatchEntry {
            type_pattern,
            specificity,
            impl_hash,
        }
    }
}

/// Dispatch table for multiple dispatch.
///
/// Maps method hashes to lists of implementations, each associated
/// with a type pattern. At runtime, the most specific matching
/// implementation is selected.
pub struct DispatchTable {
    /// Method hash → dispatch entries.
    methods: HashMap<ContentHash, Vec<DispatchEntry>>,
}

impl DispatchTable {
    /// Create a new empty dispatch table.
    pub fn new() -> DispatchTable {
        DispatchTable {
            methods: HashMap::new(),
        }
    }

    /// Register an implementation for a method.
    pub fn register(mut self, method_hash: ContentHash, entry: DispatchEntry) -> Unit {
        match self.methods.get_mut(method_hash) {
            Option::Some(entries) => {
                entries.push(entry);
            }
            Option::None => {
                let mut entries = Vec::new();
                entries.push(entry);
                self.methods.insert(method_hash, entries);
            }
        }
    }

    /// Find the best matching implementation for given argument type.
    ///
    /// Returns the implementation hash with the highest specificity
    /// among those that match the argument type.
    pub fn dispatch(self, method_hash: ContentHash, arg_type: ContentHash) -> Option<ContentHash> {
        let entries = match self.methods.get(method_hash) {
            Option::Some(e) => e,
            Option::None => return Option::None,
        };

        let mut best: Option<DispatchEntry> = Option::None;
        let mut best_specificity: U32 = 0;

        for entry in entries {
            if entry.type_pattern.matches(arg_type) {
                if entry.specificity > best_specificity {
                    best = Option::Some(*entry);
                    best_specificity = entry.specificity;
                }
            }
        };

        match best {
            Option::Some(entry) => Option::Some(entry.impl_hash),
            Option::None => Option::None,
        }
    }

    /// Get all registered methods.
    pub fn methods(self) -> Vec<ContentHash> {
        self.methods.keys().collect();
    }

    /// Get the number of registered methods.
    pub fn method_count(self) -> USize {
        self.methods.len();
    }

    /// Get the total number of implementations across all methods.
    pub fn impl_count(self) -> USize {
        let mut count: USize = 0;
        for (_, entries) in self.methods {
            count = count + entries.len();
        }
        count
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_calling_convention_properties() {
    // Blood is standard
    assert(CallingConvention::Blood.is_standard());
    assert(!CallingConvention::Blood.supports_tco());
    assert(!CallingConvention::Blood.captures_continuation());

    // Tail supports TCO
    assert(!CallingConvention::Tail.is_standard());
    assert(CallingConvention::Tail.supports_tco());

    // Effect captures continuations
    assert(CallingConvention::Effect.captures_continuation());

    // Foreign is FFI
    assert(CallingConvention::Foreign.is_foreign());
}

#[test]
fn test_effect_mask_operations() {
    let io = EffectMask::IO;
    let state = EffectMask::STATE;
    let combined = io.union(state);

    // Contains checks
    assert(combined.contains(EffectMask::IO));
    assert(combined.contains(EffectMask::STATE));
    assert(!combined.contains(EffectMask::EXCEPTION));

    // Pure check
    assert(!combined.is_pure());
    assert(EffectMask::NONE.is_pure());
}

#[test]
fn test_effect_mask_compatibility() {
    let io_state = EffectMask::IO.union(EffectMask::STATE);
    let io_only = EffectMask::IO;
    let pure = EffectMask::NONE;

    // Can remove effects (fewer is OK);
    assert(io_state.is_compatible_replacement(io_only));
    assert(io_state.is_compatible_replacement(pure));

    // Cannot add effects
    assert(!io_only.is_compatible_replacement(io_state));
    assert(!pure.is_compatible_replacement(io_only));
}

#[test]
fn test_vft_entry_builder() {
    let hash = ContentHash::compute("test_fn".as_bytes());

    let entry = VFTEntry::new(hash, 0x1000, 2)
        .with_convention(CallingConvention::Effect)
        .with_effects(EffectMask::IO)
        .with_size(64)
        .with_generation(5);

    assert(entry.arity() == 2);
    assert(entry.entry_point() == 0x1000);
    assert(entry.effects().has_io());
    assert(entry.compiled_size() == 64);
    assert(entry.generation() == 5);
    assert(entry.is_effectful());
}

#[test]
fn test_vft_entry_purity() {
    let hash = ContentHash::compute("pure_fn".as_bytes());

    let pure_entry = VFTEntry::new(hash, 0x1000, 1);
    assert(pure_entry.is_pure());

    let impure_entry = pure_entry.with_effects(EffectMask::IO);
    assert(!impure_entry.is_pure());
}

#[test]
fn test_vft_register_lookup() {
    let mut vft = VFT::new();
    let hash = ContentHash::compute("add".as_bytes());
    let entry = VFTEntry::new(hash, 0x1000, 2);

    vft.register(entry);

    let found = vft.lookup(hash);
    assert(found.is_some());

    let e = found.unwrap();
    assert(e.arity() == 2);
    assert(e.entry_point() == 0x1000);
}

#[test]
fn test_vft_immediate_swap() {
    let mut vft = VFT::new();

    let old_hash = ContentHash::compute("v1".as_bytes());
    let new_hash = ContentHash::compute("v2".as_bytes());

    vft.register(VFTEntry::new(old_hash, 0x1000, 1));
    vft.register(VFTEntry::new(new_hash, 0x2000, 1));

    vft.immediate_swap(old_hash, new_hash);

    // Looking up old hash should redirect to new
    let entry = vft.lookup(old_hash).unwrap();
    assert(entry.hash() == new_hash);
}

#[test]
fn test_vft_version_increment() {
    let mut vft = VFT::new();
    let initial = vft.version();

    let old_hash = ContentHash::compute("v1".as_bytes());
    let new_hash = ContentHash::compute("v2".as_bytes());
    vft.register(VFTEntry::new(old_hash, 0x1000, 1));
    vft.register(VFTEntry::new(new_hash, 0x2000, 1));

    vft.immediate_swap(old_hash, new_hash);

    assert(vft.version() == initial + 1);
}

#[test]
fn test_vft_unregister() {
    let mut vft = VFT::new();
    let hash = ContentHash::compute("remove_me".as_bytes());

    vft.register(VFTEntry::new(hash, 0x1000, 0));
    assert(vft.contains(hash));

    vft.unregister(hash);
    assert(!vft.contains(hash));
}

#[test]
fn test_vft_pending_swaps() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("old".as_bytes());
    let new = ContentHash::compute("new".as_bytes());
    vft.register(VFTEntry::new(old, 0x1000, 1));
    vft.register(VFTEntry::new(new, 0x2000, 1));

    vft.prepare_swap(old, new, SwapMode::Immediate);
    assert(vft.pending_count() == 1);

    vft.commit_pending_swaps();
    assert(vft.pending_count() == 0);
    assert(vft.redirect_count() == 1);
}

#[test]
fn test_validate_swap_compatibility_success() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    // Same arity, new has fewer effects (valid)
    vft.register(VFTEntry::new(old, 0x1000, 2).with_effects(EffectMask::IO));
    vft.register(VFTEntry::new(new, 0x2000, 2).with_effects(EffectMask::NONE));

    let result = vft.validate_swap_compatibility(old, new);
    assert(result.is_ok());
}

#[test]
fn test_validate_swap_arity_mismatch() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 2));
    vft.register(VFTEntry::new(new, 0x2000, 3));  // Different arity

    let result = vft.validate_swap_compatibility(old, new);
    assert(result.is_err());

    match result {
        Result::Err(HotSwapError::ArityMismatch { old_arity, new_arity }) => {
            assert(old_arity == 2);
            assert(new_arity == 3);
        }
        _ => assert(false);  // Wrong error type
    }
}

#[test]
fn test_validate_swap_effect_mismatch() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    // Old has no effects, new adds IO (not allowed)
    vft.register(VFTEntry::new(old, 0x1000, 1).with_effects(EffectMask::NONE));
    vft.register(VFTEntry::new(new, 0x2000, 1).with_effects(EffectMask::IO));

    let result = vft.validate_swap_compatibility(old, new);
    assert(result.is_err());

    match result {
        Result::Err(HotSwapError::EffectMismatch { .. }) => {}
        _ => assert(false);
    }
}

#[test]
fn test_validate_swap_convention_mismatch() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 1).with_convention(CallingConvention::Blood));
    vft.register(VFTEntry::new(new, 0x2000, 1).with_convention(CallingConvention::Tail));

    let result = vft.validate_swap_compatibility(old, new);
    assert(result.is_err());

    match result {
        Result::Err(HotSwapError::ConventionMismatch { .. }) => {}
        _ => assert(false);
    }
}

#[test]
fn test_validate_swap_old_not_found() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("missing".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(new, 0x2000, 1));

    let result = vft.validate_swap_compatibility(old, new);
    match result {
        Result::Err(HotSwapError::OldHashNotFound) => {}
        _ => assert(false);
    }
}

#[test]
fn test_validate_swap_new_not_registered() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("missing".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 1));

    let result = vft.validate_swap_compatibility(old, new);
    match result {
        Result::Err(HotSwapError::NewHashNotRegistered) => {}
        _ => assert(false);
    }
}

#[test]
fn test_hot_swap_immediate_success() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 1));
    vft.register(VFTEntry::new(new, 0x2000, 1));

    let result = vft.hot_swap(old, new, SwapMode::Immediate);

    assert(result.is_success());

    // Verify redirect works
    let entry = vft.lookup(old).unwrap();
    assert(entry.hash() == new);
}

#[test]
fn test_hot_swap_epoch_scheduled() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 1));
    vft.register(VFTEntry::new(new, 0x2000, 1));

    let current = vft.current_epoch();
    let result = vft.hot_swap(old, new, SwapMode::Epoch);

    assert(result.is_scheduled());

    // Swap not yet applied
    let entry = vft.lookup(old).unwrap();
    assert(entry.hash() == old);

    // Advance epoch
    vft.advance_epoch();

    // Now swap should be applied
    let entry = vft.lookup(old).unwrap();
    assert(entry.hash() == new);
}

#[test]
fn test_hot_swap_validation_error() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    // Different arities - should fail validation
    vft.register(VFTEntry::new(old, 0x1000, 1));
    vft.register(VFTEntry::new(new, 0x2000, 2));

    let result = vft.hot_swap(old, new, SwapMode::Immediate);

    assert(result.is_error());
}

#[test]
fn test_advance_epoch_no_updates() {
    let mut vft = VFT::new();

    let initial = vft.current_epoch();
    vft.advance_epoch();
    assert(vft.current_epoch() == initial + 1);
}

#[test]
fn test_advance_epoch_with_multiple_updates() {
    let mut vft = VFT::new();

    let old1 = ContentHash::compute("fn1_v1".as_bytes());
    let new1 = ContentHash::compute("fn1_v2".as_bytes());
    let old2 = ContentHash::compute("fn2_v1".as_bytes());
    let new2 = ContentHash::compute("fn2_v2".as_bytes());

    vft.register(VFTEntry::new(old1, 0x1000, 1));
    vft.register(VFTEntry::new(new1, 0x2000, 1));
    vft.register(VFTEntry::new(old2, 0x3000, 2));
    vft.register(VFTEntry::new(new2, 0x4000, 2));

    // Schedule both for epoch swap
    let r1 = vft.hot_swap(old1, new1, SwapMode::Epoch);
    let r2 = vft.hot_swap(old2, new2, SwapMode::Epoch);
    assert(r1.is_scheduled());
    assert(r2.is_scheduled());
    assert(vft.pending_count() == 2);

    // Advance epoch
    vft.advance_epoch();

    assert(vft.pending_count() == 0);

    // Both swaps applied
    assert(vft.lookup(old1).unwrap().hash() == new1);
    assert(vft.lookup(old2).unwrap().hash() == new2);
}

#[test]
fn test_cleanup_redirects() {
    let mut vft = VFT::new();

    let old = ContentHash::compute("fn_v1".as_bytes());
    let new = ContentHash::compute("fn_v2".as_bytes());

    vft.register(VFTEntry::new(old, 0x1000, 1));
    vft.register(VFTEntry::new(new, 0x2000, 1));

    vft.immediate_swap(old, new);
    assert(vft.redirect_count() == 1);

    // Remove the target entry
    vft.unregister(new);

    // Cleanup stale redirects
    vft.cleanup_redirects();
    assert(vft.redirect_count() == 0);
}

#[test]
fn test_type_pattern_specificity() {
    let any = TypePattern::Any;
    let concrete = TypePattern::Concrete(ContentHash::compute("Int".as_bytes()));
    let applied = TypePattern::Applied {
        constructor: ContentHash::compute("List".as_bytes()),
        args: vec![TypePattern::Concrete(ContentHash::compute("Int".as_bytes()))],
    };

    assert(any.specificity() == 0);
    assert(concrete.specificity() == 10);
    assert(applied.specificity() == 20);  // 10 + 10 for arg
}

#[test]
fn test_type_pattern_matching() {
    let int_hash = ContentHash::compute("Int".as_bytes());
    let string_hash = ContentHash::compute("String".as_bytes());

    let any = TypePattern::Any;
    let int_pattern = TypePattern::Concrete(int_hash);

    // Any matches everything
    assert(any.matches(int_hash));
    assert(any.matches(string_hash));

    // Concrete matches only specific type
    assert(int_pattern.matches(int_hash));
    assert(!int_pattern.matches(string_hash));
}

#[test]
fn test_dispatch_table() {
    let mut table = DispatchTable::new();

    let method = ContentHash::compute("show".as_bytes());
    let int_impl = ContentHash::compute("show_int".as_bytes());
    let string_impl = ContentHash::compute("show_string".as_bytes());
    let int_type = ContentHash::compute("Int".as_bytes());
    let string_type = ContentHash::compute("String".as_bytes());

    table.register(method, DispatchEntry::new(
        TypePattern::Concrete(int_type),
        int_impl,
    ))
    table.register(method, DispatchEntry::new(
        TypePattern::Concrete(string_type),
        string_impl,
    ));

    assert(table.dispatch(method, int_type) == Option::Some(int_impl));
    assert(table.dispatch(method, string_type) == Option::Some(string_impl));
}

#[test]
fn test_dispatch_table_most_specific() {
    let mut table = DispatchTable::new();

    let method = ContentHash::compute("process".as_bytes());
    let generic_impl = ContentHash::compute("process_any".as_bytes());
    let int_impl = ContentHash::compute("process_int".as_bytes());
    let int_type = ContentHash::compute("Int".as_bytes());

    // Register generic first
    table.register(method, DispatchEntry::new(
        TypePattern::Any,
        generic_impl,
    ))
    // Then specific
    table.register(method, DispatchEntry::new(
        TypePattern::Concrete(int_type),
        int_impl,
    ))

    // Should dispatch to most specific (int_impl);
    assert(table.dispatch(method, int_type) == Option::Some(int_impl));

    // Unknown type should get generic
    let unknown = ContentHash::compute("Unknown".as_bytes());
    assert(table.dispatch(method, unknown) == Option::Some(generic_impl));
}

#[test]
fn test_dispatch_table_statistics() {
    let mut table = DispatchTable::new();

    let method1 = ContentHash::compute("show".as_bytes());
    let method2 = ContentHash::compute("parse".as_bytes());
    let impl1 = ContentHash::compute("impl1".as_bytes());
    let impl2 = ContentHash::compute("impl2".as_bytes());
    let impl3 = ContentHash::compute("impl3".as_bytes());

    table.register(method1, DispatchEntry::new(TypePattern::Any, impl1));
    table.register(method1, DispatchEntry::new(TypePattern::Any, impl2));
    table.register(method2, DispatchEntry::new(TypePattern::Any, impl3));

    assert(table.method_count() == 2);
    assert(table.impl_count() == 3);
}
