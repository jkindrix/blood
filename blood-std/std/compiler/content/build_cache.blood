//! # Build Cache
//!
//! Content-addressed build cache for incremental compilation.
//!
//! ## Cache Structure
//!
//! ```text
//! ~/.blood/cache/
//! ├── v1/                    # Version prefix for format changes
//! │   ├── objects/           # Compiled object code by hash prefix
//! │   │   ├── a7/
//! │   │   │   └── f2k9m3... # Object file
//! │   │   └── ...
//! │   ├── ir/                # IR by hash (for debugging)
//! │   └── deps.json          # Dependency graph
//! └── config.json            # Cache configuration
//! ```
//!
//! ## Incremental Compilation
//!
//! 1. Compute content hash for each item
//! 2. Check cache for existing compiled artifact
//! 3. If cache hit: reuse compiled code
//! 4. If cache miss: compile and store
//! 5. Link all objects together

module std.compiler.content.build_cache;

use std.collections.HashMap;
use std.collections.HashSet;
use std.collections.Vec;
use std.result.Result;
use std.core.Option;
use std.io.Path;
use std.io.File;
use std.io.IoError;
use std.env;
use std.compiler.content.hash.ContentHash;
use std.compiler.content.hash.ContentHasher;

// ============================================================================
// Constants
// ============================================================================

/// Cache format version. Increment when changing cache structure.
///
/// Version history:
/// - v1: Initial release
/// - v2: Handler name hashing fix - invalidates old effect handler caches
///
/// Note: This version covers cache structure changes. For codegen changes
/// that affect compiled output, see `CODEGEN_ABI_VERSION` and `CODEGEN_HASH`
/// which are incorporated into the cache directory path automatically.
pub const CACHE_VERSION: u32 = 2;

/// ABI version for code generation compatibility.
/// Increment when making intentional ABI-breaking changes.
pub const CODEGEN_ABI_VERSION: u32 = 1;

/// Hash of codegen source for automatic invalidation.
/// This is computed from the codegen module source code.
pub const CODEGEN_HASH: String = "dev";

// ============================================================================
// Error Types
// ============================================================================

/// Errors that can occur during cache operations.
pub enum CacheError {
    /// IO error during file operations.
    Io(IoError),

    /// Cache data is corrupted.
    Corrupted(String),

    /// Cache version mismatch.
    VersionMismatch {
        expected: u32,
        found: u32,
    },

    /// JSON serialization/deserialization error.
    Json(String),
}

impl CacheError {
    /// Get a human-readable description of the error.
    pub fn describe(self) -> String {
        match self {
            CacheError::Io(e) => "cache IO error: " ++ e.message(),
            CacheError::Corrupted(msg) => "cache corrupted: " ++ msg,
            CacheError::VersionMismatch { expected, found } =>
                "cache version mismatch: expected " ++ expected.to_string() ++
                ", found " ++ found.to_string(),
            CacheError::Json(msg) => "cache JSON error: " ++ msg,
        }
    }
}

// ============================================================================
// Cache Statistics
// ============================================================================

/// Cache statistics for monitoring and debugging.
pub struct CacheStats {
    /// Number of cache hits.
    hits: usize,
    /// Number of cache misses.
    misses: usize,
    /// Total cached object size in bytes.
    cached_size: u64,
    /// Number of cached objects.
    cached_count: usize,
}

impl CacheStats {
    /// Create empty statistics.
    pub fn new() -> CacheStats {
        CacheStats {
            hits: 0,
            misses: 0,
            cached_size: 0,
            cached_count: 0,
        }
    }

    /// Get the number of cache hits.
    pub fn hits(self) -> usize {
        self.hits
    }

    /// Get the number of cache misses.
    pub fn misses(self) -> usize {
        self.misses
    }

    /// Get the total cached size in bytes.
    pub fn cached_size(self) -> u64 {
        self.cached_size
    }

    /// Get the number of cached objects.
    pub fn cached_count(self) -> usize {
        self.cached_count
    }

    /// Calculate the hit rate as a percentage.
    pub fn hit_rate(self) -> f64 {
        let total = self.hits + self.misses;
        if total == 0 {
            0.0
        } else {
            (self.hits as f64) / (total as f64) * 100.0
        }
    }

    /// Record a cache hit.
    pub fn record_hit(mut self) -> Unit {
        self.hits = self.hits + 1;
    }

    /// Record a cache miss.
    pub fn record_miss(mut self) -> Unit {
        self.misses = self.misses + 1;
    }
}

// ============================================================================
// Cache Index
// ============================================================================

/// Persistent cache index for dependency tracking.
///
/// This is serialized to `deps.json` in the cache directory.
pub struct CacheIndex {
    /// Cache format version for compatibility checking.
    version: u32,
    /// Dependency graph: hash → list of dependency hashes.
    dependencies: HashMap<ContentHash, Vec<ContentHash>>,
}

impl CacheIndex {
    /// Create a new cache index.
    pub fn new() -> CacheIndex {
        CacheIndex {
            version: CACHE_VERSION,
            dependencies: HashMap::new(),
        }
    }

    /// Serialize the index to JSON.
    pub fn to_json(self) -> String {
        // Simple JSON serialization
        let mut json = "{\n";
        json = json ++ "  \"version\": " ++ self.version.to_string() ++ ",\n";
        json = json ++ "  \"dependencies\": {\n";

        let mut first = true;
        for (hash, deps) in self.dependencies {
            if !first {
                json = json ++ ",\n"
            };
            first = false;

            json = json ++ "    \"" ++ hash.full_display() ++ "\": ["
            let mut first_dep = true;
            for dep in deps {
                if !first_dep {
                    json = json ++ ", "
                };
                first_dep = false;
                json = json ++ "\"" ++ dep.full_display() ++ "\""
            };
            json = json ++ "]"
        };

        json = json ++ "\n  }\n"
        json = json ++ "}"
        json
    }

    /// Deserialize the index from JSON.
    pub fn from_json(json: String) -> Result<CacheIndex, CacheError> {
        // For now, return a placeholder implementation
        // In production, this would use a proper JSON parser
        Result::Err(CacheError::Json("JSON parsing not yet implemented"))
    }
}

// ============================================================================
// Build Cache
// ============================================================================

/// Build cache for content-addressed compilation artifacts.
///
/// ## Features
///
/// - **Content-addressed storage**: Objects indexed by content hash
/// - **Dependency tracking**: Automatic invalidation of dependents
/// - **Incremental compilation**: Skip unchanged items
/// - **Version-aware**: Separate caches for different compiler versions
pub struct BuildCache {
    /// Root directory for cache storage.
    cache_dir: Path,

    /// In-memory cache of hash → file path mappings.
    object_cache: HashMap<ContentHash, Path>,

    /// Dependency graph: hash → set of dependency hashes.
    dependencies: HashMap<ContentHash, Vec<ContentHash>>,

    /// Whether caching is enabled.
    enabled: bool,

    /// Runtime statistics.
    stats: CacheStats,
}

impl BuildCache {
    /// Create a new build cache with default directory.
    ///
    /// Uses `~/.blood/cache` by default, or `$BLOOD_CACHE` if set.
    pub fn new() -> BuildCache {
        let cache_dir = BuildCache::default_cache_dir();
        BuildCache {
            cache_dir,
            object_cache: HashMap::new(),
            dependencies: HashMap::new(),
            enabled: true,
            stats: CacheStats::new(),
        }
    }

    /// Create a build cache with a custom directory.
    pub fn with_dir(cache_dir: Path) -> BuildCache {
        BuildCache {
            cache_dir,
            object_cache: HashMap::new(),
            dependencies: HashMap::new(),
            enabled: true,
            stats: CacheStats::new(),
        }
    }

    /// Create a disabled cache (no-op for all operations).
    ///
    /// Use this when caching is not desired (e.g., for testing
    /// or when the user explicitly disables caching).
    pub fn disabled() -> BuildCache {
        BuildCache {
            cache_dir: Path::new(""),
            object_cache: HashMap::new(),
            dependencies: HashMap::new(),
            enabled: false,
            stats: CacheStats::new(),
        }
    }

    /// Get the default cache directory.
    ///
    /// Priority:
    /// 1. `$BLOOD_CACHE` environment variable
    /// 2. `~/.blood/cache` (home directory)
    /// 3. `.blood-cache` (current directory fallback)
    pub fn default_cache_dir() -> Path {
        // Check environment variable
        match env::var("BLOOD_CACHE") {
            Option::Some(cache) => return Path::new(cache),
            Option::None => {}
        };

        // Check home directory
        match env::home_dir() {
            Option::Some(home) => return home.join(".blood").join("cache"),
            Option::None => {}
        }

        // Fallback to current directory
        Path::new(".blood-cache")
    }

    /// Check if caching is enabled.
    pub fn is_enabled(self) -> bool {
        self.enabled
    }

    /// Get the cache directory.
    pub fn cache_dir(self) -> Path {
        self.cache_dir.clone();
    }

    // === Version Directory ===

    /// Get the version-specific cache directory.
    ///
    /// The directory name includes:
    /// - CACHE_VERSION: Cache structure version
    /// - CODEGEN_ABI_VERSION: Intentional ABI breaking changes
    /// - CODEGEN_HASH: Automatic detection of codegen source changes
    ///
    /// This ensures cached artifacts are invalidated when the compiler's
    /// code generation changes in ways that would produce incompatible output.
    fn version_dir(self) -> Path {
        let version_name = "v" ++ CACHE_VERSION.to_string() ++
                          "_abi" ++ CODEGEN_ABI_VERSION.to_string() ++
                          "_" ++ CODEGEN_HASH;
        self.cache_dir.join(version_name)
    }

    /// Get the path for an object file by hash.
    ///
    /// Uses a two-character prefix for sharding:
    /// `objects/a7/f2k9m3...`
    fn object_path(self, hash: ContentHash) -> Path {
        let hash_str = hash.full_display();
        let prefix = hash_str.substring(0, 2);
        let suffix = hash_str.substring(2, hash_str.len());

        self.version_dir()
            .join("objects")
            .join(prefix)
            .join(suffix);
    }

    /// Get the path for an IR file by hash.
    fn ir_path(self, hash: ContentHash) -> Path {
        let hash_str = hash.full_display();
        let prefix = hash_str.substring(0, 2);
        let suffix = hash_str.substring(2, hash_str.len());

        self.version_dir()
            .join("ir")
            .join(prefix)
            .join(suffix ++ ".ll");
    }

    /// Get the path to the dependency index file.
    fn deps_path(self) -> Path {
        self.version_dir().join("deps.json");
    }

    // === Initialization ===

    /// Initialize the cache directory structure.
    ///
    /// Creates the following directories:
    /// - `{version}/objects/` for compiled artifacts
    /// - `{version}/ir/` for debugging IR dumps
    pub fn init(self) -> Result<Unit, CacheError> {
        if !self.enabled {
            return Result::Ok(());
        };

        let version_dir = self.version_dir();

        // Create directory structure
        match File::create_dir_all(version_dir.join("objects")) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(_) => {}
        };

        match File::create_dir_all(version_dir.join("ir")) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(_) => {}
        }

        Result::Ok(())
    }

    /// Initialize and load existing cache data.
    ///
    /// This creates the cache directory structure and loads any
    /// existing dependency index.
    pub fn init_and_load(mut self) -> Result<bool, CacheError> {
        match self.init() {
            Result::Err(e) => return Result::Err(e),
            Result::Ok(_) => {}
        };
        self.load_index();
    }

    // === Object Storage ===

    /// Check if a compiled object exists for a hash.
    pub fn has_object(mut self, hash: ContentHash) -> bool {
        if !self.enabled {
            return false;
        };

        // Check in-memory cache first
        if self.object_cache.contains_key(hash) {
            return true;
        };

        // Check filesystem
        self.object_path(hash).exists();
    }

    /// Get a compiled object by hash.
    ///
    /// Returns the object data if found, or None if not cached.
    pub fn get_object(mut self, hash: ContentHash) -> Result<Option[Vec<u8>>, CacheError] {
        if !self.enabled {
            return Result::Ok(Option::None);
        };

        let path = self.object_path(hash);
        if !path.exists() {
            self.stats.record_miss();
            return Result::Ok(Option::None);
        };

        match File::read_bytes(path) {
            Result::Err(e) => Result::Err(CacheError::Io(e)),
            Result::Ok(data) => {
                self.stats.record_hit();
                Result::Ok(Option::Some(data))
            }
        }
    }

    /// Store a compiled object.
    ///
    /// Returns the path where the object was stored.
    pub fn store_object(mut self, hash: ContentHash, data: Vec<u8>) -> Result<Path, CacheError> {
        if !self.enabled {
            return Result::Ok(Path::new(""));
        };

        let path = self.object_path(hash);

        // Ensure parent directory exists
        match path.parent() {
            Option::Some(parent) => {
                match File::create_dir_all(parent) {
                    Result::Err(e) => return Result::Err(CacheError::Io(e)),
                    Result::Ok(_) => {}
                }
            }
            Option::None => {}
        };

        // Write the object
        match File::write_bytes(path.clone(), data) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(_) => {}
        };

        // Update in-memory cache
        self.object_cache.insert(hash, path.clone());

        Result::Ok(path)
    }

    /// Get the path where an object file would be stored for a hash.
    ///
    /// Returns None if caching is disabled.
    pub fn get_object_path(self, hash: ContentHash) -> Option<Path> {
        if self.enabled {
            Option::Some(self.object_path(hash))
        } else {
            Option::None
        }
    }

    /// Store IR for debugging.
    pub fn store_ir(self, hash: ContentHash, ir: String) -> Result<Path, CacheError> {
        if !self.enabled {
            return Result::Ok(Path::new(""));
        };

        let path = self.ir_path(hash);

        // Ensure parent directory exists
        match path.parent() {
            Option::Some(parent) => {
                match File::create_dir_all(parent) {
                    Result::Err(e) => return Result::Err(CacheError::Io(e)),
                    Result::Ok(_) => {}
                }
            }
            Option::None => {}
        };

        // Write the IR
        match File::write_string(path.clone(), ir) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(_) => {}
        }

        Result::Ok(path)
    }

    // === Dependency Tracking ===

    /// Record dependencies for a hash.
    ///
    /// This enables automatic invalidation when dependencies change.
    pub fn record_dependencies(mut self, hash: ContentHash, deps: Vec<ContentHash>) -> Unit {
        if self.enabled {
            self.dependencies.insert(hash, deps);
        }
    }

    /// Get dependencies for a hash.
    pub fn get_dependencies(self, hash: ContentHash) -> Option[Vec<ContentHash>] {
        self.dependencies.get(hash).map(|v| v.clone());
    }

    /// Invalidate all dependents of a changed hash.
    ///
    /// This performs a transitive closure to find all items that
    /// depend (directly or indirectly) on the changed hash.
    ///
    /// Returns the list of invalidated hashes.
    pub fn invalidate(mut self, changed_hash: ContentHash) -> Result<Vec<ContentHash>, CacheError> {
        if !self.enabled {
            return Result::Ok(Vec::new());
        };

        let mut invalidated = Vec::new();
        let mut to_check = Vec::new();
        to_check.push(changed_hash);

        while !to_check.is_empty() {
            let hash = to_check.pop().unwrap();

            // Find all hashes that depend on this one
            let mut dependents = Vec::new();
            for (h, deps) in self.dependencies.clone() {
                if deps.contains(hash) {
                    dependents.push(h);
                }
            };

            for dep in dependents {
                if !invalidated.contains(dep) {
                    invalidated.push(dep);
                    to_check.push(dep);

                    // Remove cached object
                    let path = self.object_path(dep);
                    if path.exists() {
                        match File::remove(path) {
                            Result::Err(e) => return Result::Err(CacheError::Io(e)),
                            Result::Ok(_) => {}
                        }
                    };
                    self.object_cache.remove(dep);
                }
            }
        }

        Result::Ok(invalidated)
    }

    // === Index Persistence ===

    /// Save the dependency index to disk.
    ///
    /// This persists the dependency graph so that subsequent builds
    /// can use it for incremental invalidation.
    pub fn save_index(self) -> Result<Unit, CacheError> {
        if !self.enabled {
            return Result::Ok(());
        };

        let index = CacheIndex {
            version: CACHE_VERSION,
            dependencies: self.dependencies.clone(),
        };

        let json = index.to_json();
        let path = self.deps_path();

        // Ensure parent directory exists
        match path.parent() {
            Option::Some(parent) => {
                match File::create_dir_all(parent) {
                    Result::Err(e) => return Result::Err(CacheError::Io(e)),
                    Result::Ok(_) => {}
                }
            }
            Option::None => {}
        };

        match File::write_string(path, json) {
            Result::Err(e) => Result::Err(CacheError::Io(e)),
            Result::Ok(_) => Result::Ok(())
        }
    }

    /// Load the dependency index from disk.
    ///
    /// Returns `Ok(true)` if the index was successfully loaded,
    /// `Ok(false)` if no index exists (fresh cache), or an error.
    pub fn load_index(mut self) -> Result<bool, CacheError> {
        if !self.enabled {
            return Result::Ok(false);
        };

        let path = self.deps_path();
        if !path.exists() {
            return Result::Ok(false);
        };

        match File::read_string(path) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(json) => {
                match CacheIndex::from_json(json) {
                    Result::Err(e) => return Result::Err(e),
                    Result::Ok(index) => {
                        // Verify version compatibility
                        if index.version != CACHE_VERSION {
                            return Result::Err(CacheError::VersionMismatch {
                                expected: CACHE_VERSION,
                                found: index.version,
                            })
                        };
                        self.dependencies = index.dependencies;
                        Result::Ok(true)
                    }
                }
            }
        }
    }

    // === Cache Management ===

    /// Clear all cached objects.
    pub fn clear(mut self) -> Result<Unit, CacheError> {
        if !self.enabled {
            return Result::Ok(());
        };

        let version_dir = self.version_dir();
        if version_dir.exists() {
            match File::remove_dir_all(version_dir) {
                Result::Err(e) => return Result::Err(CacheError::Io(e)),
                Result::Ok(_) => {}
            }
        };

        self.object_cache.clear();
        self.dependencies.clear();
        self.init();
    }

    /// Get cache statistics.
    pub fn stats(self) -> CacheStats {
        // For accurate stats, would need to walk the directory
        // For now, return the runtime stats
        self.stats.clone();
    }

    /// Calculate full cache statistics by walking the directory.
    pub fn calculate_stats(self) -> Result<CacheStats, CacheError> {
        if !self.enabled {
            return Result::Ok(CacheStats::new());
        };

        let objects_dir = self.version_dir().join("objects");
        if !objects_dir.exists() {
            return Result::Ok(CacheStats::new());
        };

        let mut stats = self.stats.clone();

        // Walk directory and count files/sizes
        match File::walk_dir(objects_dir) {
            Result::Err(e) => return Result::Err(CacheError::Io(e)),
            Result::Ok(entries) => {
                for entry in entries {
                    if entry.is_file() {
                        stats.cached_count = stats.cached_count + 1;
                        match entry.size() {
                            Option::Some(size) => {
                                stats.cached_size = stats.cached_size + size;
                            }
                            Option::None => {}
                        }
                    }
                }
            }
        }

        Result::Ok(stats)
    }
}

// ============================================================================
// HIR Item Hashing (Placeholder)
// ============================================================================

/// Placeholder for HIR item type.
///
/// In the full compiler, this would be the HIR (High-level IR) item type.
/// For now, we define a minimal interface for hashing.
pub struct HirItem {
    name: String,
    kind: HirItemKind,
}

/// Placeholder for HIR item kinds.
pub enum HirItemKind {
    Function,
    Struct,
    Enum,
    TypeAlias,
    Const,
    Static,
    Trait,
    Impl,
    Effect,
    Handler,
    ExternFn,
    Bridge,
    Module,
}

/// Compute content hash for an HIR item.
///
/// This produces a hash based on the canonical form of the item,
/// suitable for incremental compilation cache keys.
pub fn hash_hir_item(item: HirItem) -> ContentHash {
    let mut hasher = ContentHasher::new();

    // Hash item name
    hasher.update_str(item.name);

    // Hash item kind tag
    let kind_tag: u8 = match item.kind {
        HirItemKind::Function => 0x01,
        HirItemKind::Struct => 0x02,
        HirItemKind::Enum => 0x03,
        HirItemKind::TypeAlias => 0x04,
        HirItemKind::Const => 0x05,
        HirItemKind::Static => 0x06,
        HirItemKind::Trait => 0x07,
        HirItemKind::Impl => 0x08,
        HirItemKind::Effect => 0x09,
        HirItemKind::Handler => 0x0A,
        HirItemKind::ExternFn => 0x0B,
        HirItemKind::Bridge => 0x0C,
        HirItemKind::Module => 0x0D,
    };
    hasher.update_u8(kind_tag);

    hasher.finalize();
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_cache_stats_new() {
    let stats = CacheStats::new();
    assert(stats.hits() == 0);
    assert(stats.misses() == 0);
    assert(stats.cached_size() == 0);
    assert(stats.cached_count() == 0);
}

#[test]
fn test_cache_stats_hit_rate() {
    let mut stats = CacheStats::new();

    // No operations = 0% hit rate
    assert(stats.hit_rate() == 0.0);

    // Record some hits and misses
    stats.record_hit();
    stats.record_hit();
    stats.record_hit();
    stats.record_miss();

    // 3 hits, 1 miss = 75% hit rate
    let rate = stats.hit_rate();
    assert(rate > 74.9 && rate < 75.1);  // Allow floating point tolerance
}

#[test]
fn test_cache_index_new() {
    let index = CacheIndex::new();
    assert(index.version == CACHE_VERSION);
    assert(index.dependencies.is_empty());
}

#[test]
fn test_cache_index_to_json() {
    let mut index = CacheIndex::new();

    let hash1 = ContentHash::compute("item1".as_bytes());
    let hash2 = ContentHash::compute("item2".as_bytes());
    let hash3 = ContentHash::compute("item3".as_bytes());

    // item1 depends on item2 and item3
    let mut deps = Vec::new();
    deps.push(hash2);
    deps.push(hash3);
    index.dependencies.insert(hash1, deps);

    let json = index.to_json();

    // Should contain version
    assert(json.contains("\"version\":"));
    // Should contain dependencies section
    assert(json.contains("\"dependencies\":"));
}

#[test]
fn test_build_cache_disabled() {
    let cache = BuildCache::disabled();
    assert(!cache.is_enabled());

    let hash = ContentHash::compute("test".as_bytes());
    assert(!cache.has_object(hash));
}

#[test]
fn test_build_cache_default_dir() {
    let dir = BuildCache::default_cache_dir();
    // Should return a non-empty path
    assert(!dir.to_string().is_empty());
}

#[test]
fn test_build_cache_version_dir() {
    let cache = BuildCache::with_dir(Path::new("/tmp/test-cache"));
    let version_dir = cache.version_dir();

    // Should contain version info
    let dir_str = version_dir.to_string();
    assert(dir_str.contains("v" ++ CACHE_VERSION.to_string()));
    assert(dir_str.contains("abi" ++ CODEGEN_ABI_VERSION.to_string()));
}

#[test]
fn test_build_cache_object_path_sharding() {
    let cache = BuildCache::with_dir(Path::new("/tmp/test-cache"));

    let hash = ContentHash::compute("test object".as_bytes());
    let path = cache.object_path(hash);

    let path_str = path.to_string();

    // Should be sharded by first two characters of hash
    assert(path_str.contains("/objects/"));

    // Path should contain hash
    let hash_str = hash.full_display();
    assert(path_str.contains(hash_str.substring(2, hash_str.len())));
}

#[test]
fn test_build_cache_dependencies() {
    let mut cache = BuildCache::with_dir(Path::new("/tmp/test-cache"));

    let hash_a = ContentHash::compute("a".as_bytes());
    let hash_b = ContentHash::compute("b".as_bytes());
    let hash_c = ContentHash::compute("c".as_bytes());

    // Record: B depends on A, C depends on B
    let mut deps_b = Vec::new();
    deps_b.push(hash_a);
    cache.record_dependencies(hash_b, deps_b);

    let mut deps_c = Vec::new();
    deps_c.push(hash_b);
    cache.record_dependencies(hash_c, deps_c);

    // Verify dependencies
    let got_b = cache.get_dependencies(hash_b).unwrap();
    assert(got_b.len() == 1);
    assert(got_b.contains(hash_a));

    let got_c = cache.get_dependencies(hash_c).unwrap();
    assert(got_c.len() == 1);
    assert(got_c.contains(hash_b));
}

#[test]
fn test_cache_error_describe() {
    let err1 = CacheError::Corrupted("bad data");
    assert(err1.describe().contains("corrupted"));

    let err2 = CacheError::VersionMismatch { expected: 2, found: 1 };
    assert(err2.describe().contains("version mismatch"));
    assert(err2.describe().contains("expected 2"));
    assert(err2.describe().contains("found 1"));

    let err3 = CacheError::Json("parse error");
    assert(err3.describe().contains("JSON"));
}

#[test]
fn test_hir_item_hash_determinism() {
    let item = HirItem {
        name: "my_function",
        kind: HirItemKind::Function,
    };

    let hash1 = hash_hir_item(item);
    let hash2 = hash_hir_item(HirItem {
        name: "my_function",
        kind: HirItemKind::Function,
    });

    // Same item should produce same hash
    assert(hash1 == hash2);

    // Different name should produce different hash
    let item2 = HirItem {
        name: "other_function",
        kind: HirItemKind::Function,
    };
    let hash3 = hash_hir_item(item2);
    assert(hash1 != hash3);

    // Different kind should produce different hash
    let item3 = HirItem {
        name: "my_function",
        kind: HirItemKind::Struct,
    };
    let hash4 = hash_hir_item(item3);
    assert(hash1 != hash4);
}

#[test]
fn test_hir_item_kind_tags() {
    // Verify each kind produces a unique tag
    let kinds = vec![
        HirItemKind::Function,
        HirItemKind::Struct,
        HirItemKind::Enum,
        HirItemKind::TypeAlias,
        HirItemKind::Const,
        HirItemKind::Static,
        HirItemKind::Trait,
        HirItemKind::Impl,
        HirItemKind::Effect,
        HirItemKind::Handler,
        HirItemKind::ExternFn,
        HirItemKind::Bridge,
        HirItemKind::Module,
    ];

    let mut hashes = Vec::new();
    for kind in kinds {
        let item = HirItem {
            name: "same_name",
            kind: kind,
        };
        let hash = hash_hir_item(item);

        // Each hash should be unique
        for existing in hashes.clone() {
            assert(hash != existing);
        };
        hashes.push(hash);
    }
}
