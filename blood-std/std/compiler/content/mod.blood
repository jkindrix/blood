//! # Content-Addressed Code
//!
//! Blood identifies all definitions by a cryptographic hash of their
//! canonicalized AST, not by name. This module implements the content-addressing
//! system for the self-hosted Blood compiler.
//!
//! ## Overview
//!
//! ```text
//! Source Code → Canonicalized AST → BLAKE3-256 → Hash
//!                      │
//!                      ▼
//!             CODEBASE DATABASE
//!    Hash → { ast, metadata: { name } }
//! ```
//!
//! ## Benefits
//!
//! - **No Dependency Hell**: Multiple versions coexist by hash
//! - **Perfect Incremental Compilation**: Only recompile changed hashes
//! - **Safe Refactoring**: Renames never break code
//! - **Zero-Downtime Upgrades**: Hot-swap code by hash
//! - **Distributed Caching**: Share compiled artifacts globally
//!
//! ## Modules
//!
//! - [`hash`]: BLAKE3-256 hash types and computation
//! - [`canonical`]: AST canonicalization with de Bruijn indices
//! - [`storage`]: Codebase database operations
//! - [`namespace`]: Name-to-hash mappings
//! - [`vft`]: Virtual Function Table for runtime dispatch
//! - [`build_cache`]: Build cache for incremental compilation
//! - [`distributed_cache`]: Distributed cache for remote sharing
//!
//! ## Quick Start
//!
//! ### Computing Content Hashes
//!
//! ```blood
//! use std.compiler.content.hash.ContentHash
//! use std.compiler.content.hash.ContentHasher
//!
//! // Direct computation
//! let hash = ContentHash::compute("fn add(x, y) { x + y }".as_bytes())
//!
//! // Incremental hashing
//! let mut hasher = ContentHasher::new()
//! hasher.update_str("fn add")
//! hasher.update_u8(2)  // arity
//! let hash = hasher.finalize()
//! ```
//!
//! ### Canonicalizing AST
//!
//! ```blood
//! use std.compiler.content.canonical.Canonicalizer
//! use std.compiler.content.canonical.CanonicalAST
//!
//! let mut canonicalizer = Canonicalizer::new()
//! let canonical_ast = canonicalizer.canonicalize(some_ast)
//! let hash = canonical_ast.compute_hash()
//! ```
//!
//! ### Storing Definitions
//!
//! ```blood
//! use std.compiler.content.storage.Codebase
//! use std.compiler.content.storage.DefinitionRecord
//!
//! let mut codebase = Codebase::new()
//!
//! // Store a definition
//! let record = DefinitionRecord::new(hash, canonical_ast, type_hash, effect_hash)
//! codebase.store_definition(record)
//!
//! // Retrieve by hash
//! let found = codebase.get_definition(hash)
//! ```
//!
//! ### Runtime Dispatch
//!
//! ```blood
//! use std.compiler.content.vft.VFT
//! use std.compiler.content.vft.VFTEntry
//!
//! let mut vft = VFT::new()
//!
//! // Register a function
//! let entry = VFTEntry::new(hash, entry_point_address, arity)
//! vft.register(entry)
//!
//! // Look up entry point
//! let addr = vft.get_entry_point(hash)
//! ```
//!
//! ### Incremental Compilation
//!
//! ```blood
//! use std.compiler.content.build_cache.BuildCache
//!
//! let mut cache = BuildCache::new()
//! cache.init()
//!
//! // Check for cached artifact
//! if cache.has_object(hash) {
//!     let data = cache.get_object(hash)
//! } else {
//!     // Compile and store
//!     let compiled = compile(definition)
//!     cache.store_object(hash, compiled)
//! }
//! ```
//!
//! ### Distributed Caching
//!
//! ```blood
//! use std.compiler.content.distributed_cache.DistributedCache
//! use std.compiler.content.distributed_cache.RemoteCacheConfig
//!
//! let local_cache = BuildCache::new()
//! let mut dist_cache = DistributedCache::new(local_cache)
//!
//! // Add remote cache servers
//! dist_cache.add_remote(RemoteCacheConfig::new("https://cache.blood-lang.org"))
//!
//! // Fetch (checks local first, then remotes)
//! let result = dist_cache.fetch(hash)
//! ```

module std.compiler.content;

// ============================================================================
// Submodule Declarations
// ============================================================================

/// BLAKE3-256 hash types and computation.
pub mod hash;

/// AST canonicalization with de Bruijn indices.
pub mod canonical;

/// Codebase database operations.
pub mod storage;

/// Name-to-hash mappings.
pub mod namespace;

/// Virtual Function Table for runtime dispatch.
pub mod vft;

/// Build cache for incremental compilation.
pub mod build_cache;

/// Distributed cache for remote sharing.
pub mod distributed_cache;

// ============================================================================
// Re-exports
// ============================================================================

// Hash types
pub use hash.ContentHash;
pub use hash.ContentHasher;
pub use hash.FORMAT_VERSION;

// Canonical AST types
pub use canonical.DeBruijnIndex;
pub use canonical.FieldId;
pub use canonical.VariantId;
pub use canonical.BuiltinId;
pub use canonical.CanonicalAST;
pub use canonical.CanonicalBinOp;
pub use canonical.CanonicalUnOp;
pub use canonical.CanonicalEffectRow;
pub use canonical.CanonicalHandler;
pub use canonical.CanonicalOpImpl;
pub use canonical.Canonicalizer;

// Storage types
pub use storage.StorageError;
pub use storage.SourceLocation;
pub use storage.DefinitionMetadata;
pub use storage.DefinitionRecord;
pub use storage.Codebase;
pub use storage.CodebaseStats;

// Namespace types
pub use namespace.BindingKind;
pub use namespace.NameBinding;
pub use namespace.Namespace;
pub use namespace.NameRegistry;

// VFT types
pub use vft.CallingConvention;
pub use vft.EffectMask;
pub use vft.VFTEntry;
pub use vft.SwapMode;
pub use vft.HotSwapResult;
pub use vft.HotSwapError;
pub use vft.VFT;
pub use vft.TypePattern;
pub use vft.DispatchEntry;
pub use vft.DispatchTable;

// Build cache types
pub use build_cache.CACHE_VERSION;
pub use build_cache.CacheError;
pub use build_cache.CacheStats;
pub use build_cache.CacheIndex;
pub use build_cache.BuildCache;
pub use build_cache.HirItem;
pub use build_cache.HirItemKind;
pub use build_cache.hash_hir_item;

// Distributed cache types
pub use distributed_cache.RemoteCacheConfig;
pub use distributed_cache.RemoteCacheStats;
pub use distributed_cache.FetchResult;
pub use distributed_cache.DistributedCache;
pub use distributed_cache.HeadRequest;
pub use distributed_cache.GetRequest;
pub use distributed_cache.PutRequest;
pub use distributed_cache.CacheResponse;

// ============================================================================
// Module-Level Constants
// ============================================================================

/// The version of the content-addressing system.
///
/// This should be incremented when making breaking changes to:
/// - Hash computation algorithm
/// - Canonical AST format
/// - Storage format
/// - VFT structure
pub const CONTENT_SYSTEM_VERSION: u32 = 1;

// ============================================================================
// Convenience Functions
// ============================================================================

/// Compute a content hash directly from source code.
///
/// This is a convenience function that combines canonicalization and hashing.
/// For production use, prefer the full pipeline with explicit canonicalization.
pub fn compute_source_hash(source: String) -> ContentHash {
    ContentHash::compute(source.as_bytes())
}

/// Create a new in-memory codebase.
pub fn new_codebase() -> Codebase {
    Codebase::new()
}

/// Create a new VFT.
pub fn new_vft() -> VFT {
    VFT::new()
}

/// Create a new build cache with default configuration.
pub fn new_build_cache() -> BuildCache {
    BuildCache::new()
}

/// Create a new distributed cache with local-only caching.
pub fn new_distributed_cache() -> DistributedCache {
    DistributedCache::new(BuildCache::new())
}

/// Create a distributed cache from environment configuration.
pub fn distributed_cache_from_env() -> DistributedCache {
    DistributedCache::from_env(BuildCache::new())
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_compute_source_hash_determinism() {
    let source = "fn hello() { println(\"Hello, World!\") }";

    let hash1 = compute_source_hash(source);
    let hash2 = compute_source_hash(source);

    assert(hash1 == hash2);
}

#[test]
fn test_compute_source_hash_different_sources() {
    let source1 = "fn add(x, y) { x + y }";
    let source2 = "fn sub(x, y) { x - y }";

    let hash1 = compute_source_hash(source1);
    let hash2 = compute_source_hash(source2);

    assert(hash1 != hash2);
}

#[test]
fn test_new_codebase() {
    let codebase = new_codebase();
    assert(codebase.definition_count() == 0);
}

#[test]
fn test_new_vft() {
    let vft = new_vft();
    assert(vft.is_empty());
}

#[test]
fn test_new_build_cache() {
    let cache = new_build_cache();
    assert(cache.is_enabled());
}

#[test]
fn test_content_system_version() {
    // Ensure version is positive
    assert(CONTENT_SYSTEM_VERSION > 0);
}
