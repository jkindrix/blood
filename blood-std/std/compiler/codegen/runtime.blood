//! Runtime Support for Blood Programs
//!
//! This module provides declarations and constants for runtime functions
//! that Blood programs can call. Compiled Blood programs must be linked
//! with the Blood runtime library.
//!
//! ## Runtime Linking
//!
//! - **Rust runtime** (`blood-runtime`): Full-featured runtime with fibers,
//!   channels, and effects support.
//!
//! - **C runtime** (fallback): Minimal C runtime for simple programs without
//!   advanced features.
//!
//! ## Function Categories
//!
//! ### I/O
//! - `print_int`, `println_int` - Integer output
//! - `print_str`, `println_str` - String output
//! - `print_bool`, `println_bool` - Boolean output
//!
//! ### Memory (Generational References)
//! - `blood_alloc` - Allocate with generation tracking
//! - `blood_free` - Free allocated memory
//! - `blood_validate_generation` - Validate address/generation pair
//! - `blood_register_allocation` - Register address in slot registry
//! - `blood_unregister_allocation` - Remove address from slot registry
//! - `blood_stale_reference_panic` - Handle stale reference errors
//!
//! ### Effects
//! - `blood_evidence_*` - Evidence vector management
//! - `blood_perform` - Perform effect operation
//! - `blood_handler_depth` - Get handler depth for effect
//!
//! ### Continuations
//! - `blood_fiber_*` - Fiber support
//! - `blood_snapshot_*` - Generation snapshots for continuation capture
//!
//! ### Runtime Lifecycle
//! - `blood_runtime_init` - Initialize runtime
//! - `blood_runtime_shutdown` - Cleanup runtime

// ============================================================================
// I/O Functions
// ============================================================================

/// Print an integer (no newline).
pub const PRINT_INT: &str = "print_int";

/// Print an integer with newline.
pub const PRINTLN_INT: &str = "println_int";

/// Print a 64-bit integer with newline.
pub const PRINTLN_I64: &str = "println_i64";

/// Print a string (no newline).
pub const PRINT_STR: &str = "print_str";

/// Print a string with newline.
pub const PRINTLN_STR: &str = "println_str";

/// Print a boolean (no newline).
pub const PRINT_BOOL: &str = "print_bool";

/// Print a boolean with newline.
pub const PRINTLN_BOOL: &str = "println_bool";

/// Print a newline only.
pub const PRINTLN: &str = "println";

/// Print a character.
pub const PRINT_CHAR: &str = "print_char";

/// Print a character with newline.
pub const PRINTLN_CHAR: &str = "println_char";

// ============================================================================
// Assertions
// ============================================================================

/// Assert that a condition is true.
pub const ASSERT: &str = "blood_assert";

/// Assert that two integers are equal.
pub const ASSERT_EQ_INT: &str = "blood_assert_eq_int";

/// Assert that two booleans are equal.
pub const ASSERT_EQ_BOOL: &str = "blood_assert_eq_bool";

// ============================================================================
// Control Flow
// ============================================================================

/// Unreachable code was reached.
pub const UNREACHABLE: &str = "blood_unreachable";

// ============================================================================
// Memory Management
// ============================================================================

/// Allocate memory with generational reference.
/// Returns: 0 on success, error code on failure
/// Signature: (size: i64, out_addr: *mut u64, out_gen_meta: *mut u64) -> i32
pub const ALLOC: &str = "blood_alloc";

/// Free memory.
/// Signature: (addr: u64, size: i64) -> void
pub const FREE: &str = "blood_free";

/// Allocate memory (aborts on failure).
/// Signature: (size: i64) -> u64 (address)
pub const ALLOC_OR_ABORT: &str = "blood_alloc_or_abort";

/// Validate generation for an address.
/// Returns: 0 if valid, 1 if stale.
/// Signature: (addr: u64, expected_gen: i32) -> i32
pub const VALIDATE_GENERATION: &str = "blood_validate_generation";

/// Register an allocation in the slot registry.
/// Returns: assigned generation
/// Signature: (addr: u64, size: i64) -> i32
pub const REGISTER_ALLOCATION: &str = "blood_register_allocation";

/// Unregister an allocation from the slot registry.
/// Signature: (addr: u64) -> void
pub const UNREGISTER_ALLOCATION: &str = "blood_unregister_allocation";

/// Get the current generation for an address.
/// Signature: (addr: u64) -> i32
pub const GET_GENERATION: &str = "blood_get_generation";

/// Increment the generation for an address (invalidates references).
/// Signature: (addr: *mut void) -> void
pub const INCREMENT_GENERATION: &str = "blood_increment_generation";

/// Called on stale reference access.
/// Signature: (expected: u32, actual: u32) -> ! (never returns)
pub const STALE_REFERENCE_PANIC: &str = "blood_stale_reference_panic";

// ============================================================================
// Effect Runtime - Evidence Vectors
// ============================================================================

/// Create evidence vector.
/// Signature: () -> *mut void
pub const EVIDENCE_CREATE: &str = "blood_evidence_create";

/// Destroy evidence vector.
/// Signature: (ev: *mut void) -> void
pub const EVIDENCE_DESTROY: &str = "blood_evidence_destroy";

/// Push handler onto evidence vector.
/// Signature: (ev: *mut void, handler: u64) -> void
pub const EVIDENCE_PUSH: &str = "blood_evidence_push";

/// Pop handler from evidence vector.
/// Signature: (ev: *mut void) -> u64
pub const EVIDENCE_POP: &str = "blood_evidence_pop";

/// Get handler from evidence vector by index.
/// Signature: (ev: *mut void, index: u64) -> u64
pub const EVIDENCE_GET: &str = "blood_evidence_get";

/// Push handler with state onto evidence vector.
/// Signature: (ev: *mut void, effect_id: u64, state: *mut void) -> void
pub const EVIDENCE_PUSH_WITH_STATE: &str = "blood_evidence_push_with_state";

/// Set the current evidence vector.
/// Signature: (ev: *mut void) -> void
pub const EVIDENCE_SET_CURRENT: &str = "blood_evidence_set_current";

/// Register handler with operations for an effect.
/// Signature: (ev: *mut void, effect_id: u64, ops: **mut void, op_count: u64) -> void
pub const EVIDENCE_REGISTER: &str = "blood_evidence_register";

/// Set state for current handler.
/// Signature: (ev: *mut void, state: *mut void) -> void
pub const EVIDENCE_SET_STATE: &str = "blood_evidence_set_state";

/// Get state for handler at index.
/// Signature: (ev: *mut void, index: u64) -> *mut void
pub const EVIDENCE_GET_STATE: &str = "blood_evidence_get_state";

/// Get current evidence vector.
/// Signature: () -> *mut void
pub const EVIDENCE_CURRENT: &str = "blood_evidence_current";

/// Perform an effect operation.
/// Signature: (effect_id: u64, op_index: i32, args: *mut i64, arg_count: i64) -> i64
pub const PERFORM: &str = "blood_perform";

/// Get handler depth for an effect.
/// Signature: (effect_id: u64) -> i64
pub const HANDLER_DEPTH: &str = "blood_handler_depth";

// ============================================================================
// Fiber/Continuation Support
// ============================================================================

/// Create a new fiber.
/// Signature: () -> u64
pub const FIBER_CREATE: &str = "blood_fiber_create";

/// Suspend current fiber.
/// Signature: () -> u64
pub const FIBER_SUSPEND: &str = "blood_fiber_suspend";

/// Resume a suspended fiber.
/// Signature: (fiber: u64, value: u64) -> void
pub const FIBER_RESUME: &str = "blood_fiber_resume";

// ============================================================================
// Generation Snapshots
// ============================================================================

/// Create a generation snapshot for continuation capture.
/// Signature: () -> u64
pub const SNAPSHOT_CREATE: &str = "blood_snapshot_create";

/// Add an entry to a generation snapshot.
/// Signature: (snapshot_id: u64, address: u64, generation: i32) -> void
pub const SNAPSHOT_ADD_ENTRY: &str = "blood_snapshot_add_entry";

/// Validate all entries in a snapshot against current generations.
/// Returns: 0 if all valid, or 1-indexed position of first stale ref.
/// Signature: (snapshot_id: u64) -> i64
pub const SNAPSHOT_VALIDATE: &str = "blood_snapshot_validate";

/// Get the number of entries in a snapshot.
/// Signature: (snapshot_id: u64) -> i64
pub const SNAPSHOT_LEN: &str = "blood_snapshot_len";

/// Destroy a generation snapshot.
/// Signature: (snapshot_id: u64) -> void
pub const SNAPSHOT_DESTROY: &str = "blood_snapshot_destroy";

// ============================================================================
// Runtime Lifecycle
// ============================================================================

/// Initialize runtime.
/// Signature: () -> i32
pub const RUNTIME_INIT: &str = "blood_runtime_init";

/// Shutdown runtime.
/// Signature: () -> void
pub const RUNTIME_SHUTDOWN: &str = "blood_runtime_shutdown";

/// Panic handler.
/// Signature: (msg: BloodStr) -> ! (never returns)
pub const PANIC: &str = "blood_panic";

// ============================================================================
// Multiple Dispatch
// ============================================================================

/// Register a method implementation for a type.
/// Signature: (method_slot: u64, type_tag: u64, impl_ptr: *mut void) -> void
pub const DISPATCH_REGISTER: &str = "blood_dispatch_register";

/// Look up a method implementation for a type.
/// Signature: (method_slot: u64, type_tag: u64) -> *mut void
pub const DISPATCH_LOOKUP: &str = "blood_dispatch_lookup";

/// Get the runtime type tag from an object.
/// Signature: (obj: *mut void) -> u64
pub const GET_TYPE_TAG: &str = "blood_get_type_tag";

// ============================================================================
// Work-Stealing Scheduler
// ============================================================================

/// Initialize the scheduler.
/// Signature: (num_workers: i64) -> i32
pub const SCHEDULER_INIT: &str = "blood_scheduler_init";

/// Spawn a task with argument.
/// Signature: (task_fn: *mut void, arg: *mut void) -> u64
pub const SCHEDULER_SPAWN: &str = "blood_scheduler_spawn";

/// Spawn a task without argument.
/// Signature: (task_fn: *mut void) -> u64
pub const SCHEDULER_SPAWN_SIMPLE: &str = "blood_scheduler_spawn_simple";

/// Yield the current task.
/// Signature: () -> void
pub const SCHEDULER_YIELD: &str = "blood_scheduler_yield";

/// Run the scheduler.
/// Signature: () -> void
pub const SCHEDULER_RUN: &str = "blood_scheduler_run";

/// Run the scheduler in background.
/// Signature: () -> void
pub const SCHEDULER_RUN_BACKGROUND: &str = "blood_scheduler_run_background";

/// Shutdown the scheduler.
/// Signature: () -> void
pub const SCHEDULER_SHUTDOWN: &str = "blood_scheduler_shutdown";

/// Wait for all tasks to complete.
/// Signature: () -> void
pub const SCHEDULER_WAIT: &str = "blood_scheduler_wait";

/// Get count of active fibers.
/// Signature: () -> i64
pub const SCHEDULER_ACTIVE_FIBERS: &str = "blood_scheduler_active_fibers";

/// Get count of runnable fibers.
/// Signature: () -> i64
pub const SCHEDULER_RUNNABLE_FIBERS: &str = "blood_scheduler_runnable_fibers";

/// Check if scheduler is running.
/// Signature: () -> i32
pub const SCHEDULER_IS_RUNNING: &str = "blood_scheduler_is_running";

// ============================================================================
// String Operations
// ============================================================================

/// Get string length.
/// Signature: (s: BloodStr) -> i64
pub const STR_LEN: &str = "str_len";

/// Compare two strings for equality.
/// Signature: (a: BloodStr, b: BloodStr) -> i32
pub const STR_EQ: &str = "str_eq";

/// Concatenate two strings.
/// Signature: (a: BloodStr, b: BloodStr) -> BloodStr
pub const STR_CONCAT: &str = "blood_str_concat";

/// Convert integer to string.
/// Signature: (n: i32) -> BloodStr
pub const INT_TO_STRING: &str = "int_to_string";

/// Convert boolean to string.
/// Signature: (b: i32) -> BloodStr
pub const BOOL_TO_STRING: &str = "bool_to_string";

// ============================================================================
// Runtime Function Info
// ============================================================================

/// Information about a runtime function for declaration.
pub struct RuntimeFunctionInfo {
    /// The function name (link name).
    pub name: String,
    /// Number of parameters.
    pub param_count: u32,
    /// Whether the function returns a value (vs void).
    pub has_return: bool,
    /// Whether the function never returns (like panic).
    pub is_noreturn: bool,
}

impl RuntimeFunctionInfo {
    /// Create a new runtime function info.
    pub fn new(name: String, param_count: u32, has_return: bool) -> RuntimeFunctionInfo {
        RuntimeFunctionInfo {
            name,
            param_count,
            has_return,
            is_noreturn: false,
        }
    }

    /// Create a noreturn function info.
    pub fn noreturn(name: String, param_count: u32) -> RuntimeFunctionInfo {
        RuntimeFunctionInfo {
            name,
            param_count,
            has_return: false,
            is_noreturn: true,
        }
    }
}

/// Get all I/O runtime functions.
pub fn io_functions() -> [RuntimeFunctionInfo] {
    [
        RuntimeFunctionInfo::new(PRINT_INT.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINTLN_INT.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINTLN_I64.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINT_STR.to_string(), 1, false),  // BloodStr is 2 words
        RuntimeFunctionInfo::new(PRINTLN_STR.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINT_BOOL.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINTLN_BOOL.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINTLN.to_string(), 0, false),
        RuntimeFunctionInfo::new(PRINT_CHAR.to_string(), 1, false),
        RuntimeFunctionInfo::new(PRINTLN_CHAR.to_string(), 1, false),
    ]
}

/// Get all memory management runtime functions.
pub fn memory_functions() -> [RuntimeFunctionInfo] {
    [
        RuntimeFunctionInfo::new(ALLOC.to_string(), 3, true),
        RuntimeFunctionInfo::new(FREE.to_string(), 2, false),
        RuntimeFunctionInfo::new(ALLOC_OR_ABORT.to_string(), 1, true),
        RuntimeFunctionInfo::new(VALIDATE_GENERATION.to_string(), 2, true),
        RuntimeFunctionInfo::new(REGISTER_ALLOCATION.to_string(), 2, true),
        RuntimeFunctionInfo::new(UNREGISTER_ALLOCATION.to_string(), 1, false),
        RuntimeFunctionInfo::new(GET_GENERATION.to_string(), 1, true),
        RuntimeFunctionInfo::new(INCREMENT_GENERATION.to_string(), 1, false),
        RuntimeFunctionInfo::noreturn(STALE_REFERENCE_PANIC.to_string(), 2),
    ]
}

/// Get all effect runtime functions.
pub fn effect_functions() -> [RuntimeFunctionInfo] {
    [
        RuntimeFunctionInfo::new(EVIDENCE_CREATE.to_string(), 0, true),
        RuntimeFunctionInfo::new(EVIDENCE_DESTROY.to_string(), 1, false),
        RuntimeFunctionInfo::new(EVIDENCE_PUSH.to_string(), 2, false),
        RuntimeFunctionInfo::new(EVIDENCE_POP.to_string(), 1, true),
        RuntimeFunctionInfo::new(EVIDENCE_GET.to_string(), 2, true),
        RuntimeFunctionInfo::new(EVIDENCE_PUSH_WITH_STATE.to_string(), 3, false),
        RuntimeFunctionInfo::new(EVIDENCE_SET_CURRENT.to_string(), 1, false),
        RuntimeFunctionInfo::new(EVIDENCE_REGISTER.to_string(), 4, false),
        RuntimeFunctionInfo::new(EVIDENCE_SET_STATE.to_string(), 2, false),
        RuntimeFunctionInfo::new(EVIDENCE_GET_STATE.to_string(), 2, true),
        RuntimeFunctionInfo::new(EVIDENCE_CURRENT.to_string(), 0, true),
        RuntimeFunctionInfo::new(PERFORM.to_string(), 4, true),
        RuntimeFunctionInfo::new(HANDLER_DEPTH.to_string(), 1, true),
    ]
}

/// Get all assertion runtime functions.
pub fn assertion_functions() -> [RuntimeFunctionInfo] {
    [
        RuntimeFunctionInfo::new(ASSERT.to_string(), 1, false),
        RuntimeFunctionInfo::new(ASSERT_EQ_INT.to_string(), 2, false),
        RuntimeFunctionInfo::new(ASSERT_EQ_BOOL.to_string(), 2, false),
        RuntimeFunctionInfo::noreturn(UNREACHABLE.to_string(), 0),
    ]
}

/// Get all lifecycle runtime functions.
pub fn lifecycle_functions() -> [RuntimeFunctionInfo] {
    [
        RuntimeFunctionInfo::new(RUNTIME_INIT.to_string(), 0, true),
        RuntimeFunctionInfo::new(RUNTIME_SHUTDOWN.to_string(), 0, false),
        RuntimeFunctionInfo::noreturn(PANIC.to_string(), 1),
    ]
}
