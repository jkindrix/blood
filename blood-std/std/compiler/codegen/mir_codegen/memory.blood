//! MIR Memory Management Code Generation
//!
//! This module handles memory allocation, generation checks, and related
//! runtime interactions for the Blood memory safety system.
//!
//! ## Memory Tier System
//!
//! | Tier | Allocation | Generation Tracking | Use Case |
//! |------|------------|---------------------|----------|
//! | Stack | LLVM alloca | None | NoEscape locals |
//! | Region | blood_alloc | Slot registry | ArgEscape/GlobalEscape |
//! | Persistent | blood_alloc | Slot registry | Effect-captured |
//!
//! ## Generation Validation Flow
//!
//! ```text
//! 1. On allocation:
//!    address = blood_alloc_or_abort(size, &out_generation)
//!    store generation in local_generations[local_id]
//!
//! 2. On dereference:
//!    result = blood_validate_generation(address, expected_gen)
//!    if result != 0:
//!        blood_stale_reference_panic(expected, actual)
//!
//! 3. On deallocation (scope exit):
//!    blood_unregister_allocation(address)
//!    // This increments generation, invalidating all references
//! ```

use std.compiler.codegen.llvm::{
    LLVMValueRef, LLVMTypeRef,
    types::{i32_type, i64_type, ptr_type},
    values::{const_int, append_basic_block},
};
use std.compiler.codegen.context::CodegenContext;

use std.compiler.hir::LocalId;
use std.compiler.diagnostics::Diagnostic;
use std.compiler.span::Span;

// ============================================================================
// Generation Lookup
// ============================================================================

/// Get the generation for an address by calling blood_get_generation.
///
/// This is used to look up the current generation from the slot registry
/// when validating references or building error messages.
pub fn get_generation_for_address(
    ctx: &CodegenContext,
    address: LLVMValueRef,
    span: Span,
) -> Result<LLVMValueRef, Vec<Diagnostic>> {
    let get_gen_fn = ctx.get_runtime_fn("blood_get_generation")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_get_generation not declared. This function should be declared by CodegenContext::new()",
            span
        )])?;

    let gen_result = ctx.llvm_builder().build_call(get_gen_fn, &[address], "gen_lookup\0");

    Ok(gen_result)
}

// ============================================================================
// Generation Checks
// ============================================================================

/// Emit a generation check for a pointer dereference.
///
/// The check works as follows:
/// 1. Call blood_validate_generation(address, expected_gen)
/// 2. If result != 0 (stale), call blood_stale_reference_panic
/// 3. If result == 0 (valid), continue execution
///
/// This is called for every dereference of region-allocated values.
/// Stack-allocated values skip this check (handled by escape analysis).
pub fn emit_generation_check(
    ctx: &mut CodegenContext,
    ptr: LLVMValueRef,
    expected_gen: LLVMValueRef,
    span: Span,
) -> Result<(), Vec<Diagnostic>> {
    let i32_ty = i32_type(ctx.llvm_context_ref());
    let i64_ty = i64_type(ctx.llvm_context_ref());

    // Get the validation function
    let validate_fn = ctx.get_runtime_fn("blood_validate_generation")
        .ok_or_else(|| vec![Diagnostic::error(
            "blood_validate_generation not declared",
            span
        )])?;

    // Convert pointer to i64 address for the runtime call
    let address = ctx.llvm_builder().build_ptr_to_int(ptr, i64_ty, "ptr_addr\0");

    // Call blood_validate_generation(address: i64, expected_gen: i32) -> i32
    // Returns: 0 = valid, 1 = stale (generation mismatch);
    let is_stale = ctx.llvm_builder().build_call(
        validate_fn,
        &[address, expected_gen],
        "gen_check\0"
    );

    // Create blocks for valid and stale paths
    let fn_value = ctx.current_fn().ok_or_else(|| {
        vec![Diagnostic::error("No current function", span)]
    })?;

    let valid_bb = append_basic_block(ctx.llvm_context_ref(), fn_value, "gen_valid\0");
    let stale_bb = append_basic_block(ctx.llvm_context_ref(), fn_value, "gen_stale\0");

    // Compare: is_stale == 0 (valid if result is 0);
    let zero = const_int(i32_ty, 0, false);
    let is_valid = ctx.llvm_builder().build_icmp_eq(is_stale, zero, "is_valid\0");

    ctx.llvm_builder().build_cond_br(is_valid, valid_bb.raw(), stale_bb.raw());

    // Stale path: call panic handler
    ctx.llvm_builder().position_at_end(stale_bb.raw());

    let panic_fn = ctx.get_runtime_fn("blood_stale_reference_panic")
        .ok_or_else(|| vec![Diagnostic::error(
            "blood_stale_reference_panic not declared",
            span
        )])?;

    // Get current generation for the error message
    if let Some(get_gen_fn) = ctx.get_runtime_fn("blood_get_generation") {
        let actual_gen = ctx.llvm_builder().build_call(get_gen_fn, &[address], "actual_gen\0");
        ctx.llvm_builder().build_call(panic_fn, &[expected_gen, actual_gen], "\0");
    } else {
        // blood_get_generation not available - use expected as fallback
        ctx.llvm_builder().build_call(panic_fn, &[expected_gen, expected_gen], "\0");
    };

    ctx.llvm_builder().build_unreachable();

    // Continue at valid block
    ctx.llvm_builder().position_at_end(valid_bb.raw());

    Ok(())
}

// ============================================================================
// Region Allocation
// ============================================================================

/// Allocate memory using blood_alloc for Region/Persistent tier.
///
/// This function:
/// 1. Calls blood_alloc_or_abort(size, &out_generation)
/// 2. Converts the returned address to a typed pointer
/// 3. Stores the generation in local_generations for later validation
///
/// The blood_alloc_or_abort function aborts on allocation failure,
/// so no error handling branches are needed here.
pub fn allocate_with_blood_alloc(
    ctx: &mut CodegenContext,
    llvm_ty: LLVMTypeRef,
    local_id: LocalId,
    span: Span,
) -> Result<LLVMValueRef, Vec<Diagnostic>> {
    let i32_ty = i32_type(ctx.llvm_context_ref());
    let i64_ty = i64_type(ctx.llvm_context_ref());

    // Get the blood_alloc_or_abort function
    let alloc_fn = ctx.get_runtime_fn("blood_alloc_or_abort")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_alloc_or_abort not found",
            span
        )])?;

    // Calculate size of the type
    let type_size = ctx.get_type_size(llvm_ty);
    let size_val = const_int(i64_ty, type_size, false);

    // Create stack alloca for the generation output parameter
    let gen_alloca = ctx.llvm_builder().build_alloca(i32_ty, &format!("_{}_gen\0", local_id.index));

    // Call blood_alloc_or_abort(size, &out_generation) -> address
    let address = ctx.llvm_builder().build_call(
        alloc_fn,
        &[size_val, gen_alloca],
        &format!("_{}_addr\0", local_id.index)
    );

    // Convert the address (i64) to a pointer of the appropriate type
    let typed_ptr = ctx.llvm_builder().build_int_to_ptr(
        address,
        ptr_type(ctx.llvm_context_ref()),
        &format!("_{}_ptr\0", local_id.index)
    );

    // Store the generation alloca in local_generations map for later validation
    ctx.local_generations.insert(local_id, gen_alloca);

    Ok(typed_ptr)
}

// ============================================================================
// Snapshot Operations
// ============================================================================

/// Create a generation snapshot for effect operations.
///
/// A snapshot captures the current generations of all generational references
/// that may be accessed after the continuation resumes. This enables detecting
/// use-after-free across effect boundaries.
pub fn create_snapshot(ctx: &mut CodegenContext, span: Span) -> Result<LLVMValueRef, Vec<Diagnostic>> {
    let snapshot_create = ctx.get_runtime_fn("blood_snapshot_create")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_snapshot_create not found",
            span
        )])?;

    Ok(ctx.llvm_builder().build_call(snapshot_create, &[], "snapshot\0"))
}

/// Add an entry to a generation snapshot.
///
/// Each entry consists of an address and its expected generation.
/// On resume, all entries are validated to detect stale references.
pub fn add_snapshot_entry(
    ctx: &mut CodegenContext,
    snapshot: LLVMValueRef,
    address: LLVMValueRef,
    generation: LLVMValueRef,
    span: Span,
) -> Result<(), Vec<Diagnostic>> {
    let snapshot_add_entry = ctx.get_runtime_fn("blood_snapshot_add_entry")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_snapshot_add_entry not found",
            span
        )])?;

    ctx.llvm_builder().build_call(
        snapshot_add_entry,
        &[snapshot, address, generation],
        "\0"
    );

    Ok(())
}

/// Validate a generation snapshot after effect operation returns.
///
/// Returns 0 if all entries are valid, or a non-zero value indicating
/// the index of the first stale entry.
pub fn validate_snapshot(
    ctx: &mut CodegenContext,
    snapshot: LLVMValueRef,
    span: Span,
) -> Result<LLVMValueRef, Vec<Diagnostic>> {
    let snapshot_validate = ctx.get_runtime_fn("blood_snapshot_validate")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_snapshot_validate not found",
            span
        )])?;

    Ok(ctx.llvm_builder().build_call(snapshot_validate, &[snapshot], "validation\0"))
}

/// Destroy a generation snapshot after use.
pub fn destroy_snapshot(
    ctx: &mut CodegenContext,
    snapshot: LLVMValueRef,
    span: Span,
) -> Result<(), Vec<Diagnostic>> {
    let snapshot_destroy = ctx.get_runtime_fn("blood_snapshot_destroy")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_snapshot_destroy not found",
            span
        )])?;

    ctx.llvm_builder().build_call(snapshot_destroy, &[snapshot], "\0");

    Ok(())
}

// ============================================================================
// Deallocation
// ============================================================================

/// Unregister an allocation, invalidating its generation.
///
/// This is called when a region-allocated value goes out of scope.
/// It increments the generation counter for that address slot, causing
/// any subsequent dereference with the old generation to fail validation.
pub fn unregister_allocation(
    ctx: &mut CodegenContext,
    address: LLVMValueRef,
    span: Span,
) -> Result<(), Vec<Diagnostic>> {
    let unregister_fn = ctx.get_runtime_fn("blood_unregister_allocation")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_unregister_allocation not found",
            span
        )])?;

    ctx.llvm_builder().build_call(unregister_fn, &[address], "\0");

    Ok(())
}

/// Free region-allocated memory.
///
/// This deallocates the memory and makes the address available for reuse.
/// Generation validation should be done before freeing to catch use-after-free.
pub fn free_allocation(
    ctx: &mut CodegenContext,
    address: LLVMValueRef,
    size: LLVMValueRef,
    span: Span,
) -> Result<(), Vec<Diagnostic>> {
    let free_fn = ctx.get_runtime_fn("blood_free")
        .ok_or_else(|| vec![Diagnostic::error(
            "Runtime function blood_free not found",
            span
        )])?;

    ctx.llvm_builder().build_call(free_fn, &[address, size], "\0");

    Ok(())
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Check if a type may contain generational references.
///
/// Used to determine which locals need snapshot capture during effect operations.
pub fn type_may_contain_genref(ty: &crate.compiler.hir.Type) -> bool {
    use std.compiler.hir::TypeKind;

    match ty.kind() {
        TypeKind::Ref { .. } => true,
        TypeKind::Ptr { .. } => true,
        TypeKind::Tuple(fields) => {
            fields.iter().any(|f| type_may_contain_genref(f));
        }
        TypeKind::Array { element, .. } => {
            type_may_contain_genref(element)
        }
        TypeKind::Slice { element } => {
            type_may_contain_genref(element)
        }
        TypeKind::Adt { .. } => {
            // ADTs may contain references - conservative
            true
        }
        TypeKind::Closure { .. } => {
            // Closures may capture references
            true
        }
        _ => false,
    }
}
