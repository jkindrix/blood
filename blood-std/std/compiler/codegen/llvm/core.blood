//! LLVM Core API Bindings
//!
//! This module provides bindings to LLVM's core functionality:
//! - Context management
//! - Module creation and manipulation
//! - Memory management

use super::{
    LLVMContextRef, LLVMModuleRef, LLVMTypeRef, LLVMValueRef,
    LLVMBasicBlockRef, LLVMBuilderRef, LLVMMemoryBufferRef,
    Linkage, Visibility, CallConv,
    LLVM_TRUE, LLVM_FALSE,
};

// ============================================================================
// Raw FFI Declarations
// ============================================================================

bridge "C" llvm_core {
    // === Context Management ===

    /// Create a new LLVM context.
    fn LLVMContextCreate() -> LLVMContextRef;

    /// Get the global LLVM context.
    fn LLVMGetGlobalContext() -> LLVMContextRef;

    /// Dispose of an LLVM context.
    fn LLVMContextDispose(ctx: LLVMContextRef);

    // === Module Management ===

    /// Create a new LLVM module with the given name in the given context.
    fn LLVMModuleCreateWithNameInContext(name: *const u8, ctx: LLVMContextRef) -> LLVMModuleRef;

    /// Create a new LLVM module with the given name.
    fn LLVMModuleCreateWithName(name: *const u8) -> LLVMModuleRef;

    /// Dispose of an LLVM module.
    fn LLVMDisposeModule(module: LLVMModuleRef);

    /// Clone a module.
    fn LLVMCloneModule(module: LLVMModuleRef) -> LLVMModuleRef;

    /// Get the module identifier (name).
    fn LLVMGetModuleIdentifier(module: LLVMModuleRef, len: *mut u64) -> *const u8;

    /// Set the module identifier (name).
    fn LLVMSetModuleIdentifier(module: LLVMModuleRef, name: *const u8, len: u64);

    /// Get the source filename for the module.
    fn LLVMGetSourceFileName(module: LLVMModuleRef, len: *mut u64) -> *const u8;

    /// Set the source filename for the module.
    fn LLVMSetSourceFileName(module: LLVMModuleRef, name: *const u8, len: u64);

    /// Get the data layout string for the module.
    fn LLVMGetDataLayoutStr(module: LLVMModuleRef) -> *const u8;

    /// Set the data layout string for the module.
    fn LLVMSetDataLayout(module: LLVMModuleRef, layout: *const u8);

    /// Get the target triple for the module.
    fn LLVMGetTarget(module: LLVMModuleRef) -> *const u8;

    /// Set the target triple for the module.
    fn LLVMSetTarget(module: LLVMModuleRef, triple: *const u8);

    /// Print the module to a string.
    fn LLVMPrintModuleToString(module: LLVMModuleRef) -> *mut u8;

    /// Print the module to a file.
    fn LLVMPrintModuleToFile(module: LLVMModuleRef, filename: *const u8, err_msg: *mut *mut u8) -> i32;

    /// Get the context for a module.
    fn LLVMGetModuleContext(module: LLVMModuleRef) -> LLVMContextRef;

    // === Module Verification ===

    /// Verify a module. Returns 0 if valid.
    /// action: 0=AbortProcess, 1=PrintMessage, 2=ReturnStatus
    fn LLVMVerifyModule(module: LLVMModuleRef, action: i32, out_message: *mut *mut u8) -> i32;

    // === Function Management ===

    /// Add a function to a module.
    fn LLVMAddFunction(module: LLVMModuleRef, name: *const u8, fn_ty: LLVMTypeRef) -> LLVMValueRef;

    /// Get a function from a module by name.
    fn LLVMGetNamedFunction(module: LLVMModuleRef, name: *const u8) -> LLVMValueRef;

    /// Get the first function in a module.
    fn LLVMGetFirstFunction(module: LLVMModuleRef) -> LLVMValueRef;

    /// Get the last function in a module.
    fn LLVMGetLastFunction(module: LLVMModuleRef) -> LLVMValueRef;

    /// Get the next function in a module.
    fn LLVMGetNextFunction(func: LLVMValueRef) -> LLVMValueRef;

    /// Get the previous function in a module.
    fn LLVMGetPreviousFunction(func: LLVMValueRef) -> LLVMValueRef;

    // === Global Variable Management ===

    /// Add a global variable to a module.
    fn LLVMAddGlobal(module: LLVMModuleRef, ty: LLVMTypeRef, name: *const u8) -> LLVMValueRef;

    /// Add a global variable to a specific address space.
    fn LLVMAddGlobalInAddressSpace(module: LLVMModuleRef, ty: LLVMTypeRef, name: *const u8, addr_space: u32) -> LLVMValueRef;

    /// Get a global variable by name.
    fn LLVMGetNamedGlobal(module: LLVMModuleRef, name: *const u8) -> LLVMValueRef;

    /// Get the first global variable in a module.
    fn LLVMGetFirstGlobal(module: LLVMModuleRef) -> LLVMValueRef;

    /// Get the last global variable in a module.
    fn LLVMGetLastGlobal(module: LLVMModuleRef) -> LLVMValueRef;

    /// Get the next global variable.
    fn LLVMGetNextGlobal(global: LLVMValueRef) -> LLVMValueRef;

    /// Get the previous global variable.
    fn LLVMGetPreviousGlobal(global: LLVMValueRef) -> LLVMValueRef;

    /// Delete a global variable.
    fn LLVMDeleteGlobal(global: LLVMValueRef);

    /// Set the initializer for a global variable.
    fn LLVMSetInitializer(global: LLVMValueRef, value: LLVMValueRef);

    /// Get the initializer for a global variable.
    fn LLVMGetInitializer(global: LLVMValueRef) -> LLVMValueRef;

    /// Set whether a global is constant.
    fn LLVMSetGlobalConstant(global: LLVMValueRef, is_constant: i32);

    /// Check if a global is constant.
    fn LLVMIsGlobalConstant(global: LLVMValueRef) -> i32;

    // === Memory Management ===

    /// Dispose of a message returned by LLVM.
    fn LLVMDisposeMessage(msg: *mut u8);

    // === Intrinsics ===

    /// Get an intrinsic's ID by name.
    fn LLVMLookupIntrinsicID(name: *const u8, name_len: u64) -> u32;

    /// Get the intrinsic declaration for a module.
    fn LLVMGetIntrinsicDeclaration(module: LLVMModuleRef, id: u32, param_types: *const LLVMTypeRef, param_count: u64) -> LLVMValueRef;
}

// ============================================================================
// Safe Wrapper: LLVMContext
// ============================================================================

/// Safe wrapper around an LLVM context.
///
/// The context owns all LLVM IR objects created within it.
/// When the context is dropped, all associated objects are freed.
pub struct LLVMContext {
    /// The raw LLVM context reference.
    raw: LLVMContextRef,
    /// Whether this context should be disposed on drop.
    owned: bool,
}

impl LLVMContext {
    /// Create a new LLVM context.
    pub fn new() -> LLVMContext {
        let raw = llvm_core::LLVMContextCreate();
        LLVMContext { raw, owned: true }
    }

    /// Get the global LLVM context.
    ///
    /// Note: Using the global context is not recommended for multi-threaded
    /// compilation as it is not thread-safe.
    pub fn global() -> LLVMContext {
        let raw = llvm_core::LLVMGetGlobalContext();
        LLVMContext { raw, owned: false }
    }

    /// Get the raw context reference.
    pub fn raw(&self) -> LLVMContextRef {
        self.raw
    }

    /// Check if this is the global context.
    pub fn is_global(&self) -> bool {
        !self.owned
    }
}

impl Drop for LLVMContext {
    fn drop(&mut self) {
        if self.owned && !self.raw.is_null() {
            llvm_core::LLVMContextDispose(self.raw);
        }
    }
}

// ============================================================================
// Safe Wrapper: LLVMModule
// ============================================================================

/// Safe wrapper around an LLVM module.
///
/// A module represents a compilation unit containing functions, globals,
/// and type definitions.
pub struct LLVMModule {
    /// The raw LLVM module reference.
    raw: LLVMModuleRef,
    /// Whether this module should be disposed on drop.
    owned: bool,
}

impl LLVMModule {
    /// Create a new LLVM module with the given name.
    pub fn new(name: &str, ctx: &LLVMContext) -> LLVMModule {
        let name_ptr = name.as_ptr();
        let raw = llvm_core::LLVMModuleCreateWithNameInContext(name_ptr, ctx.raw());
        LLVMModule { raw, owned: true }
    }

    /// Create a new module in the global context.
    pub fn new_global(name: &str) -> LLVMModule {
        let name_ptr = name.as_ptr();
        let raw = llvm_core::LLVMModuleCreateWithName(name_ptr);
        LLVMModule { raw, owned: true }
    }

    /// Clone this module.
    pub fn clone(&self) -> LLVMModule {
        let raw = llvm_core::LLVMCloneModule(self.raw);
        LLVMModule { raw, owned: true }
    }

    /// Get the raw module reference.
    pub fn raw(&self) -> LLVMModuleRef {
        self.raw
    }

    /// Get the context for this module.
    pub fn context(&self) -> LLVMContext {
        let raw = llvm_core::LLVMGetModuleContext(self.raw);
        LLVMContext { raw, owned: false }
    }

    /// Set the target triple for this module.
    pub fn set_target(&self, triple: &str) {
        let triple_ptr = triple.as_ptr();
        llvm_core::LLVMSetTarget(self.raw, triple_ptr);
    }

    /// Set the data layout for this module.
    pub fn set_data_layout(&self, layout: &str) {
        let layout_ptr = layout.as_ptr();
        llvm_core::LLVMSetDataLayout(self.raw, layout_ptr);
    }

    /// Add a function to this module.
    pub fn add_function(&self, name: &str, fn_ty: LLVMTypeRef) -> LLVMValueRef {
        let name_ptr = name.as_ptr();
        llvm_core::LLVMAddFunction(self.raw, name_ptr, fn_ty)
    }

    /// Get a function by name.
    pub fn get_function(&self, name: &str) -> Option<LLVMValueRef> {
        let name_ptr = name.as_ptr();
        let func = llvm_core::LLVMGetNamedFunction(self.raw, name_ptr);
        if func.is_null() {
            None
        } else {
            Some(func)
        }
    }

    /// Add a global variable to this module.
    pub fn add_global(&self, ty: LLVMTypeRef, name: &str) -> LLVMValueRef {
        let name_ptr = name.as_ptr();
        llvm_core::LLVMAddGlobal(self.raw, ty, name_ptr)
    }

    /// Get a global variable by name.
    pub fn get_global(&self, name: &str) -> Option<LLVMValueRef> {
        let name_ptr = name.as_ptr();
        let global = llvm_core::LLVMGetNamedGlobal(self.raw, name_ptr);
        if global.is_null() {
            None
        } else {
            Some(global)
        }
    }

    /// Verify the module.
    ///
    /// Returns Ok(()) if valid, Err(message) if invalid.
    pub fn verify(&self) -> Result<(), String> {
        let mut err_msg: *mut u8 = core::ptr::null_mut();
        let result = llvm_core::LLVMVerifyModule(self.raw, 2, &mut err_msg);  // 2 = ReturnStatus

        if result == 0 {
            Ok(())
        } else {
            let msg = if !err_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(err_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(err_msg);
                result
            } else {
                "Unknown verification error".to_string()
            };
            Err(msg)
        }
    }

    /// Print the module to a string (LLVM IR text).
    pub fn print_to_string(&self) -> String {
        let ir_ptr = llvm_core::LLVMPrintModuleToString(self.raw);
        if ir_ptr.is_null() {
            "".to_string()
        } else {
            let s = @unsafe { core::ffi::CStr::from_ptr(ir_ptr as *const i8) };
            let result = s.to_string_lossy().to_string();
            llvm_core::LLVMDisposeMessage(ir_ptr);
            result
        }
    }

    /// Print the module to a file.
    pub fn print_to_file(&self, filename: &str) -> Result<(), String> {
        let filename_ptr = filename.as_ptr();
        let mut err_msg: *mut u8 = core::ptr::null_mut();
        let result = llvm_core::LLVMPrintModuleToFile(self.raw, filename_ptr, &mut err_msg);

        if result == 0 {
            Ok(())
        } else {
            let msg = if !err_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(err_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(err_msg);
                result
            } else {
                "Unknown error writing module to file".to_string()
            };
            Err(msg)
        }
    }

    /// Get an intrinsic declaration.
    pub fn get_intrinsic(&self, id: u32, param_types: &[LLVMTypeRef]) -> LLVMValueRef {
        let types_ptr = if param_types.is_empty() {
            core::ptr::null()
        } else {
            param_types.as_ptr();
        };
        llvm_core::LLVMGetIntrinsicDeclaration(
            self.raw,
            id,
            types_ptr,
            param_types.len() as u64
        )
    }
}

impl Drop for LLVMModule {
    fn drop(&mut self) {
        if self.owned && !self.raw.is_null() {
            llvm_core::LLVMDisposeModule(self.raw);
        }
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Dispose of a message returned by LLVM.
pub fn dispose_message(msg: *mut u8) {
    if !msg.is_null() {
        llvm_core::LLVMDisposeMessage(msg);
    }
}

/// Look up an intrinsic ID by name.
pub fn lookup_intrinsic(name: &str) -> u32 {
    llvm_core::LLVMLookupIntrinsicID(name.as_ptr(), name.len() as u64)
}
