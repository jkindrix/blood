//! LLVM Target Machine API Bindings
//!
//! This module provides bindings to LLVM's target and code generation:
//! - Target initialization
//! - Target machine creation
//! - Code emission (object files, assembly)
//! - Target data layout

use std.core::Drop;
use std.compiler.codegen.llvm::{
    LLVMContextRef, LLVMModuleRef, LLVMTypeRef, LLVMValueRef,
    LLVMTargetRef, LLVMTargetMachineRef, LLVMTargetDataRef,
    LLVMMemoryBufferRef, LLVMPassManagerRef,
    OptLevel, RelocMode, CodeModel, CodeGenFileType,
    LLVM_TRUE, LLVM_FALSE,
};
use std.compiler.codegen.llvm.core::llvm_core;

// ============================================================================
// Raw FFI Declarations
// ============================================================================

bridge "C" llvm_target {
    // === Target Initialization ===

    /// Initialize all targets.
    fn LLVM_InitializeAllTargetInfos();

    /// Initialize all target MCs.
    fn LLVM_InitializeAllTargetMCs();

    /// Initialize all target ASM printers.
    fn LLVM_InitializeAllAsmPrinters();

    /// Initialize all target ASM parsers.
    fn LLVM_InitializeAllAsmParsers();

    /// Initialize all target disassemblers.
    fn LLVM_InitializeAllDisassemblers();

    /// Initialize native target.
    fn LLVM_InitializeNativeTarget() -> i32;

    /// Initialize native ASM printer.
    fn LLVM_InitializeNativeAsmPrinter() -> i32;

    /// Initialize native ASM parser.
    fn LLVM_InitializeNativeAsmParser() -> i32;

    /// Initialize native disassembler.
    fn LLVM_InitializeNativeDisassembler() -> i32;

    // === Target Lookup ===

    /// Get the first available target.
    fn LLVMGetFirstTarget() -> LLVMTargetRef;

    /// Get the next target.
    fn LLVMGetNextTarget(target: LLVMTargetRef) -> LLVMTargetRef;

    /// Get the target for a triple.
    fn LLVMGetTargetFromTriple(
        triple: *const u8,
        target: *mut LLVMTargetRef,
        error_message: *mut *mut u8
    ) -> i32;

    /// Get the target for a name.
    fn LLVMGetTargetFromName(name: *const u8) -> LLVMTargetRef;

    // === Target Info ===

    /// Get the name of a target.
    fn LLVMGetTargetName(target: LLVMTargetRef) -> *const u8;

    /// Get the description of a target.
    fn LLVMGetTargetDescription(target: LLVMTargetRef) -> *const u8;

    /// Check if a target has a JIT.
    fn LLVMTargetHasJIT(target: LLVMTargetRef) -> i32;

    /// Check if a target has a target machine.
    fn LLVMTargetHasTargetMachine(target: LLVMTargetRef) -> i32;

    /// Check if a target has an ASM backend.
    fn LLVMTargetHasAsmBackend(target: LLVMTargetRef) -> i32;

    // === Triple ===

    /// Get the default target triple for the host.
    fn LLVMGetDefaultTargetTriple() -> *mut u8;

    /// Normalize a target triple.
    fn LLVMNormalizeTargetTriple(triple: *const u8) -> *mut u8;

    /// Get the host CPU name.
    fn LLVMGetHostCPUName() -> *mut u8;

    /// Get the host CPU features.
    fn LLVMGetHostCPUFeatures() -> *mut u8;

    // === Target Machine Creation ===

    /// Create a target machine.
    fn LLVMCreateTargetMachine(
        target: LLVMTargetRef,
        triple: *const u8,
        cpu: *const u8,
        features: *const u8,
        level: i32,
        reloc: i32,
        code_model: i32
    ) -> LLVMTargetMachineRef;

    /// Dispose of a target machine.
    fn LLVMDisposeTargetMachine(tm: LLVMTargetMachineRef);

    /// Get the target of a target machine.
    fn LLVMGetTargetMachineTarget(tm: LLVMTargetMachineRef) -> LLVMTargetRef;

    /// Get the triple of a target machine.
    fn LLVMGetTargetMachineTriple(tm: LLVMTargetMachineRef) -> *mut u8;

    /// Get the CPU of a target machine.
    fn LLVMGetTargetMachineCPU(tm: LLVMTargetMachineRef) -> *mut u8;

    /// Get the feature string of a target machine.
    fn LLVMGetTargetMachineFeatureString(tm: LLVMTargetMachineRef) -> *mut u8;

    /// Create a target data layout from a target machine.
    fn LLVMCreateTargetDataLayout(tm: LLVMTargetMachineRef) -> LLVMTargetDataRef;

    /// Set the ASM verbosity of a target machine.
    fn LLVMSetTargetMachineAsmVerbosity(tm: LLVMTargetMachineRef, verbose: i32);

    // === Code Emission ===

    /// Emit to a file.
    fn LLVMTargetMachineEmitToFile(
        tm: LLVMTargetMachineRef,
        module: LLVMModuleRef,
        filename: *const u8,
        codegen: i32,
        error_message: *mut *mut u8
    ) -> i32;

    /// Emit to a memory buffer.
    fn LLVMTargetMachineEmitToMemoryBuffer(
        tm: LLVMTargetMachineRef,
        module: LLVMModuleRef,
        codegen: i32,
        error_message: *mut *mut u8,
        out_mem_buf: *mut LLVMMemoryBufferRef
    ) -> i32;

    // === Target Data Layout ===

    /// Create a target data from a string representation.
    fn LLVMCreateTargetData(string_rep: *const u8) -> LLVMTargetDataRef;

    /// Dispose of a target data.
    fn LLVMDisposeTargetData(td: LLVMTargetDataRef);

    /// Get the string representation of a target data.
    fn LLVMCopyStringRepOfTargetData(td: LLVMTargetDataRef) -> *mut u8;

    /// Get the byte order of a target data.
    fn LLVMByteOrder(td: LLVMTargetDataRef) -> i32;

    /// Get the pointer size of a target data.
    fn LLVMPointerSize(td: LLVMTargetDataRef) -> u32;

    /// Get the pointer size for an address space.
    fn LLVMPointerSizeForAS(td: LLVMTargetDataRef, addr_space: u32) -> u32;

    /// Get the integer type that is the same size as a pointer.
    fn LLVMIntPtrType(td: LLVMTargetDataRef) -> LLVMTypeRef;

    /// Get the integer type for a pointer in an address space.
    fn LLVMIntPtrTypeForAS(td: LLVMTargetDataRef, addr_space: u32) -> LLVMTypeRef;

    /// Get the integer type that is the same size as a pointer in a context.
    fn LLVMIntPtrTypeInContext(ctx: LLVMContextRef, td: LLVMTargetDataRef) -> LLVMTypeRef;

    /// Get the integer type for a pointer in an address space in a context.
    fn LLVMIntPtrTypeForASInContext(ctx: LLVMContextRef, td: LLVMTargetDataRef, addr_space: u32) -> LLVMTypeRef;

    /// Get the size of a type in bits.
    fn LLVMSizeOfTypeInBits(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u64;

    /// Get the store size of a type in bytes.
    fn LLVMStoreSizeOfType(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u64;

    /// Get the ABI size of a type in bytes.
    fn LLVMABISizeOfType(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u64;

    /// Get the ABI alignment of a type.
    fn LLVMABIAlignmentOfType(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u32;

    /// Get the call frame alignment of a type.
    fn LLVMCallFrameAlignmentOfType(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u32;

    /// Get the preferred alignment of a type.
    fn LLVMPreferredAlignmentOfType(td: LLVMTargetDataRef, ty: LLVMTypeRef) -> u32;

    /// Get the preferred alignment of a global.
    fn LLVMPreferredAlignmentOfGlobal(td: LLVMTargetDataRef, global: LLVMValueRef) -> u32;

    /// Get the element at a given offset in a struct.
    fn LLVMElementAtOffset(td: LLVMTargetDataRef, struct_ty: LLVMTypeRef, offset: u64) -> u32;

    /// Get the offset of an element in a struct.
    fn LLVMOffsetOfElement(td: LLVMTargetDataRef, struct_ty: LLVMTypeRef, element: u32) -> u64;

    // === Memory Buffer ===

    /// Get the start of a memory buffer.
    fn LLVMGetBufferStart(mem_buf: LLVMMemoryBufferRef) -> *const u8;

    /// Get the size of a memory buffer.
    fn LLVMGetBufferSize(mem_buf: LLVMMemoryBufferRef) -> u64;

    /// Dispose of a memory buffer.
    fn LLVMDisposeMemoryBuffer(mem_buf: LLVMMemoryBufferRef);

    /// Create a memory buffer from a file.
    fn LLVMCreateMemoryBufferWithContentsOfFile(
        path: *const u8,
        out_mem_buf: *mut LLVMMemoryBufferRef,
        out_message: *mut *mut u8
    ) -> i32;

    /// Create a memory buffer from stdin.
    fn LLVMCreateMemoryBufferWithSTDIN(
        out_mem_buf: *mut LLVMMemoryBufferRef,
        out_message: *mut *mut u8
    ) -> i32;

    /// Create a memory buffer from a memory range.
    fn LLVMCreateMemoryBufferWithMemoryRange(
        input_data: *const u8,
        input_data_length: u64,
        buffer_name: *const u8,
        requires_null_terminator: i32
    ) -> LLVMMemoryBufferRef;

    /// Create a memory buffer from a memory range (copy).
    fn LLVMCreateMemoryBufferWithMemoryRangeCopy(
        input_data: *const u8,
        input_data_length: u64,
        buffer_name: *const u8
    ) -> LLVMMemoryBufferRef;

    // === Pass Manager ===

    /// Create a pass manager.
    fn LLVMCreatePassManager() -> LLVMPassManagerRef;

    /// Create a function pass manager.
    fn LLVMCreateFunctionPassManagerForModule(module: LLVMModuleRef) -> LLVMPassManagerRef;

    /// Dispose of a pass manager.
    fn LLVMDisposePassManager(pm: LLVMPassManagerRef);

    /// Run the pass manager on a module.
    fn LLVMRunPassManager(pm: LLVMPassManagerRef, module: LLVMModuleRef) -> i32;

    /// Initialize the function pass manager.
    fn LLVMInitializeFunctionPassManager(pm: LLVMPassManagerRef) -> i32;

    /// Run the function pass manager on a function.
    fn LLVMRunFunctionPassManager(pm: LLVMPassManagerRef, func: LLVMValueRef) -> i32;

    /// Finalize the function pass manager.
    fn LLVMFinalizeFunctionPassManager(pm: LLVMPassManagerRef) -> i32;
}

// ============================================================================
// Target Initialization
// ============================================================================

/// Initialize all available targets.
pub fn initialize_all_targets() {
    llvm_target::LLVM_InitializeAllTargetInfos();
    llvm_target::LLVM_InitializeAllTargetMCs();
    llvm_target::LLVM_InitializeAllAsmPrinters();
    llvm_target::LLVM_InitializeAllAsmParsers();
}

/// Initialize the native target.
pub fn initialize_native_target() -> Result<(), String> {
    let info = llvm_target::LLVM_InitializeNativeTarget();
    let asm_printer = llvm_target::LLVM_InitializeNativeAsmPrinter();
    let asm_parser = llvm_target::LLVM_InitializeNativeAsmParser();

    if info != 0 || asm_printer != 0 || asm_parser != 0 {
        Err("Failed to initialize native target".to_string())
    } else {
        Ok(())
    }
}

/// Get the default target triple for the host.
pub fn get_default_target_triple() -> String {
    let ptr = llvm_target::LLVMGetDefaultTargetTriple();
    if ptr.is_null() {
        "".to_string()
    } else {
        let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
        let result = s.to_string_lossy().to_string();
        llvm_core::LLVMDisposeMessage(ptr);
        result
    }
}

/// Get the host CPU name.
pub fn get_host_cpu_name() -> String {
    let ptr = llvm_target::LLVMGetHostCPUName();
    if ptr.is_null() {
        "".to_string()
    } else {
        let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
        let result = s.to_string_lossy().to_string();
        llvm_core::LLVMDisposeMessage(ptr);
        result
    }
}

/// Get the host CPU features.
pub fn get_host_cpu_features() -> String {
    let ptr = llvm_target::LLVMGetHostCPUFeatures();
    if ptr.is_null() {
        "".to_string()
    } else {
        let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
        let result = s.to_string_lossy().to_string();
        llvm_core::LLVMDisposeMessage(ptr);
        result
    }
}

// ============================================================================
// Safe Wrapper: LLVMTarget
// ============================================================================

/// Safe wrapper around an LLVM target.
///
/// A target represents a specific architecture that LLVM can generate code for.
pub struct LLVMTarget {
    /// The raw LLVM target reference.
    raw: LLVMTargetRef,
}

impl LLVMTarget {
    /// Create a wrapper from a raw target reference.
    pub fn from_raw(raw: LLVMTargetRef) -> LLVMTarget {
        LLVMTarget { raw }
    }

    /// Get the raw target reference.
    pub fn raw(&self) -> LLVMTargetRef {
        self.raw
    }

    /// Check if this is a null reference.
    pub fn is_null(&self) -> bool {
        self.raw.is_null();
    }

    /// Get a target from a triple.
    pub fn from_triple(triple: &str) -> Result<LLVMTarget, String> {
        let mut target: LLVMTargetRef = core::ptr::null_mut();
        let mut error_msg: *mut u8 = core::ptr::null_mut();

        let result = llvm_target::LLVMGetTargetFromTriple(
            triple.as_ptr(),
            &mut target,
            &mut error_msg
        );

        if result != 0 {
            let msg = if !error_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(error_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(error_msg);
                result
            } else {
                format!("Unknown error looking up target for triple '{}'", triple)
            };
            Err(msg)
        } else {
            Ok(LLVMTarget { raw: target })
        }
    }

    /// Get the first available target.
    pub fn first() -> Option<LLVMTarget> {
        let target = llvm_target::LLVMGetFirstTarget();
        if target.is_null() {
            None
        } else {
            Some(LLVMTarget { raw: target })
        }
    }

    /// Get the next target.
    pub fn next(&self) -> Option<LLVMTarget> {
        let target = llvm_target::LLVMGetNextTarget(self.raw);
        if target.is_null() {
            None
        } else {
            Some(LLVMTarget { raw: target })
        }
    }

    /// Get the name of this target.
    pub fn name(&self) -> String {
        let ptr = llvm_target::LLVMGetTargetName(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) }
                .to_string_lossy()
                .to_string();
        }
    }

    /// Get the description of this target.
    pub fn description(&self) -> String {
        let ptr = llvm_target::LLVMGetTargetDescription(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) }
                .to_string_lossy()
                .to_string();
        }
    }

    /// Check if this target has a JIT.
    pub fn has_jit(&self) -> bool {
        llvm_target::LLVMTargetHasJIT(self.raw) != 0
    }

    /// Check if this target has a target machine.
    pub fn has_target_machine(&self) -> bool {
        llvm_target::LLVMTargetHasTargetMachine(self.raw) != 0
    }

    /// Check if this target has an ASM backend.
    pub fn has_asm_backend(&self) -> bool {
        llvm_target::LLVMTargetHasAsmBackend(self.raw) != 0
    }
}

// ============================================================================
// Safe Wrapper: LLVMTargetMachine
// ============================================================================

/// Safe wrapper around an LLVM target machine.
///
/// A target machine is a fully configured target for code generation,
/// including the CPU, features, and code generation options.
pub struct LLVMTargetMachine {
    /// The raw LLVM target machine reference.
    raw: LLVMTargetMachineRef,
}

impl LLVMTargetMachine {
    /// Create a target machine.
    pub fn new(
        target: &LLVMTarget,
        triple: &str,
        cpu: &str,
        features: &str,
        opt_level: OptLevel,
        reloc_mode: RelocMode,
        code_model: CodeModel
    ) -> LLVMTargetMachine {
        let raw = llvm_target::LLVMCreateTargetMachine(
            target.raw,
            triple.as_ptr(),
            cpu.as_ptr(),
            features.as_ptr(),
            opt_level as i32,
            reloc_mode as i32,
            code_model as i32
        );
        LLVMTargetMachine { raw }
    }

    /// Create a target machine for the native host.
    pub fn native(opt_level: OptLevel) -> Result<LLVMTargetMachine, String> {
        initialize_native_target()?;

        let triple = get_default_target_triple();
        let cpu = get_host_cpu_name();
        let features = get_host_cpu_features();

        let target = LLVMTarget::from_triple(&triple)?;

        Ok(LLVMTargetMachine::new(
            &target,
            &triple,
            &cpu,
            &features,
            opt_level,
            RelocMode::Default,
            CodeModel::Default
        ))
    }

    /// Get the raw target machine reference.
    pub fn raw(&self) -> LLVMTargetMachineRef {
        self.raw
    }

    /// Check if this is a null reference.
    pub fn is_null(&self) -> bool {
        self.raw.is_null();
    }

    /// Get the target of this target machine.
    pub fn target(&self) -> LLVMTarget {
        LLVMTarget::from_raw(llvm_target::LLVMGetTargetMachineTarget(self.raw))
    }

    /// Get the triple of this target machine.
    pub fn triple(&self) -> String {
        let ptr = llvm_target::LLVMGetTargetMachineTriple(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
            let result = s.to_string_lossy().to_string();
            llvm_core::LLVMDisposeMessage(ptr);
            result
        }
    }

    /// Get the CPU of this target machine.
    pub fn cpu(&self) -> String {
        let ptr = llvm_target::LLVMGetTargetMachineCPU(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
            let result = s.to_string_lossy().to_string();
            llvm_core::LLVMDisposeMessage(ptr);
            result
        }
    }

    /// Get the feature string of this target machine.
    pub fn features(&self) -> String {
        let ptr = llvm_target::LLVMGetTargetMachineFeatureString(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
            let result = s.to_string_lossy().to_string();
            llvm_core::LLVMDisposeMessage(ptr);
            result
        }
    }

    /// Create a target data layout from this target machine.
    pub fn create_data_layout(&self) -> LLVMTargetData {
        LLVMTargetData::from_raw(llvm_target::LLVMCreateTargetDataLayout(self.raw))
    }

    /// Set the ASM verbosity.
    pub fn set_asm_verbosity(&self, verbose: bool) {
        let flag = if verbose { LLVM_TRUE } else { LLVM_FALSE };
        llvm_target::LLVMSetTargetMachineAsmVerbosity(self.raw, flag);
    }

    /// Emit to a file.
    pub fn emit_to_file(
        &self,
        module: LLVMModuleRef,
        filename: &str,
        file_type: CodeGenFileType
    ) -> Result<(), String> {
        let mut error_msg: *mut u8 = core::ptr::null_mut();

        let result = llvm_target::LLVMTargetMachineEmitToFile(
            self.raw,
            module,
            filename.as_ptr(),
            file_type as i32,
            &mut error_msg
        );

        if result != 0 {
            let msg = if !error_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(error_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(error_msg);
                result
            } else {
                "Unknown error emitting to file".to_string()
            };
            Err(msg)
        } else {
            Ok(())
        }
    }

    /// Emit to a memory buffer.
    pub fn emit_to_memory_buffer(
        &self,
        module: LLVMModuleRef,
        file_type: CodeGenFileType
    ) -> Result<LLVMMemoryBuffer, String> {
        let mut error_msg: *mut u8 = core::ptr::null_mut();
        let mut mem_buf: LLVMMemoryBufferRef = core::ptr::null_mut();

        let result = llvm_target::LLVMTargetMachineEmitToMemoryBuffer(
            self.raw,
            module,
            file_type as i32,
            &mut error_msg,
            &mut mem_buf
        );

        if result != 0 {
            let msg = if !error_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(error_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(error_msg);
                result
            } else {
                "Unknown error emitting to memory buffer".to_string()
            };
            Err(msg)
        } else {
            Ok(LLVMMemoryBuffer { raw: mem_buf })
        }
    }
}

impl Drop for LLVMTargetMachine {
    fn drop(&mut self) {
        if !self.raw.is_null() {
            llvm_target::LLVMDisposeTargetMachine(self.raw);
        }
    }
}

// ============================================================================
// Safe Wrapper: LLVMTargetData
// ============================================================================

/// Safe wrapper around an LLVM target data layout.
///
/// The target data layout describes the size and alignment of types
/// on a specific target.
pub struct LLVMTargetData {
    /// The raw LLVM target data reference.
    raw: LLVMTargetDataRef,
}

impl LLVMTargetData {
    /// Create a wrapper from a raw target data reference.
    pub fn from_raw(raw: LLVMTargetDataRef) -> LLVMTargetData {
        LLVMTargetData { raw }
    }

    /// Create a target data from a string representation.
    pub fn from_string(layout: &str) -> LLVMTargetData {
        let raw = llvm_target::LLVMCreateTargetData(layout.as_ptr());
        LLVMTargetData { raw }
    }

    /// Get the raw target data reference.
    pub fn raw(&self) -> LLVMTargetDataRef {
        self.raw
    }

    /// Check if this is a null reference.
    pub fn is_null(&self) -> bool {
        self.raw.is_null();
    }

    /// Get the string representation of this target data.
    pub fn to_string(&self) -> String {
        let ptr = llvm_target::LLVMCopyStringRepOfTargetData(self.raw);
        if ptr.is_null() {
            "".to_string()
        } else {
            let s = @unsafe { core::ffi::CStr::from_ptr(ptr as *const i8) };
            let result = s.to_string_lossy().to_string();
            llvm_core::LLVMDisposeMessage(ptr);
            result
        }
    }

    /// Get the byte order (0 = big endian, 1 = little endian).
    pub fn byte_order(&self) -> i32 {
        llvm_target::LLVMByteOrder(self.raw)
    }

    /// Check if the target is little endian.
    pub fn is_little_endian(&self) -> bool {
        self.byte_order() == 1
    }

    /// Get the pointer size in bytes.
    pub fn pointer_size(&self) -> u32 {
        llvm_target::LLVMPointerSize(self.raw)
    }

    /// Get the pointer size in bytes for an address space.
    pub fn pointer_size_for_as(&self, addr_space: u32) -> u32 {
        llvm_target::LLVMPointerSizeForAS(self.raw, addr_space)
    }

    /// Get the size of a type in bits.
    pub fn size_of_type_in_bits(&self, ty: LLVMTypeRef) -> u64 {
        llvm_target::LLVMSizeOfTypeInBits(self.raw, ty)
    }

    /// Get the store size of a type in bytes.
    pub fn store_size_of_type(&self, ty: LLVMTypeRef) -> u64 {
        llvm_target::LLVMStoreSizeOfType(self.raw, ty)
    }

    /// Get the ABI size of a type in bytes.
    pub fn abi_size_of_type(&self, ty: LLVMTypeRef) -> u64 {
        llvm_target::LLVMABISizeOfType(self.raw, ty)
    }

    /// Get the ABI alignment of a type in bytes.
    pub fn abi_alignment_of_type(&self, ty: LLVMTypeRef) -> u32 {
        llvm_target::LLVMABIAlignmentOfType(self.raw, ty)
    }

    /// Get the preferred alignment of a type in bytes.
    pub fn preferred_alignment_of_type(&self, ty: LLVMTypeRef) -> u32 {
        llvm_target::LLVMPreferredAlignmentOfType(self.raw, ty)
    }

    /// Get the offset of a struct element.
    pub fn offset_of_element(&self, struct_ty: LLVMTypeRef, element: u32) -> u64 {
        llvm_target::LLVMOffsetOfElement(self.raw, struct_ty, element)
    }

    /// Get the element at a given offset in a struct.
    pub fn element_at_offset(&self, struct_ty: LLVMTypeRef, offset: u64) -> u32 {
        llvm_target::LLVMElementAtOffset(self.raw, struct_ty, offset)
    }
}

impl Drop for LLVMTargetData {
    fn drop(&mut self) {
        if !self.raw.is_null() {
            llvm_target::LLVMDisposeTargetData(self.raw);
        }
    }
}

// ============================================================================
// Safe Wrapper: LLVMMemoryBuffer
// ============================================================================

/// Safe wrapper around an LLVM memory buffer.
///
/// A memory buffer holds compiled code or other data in memory.
pub struct LLVMMemoryBuffer {
    /// The raw LLVM memory buffer reference.
    raw: LLVMMemoryBufferRef,
}

impl LLVMMemoryBuffer {
    /// Create a wrapper from a raw memory buffer reference.
    pub fn from_raw(raw: LLVMMemoryBufferRef) -> LLVMMemoryBuffer {
        LLVMMemoryBuffer { raw }
    }

    /// Get the raw memory buffer reference.
    pub fn raw(&self) -> LLVMMemoryBufferRef {
        self.raw
    }

    /// Check if this is a null reference.
    pub fn is_null(&self) -> bool {
        self.raw.is_null();
    }

    /// Get the start of the buffer.
    pub fn start(&self) -> *const u8 {
        llvm_target::LLVMGetBufferStart(self.raw)
    }

    /// Get the size of the buffer.
    pub fn size(&self) -> u64 {
        llvm_target::LLVMGetBufferSize(self.raw)
    }

    /// Get the buffer contents as a slice.
    pub fn as_slice(&self) -> &[u8] {
        let start = self.start();
        let size = self.size() as usize;
        if start.is_null() || size == 0 {
            &[]
        } else {
            @unsafe { core::slice::from_raw_parts(start, size) };
        }
    }

    /// Create a memory buffer from a file.
    pub fn from_file(path: &str) -> Result<LLVMMemoryBuffer, String> {
        let mut mem_buf: LLVMMemoryBufferRef = core::ptr::null_mut();
        let mut error_msg: *mut u8 = core::ptr::null_mut();

        let result = llvm_target::LLVMCreateMemoryBufferWithContentsOfFile(
            path.as_ptr(),
            &mut mem_buf,
            &mut error_msg
        );

        if result != 0 {
            let msg = if !error_msg.is_null() {
                let s = @unsafe { core::ffi::CStr::from_ptr(error_msg as *const i8) };
                let result = s.to_string_lossy().to_string();
                llvm_core::LLVMDisposeMessage(error_msg);
                result
            } else {
                format!("Unknown error reading file '{}'", path)
            };
            Err(msg)
        } else {
            Ok(LLVMMemoryBuffer { raw: mem_buf })
        }
    }

    /// Create a memory buffer from a byte slice (copies the data).
    pub fn from_bytes(data: &[u8], name: &str) -> LLVMMemoryBuffer {
        let raw = llvm_target::LLVMCreateMemoryBufferWithMemoryRangeCopy(
            data.as_ptr(),
            data.len() as u64,
            name.as_ptr(),
        );
        LLVMMemoryBuffer { raw }
    }
}

impl Drop for LLVMMemoryBuffer {
    fn drop(&mut self) {
        if !self.raw.is_null() {
            llvm_target::LLVMDisposeMemoryBuffer(self.raw);
        }
    }
}

// ============================================================================
// Safe Wrapper: LLVMPassManager
// ============================================================================

/// Safe wrapper around an LLVM pass manager.
pub struct LLVMPassManager {
    /// The raw LLVM pass manager reference.
    raw: LLVMPassManagerRef,
}

impl LLVMPassManager {
    /// Create a new module pass manager.
    pub fn new() -> LLVMPassManager {
        let raw = llvm_target::LLVMCreatePassManager();
        LLVMPassManager { raw }
    }

    /// Create a function pass manager for a module.
    pub fn for_module(module: LLVMModuleRef) -> LLVMPassManager {
        let raw = llvm_target::LLVMCreateFunctionPassManagerForModule(module);
        LLVMPassManager { raw }
    }

    /// Get the raw pass manager reference.
    pub fn raw(&self) -> LLVMPassManagerRef {
        self.raw
    }

    /// Run the pass manager on a module.
    pub fn run(&self, module: LLVMModuleRef) -> bool {
        llvm_target::LLVMRunPassManager(self.raw, module) != 0
    }

    /// Initialize the function pass manager.
    pub fn initialize(&self) -> bool {
        llvm_target::LLVMInitializeFunctionPassManager(self.raw) != 0
    }

    /// Run the function pass manager on a function.
    pub fn run_on_function(&self, func: LLVMValueRef) -> bool {
        llvm_target::LLVMRunFunctionPassManager(self.raw, func) != 0
    }

    /// Finalize the function pass manager.
    pub fn finalize(&self) -> bool {
        llvm_target::LLVMFinalizeFunctionPassManager(self.raw) != 0
    }
}

impl Drop for LLVMPassManager {
    fn drop(&mut self) {
        if !self.raw.is_null() {
            llvm_target::LLVMDisposePassManager(self.raw);
        }
    }
}
