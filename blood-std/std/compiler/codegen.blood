// Blood Self-Hosted Compiler - Code Generator
//
// This module provides the main entry point for generating LLVM IR from MIR.
// It coordinates the generation of function bodies, declarations, and
// produces complete LLVM modules as text.

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_lower_ctx;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod codegen_ctx;
mod codegen_expr;
mod codegen_stmt;
mod codegen_term;

// ============================================================
// Module Generation
// ============================================================

/// Result of code generation for a complete module.
pub struct CodegenResult {
    /// The generated LLVM IR as a string.
    pub llvm_ir: String,
    /// Any warnings generated during codegen.
    pub warnings: Vec<String>,
    /// Whether codegen was successful.
    pub success: bool,
}

impl CodegenResult {
    /// Creates a successful result.
    pub fn ok(llvm_ir: String) -> CodegenResult {
        CodegenResult {
            llvm_ir: llvm_ir,
            warnings: Vec::new(),
            success: true,
        }
    }

    /// Creates a failed result.
    pub fn error(msg: String) -> CodegenResult {
        let mut warnings = Vec::new();
        warnings.push(msg);
        CodegenResult {
            llvm_ir: String::new(),
            warnings: warnings,
            success: false,
        }
    }
}

/// Generates LLVM IR for a module with multiple functions.
pub fn generate_module(
    module_name: &str,
    functions: &Vec<(String, mir_body::MirBody)>,
) -> CodegenResult {
    // Empty items list for backward compatibility
    let empty_items: Vec<hir_lower_ctx::ItemEntry> = Vec::new();
    generate_module_with_items(module_name, functions, &empty_items)
}

/// Generates LLVM IR for a module with multiple functions and ADT item info.
pub fn generate_module_with_items(
    module_name: &str,
    functions: &Vec<(String, mir_body::MirBody)>,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) -> CodegenResult {
    let mut output = String::new();

    // Build the DefId to name mapping for all functions
    let mut def_names: Vec<codegen_ctx::DefNameEntry> = Vec::new();
    let mut idx: usize = 0;
    while idx < functions.len() {
        let (ref name, ref body) = functions[idx];
        def_names.push(codegen_ctx::DefNameEntry::new(
            body.def_id.index,
            clone_string(name),
        ));
        idx = idx + 1;
    }

    // Create the shared codegen context with def names
    let mut ctx = codegen_ctx::CodegenCtx::new();
    let mut di: usize = 0;
    while di < def_names.len() {
        ctx.register_def_name(def_names[di].def_id, clone_string(&def_names[di].name));
        di = di + 1;
    }

    // Populate ADT registry from HIR items
    populate_adt_registry(&mut ctx, items);

    // Module header
    output.push_str("; ModuleID = '");
    output.push_str(module_name);
    output.push_str("'\n");
    output.push_str("source_filename = \"");
    output.push_str(module_name);
    output.push_str(".blood\"\n");
    output.push_str("target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\n");
    output.push_str("target triple = \"x86_64-unknown-linux-gnu\"\n");
    output.push_str("\n");

    // Generate each function using the shared context
    let mut i: usize = 0;
    while i < functions.len() {
        let (ref name, ref body) = functions[i];
        let fn_ir = generate_function_with_ctx(&mut ctx, body, name.as_str());
        output.push_str(fn_ir.as_str());
        i = i + 1;
    }

    // Append string constants from the context
    ctx.emit_string_constants();
    output.push_str(ctx.output.as_str());

    // Intrinsic and runtime declarations (consolidated in intrinsic_declarations())
    let decls = intrinsic_declarations();
    output.push_str(decls.as_str());

    CodegenResult::ok(output)
}

/// Generates LLVM IR for a function with access to def names table.
/// Legacy function for backward compatibility.
pub fn generate_function_with_defs(
    body: &mir_body::MirBody,
    fn_name: &str,
    def_names: &Vec<codegen_ctx::DefNameEntry>,
) -> String {
    let mut ctx = codegen_ctx::CodegenCtx::new();

    // Register all def names in the context
    let mut i: usize = 0;
    while i < def_names.len() {
        ctx.register_def_name(def_names[i].def_id, clone_string(&def_names[i].name));
        i = i + 1;
    }

    generate_function_with_ctx(&mut ctx, body, fn_name)
}

/// Generates LLVM IR for a single function using a shared codegen context.
pub fn generate_function_with_ctx(
    ctx: &mut codegen_ctx::CodegenCtx,
    body: &mir_body::MirBody,
    fn_name: &str,
) -> String {
    // Reset per-function state but keep global state (def_names, adt_registry, string_table)
    ctx.clear_locals();
    ctx.output = String::new();
    ctx.begin_function(common::make_string(fn_name));

    // Build parameter list (skip first local which is return place)
    let mut params: Vec<(String, String)> = Vec::new();
    let mut p: usize = 1; // Start at 1 to skip return place
    let param_end: usize = 1usize + (body.param_count as usize);
    while p < param_end && p < body.locals.len() {
        let local = &body.locals[p];
        let ty = codegen_stmt::type_to_llvm_with_ctx(ctx, &local.ty);
        let mut arg_name = common::make_string("%arg");
        let idx_str = codegen_types::format_u64((p - 1) as u64);
        arg_name.push_str(idx_str.as_str());
        params.push((ty, arg_name));
        p = p + 1;
    }

    // Get return type (local _0)
    // Normalize {} (empty struct / unit) to void for LLVM function signatures
    let ret_ty_raw = if body.locals.len() > 0 {
        codegen_stmt::type_to_llvm_with_ctx(ctx, &body.locals[0].ty)
    } else {
        common::make_string("void")
    };
    let ret_ty = if is_empty_struct_type(ret_ty_raw.as_str()) {
        common::make_string("void")
    } else {
        ret_ty_raw
    };

    // Emit function header
    ctx.emit_fn_header(fn_name, &params, ret_ty.as_str());

    // Emit entry label
    ctx.write("entry:\n");

    // Emit allocas for all locals
    codegen_stmt::emit_allocas(ctx, body);

    // Store arguments into allocas
    codegen_stmt::emit_arg_stores(ctx, body);

    // Jump to first basic block if there are any
    if body.basic_blocks.len() > 0 {
        let first_label = ctx.block_label(mir_def::BasicBlockId::new(0));
        ctx.indent();
        ctx.emit_br(first_label.as_str());
        ctx.dedent();
    } else {
        ctx.indent();
        ctx.emit_unreachable();
        ctx.dedent();
    }

    // Emit all basic blocks
    let mut block_idx: usize = 0;
    while block_idx < body.basic_blocks.len() {
        let block_id = mir_def::BasicBlockId::new(block_idx as u32);
        codegen_term::emit_basic_block(ctx, block_id, &body.basic_blocks[block_idx]);
        block_idx = block_idx + 1;
    }

    ctx.emit_fn_footer();
    ctx.end_function();

    // Extract and return the function IR
    let result = clone_string(&ctx.output);
    ctx.output = String::new();
    result
}

// ============================================================
// ADT Registry Population
// ============================================================

/// Populates the ADT registry from HIR items.
/// Uses a two-pass approach: first register all ADTs with placeholder field types,
/// then rebuild layouts using the now-populated registry for correct nested ADT types.
pub fn populate_adt_registry(
    ctx: &mut codegen_ctx::CodegenCtx,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    // Pass 1: Register all ADTs with basic (possibly ptr) field types.
    // This ensures all ADT def_ids are known before resolving nested types.
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Struct(ref struct_def) => {
                let layout = build_struct_layout_basic(entry.def_id.index, struct_def);
                ctx.register_struct(layout);
            }
            &hir_item::ItemKind::Enum(ref enum_def) => {
                let layout = build_enum_layout(entry.def_id.index, enum_def);
                ctx.register_enum(layout);
            }
            &hir_item::ItemKind::Fn(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(_) => {}
            &hir_item::ItemKind::Static(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(_) => {}
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Impl(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }

    // Pass 2+: Rebuild struct layouts using context-aware type resolution.
    // Each pass resolves one more level of nesting. Since lookup_struct and
    // adt_llvm_type scan from the end, new entries override old ones.
    // Repeat until all types stabilize (typically 2-3 iterations).
    let mut pass: u32 = 0;
    while pass < 4 {
        let mut j: usize = 0;
        while j < items.len() {
            let entry = &items[j];
            match &entry.item.kind {
                &hir_item::ItemKind::Struct(ref struct_def) => {
                    let layout = build_struct_layout_with_ctx(ctx, entry.def_id.index, struct_def);
                    ctx.register_struct(layout);
                }
                _ => {}
            }
            j = j + 1;
        }
        pass = pass + 1;
    }
}

/// Builds a StructLayout using basic type resolution (no ADT registry lookups).
/// Used in pass 1 to get all ADTs registered before resolving nested types.
fn build_struct_layout_basic(def_id: u32, struct_def: &hir_item::StructDef) -> codegen_ctx::StructLayout {
    let mut fields: Vec<codegen_ctx::AdtFieldInfo> = Vec::new();
    let mut llvm_type = common::make_string("{ ");

    match &struct_def.body {
        &hir_item::StructBody::Record(ref struct_fields) => {
            let mut fi: usize = 0;
            while fi < struct_fields.len() {
                if fi > 0 {
                    llvm_type.push_str(", ");
                }
                let field_ty = codegen_types::type_to_llvm(&struct_fields[fi].ty);
                llvm_type.push_str(field_ty.as_str());
                fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                fi = fi + 1;
            }
        }
        &hir_item::StructBody::Tuple(ref tuple_fields) => {
            let mut fi: usize = 0;
            while fi < tuple_fields.len() {
                if fi > 0 {
                    llvm_type.push_str(", ");
                }
                let field_ty = codegen_types::type_to_llvm(&tuple_fields[fi]);
                llvm_type.push_str(field_ty.as_str());
                fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                fi = fi + 1;
            }
        }
        &hir_item::StructBody::Unit => {
            // Unit struct: empty
        }
    }

    llvm_type.push_str(" }");

    // Handle edge case: empty struct
    if fields.len() == 0 {
        llvm_type = common::make_string("{}");
    }

    codegen_ctx::StructLayout {
        def_id: def_id,
        fields: fields,
        llvm_type: llvm_type,
    }
}

/// Builds a StructLayout using context-aware type resolution.
/// ADT fields resolve to their actual struct/enum types from the registry.
fn build_struct_layout_with_ctx(
    ctx: &mut codegen_ctx::CodegenCtx,
    def_id: u32,
    struct_def: &hir_item::StructDef,
) -> codegen_ctx::StructLayout {
    let mut fields: Vec<codegen_ctx::AdtFieldInfo> = Vec::new();
    let mut llvm_type = common::make_string("{ ");

    match &struct_def.body {
        &hir_item::StructBody::Record(ref struct_fields) => {
            let mut fi: usize = 0;
            while fi < struct_fields.len() {
                if fi > 0 {
                    llvm_type.push_str(", ");
                }
                let field_ty = codegen_stmt::type_to_llvm_with_ctx(ctx, &struct_fields[fi].ty);
                llvm_type.push_str(field_ty.as_str());
                fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                fi = fi + 1;
            }
        }
        &hir_item::StructBody::Tuple(ref tuple_fields) => {
            let mut fi: usize = 0;
            while fi < tuple_fields.len() {
                if fi > 0 {
                    llvm_type.push_str(", ");
                }
                let field_ty = codegen_stmt::type_to_llvm_with_ctx(ctx, &tuple_fields[fi]);
                llvm_type.push_str(field_ty.as_str());
                fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                fi = fi + 1;
            }
        }
        &hir_item::StructBody::Unit => {
            // Unit struct: empty
        }
    }

    llvm_type.push_str(" }");

    if fields.len() == 0 {
        llvm_type = common::make_string("{}");
    }

    codegen_ctx::StructLayout {
        def_id: def_id,
        fields: fields,
        llvm_type: llvm_type,
    }
}

/// Builds an EnumLayout from an enum definition.
fn build_enum_layout(def_id: u32, enum_def: &hir_item::EnumDef) -> codegen_ctx::EnumLayout {
    let mut variants: Vec<codegen_ctx::VariantLayout> = Vec::new();
    let mut max_payload_size: u64 = 0;

    let mut vi: usize = 0;
    while vi < enum_def.variants.len() {
        let variant = &enum_def.variants[vi];
        let mut fields: Vec<codegen_ctx::AdtFieldInfo> = Vec::new();
        let mut payload_size: u64 = 0;
        let mut payload_type = common::make_string("{}");

        match &variant.kind {
            &hir_item::VariantKind::Unit => {
                // No payload
            }
            &hir_item::VariantKind::Tuple(ref tuple_fields) => {
                let mut pt = common::make_string("{ ");
                let mut fi: usize = 0;
                while fi < tuple_fields.len() {
                    if fi > 0 {
                        pt.push_str(", ");
                    }
                    let field_ty = codegen_types::type_to_llvm(&tuple_fields[fi]);
                    payload_size = payload_size + codegen_types::type_size_bytes(&tuple_fields[fi]);
                    pt.push_str(field_ty.as_str());
                    fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                    fi = fi + 1;
                }
                pt.push_str(" }");
                if tuple_fields.len() > 0 {
                    payload_type = pt;
                }
            }
            &hir_item::VariantKind::Record(ref record_fields) => {
                let mut pt = common::make_string("{ ");
                let mut fi: usize = 0;
                while fi < record_fields.len() {
                    if fi > 0 {
                        pt.push_str(", ");
                    }
                    let field_ty = codegen_types::type_to_llvm(&record_fields[fi].ty);
                    payload_size = payload_size + codegen_types::type_size_bytes(&record_fields[fi].ty);
                    pt.push_str(field_ty.as_str());
                    fields.push(codegen_ctx::AdtFieldInfo { llvm_type: field_ty });
                    fi = fi + 1;
                }
                pt.push_str(" }");
                if record_fields.len() > 0 {
                    payload_type = pt;
                }
            }
        }

        if payload_size > max_payload_size {
            max_payload_size = payload_size;
        }

        variants.push(codegen_ctx::VariantLayout {
            variant_idx: variant.discriminant,
            fields: fields,
            payload_llvm_type: payload_type,
        });

        vi = vi + 1;
    }

    // Determine discriminant type based on number of variants
    let num_variants = enum_def.variants.len();
    let discriminant_type = if num_variants <= 256 {
        common::make_string("i8")
    } else if num_variants <= 65536 {
        common::make_string("i16")
    } else {
        common::make_string("i32")
    };

    // Build the enum LLVM type: { discriminant_type, [max_payload_size x i8] }
    let mut llvm_type = common::make_string("{ ");
    llvm_type.push_str(discriminant_type.as_str());
    if max_payload_size > 0 {
        llvm_type.push_str(", [");
        let size_str = codegen_types::format_u64(max_payload_size);
        llvm_type.push_str(size_str.as_str());
        llvm_type.push_str(" x i8]");
    }
    llvm_type.push_str(" }");

    codegen_ctx::EnumLayout {
        def_id: def_id,
        discriminant_type: discriminant_type,
        variants: variants,
        llvm_type: llvm_type,
        max_payload_size: max_payload_size,
    }
}

// ============================================================
// Simple Function Generator
// ============================================================

/// Generates a simple function that returns a constant.
pub fn generate_constant_function(name: &str, value: i64) -> String {
    let mut output = String::new();
    output.push_str("define i64 @");
    output.push_str(name);
    output.push_str("() {\n");
    output.push_str("entry:\n");
    output.push_str("    ret i64 ");
    let val_str = codegen_types::i64_to_string(value);
    output.push_str(val_str.as_str());
    output.push_str("\n}\n");
    output
}

// ============================================================
// Module Preamble
// ============================================================

/// Generates the standard module preamble.
pub fn module_preamble(module_name: &str) -> String {
    let mut output = String::new();
    output.push_str("; ModuleID = '");
    output.push_str(module_name);
    output.push_str("'\n");
    output.push_str("source_filename = \"");
    output.push_str(module_name);
    output.push_str(".blood\"\n");
    output.push_str("target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\n");
    output.push_str("target triple = \"x86_64-unknown-linux-gnu\"\n\n");
    output
}

/// Generates standard intrinsic declarations.
pub fn intrinsic_declarations() -> String {
    let mut output = String::new();
    output.push_str("\n; Intrinsic declarations\n");
    output.push_str("declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)\n");
    output.push_str("declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)\n");
    output.push_str("declare void @llvm.trap()\n");
    output.push_str("declare void @llvm.debugtrap()\n");

    // C library declarations
    output.push_str("\n; C library declarations\n");
    output.push_str("declare i32 @puts(ptr)\n");

    // Box runtime declarations
    output.push_str("\n; Box runtime declarations\n");
    output.push_str("declare ptr @box_new(ptr, i64)\n");

    // Effect runtime declarations
    output.push_str("\n; Effect runtime declarations\n");
    output.push_str("declare void @blood_push_handler(i64, ptr)\n");
    output.push_str("declare void @blood_pop_handler()\n");
    output.push_str("declare void @blood_push_inline_handler(i64)\n");
    output.push_str("declare i64 @blood_perform(i64, i64, i64)\n");
    output.push_str("declare void @blood_resume(i64)\n");

    // Builtin constructor stubs (used as function pointers for match dispatch, not called directly)
    output.push_str("\n; Builtin constructor stubs\n");
    output.push_str("define void @option_none_ctor() { ret void }\n");
    output.push_str("define void @option_some_ctor(ptr %0) { ret void }\n");
    output.push_str("declare void @string_new(ptr)\n");
    output.push_str("declare void @vec_new(i64, ptr)\n");

    // Builtin method runtime declarations
    // These are runtime functions called by builtin method resolution.
    // Signatures match blood-rust's codegen/context/mod.rs.
    output.push_str("\n; String method runtime declarations\n");
    output.push_str("declare i64 @string_len(ptr)\n");
    output.push_str("declare void @string_push(ptr, i32)\n");
    output.push_str("declare void @string_push_str(ptr, ptr)\n");
    output.push_str("declare ptr @string_as_str(ptr)\n");
    output.push_str("declare ptr @string_as_bytes(ptr)\n");

    output.push_str("\n; str method runtime declarations\n");
    output.push_str("declare ptr @str_as_bytes(ptr)\n");

    output.push_str("\n; Vec method runtime declarations\n");
    output.push_str("declare i64 @vec_len(ptr)\n");
    output.push_str("declare void @vec_push(ptr, ptr, i64)\n");
    output.push_str("declare i32 @vec_pop(ptr, i64, ptr)\n");
    output.push_str("declare void @vec_clear(ptr)\n");

    output.push_str("\n; Option method runtime declarations\n");
    output.push_str("declare i32 @option_is_some(ptr)\n");
    output.push_str("declare i32 @option_is_none(ptr)\n");
    output.push_str("declare void @option_unwrap(ptr, i64, ptr)\n");
    output.push_str("declare void @option_as_ref(ptr, i64, ptr)\n");

    output.push_str("\n; Slice method runtime declarations\n");
    output.push_str("declare i64 @slice_len(ptr)\n");

    // Region memory management runtime wrappers
    // The runtime uses blood_region_* prefix; we provide region_* wrappers for codegen
    output.push_str("\n; Region memory management\n");
    output.push_str("declare i64 @blood_region_create(i64, i64)\n");
    output.push_str("declare void @blood_region_destroy(i64)\n");
    output.push_str("declare void @blood_region_activate(i64)\n");
    output.push_str("declare void @blood_region_deactivate()\n");
    output.push_str("declare i64 @blood_region_alloc(i64, i64, i64)\n");
    output.push_str("declare i32 @blood_region_exit_scope(i64)\n");
    output.push_str("define i64 @region_create(i64 %0, i64 %1) { %r = call i64 @blood_region_create(i64 %0, i64 %1) ret i64 %r }\n");
    output.push_str("define void @region_destroy(i64 %0) { call void @blood_region_destroy(i64 %0) ret void }\n");
    output.push_str("define void @region_activate(i64 %0) { call void @blood_region_activate(i64 %0) ret void }\n");
    output.push_str("define void @region_deactivate() { call void @blood_region_deactivate() ret void }\n");
    output.push_str("define i64 @region_alloc(i64 %0, i64 %1, i64 %2) { %r = call i64 @blood_region_alloc(i64 %0, i64 %1, i64 %2) ret i64 %r }\n");
    output.push_str("define i32 @region_exit_scope(i64 %0) { %r = call i32 @blood_region_exit_scope(i64 %0) ret i32 %r }\n");

    output
}

// ============================================================
// External Function Declarations
// ============================================================

/// Generates an external function declaration.
pub fn extern_function(name: &str, params: &Vec<String>, ret_ty: &str) -> String {
    let mut output = String::new();
    output.push_str("declare ");
    output.push_str(ret_ty);
    output.push_str(" @");
    output.push_str(name);
    output.push_str("(");
    let mut i: usize = 0;
    while i < params.len() {
        if i > 0 {
            output.push_str(", ");
        }
        output.push_str(params[i].as_str());
        i = i + 1;
    }
    output.push_str(")\n");
    output
}

// ============================================================
// String Helpers
// ============================================================

/// Checks if an LLVM type string is "{}" (empty struct / unit type).
fn is_empty_struct_type(ty: &str) -> bool {
    let bytes = ty.as_bytes();
    if bytes.len() == 2 {
        bytes[0] == 123 && bytes[1] == 125
    } else {
        false
    }
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    let bytes = s.as_bytes();
    let mut i: usize = 0;
    while i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

// ============================================================
// Integration Tests (compile-time verification)
// ============================================================

/// Generates a minimal test module to verify codegen works.
pub fn generate_test_module() -> String {
    let mut output = String::new();

    // Module header
    output.push_str("; Test module for Blood codegen\n");
    output.push_str("source_filename = \"test.blood\"\n\n");

    // Simple function that returns 42
    output.push_str("define i64 @test_return() {\n");
    output.push_str("entry:\n");
    output.push_str("    ret i64 42\n");
    output.push_str("}\n\n");

    // Function with parameters
    output.push_str("define i64 @test_add(i64 %a, i64 %b) {\n");
    output.push_str("entry:\n");
    output.push_str("    %result = add i64 %a, %b\n");
    output.push_str("    ret i64 %result\n");
    output.push_str("}\n\n");

    // Function with control flow
    output.push_str("define i64 @test_if(i64 %cond) {\n");
    output.push_str("entry:\n");
    output.push_str("    %cmp = icmp ne i64 %cond, 0\n");
    output.push_str("    br i1 %cmp, label %then, label %else\n");
    output.push_str("then:\n");
    output.push_str("    br label %merge\n");
    output.push_str("else:\n");
    output.push_str("    br label %merge\n");
    output.push_str("merge:\n");
    output.push_str("    %result = phi i64 [ 1, %then ], [ 0, %else ]\n");
    output.push_str("    ret i64 %result\n");
    output.push_str("}\n");

    output
}
