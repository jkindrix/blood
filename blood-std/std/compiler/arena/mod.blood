//! # Arena Allocation Module
//!
//! Efficient memory allocation for the Blood compiler.
//!
//! ## Overview
//!
//! This module provides arena allocators optimized for compiler workloads:
//! - Fast O(1) bump allocation
//! - Cache-friendly contiguous memory
//! - Simple bulk deallocation
//! - String interning for deduplication
//!
//! ## Module Structure
//!
//! ```text
//! arena/
//! ├── mod.blood     # This file - module entry point
//! ├── chunk.blood   # Memory chunk management
//! ├── typed.blood   # TypedArena<T> - generic typed arena
//! ├── string.blood  # StringArena - string arena with interning
//! └── stats.blood   # ArenaStats - usage statistics
//! ```
//!
//! ## Arena Types
//!
//! | Arena | Use Case |
//! |-------|----------|
//! | `TypedArena<T>` | Single-type allocations (AST nodes, types) |
//! | `StringArena` | String storage with interning |
//! | `SymbolArena` | Compiler symbols and identifiers |
//!
//! ## Quick Start
//!
//! ### TypedArena for AST Nodes
//!
//! ```blood
//! use std.compiler.arena.TypedArena
//!
//! struct AstNode {
//!     kind: NodeKind,
//!     span: Span,
//! }
//!
//! let arena: TypedArena<AstNode> = TypedArena::new()
//!
//! let node1 = arena.alloc(AstNode { kind: NodeKind::Expr, span: Span::dummy() })
//! let node2 = arena.alloc(AstNode { kind: NodeKind::Stmt, span: Span::dummy() })
//!
//! // All nodes freed when arena drops
//! ```
//!
//! ### StringArena for Identifiers
//!
//! ```blood
//! use std.compiler.arena.StringArena
//!
//! let strings = StringArena::new()
//!
//! let hello = strings.alloc("hello")
//! let world = strings.alloc("world")
//! let hello2 = strings.alloc("hello")
//!
//! // Interning: hello and hello2 point to same memory!
//! assert(hello.as_ptr() == hello2.as_ptr())
//! ```
//!
//! ## Performance Characteristics
//!
//! | Operation | Complexity | Notes |
//! |-----------|------------|-------|
//! | Allocation | O(1) amortized | Occasional chunk allocation |
//! | Interning lookup | O(1) average | Hash table lookup |
//! | Deallocation | O(n) | Drop all at once |
//! | Memory overhead | Low | No per-object metadata |
//!
//! ## Memory Management
//!
//! Arena allocators use a "bump allocation" strategy:
//!
//! ```text
//! Initial state:
//! |<------------------- chunk capacity ------------------->|
//! |                    free space                          |
//! ^
//! offset (0)
//!
//! After allocations:
//! |<------------------- chunk capacity ------------------->|
//! | obj1 | obj2 | obj3 |        free space                 |
//!                       ^
//!                       offset
//!
//! After more allocations (new chunk):
//! Chunk 0: | obj1 | obj2 | obj3 | obj4 | obj5 | ...full... |
//! Chunk 1: | obj6 | obj7 |        free space               |
//! ```
//!
//! ## Compiler Usage Patterns
//!
//! ### Parsing Phase
//!
//! ```blood
//! struct Parser {
//!     ast_arena: TypedArena<AstNode>,
//!     string_arena: StringArena,
//! }
//!
//! impl Parser {
//!     fn parse_identifier(mut self) -> &str {
//!         let token = self.consume(TokenKind::Ident)
//!         self.string_arena.alloc(token.text)
//!     }
//!
//!     fn parse_expression(mut self) -> &AstNode {
//!         let node = AstExpr { ... }
//!         self.ast_arena.alloc(node)
//!     }
//! }
//! ```
//!
//! ### Type Checking Phase
//!
//! ```blood
//! struct TypeChecker {
//!     type_arena: TypedArena<Type>,
//!     // Types are interned separately...
//! }
//! ```
//!
//! ## Thread Safety
//!
//! Arena allocators in this module are NOT thread-safe. For concurrent
//! compilation, use one of these strategies:
//!
//! 1. **Per-thread arenas**: Each thread has its own arena
//! 2. **External synchronization**: Wrap arena in Mutex
//! 3. **Phase separation**: Different phases use different arenas
//!
//! ## Design References
//!
//! This module is inspired by:
//! - Rust's `typed_arena` crate
//! - LLVM's BumpPtrAllocator
//! - Zig's GeneralPurposeAllocator arena mode
//! - Vale's generational allocator

module std.compiler.arena;

// ============================================================================
// Core Types (Re-exports)
// ============================================================================

// Memory chunk management
pub use chunk.Chunk
pub use chunk.DEFAULT_CHUNK_SIZE
pub use chunk.MAX_CHUNK_SIZE
pub use chunk.DEFAULT_ALIGNMENT
pub use chunk.align_up
pub use chunk.align_down
pub use chunk.is_aligned

// Typed arena allocator
pub use typed.TypedArena

// String arena with interning
pub use string.StringArena
pub use string.SymbolArena

// Statistics
pub use stats.ArenaStats
pub use stats.ArenaReport

// ============================================================================
// Convenience Type Aliases
// ============================================================================

/// Arena for AST nodes (alias for common use case).
pub type AstArena<T> = TypedArena<T>

/// Arena for HIR nodes (alias for common use case).
pub type HirArena<T> = TypedArena<T>

/// Arena for type information (alias for common use case).
pub type TypeArena<T> = TypedArena<T>

// ============================================================================
// Arena Collection
// ============================================================================

/// A collection of arenas used during compilation.
///
/// This provides a convenient way to manage all compiler arenas together.
///
/// ## Example
///
/// ```blood
/// let arenas = CompilerArenas::new()
///
/// // Parse phase uses AST arena
/// let ast_node = arenas.ast.alloc(...)
///
/// // Strings are interned
/// let name = arenas.strings.alloc("main")
///
/// // Get combined stats
/// let report = arenas.stats()
/// println("Total memory: {} bytes", report.total.total_used)
/// ```
pub struct CompilerArenas<AstNode, HirNode, TypeInfo> {
    /// Arena for AST nodes.
    pub ast: TypedArena<AstNode>,

    /// Arena for HIR nodes.
    pub hir: TypedArena<HirNode>,

    /// Arena for type information.
    pub types: TypedArena<TypeInfo>,

    /// Arena for interned strings and symbols.
    pub strings: StringArena,
}

impl<AstNode, HirNode, TypeInfo> CompilerArenas[AstNode, HirNode, TypeInfo] {
    /// Create a new collection of compiler arenas.
    pub fn new() -> CompilerArenas[AstNode, HirNode, TypeInfo] {
        CompilerArenas {
            ast: TypedArena::new(),
            hir: TypedArena::new(),
            types: TypedArena::new(),
            strings: StringArena::new(),
        }
    }

    /// Create arenas with pre-allocated capacity.
    ///
    /// ## Arguments
    ///
    /// * `ast_capacity` - Number of AST nodes to pre-allocate for
    /// * `hir_capacity` - Number of HIR nodes to pre-allocate for
    /// * `type_capacity` - Number of types to pre-allocate for
    /// * `string_bytes` - Bytes to pre-allocate for strings
    pub fn with_capacity(
        ast_capacity: USize,
        hir_capacity: USize,
        type_capacity: USize,
        string_bytes: USize,
    ) -> CompilerArenas[AstNode, HirNode, TypeInfo] {
        CompilerArenas {
            ast: TypedArena::with_capacity(ast_capacity),
            hir: TypedArena::with_capacity(hir_capacity),
            types: TypedArena::with_capacity(type_capacity),
            strings: StringArena::with_capacity(string_bytes),
        }
    }

    /// Get a report of arena usage.
    pub fn stats(self) -> ArenaReport {
        let mut report = ArenaReport::new()

        report.ast_arena = self.ast.stats()
        report.hir_arena = self.hir.stats()
        report.type_arena = self.types.stats()
        report.string_arena = self.strings.stats()
        report.compute_total()

        report
    }

    /// Clear all arenas for reuse.
    ///
    /// ## Safety
    ///
    /// All references to arena-allocated values become invalid.
    pub unsafe fn clear(mut self) {
        self.ast.clear()
        self.hir.clear()
        self.types.clear()
        self.strings.clear()
    }
}

impl<AstNode, HirNode, TypeInfo> Default for CompilerArenas[AstNode, HirNode, TypeInfo] {
    fn default() -> CompilerArenas[AstNode, HirNode, TypeInfo] {
        CompilerArenas::new()
    }
}

// ============================================================================
// Module-Level Tests
// ============================================================================

#[test]
fn test_module_exports() {
    // Verify that all expected types are accessible
    let _: TypedArena<Int> = TypedArena::new()
    let _: StringArena = StringArena::new()
    let _: ArenaStats = ArenaStats::new()
    let _: ArenaReport = ArenaReport::new()
}

#[test]
fn test_compiler_arenas() {
    struct MockAst { value: Int }
    struct MockHir { value: Int }
    struct MockType { value: Int }

    let arenas: CompilerArenas[MockAst, MockHir, MockType] = CompilerArenas::new()

    let ast = arenas.ast.alloc(MockAst { value: 1 })
    let hir = arenas.hir.alloc(MockHir { value: 2 })
    let ty = arenas.types.alloc(MockType { value: 3 })
    let name = arenas.strings.alloc("test")

    assert(ast.value == 1)
    assert(hir.value == 2)
    assert(ty.value == 3)
    assert(name == "test")
}

#[test]
fn test_compiler_arenas_stats() {
    struct MockNode { value: Int }

    let arenas: CompilerArenas[MockNode, MockNode, MockNode] = CompilerArenas::new()

    let _ = arenas.ast.alloc(MockNode { value: 1 })
    let _ = arenas.ast.alloc(MockNode { value: 2 })
    let _ = arenas.strings.alloc("hello")

    let report = arenas.stats()

    assert(report.ast_arena.num_items == 2)
    assert(report.string_arena.num_items == 1)
    assert(report.total.num_items >= 3)
}

#[test]
fn test_alignment_helpers() {
    assert(align_up(0, 8) == 0)
    assert(align_up(1, 8) == 8)
    assert(align_up(8, 8) == 8)
    assert(align_up(9, 8) == 16)

    assert(align_down(7, 8) == 0)
    assert(align_down(8, 8) == 8)
    assert(align_down(15, 8) == 8)

    assert(is_aligned(0, 8))
    assert(is_aligned(8, 8))
    assert(is_aligned(16, 8))
    assert(!is_aligned(7, 8))
}
