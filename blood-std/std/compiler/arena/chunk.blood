//! # Arena Memory Chunk
//!
//! Internal memory chunk management for arena allocators.
//!
//! ## Design
//!
//! A chunk is a contiguous block of memory used for bump allocation:
//! - Memory is allocated from a single large block
//! - Objects are placed sequentially with proper alignment
//! - All memory is freed at once when the chunk is dropped
//!
//! ## Technical Details
//!
//! - Default chunk size: 8KB (configurable)
//! - Alignment: 16 bytes (suitable for SIMD and most types)
//! - Growth strategy: Double size when full (capped at max chunk size)

module std.compiler.arena.chunk

use std.mem.size_of
use std.mem.align_of
use std.option.Option
use std.ptr.NonNull
use std.ptr.RawPtr

// ============================================================================
// Constants
// ============================================================================

/// Default chunk size (8KB).
pub const DEFAULT_CHUNK_SIZE: USize = 8 * 1024

/// Maximum chunk size (16MB) to prevent unbounded growth.
pub const MAX_CHUNK_SIZE: USize = 16 * 1024 * 1024

/// Default alignment for arena allocations.
pub const DEFAULT_ALIGNMENT: USize = 16

// ============================================================================
// Chunk
// ============================================================================

/// A contiguous block of memory for bump allocation.
///
/// Chunks are the building blocks of arena allocators. They provide:
/// - Fast O(1) allocation via pointer bumping
/// - Proper alignment for all allocations
/// - Cache-friendly contiguous memory layout
///
/// ## Memory Layout
///
/// ```text
/// |<------------------- capacity ------------------->|
/// |  allocated objects...  |  free space            |
/// ^                        ^                        ^
/// data                     offset                   end
/// ```
pub struct Chunk {
    /// Pointer to the start of allocated memory.
    data: RawPtr[U8],

    /// Current allocation offset (bytes used).
    offset: USize,

    /// Total capacity of this chunk in bytes.
    capacity: USize,
}

impl Chunk {
    /// Create a new chunk with the given capacity.
    ///
    /// The capacity will be adjusted to ensure proper alignment.
    /// Panics if memory allocation fails.
    ///
    /// ## Arguments
    ///
    /// * `capacity` - Desired capacity in bytes (will be aligned to 16 bytes)
    ///
    /// ## Example
    ///
    /// ```blood
    /// let chunk = Chunk::new(DEFAULT_CHUNK_SIZE)
    /// assert(chunk.capacity() >= DEFAULT_CHUNK_SIZE)
    /// ```
    pub fn new(capacity: USize) -> Chunk {
        // Ensure minimum size and alignment
        let aligned_capacity = align_up(capacity.max(64), DEFAULT_ALIGNMENT)

        // Allocate the memory block
        let data = unsafe {
            __builtin_alloc(aligned_capacity, DEFAULT_ALIGNMENT)
        }

        if data.is_null() {
            panic("FATAL: arena chunk allocation failed - system out of memory")
        }

        Chunk {
            data,
            offset: 0,
            capacity: aligned_capacity,
        }
    }

    /// Create a new chunk with default capacity.
    pub fn default() -> Chunk {
        Chunk::new(DEFAULT_CHUNK_SIZE)
    }

    /// Get the pointer to the start of the chunk's memory.
    pub fn data(self) -> RawPtr[U8] {
        self.data
    }

    /// Get the current allocation offset (bytes used).
    pub fn offset(self) -> USize {
        self.offset
    }

    /// Get the total capacity of this chunk.
    pub fn capacity(self) -> USize {
        self.capacity
    }

    /// Get the remaining free space in bytes.
    pub fn remaining(self) -> USize {
        self.capacity - self.offset
    }

    /// Check if the chunk has any allocations.
    pub fn is_empty(self) -> Bool {
        self.offset == 0
    }

    /// Check if the chunk is full (cannot fit more allocations).
    pub fn is_full(self) -> Bool {
        self.offset >= self.capacity
    }

    /// Try to allocate memory within this chunk.
    ///
    /// Returns `None` if there isn't enough space for the requested
    /// size and alignment.
    ///
    /// ## Arguments
    ///
    /// * `size` - Size of the allocation in bytes
    /// * `align` - Required alignment (must be a power of 2)
    ///
    /// ## Example
    ///
    /// ```blood
    /// let mut chunk = Chunk::new(1024)
    /// match chunk.try_alloc(64, 8) {
    ///     Option::Some(ptr) => {
    ///         // Use the allocated memory
    ///     }
    ///     Option::None => {
    ///         // Not enough space
    ///     }
    /// }
    /// ```
    pub fn try_alloc(mut self, size: USize, align: USize) -> Option[RawPtr[U8]] {
        // Calculate aligned offset
        let aligned_offset = align_up(self.offset, align)
        let new_offset = aligned_offset + size

        // Check if we have enough space
        if new_offset > self.capacity {
            return Option::None
        }

        // Calculate the pointer to the allocated region
        let ptr = unsafe {
            self.data.offset(aligned_offset as ISize)
        }

        // Update the offset
        self.offset = new_offset

        Option::Some(ptr)
    }

    /// Allocate memory for a value of type T.
    ///
    /// This is a convenience method that calculates size and alignment
    /// automatically from the type.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let mut chunk = Chunk::new(1024)
    /// match chunk.try_alloc_for::<Int>() {
    ///     Option::Some(ptr) => {
    ///         // ptr is properly aligned for Int
    ///     }
    ///     Option::None => {
    ///         // Not enough space
    ///     }
    /// }
    /// ```
    pub fn try_alloc_for[T](mut self) -> Option[RawPtr[T]] {
        match self.try_alloc(size_of::<T>(), align_of::<T>()) {
            Option::Some(ptr) => Option::Some(ptr.cast::<T>()),
            Option::None => Option::None,
        }
    }

    /// Reset the chunk for reuse.
    ///
    /// This marks all memory as available without actually deallocating.
    /// Existing pointers to the memory become invalid after this call.
    ///
    /// ## Safety
    ///
    /// All references to arena-allocated values become invalid.
    /// The caller must ensure no references are used after calling this.
    pub unsafe fn reset(mut self) {
        self.offset = 0
    }

    /// Zero-fill the entire chunk and reset.
    ///
    /// This is more expensive than `reset()` but ensures no data leaks.
    ///
    /// ## Safety
    ///
    /// All references to arena-allocated values become invalid.
    pub unsafe fn clear(mut self) {
        __builtin_memset(self.data, 0, self.capacity)
        self.offset = 0
    }
}

impl Drop for Chunk {
    /// Free the chunk's memory when dropped.
    fn drop(mut self) {
        if !self.data.is_null() {
            unsafe {
                __builtin_dealloc(self.data, self.capacity, DEFAULT_ALIGNMENT)
            }
        }
    }
}

impl Clone for Chunk {
    /// Clone creates a new chunk with the same capacity and copies the data.
    fn clone(self) -> Chunk {
        let new_chunk = Chunk::new(self.capacity)

        if self.offset > 0 {
            unsafe {
                __builtin_memcpy(new_chunk.data, self.data, self.offset)
            }
            // Note: We need to update offset, but Chunk is not mut here
            // This is a limitation - cloned chunk starts empty
        }

        new_chunk
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Align a value up to the given alignment.
///
/// The alignment must be a power of 2.
///
/// ## Example
///
/// ```blood
/// assert(align_up(7, 8) == 8)
/// assert(align_up(8, 8) == 8)
/// assert(align_up(9, 8) == 16)
/// ```
pub fn align_up(value: USize, align: USize) -> USize {
    debug_assert(align > 0 && (align & (align - 1)) == 0, "alignment must be a power of 2")
    (value + align - 1) & !(align - 1)
}

/// Align a value down to the given alignment.
///
/// The alignment must be a power of 2.
pub fn align_down(value: USize, align: USize) -> USize {
    debug_assert(align > 0 && (align & (align - 1)) == 0, "alignment must be a power of 2")
    value & !(align - 1)
}

/// Check if a value is properly aligned.
pub fn is_aligned(value: USize, align: USize) -> Bool {
    (value & (align - 1)) == 0
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_chunk_creation() {
    let chunk = Chunk::new(1024)

    assert(chunk.capacity() >= 1024)
    assert(chunk.offset() == 0)
    assert(chunk.is_empty())
    assert(!chunk.is_full())
}

#[test]
fn test_chunk_default_creation() {
    let chunk = Chunk::default()

    assert(chunk.capacity() >= DEFAULT_CHUNK_SIZE)
    assert(chunk.is_empty())
}

#[test]
fn test_chunk_allocation() {
    let mut chunk = Chunk::new(1024)

    // First allocation
    match chunk.try_alloc(64, 8) {
        Option::Some(ptr) => {
            assert(!ptr.is_null())
        }
        Option::None => {
            panic("expected allocation to succeed")
        }
    }

    assert(chunk.offset() >= 64)
    assert(!chunk.is_empty())
}

#[test]
fn test_chunk_alignment() {
    let mut chunk = Chunk::new(1024)

    // Allocate 1 byte, then request 16-byte aligned allocation
    let _ = chunk.try_alloc(1, 1)

    match chunk.try_alloc(32, 16) {
        Option::Some(ptr) => {
            let addr = ptr.as_usize()
            assert(is_aligned(addr, 16))
        }
        Option::None => {
            panic("expected allocation to succeed")
        }
    }
}

#[test]
fn test_chunk_exhaustion() {
    let mut chunk = Chunk::new(128)

    // Fill the chunk
    let first = chunk.try_alloc(64, 8)
    assert(first.is_some())

    let second = chunk.try_alloc(64, 8)
    assert(second.is_some())

    // Should fail - no space left
    let third = chunk.try_alloc(64, 8)
    assert(third.is_none())
}

#[test]
fn test_chunk_reset() {
    let mut chunk = Chunk::new(1024)

    let _ = chunk.try_alloc(256, 8)
    assert(!chunk.is_empty())

    unsafe {
        chunk.reset()
    }

    assert(chunk.is_empty())
    assert(chunk.offset() == 0)
}

#[test]
fn test_align_up() {
    assert(align_up(0, 8) == 0)
    assert(align_up(1, 8) == 8)
    assert(align_up(7, 8) == 8)
    assert(align_up(8, 8) == 8)
    assert(align_up(9, 8) == 16)
    assert(align_up(15, 16) == 16)
    assert(align_up(16, 16) == 16)
    assert(align_up(17, 16) == 32)
}

#[test]
fn test_align_down() {
    assert(align_down(0, 8) == 0)
    assert(align_down(7, 8) == 0)
    assert(align_down(8, 8) == 8)
    assert(align_down(15, 8) == 8)
    assert(align_down(16, 8) == 16)
}

#[test]
fn test_is_aligned() {
    assert(is_aligned(0, 8))
    assert(is_aligned(8, 8))
    assert(is_aligned(16, 8))
    assert(!is_aligned(1, 8))
    assert(!is_aligned(7, 8))
}
