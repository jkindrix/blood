//! # Typed Arena Allocator
//!
//! A typed bump allocator that efficiently allocates values of a single type.
//!
//! ## Overview
//!
//! TypedArena provides fast O(1) bump allocation for objects of a specific type.
//! All allocated objects share the arena's lifetime and are freed together when
//! the arena is dropped.
//!
//! ## Benefits
//!
//! - **Fast allocation**: O(1) pointer bumping, no per-object overhead
//! - **Cache-friendly**: Contiguous memory layout improves cache utilization
//! - **Simple deallocation**: All memory freed at once when arena drops
//! - **Reduced fragmentation**: No individual free operations
//!
//! ## Use Cases
//!
//! TypedArena is ideal for:
//! - AST nodes during parsing (all freed after compilation phase)
//! - HIR/MIR nodes during lowering
//! - Type information during type checking
//! - Temporary data structures with clear lifetimes
//!
//! ## Example
//!
//! ```blood
//! use std.compiler.arena.TypedArena
//!
//! struct AstNode {
//!     kind: NodeKind,
//!     span: Span,
//! }
//!
//! let arena: TypedArena<AstNode> = TypedArena::new()
//!
//! // Allocate nodes
//! let node1 = arena.alloc(AstNode { kind: NodeKind::Expr, span: Span::dummy() })
//! let node2 = arena.alloc(AstNode { kind: NodeKind::Stmt, span: Span::dummy() })
//!
//! // All nodes freed when arena drops
//! ```

module std.compiler.arena.typed;

use std.mem.size_of;
use std.mem.align_of;
use std.option.Option;
use std.collections.Vec;
use std.ptr.RawPtr;
use std.compiler.arena.chunk.Chunk;
use std.compiler.arena.chunk.DEFAULT_CHUNK_SIZE;
use std.compiler.arena.chunk.DEFAULT_ALIGNMENT;
use std.compiler.arena.chunk.align_up;
use std.compiler.arena.stats.ArenaStats;

// ============================================================================
// TypedArena
// ============================================================================

/// A typed arena allocator for efficient bump allocation.
///
/// TypedArena allocates values of type T in contiguous memory chunks.
/// All allocations are valid for the lifetime of the arena.
///
/// ## Thread Safety
///
/// TypedArena uses interior mutability for allocation and is NOT thread-safe.
/// For concurrent access, use external synchronization or per-thread arenas.
///
/// ## Growth Strategy
///
/// The arena starts with a default chunk size and grows as needed:
/// 1. First chunk: DEFAULT_CHUNK_SIZE (8KB)
/// 2. Subsequent chunks: Double the previous size (capped at 16MB)
///
/// ## Memory Layout
///
/// ```text
/// TypedArena<T>
/// ├── chunks: Vec<Chunk>
/// │   ├── Chunk 0: [T, T, T, T, ...]
/// │   ├── Chunk 1: [T, T, T, ...]
/// │   └── ...
/// └── count: USize  (total allocations)
/// ```
pub struct TypedArena<T> {
    /// The memory chunks holding allocated values.
    chunks: Vec<Chunk>,

    /// Total number of values allocated.
    count: USize,
}

impl<T> TypedArena<T> {
    /// Create a new empty typed arena.
    ///
    /// The arena lazily allocates its first chunk on the first allocation.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let arena: TypedArena<Int> = TypedArena::new()
    /// assert(arena.is_empty())
    /// ```
    pub fn new() -> TypedArena<T> {
        TypedArena {
            chunks: Vec::new(),
            count: 0,
        }
    }

    /// Create a new arena with pre-allocated capacity.
    ///
    /// Pre-allocates enough space for at least `capacity` values.
    /// This avoids reallocation during initial use.
    ///
    /// ## Arguments
    ///
    /// * `capacity` - Number of values to pre-allocate space for
    ///
    /// ## Example
    ///
    /// ```blood
    /// // Pre-allocate space for 1000 AST nodes
    /// let arena: TypedArena<AstNode> = TypedArena::with_capacity(1000)
    /// ```
    pub fn with_capacity(capacity: USize) -> TypedArena<T> {
        let item_size = size_of::<T>();
        let chunk_size = (capacity * item_size).max(DEFAULT_CHUNK_SIZE);

        let mut arena = TypedArena {
            chunks: Vec::with_capacity(1),
            count: 0,
        };

        arena.chunks.push(Chunk::new(chunk_size));
        arena
    }

    /// Allocate a value in the arena.
    ///
    /// Returns a reference to the allocated value. The reference is valid
    /// for the lifetime of the arena.
    ///
    /// ## Arguments
    ///
    /// * `value` - The value to allocate
    ///
    /// ## Returns
    ///
    /// A reference to the allocated value.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let arena: TypedArena<Int> = TypedArena::new()
    /// let x = arena.alloc(42)
    /// let y = arena.alloc(100)
    ///
    /// assert(*x == 42)
    /// assert(*y == 100)
    /// ```
    pub fn alloc(mut self, value: T) -> &T {
        let ptr = self.alloc_raw();

        // Write the value to the allocated memory
        @unsafe {
            ptr.write(value);
        };

        self.count = self.count + 1;

        // Return a reference to the written value
        @unsafe {
            &*ptr.as_ptr()
        }
    }

    /// Allocate an uninitialized value in the arena.
    ///
    /// Returns a raw pointer to uninitialized memory. The caller is
    /// responsible for initializing the memory before use.
    ///
    /// ## Safety
    ///
    /// The returned memory is uninitialized. Reading from it before
    /// initialization is undefined behavior.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let arena: TypedArena<LargeStruct> = TypedArena::new()
    ///
    /// let ptr = arena.alloc_uninit()
    /// @unsafe {
    ///     // Initialize fields individually to avoid copying
    ///     (*ptr).field1 = compute_value1()
    ///     (*ptr).field2 = compute_value2()
    /// }
    /// ```
    pub fn alloc_uninit(mut self) -> RawPtr<T> {
        let ptr = self.alloc_raw();
        self.count = self.count + 1;
        ptr
    }

    /// Allocate a slice of values in the arena.
    ///
    /// Copies the values from the source slice into contiguous arena memory.
    ///
    /// ## Arguments
    ///
    /// * `values` - Slice of values to allocate
    ///
    /// ## Returns
    ///
    /// A slice reference to the allocated values.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let arena: TypedArena<Int> = TypedArena::new()
    /// let slice = arena.alloc_slice(&[1, 2, 3, 4, 5])
    ///
    /// assert(slice.len() == 5)
    /// assert(slice[0] == 1)
    /// assert(slice[4] == 5)
    /// ```
    pub fn alloc_slice(mut self, values: &[T]) -> &[T]
    where T: Copy
    {
        if values.is_empty() {
            return &[];
        };

        let len = values.len();
        let ptr = self.alloc_slice_raw(len);

        // Copy values to the allocated memory
        @unsafe {
            __builtin_memcpy(
                ptr.as_ptr() as RawPtr<U8>,
                values.as_ptr() as RawPtr<U8>,
                len * size_of::<T>()
            )
        };

        self.count = self.count + len;

        // Return a slice reference
        @unsafe {
            __builtin_slice_from_raw_parts(ptr.as_ptr(), len);
        }
    }

    /// Allocate an uninitialized slice in the arena.
    ///
    /// ## Safety
    ///
    /// The returned memory is uninitialized.
    pub fn alloc_slice_uninit(mut self, len: USize) -> &mut [T] {
        if len == 0 {
            return &mut [];
        };

        let ptr = self.alloc_slice_raw(len);
        self.count = self.count + len;

        @unsafe {
            __builtin_slice_from_raw_parts_mut(ptr.as_ptr(), len);
        }
    }

    /// Get the number of allocated values.
    pub fn len(self) -> USize {
        self.count
    }

    /// Check if the arena is empty.
    pub fn is_empty(self) -> Bool {
        self.count == 0;
    }

    /// Get statistics about arena usage.
    pub fn stats(self) -> ArenaStats {
        let num_chunks = self.chunks.len();
        let mut total_capacity: USize = 0;
        let mut total_used: USize = 0;

        for chunk in self.chunks.iter() {
            total_capacity = total_capacity + chunk.capacity();
            total_used = total_used + chunk.offset();
        }

        ArenaStats {
            num_chunks,
            total_capacity,
            total_used,
            num_items: self.count,
        }
    }

    /// Clear all allocations, keeping memory for reuse.
    ///
    /// After calling clear(), all previously allocated references become
    /// invalid. The arena can be reused for new allocations.
    ///
    /// ## Safety
    ///
    /// All references to arena-allocated values become invalid.
    /// Using them after clear() is undefined behavior.
    ///
    /// ## Example
    ///
    /// ```blood
    /// let mut arena: TypedArena<Int> = TypedArena::new()
    /// let _ = arena.alloc(42)
    ///
    /// @unsafe {
    ///     arena.clear()
    /// }
    ///
    /// assert(arena.is_empty())
    /// ```
    pub unsafe fn clear(mut self) {
        for chunk in self.chunks.iter_mut() {
            chunk.reset();
        };
        self.count = 0;
    }

    // ========================================================================
    // Private Methods
    // ========================================================================

    /// Allocate raw memory for a single value.
    fn alloc_raw(mut self) -> RawPtr<T> {
        let size = size_of::<T>();
        let align = align_of::<T>();

        // Try to allocate in the current chunk
        if let Some(chunk) = self.chunks.last_mut() {
            if let Option::Some(ptr) = chunk.try_alloc(size, align) {
                return ptr.cast::<T>();
            }
        };

        // Need a new chunk
        self.grow_for(size, align);

        // Allocate in the new chunk (guaranteed to succeed);
        let chunk = self.chunks.last_mut().unwrap();
        chunk.try_alloc(size, align)
            .expect("BUG: fresh chunk must have space")
            .cast::<T>();
    }

    /// Allocate raw memory for a slice.
    fn alloc_slice_raw(mut self, len: USize) -> RawPtr<T> {
        let item_size = size_of::<T>();
        let align = align_of::<T>();
        let total_size = len * item_size;

        // Try to allocate in the current chunk
        if let Some(chunk) = self.chunks.last_mut() {
            if let Option::Some(ptr) = chunk.try_alloc(total_size, align) {
                return ptr.cast::<T>();
            }
        };

        // Need a new chunk
        self.grow_for(total_size, align);

        // Allocate in the new chunk
        let chunk = self.chunks.last_mut().unwrap();
        chunk.try_alloc(total_size, align)
            .expect("BUG: fresh chunk must have space")
            .cast::<T>();
    }

    /// Grow the arena to accommodate an allocation.
    fn grow_for(mut self, size: USize, align: USize) {
        // Calculate new chunk size (double previous, or default);
        let last_capacity = self.chunks.last()
            .map(|c| c.capacity())
            .unwrap_or(DEFAULT_CHUNK_SIZE);

        let min_size = align_up(size, align);
        let new_capacity = (last_capacity * 2).max(min_size).max(DEFAULT_CHUNK_SIZE);

        self.chunks.push(Chunk::new(new_capacity));
    }
}

impl<T> Default for TypedArena<T> {
    fn default() -> TypedArena<T> {
        TypedArena::new()
    }
}

impl<T> Drop for TypedArena<T> {
    /// Drop all chunks when the arena is dropped.
    fn drop(mut self) {
        // Note: Chunks are automatically dropped when Vec drops.
        // If T has a Drop impl, we should run it for each value.
        // This is a simplification - full impl would track destructors.
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_typed_arena_new() {
    let arena: TypedArena<Int> = TypedArena::new();

    assert(arena.is_empty());
    assert(arena.len() == 0);
}

#[test]
fn test_typed_arena_with_capacity() {
    let arena: TypedArena<Int> = TypedArena::with_capacity(1000);

    assert(arena.is_empty());

    let stats = arena.stats();
    assert(stats.total_capacity >= 1000 * size_of::<Int>());
}

#[test]
fn test_typed_arena_alloc() {
    let arena: TypedArena<Int> = TypedArena::new();

    let x = arena.alloc(42);
    let y = arena.alloc(100);
    let z = arena.alloc(-1);

    assert(*x == 42);
    assert(*y == 100);
    assert(*z == -1);
    assert(arena.len() == 3);
}

#[test]
fn test_typed_arena_many_allocations() {
    let arena: TypedArena<U64> = TypedArena::new();
    let mut refs: Vec[&U64] = Vec::new();

    for i in 0..10000 {
        refs.push(arena.alloc(i as U64));
    };

    for i in 0..10000 {
        assert(*refs[i] == i as U64);
    }
}

#[test]
fn test_typed_arena_alloc_slice() {
    let arena: TypedArena<Int> = TypedArena::new();
    let slice = arena.alloc_slice(&[1, 2, 3, 4, 5]);

    assert(slice.len() == 5);
    assert(slice[0] == 1);
    assert(slice[1] == 2);
    assert(slice[2] == 3);
    assert(slice[3] == 4);
    assert(slice[4] == 5);
}

#[test]
fn test_typed_arena_empty_slice() {
    let arena: TypedArena<Int> = TypedArena::new();
    let slice = arena.alloc_slice(&[]);

    assert(slice.len() == 0);
}

#[test]
fn test_typed_arena_stats() {
    let arena: TypedArena<Int> = TypedArena::new();

    let _ = arena.alloc(1);
    let _ = arena.alloc(2);
    let _ = arena.alloc(3);

    let stats = arena.stats();
    assert(stats.num_items == 3);
    assert(stats.total_used >= 3 * size_of::<Int>());
}

#[test]
fn test_typed_arena_clear() {
    let mut arena: TypedArena<Int> = TypedArena::new();

    let _ = arena.alloc(42);
    let _ = arena.alloc(100);
    assert(!arena.is_empty());

    @unsafe {
        arena.clear();
    };

    assert(arena.is_empty());
    assert(arena.len() == 0);
}

#[test]
fn test_typed_arena_growth() {
    let arena: TypedArena<Int> = TypedArena::new();

    // Allocate enough to trigger multiple chunks
    for i in 0..100000 {
        let _ = arena.alloc(i);
    };

    let stats = arena.stats();
    assert(stats.num_chunks > 1);
    assert(stats.num_items == 100000);
}

#[test]
fn test_typed_arena_struct() {
    struct Point {
        x: Int,
        y: Int,
    }

    let arena: TypedArena<Point> = TypedArena::new();

    let p1 = arena.alloc(Point { x: 10, y: 20 });
    let p2 = arena.alloc(Point { x: -5, y: 15 });

    assert(p1.x == 10);
    assert(p1.y == 20);
    assert(p2.x == -5);
    assert(p2.y == 15);
}
