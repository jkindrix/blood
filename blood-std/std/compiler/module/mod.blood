//! Blood Module System
//!
//! This module provides the infrastructure for Blood's module system,
//! handling the organization of code into hierarchical namespaces.
//!
//! ## Overview
//!
//! Blood uses a file-based module system similar to Rust:
//!
//! - Each `.blood` file is a module
//! - Modules form a tree rooted at the crate
//! - `mod foo;` declares a submodule (loads `foo.blood` or `foo/mod.blood`)
//! - `use` statements bring items into scope
//!
//! ## Module Components
//!
//! | Component | Purpose |
//! |-----------|---------|
//! | `ModulePath` | Hierarchical paths like `crate::foo::bar` |
//! | `ModuleTree` | The complete module hierarchy |
//! | `ModuleResolver` | Finds source files for modules |
//! | `ModuleId` | Unique identifier per module |
//!
//! ## Usage Example
//!
//! ```blood
//! // Build a module tree from a project
//! let resolver = ModuleResolver::new("/my/project");
//! let mut tree = ModuleTree::new("/my/project/src/lib.blood", "mylib");
//!
//! // Add modules discovered from parsing
//! let utils_file = resolver.resolve_module(
//!     "/my/project/src/lib.blood",
//!     "utils"
//! )?;
//!
//! let utils_id = tree.add_child(
//!     tree.root(),
//!     "utils",
//!     &utils_file,
//!     false,
//!     Visibility::Public,
//! )?;
//!
//! // Look up modules by path
//! let path = ModulePath::from_double_colon("crate::utils");
//! let found = tree.by_path(&path);  // Some(utils_id)
//! ```
//!
//! ## File Layout
//!
//! Blood follows Rust's module conventions:
//!
//! ```text
//! src/
//! ├── lib.blood           # Crate root (mod declarations here)
//! ├── utils.blood         # mod utils; → loads this file
//! ├── utils/              # Alternative: directory + mod.blood
//! │   ├── mod.blood       # mod utils; → loads this file
//! │   └── helpers.blood   # mod helpers; (declared in utils/mod.blood)
//! └── core/
//!     ├── mod.blood
//!     └── types.blood
//! ```

// ============================================================================
// Submodule Declarations
// ============================================================================

pub mod path;
pub mod tree;
pub mod resolve;

// ============================================================================
// Re-exports
// ============================================================================

pub use path::ModulePath;
pub use tree::{ModuleId, Module, ModuleTree, ModuleTreeError, Visibility};
pub use resolve::{ModuleResolver, ResolveError};

// ============================================================================
// Module Info for Type Context
// ============================================================================

use std.collections::{HashMap};
use crate.hir::DefId;

/// Information about a module's contents.
///
/// This structure is used by the type checker to track what items
/// are defined in each module, enabling import resolution and
/// cross-module name lookup.
pub struct ModuleInfo {
    /// The module's DefId.
    pub def_id: DefId,

    /// Items defined in this module (DefIds of functions, types, etc.).
    pub items: [DefId],

    /// Child modules (DefIds of submodules).
    pub submodules: [DefId],

    /// Re-exported items (items visible via `pub use`).
    pub reexports: [DefId],
}

impl ModuleInfo {
    /// Create a new empty module info.
    pub fn new(def_id: DefId) -> ModuleInfo {
        ModuleInfo {
            def_id,
            items: vec![],
            submodules: vec![],
            reexports: vec![],
        }
    }

    /// Add an item to this module.
    pub fn add_item(&mut self, item_id: DefId) {
        self.items.push(item_id);
    }

    /// Add a submodule to this module.
    pub fn add_submodule(&mut self, submodule_id: DefId) {
        self.submodules.push(submodule_id);
    }

    /// Add a re-export to this module.
    pub fn add_reexport(&mut self, item_id: DefId) {
        self.reexports.push(item_id);
    }

    /// Check if this module contains an item with the given DefId.
    pub fn contains_item(&self, item_id: &DefId) -> bool {
        for id in self.items.iter() {
            if id == item_id {
                return true;
            }
        }
        false
    }

    /// Get all public items (items + reexports).
    pub fn all_public_items(&self) -> [DefId] {
        let mut result: [DefId] = vec![];
        for id in self.items.iter() {
            result.push(*id);
        };
        for id in self.reexports.iter() {
            result.push(*id);
        }
        result
    }
}

impl Clone for ModuleInfo {
    fn clone(&self) -> ModuleInfo {
        ModuleInfo {
            def_id: self.def_id,
            items: self.items.clone(),
            submodules: self.submodules.clone(),
            reexports: self.reexports.clone(),
        }
    }
}

// ============================================================================
// Module Definitions Map
// ============================================================================

/// A map from DefId to ModuleInfo.
///
/// This is the primary data structure used by the type checker to
/// look up module contents during import resolution.
pub type ModuleDefs = HashMap<DefId, ModuleInfo>;

/// Create a new empty module definitions map.
pub fn new_module_defs() -> ModuleDefs {
    HashMap::new()
}

// ============================================================================
// Builder Functions
// ============================================================================

/// Build a module tree from a project root.
///
/// This function:
/// 1. Finds the crate root file (lib.blood or main.blood)
/// 2. Parses module declarations recursively
/// 3. Builds the complete ModuleTree
///
/// # Arguments
/// * `project_root` - Path to the project directory
/// * `crate_name` - Name of the crate
///
/// # Returns
/// A tuple of (ModuleTree, list of file paths to parse)
pub fn build_module_tree(
    project_root: &str,
    crate_name: &str,
) -> Result<(ModuleTree, [String]), ResolveError> {
    let resolver = ModuleResolver::new(project_root);

    // Find the crate root
    let root_file = resolver.resolve_absolute_path(&ModulePath::crate_root())?;

    // Create the tree
    let tree = ModuleTree::new(&root_file, crate_name);

    // Return tree and list of files to parse
    // The caller should parse these files and call discover_submodules
    Ok((tree, vec![root_file]))
}

/// Discover and add submodules from parsed module declarations.
///
/// Call this after parsing a file to add any `mod foo;` declarations
/// to the module tree.
///
/// # Arguments
/// * `tree` - The module tree to update
/// * `resolver` - The module resolver
/// * `parent_id` - The module ID of the parent
/// * `parent_file` - The file path of the parent
/// * `mod_names` - Names of modules declared with `mod foo;`
/// * `visibilities` - Visibility of each module
///
/// # Returns
/// A list of (ModuleId, file_path) pairs for newly discovered modules
pub fn discover_submodules(
    tree: &mut ModuleTree,
    resolver: &ModuleResolver,
    parent_id: ModuleId,
    parent_file: &str,
    mod_names: &[String],
    visibilities: &[Visibility],
) -> Result<[(ModuleId, String)], ResolveError> {
    let mut discovered: [(ModuleId, String)] = vec![];

    let mut i: usize = 0;
    while i < mod_names.len() {
        let name = &mod_names[i];
        let visibility = if i < visibilities.len() {
            visibilities[i].clone()
        } else {
            Visibility::Private
        };

        // Resolve the module file
        let file_path = resolver.resolve_module(parent_file, name)?;

        // Add to tree
        let module_id = tree.add_child(
            parent_id,
            name,
            &file_path,
            false,  // external module
            visibility,
        ).map_err(|e| ResolveError::InvalidPath {
            message: e.message(),
        })?;

        discovered.push((module_id, file_path));
        i = i + 1;
    };

    Ok(discovered)
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_module_info_creation() {
        let def_id = DefId::new(1);
        let info = ModuleInfo::new(def_id);

        assert_eq!(info.def_id, def_id);
        assert!(info.items.is_empty());
        assert!(info.submodules.is_empty());
        assert!(info.reexports.is_empty());
    }

    #[test]
    fn test_module_info_add_items() {
        let def_id = DefId::new(1);
        let mut info = ModuleInfo::new(def_id);

        let item1 = DefId::new(10);
        let item2 = DefId::new(11);

        info.add_item(item1);
        info.add_item(item2);

        assert_eq!(info.items.len(), 2);
        assert!(info.contains_item(&item1));
        assert!(info.contains_item(&item2));
    }

    #[test]
    fn test_all_public_items() {
        let def_id = DefId::new(1);
        let mut info = ModuleInfo::new(def_id);

        let item1 = DefId::new(10);
        let reexport1 = DefId::new(20);

        info.add_item(item1);
        info.add_reexport(reexport1);

        let all = info.all_public_items();
        assert_eq!(all.len(), 2);
    }
}
