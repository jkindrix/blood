//! Module Path Representation
//!
//! This module provides the `ModulePath` type for representing hierarchical
//! module paths like `crate::foo::bar` or `std.collections.vec`.
//!
//! ## Path Syntax
//!
//! Blood uses two separators for different purposes:
//!
//! | Separator | Usage | Example |
//! |-----------|-------|---------|
//! | `.` | Module hierarchy | `std.collections.vec` |
//! | `::` | Item access within module | `Vec::new` |
//!
//! Internally, paths are normalized to use `::` for consistency with Rust.

use std.collections::{Vec};

// ============================================================================
// ModulePath
// ============================================================================

/// A hierarchical module path.
///
/// Represents paths like `crate::foo::bar` as a sequence of string segments.
/// The first segment is typically `crate` for absolute paths within the
/// current crate, or a crate name for external dependencies.
///
/// ## Examples
///
/// ```blood
/// let path = ModulePath::crate_root();           // "crate"
/// let child = path.child("utils");               // "crate::utils"
/// let grandchild = child.child("helpers");       // "crate::utils::helpers"
/// ```
pub struct ModulePath {
    /// The path segments (e.g., ["crate", "foo", "bar"])
    segments: [String],
}

impl ModulePath {
    /// Create a new module path from segments.
    pub fn new(segments: [String]) -> ModulePath {
        ModulePath { segments }
    }

    /// Create an empty module path.
    pub fn empty() -> ModulePath {
        ModulePath { segments: vec![] }
    }

    /// Create the crate root path (`crate`).
    ///
    /// This is the entry point for all paths within the current crate.
    pub fn crate_root() -> ModulePath {
        ModulePath {
            segments: vec!["crate".to_string()],
        }
    }

    /// Create a path from a single segment.
    pub fn from_name(name: String) -> ModulePath {
        ModulePath {
            segments: vec![name],
        }
    }

    /// Parse a path from a dot-separated string (e.g., "std.collections.vec").
    ///
    /// This is the format used in Blood source code for module declarations
    /// and import paths.
    pub fn from_dotted(path: &str) -> ModulePath {
        let mut segments: [String] = vec![];
        let parts = path.split(".");
        for part in parts {
            if !part.is_empty() {
                segments.push(part.to_string());
            }
        }
        ModulePath { segments }
    }

    /// Parse a path from a `::` separated string (e.g., "crate::foo::bar").
    ///
    /// This is the internal canonical format.
    pub fn from_double_colon(path: &str) -> ModulePath {
        let mut segments: [String] = vec![];
        let parts = path.split("::");
        for part in parts {
            if !part.is_empty() {
                segments.push(part.to_string());
            }
        }
        ModulePath { segments }
    }

    // ========================================================================
    // Accessors
    // ========================================================================

    /// Get the path segments.
    pub fn segments(&self) -> &[String] {
        &self.segments
    }

    /// Get the number of segments in this path.
    pub fn len(&self) -> usize {
        self.segments.len()
    }

    /// Check if this path is empty.
    pub fn is_empty(&self) -> bool {
        self.segments.is_empty()
    }

    /// Get the first segment, if any.
    pub fn first(&self) -> Option<&String> {
        if self.segments.is_empty() {
            None
        } else {
            Some(&self.segments[0])
        }
    }

    /// Get the last segment (the module's simple name).
    pub fn last(&self) -> Option<&String> {
        if self.segments.is_empty() {
            None
        } else {
            Some(&self.segments[self.segments.len() - 1])
        }
    }

    /// Get a segment by index.
    pub fn get(&self, index: usize) -> Option<&String> {
        if index < self.segments.len() {
            Some(&self.segments[index])
        } else {
            None
        }
    }

    // ========================================================================
    // Path Properties
    // ========================================================================

    /// Check if this is an absolute path (starts with "crate").
    ///
    /// Absolute paths are unambiguous within a crate. Relative paths
    /// need context to resolve.
    pub fn is_absolute(&self) -> bool {
        match self.first() {
            Some(s) => s == "crate",
            None => false,
        }
    }

    /// Check if this is a relative path (doesn't start with "crate").
    pub fn is_relative(&self) -> bool {
        !self.is_absolute()
    }

    /// Check if this is the crate root path.
    pub fn is_crate_root(&self) -> bool {
        self.segments.len() == 1 && self.is_absolute()
    }

    /// Check if this path starts with "super" (parent module reference).
    pub fn starts_with_super(&self) -> bool {
        match self.first() {
            Some(s) => s == "super",
            None => false,
        }
    }

    /// Check if this path starts with "self" (current module reference).
    pub fn starts_with_self(&self) -> bool {
        match self.first() {
            Some(s) => s == "self",
            None => false,
        }
    }

    // ========================================================================
    // Path Operations
    // ========================================================================

    /// Append a segment to this path, returning a new path.
    pub fn child(&self, name: &str) -> ModulePath {
        let mut segments = self.segments.clone();
        segments.push(name.to_string());
        ModulePath { segments }
    }

    /// Append a segment in-place.
    pub fn push(&mut self, name: String) {
        self.segments.push(name);
    }

    /// Remove and return the last segment.
    pub fn pop(&mut self) -> Option<String> {
        self.segments.pop()
    }

    /// Get the parent path (all segments except the last).
    ///
    /// Returns `None` if this path has one or fewer segments.
    pub fn parent(&self) -> Option<ModulePath> {
        if self.segments.len() <= 1 {
            None
        } else {
            let mut segments = self.segments.clone();
            segments.pop();
            Some(ModulePath { segments })
        }
    }

    /// Join this path with another, creating a longer path.
    ///
    /// If `other` is absolute, it replaces this path entirely.
    /// Otherwise, the segments of `other` are appended.
    pub fn join(&self, other: &ModulePath) -> ModulePath {
        if other.is_absolute() {
            other.clone()
        } else {
            let mut segments = self.segments.clone();
            for seg in other.segments.iter() {
                segments.push(seg.clone());
            }
            ModulePath { segments }
        }
    }

    /// Create a subpath from this path.
    ///
    /// Returns segments from `start` to `end` (exclusive).
    pub fn subpath(&self, start: usize, end: usize) -> ModulePath {
        let mut segments: [String] = vec![];
        let actual_end = if end > self.segments.len() {
            self.segments.len()
        } else {
            end
        };

        let mut i = start;
        while i < actual_end {
            segments.push(self.segments[i].clone());
            i = i + 1;
        }
        ModulePath { segments }
    }

    /// Check if this path starts with the given prefix.
    pub fn starts_with(&self, prefix: &ModulePath) -> bool {
        if prefix.len() > self.len() {
            return false;
        }

        let mut i: usize = 0;
        while i < prefix.len() {
            if self.segments[i] != prefix.segments[i] {
                return false;
            }
            i = i + 1;
        }
        true
    }

    /// Strip a prefix from this path, if present.
    ///
    /// Returns `None` if this path doesn't start with the prefix.
    pub fn strip_prefix(&self, prefix: &ModulePath) -> Option<ModulePath> {
        if !self.starts_with(prefix) {
            return None;
        }
        Some(self.subpath(prefix.len(), self.len()))
    }

    // ========================================================================
    // Formatting
    // ========================================================================

    /// Format as a `::` separated string (e.g., "crate::foo::bar").
    ///
    /// This is the canonical internal format.
    pub fn to_string(&self) -> String {
        self.segments.join("::")
    }

    /// Format as a `.` separated string (e.g., "crate.foo.bar").
    ///
    /// This matches the Blood source syntax for module declarations.
    pub fn to_dotted_string(&self) -> String {
        self.segments.join(".")
    }

    /// Format for display in error messages.
    ///
    /// Uses `::` separator for clarity.
    pub fn display(&self) -> String {
        if self.is_empty() {
            "<empty path>".to_string()
        } else {
            self.to_string()
        }
    }
}

impl Clone for ModulePath {
    fn clone(&self) -> ModulePath {
        ModulePath {
            segments: self.segments.clone(),
        }
    }
}

impl PartialEq for ModulePath {
    fn eq(&self, other: &ModulePath) -> bool {
        if self.segments.len() != other.segments.len() {
            return false;
        }

        let mut i: usize = 0;
        while i < self.segments.len() {
            if self.segments[i] != other.segments[i] {
                return false;
            }
            i = i + 1;
        }
        true
    }
}

impl Eq for ModulePath {}

// ============================================================================
// Hash Implementation for HashMap Keys
// ============================================================================

impl Hash for ModulePath {
    fn hash(&self, state: &mut Hasher) {
        for segment in self.segments.iter() {
            segment.hash(state);
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_crate_root() {
        let path = ModulePath::crate_root();
        assert_eq!(path.to_string(), "crate");
        assert!(path.is_absolute());
        assert!(path.is_crate_root());
    }

    #[test]
    fn test_child_path() {
        let path = ModulePath::crate_root();
        let child = path.child("utils");
        assert_eq!(child.to_string(), "crate::utils");

        let grandchild = child.child("helpers");
        assert_eq!(grandchild.to_string(), "crate::utils::helpers");
    }

    #[test]
    fn test_parent_path() {
        let path = ModulePath::from_double_colon("crate::foo::bar");
        let parent = path.parent().unwrap();
        assert_eq!(parent.to_string(), "crate::foo");

        let grandparent = parent.parent().unwrap();
        assert_eq!(grandparent.to_string(), "crate");

        // Crate root has no parent
        assert!(grandparent.parent().is_none());
    }

    #[test]
    fn test_from_dotted() {
        let path = ModulePath::from_dotted("std.collections.vec");
        assert_eq!(path.len(), 3);
        assert_eq!(path.segments[0], "std");
        assert_eq!(path.segments[1], "collections");
        assert_eq!(path.segments[2], "vec");
    }

    #[test]
    fn test_dotted_output() {
        let path = ModulePath::from_double_colon("crate::foo::bar");
        assert_eq!(path.to_dotted_string(), "crate.foo.bar");
    }

    #[test]
    fn test_starts_with() {
        let path = ModulePath::from_double_colon("crate::foo::bar::baz");
        let prefix = ModulePath::from_double_colon("crate::foo");

        assert!(path.starts_with(&prefix));
        assert!(!prefix.starts_with(&path));
    }

    #[test]
    fn test_strip_prefix() {
        let path = ModulePath::from_double_colon("crate::foo::bar::baz");
        let prefix = ModulePath::from_double_colon("crate::foo");

        let suffix = path.strip_prefix(&prefix).unwrap();
        assert_eq!(suffix.to_string(), "bar::baz");
    }

    #[test]
    fn test_equality() {
        let a = ModulePath::from_double_colon("crate::foo::bar");
        let b = ModulePath::from_dotted("crate.foo.bar");
        assert_eq!(a, b);
    }

    #[test]
    fn test_special_prefixes() {
        let super_path = ModulePath::from_double_colon("super::sibling");
        assert!(super_path.starts_with_super());
        assert!(!super_path.is_absolute());

        let self_path = ModulePath::from_double_colon("self::local");
        assert!(self_path.starts_with_self());
        assert!(!self_path.is_absolute());
    }
}
