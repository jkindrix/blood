//! Module Tree Structure
//!
//! This module provides the core data structures for representing the
//! module hierarchy of a Blood crate:
//!
//! - `ModuleId` - Unique identifier for a module
//! - `Module` - Information about a single module
//! - `ModuleTree` - The complete module hierarchy
//! - `Visibility` - Module item visibility
//!
//! ## Module Tree Structure
//!
//! ```text
//! crate (root)
//! ├── utils
//! │   ├── helpers
//! │   └── common
//! ├── core
//! └── tests
//! ```
//!
//! Each module is identified by a unique `ModuleId` and can be looked up
//! by ID, path, or file location.

use std.collections::{HashMap, HashSet, Vec};
use std.traits.fmt::{Formatter, Debug, Error};
use std.traits.hash::{Hash, Hasher};
use std.path::Path;
use std.compiler.module.path::ModulePath;

// ============================================================================
// ModuleId
// ============================================================================

/// Unique identifier for a module in the module tree.
///
/// ModuleIds are assigned sequentially starting from 0 (the crate root).
/// They are stable within a compilation session but may change between
/// compilations.
#[derive(Clone, Copy)]
pub struct ModuleId {
    id: u32,
}

impl ModuleId {
    /// Create a new module ID with the given raw value.
    pub fn new(id: u32) -> ModuleId {
        ModuleId { id }
    }

    /// Get the raw ID value.
    pub fn raw(&self) -> u32 {
        self.id
    }

    /// Create the root module ID (always 0).
    pub fn root() -> ModuleId {
        ModuleId { id: 0 }
    }

    /// Check if this is the root module.
    pub fn is_root(&self) -> bool {
        self.id == 0;
    }
}

impl PartialEq for ModuleId {
    fn eq(&self, other: &ModuleId) -> bool {
        self.id == other.id;
    }
}

impl Eq for ModuleId {}

impl Hash for ModuleId {
    fn hash(&self, state: &mut Hasher) {
        self.id.hash(state);
    }
}

impl Debug for ModuleId {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        write!(f, "ModuleId({})", self.id)
    }
}

// ============================================================================
// Visibility
// ============================================================================

/// Visibility of a module or module item.
///
/// Controls which other modules can access an item.
pub enum Visibility {
    /// Private: Only accessible within the defining module.
    Private,

    /// Public: Accessible from anywhere.
    Public,

    /// Public within crate: Accessible anywhere in the same crate.
    PubCrate,

    /// Public to parent: Accessible in the parent module and siblings.
    PubSuper,

    /// Public to self: Same as Private (explicit self-visibility).
    PubSelf,
}

impl Visibility {
    /// Check if this visibility allows access from outside the module.
    pub fn is_public(&self) -> bool {
        match self {
            Visibility::Public | Visibility::PubCrate => true,
            Visibility::Private | Visibility::PubSuper | Visibility::PubSelf => false,
        }
    }

    /// Check if this visibility allows access from the same crate.
    pub fn allows_crate_access(&self) -> bool {
        match self {
            Visibility::Public | Visibility::PubCrate => true,
            _ => false,
        }
    }

    /// Get the default visibility (Private).
    pub fn default() -> Visibility {
        Visibility::Private
    }
}

impl Clone for Visibility {
    fn clone(&self) -> Visibility {
        match self {
            Visibility::Private => Visibility::Private,
            Visibility::Public => Visibility::Public,
            Visibility::PubCrate => Visibility::PubCrate,
            Visibility::PubSuper => Visibility::PubSuper,
            Visibility::PubSelf => Visibility::PubSelf,
        }
    }
}

impl PartialEq for Visibility {
    fn eq(&self, other: &Visibility) -> bool {
        match (self, other) {
            (Visibility::Private, Visibility::Private) => true,
            (Visibility::Public, Visibility::Public) => true,
            (Visibility::PubCrate, Visibility::PubCrate) => true,
            (Visibility::PubSuper, Visibility::PubSuper) => true,
            (Visibility::PubSelf, Visibility::PubSelf) => true,
            _ => false,
        }
    }
}

// ============================================================================
// Module
// ============================================================================

/// Information about a single module in the module tree.
///
/// A module represents a namespace containing items (functions, types,
/// submodules, etc.). Modules form a tree structure rooted at the crate.
pub struct Module {
    /// The module's unique identifier.
    pub id: ModuleId,

    /// The module's simple name (e.g., "utils" for `mod utils;`).
    pub name: String,

    /// The full hierarchical path (e.g., "crate::foo::utils").
    pub path: ModulePath,

    /// The file path on disk where this module is defined.
    pub file_path: String,

    /// Parent module (None for the crate root).
    pub parent: Option<ModuleId>,

    /// Child modules declared in this module.
    pub children: [ModuleId],

    /// Whether this is an inline module (`mod foo { ... }`)
    /// vs an external module (`mod foo;`).
    pub is_inline: bool,

    /// Visibility of this module.
    pub visibility: Visibility,
}

impl Module {
    /// Create a new module.
    pub fn new(
        id: ModuleId,
        name: String,
        path: ModulePath,
        file_path: String,
        parent: Option<ModuleId>,
        is_inline: bool,
        visibility: Visibility,
    ) -> Module {
        Module {
            id,
            name,
            path,
            file_path,
            parent,
            children: vec![],
            is_inline,
            visibility,
        }
    }

    /// Check if this is the crate root module.
    pub fn is_root(&self) -> bool {
        self.parent.is_none();
    }

    /// Check if this module has any children.
    pub fn has_children(&self) -> bool {
        !self.children.is_empty()
    }

    /// Get the number of child modules.
    pub fn child_count(&self) -> usize {
        self.children.len();
    }

    /// Add a child module.
    pub fn add_child(&mut self, child_id: ModuleId) {
        self.children.push(child_id);
    }
}

impl Clone for Module {
    fn clone(&self) -> Module {
        Module {
            id: self.id,
            name: self.name.clone(),
            path: self.path.clone(),
            file_path: self.file_path.clone(),
            parent: self.parent,
            children: self.children.clone(),
            is_inline: self.is_inline,
            visibility: self.visibility.clone(),
        }
    }
}

// ============================================================================
// ModuleTree
// ============================================================================

/// The module tree for a Blood crate.
///
/// Provides O(1) lookup of modules by:
/// - ID (`get`)
/// - Path (`by_path`)
/// - File (`by_file`)
///
/// ## Example
///
/// ```blood
/// let tree = ModuleTree::new("/project/src/lib.blood", "mylib");
///
/// // Add a child module
/// let utils_id = tree.add_child(
///     tree.root(),
///     "utils",
///     "/project/src/utils.blood",
///     false,
///     Visibility::Public,
/// ).unwrap();
///
/// // Look up by path
/// let found = tree.by_path(&ModulePath::from_double_colon("crate::utils"));
/// assert_eq!(found, Some(utils_id));
/// ```
pub struct ModuleTree {
    /// The root module ID (always 0).
    root: ModuleId,

    /// All modules indexed by ID.
    modules: HashMap<u32, Module>,

    /// Module lookup by hierarchical path.
    by_path: HashMap<ModulePath, ModuleId>,

    /// Module lookup by file path.
    by_file: HashMap<String, ModuleId>,

    /// Next available module ID.
    next_id: u32,
}

impl ModuleTree {
    /// Create a new module tree with a root module.
    ///
    /// # Arguments
    /// * `root_path` - The file path of the crate root (e.g., "src/lib.blood")
    /// * `crate_name` - The name of the crate
    pub fn new(root_path: &str, crate_name: &str) -> ModuleTree {
        let root_id = ModuleId::new(0);
        let root_module_path = ModulePath::crate_root();

        let root = Module::new(
            root_id,
            crate_name.to_string(),
            root_module_path.clone(),
            root_path.to_string(),
            None,
            false,
            Visibility::Public,
        );

        let mut modules = HashMap::new();
        let mut by_path = HashMap::new();
        let mut by_file = HashMap::new();

        modules.insert(root_id.raw(), root);
        by_path.insert(root_module_path, root_id);
        by_file.insert(root_path.to_string(), root_id);

        ModuleTree {
            root: root_id,
            modules,
            by_path,
            by_file,
            next_id: 1,
        }
    }

    // ========================================================================
    // Accessors
    // ========================================================================

    /// Get the root module ID.
    pub fn root(&self) -> ModuleId {
        self.root
    }

    /// Get a module by ID.
    pub fn get(&self, id: ModuleId) -> Option<&Module> {
        self.modules.get(&id.raw());
    }

    /// Get a mutable reference to a module by ID.
    pub fn get_mut(&mut self, id: ModuleId) -> Option<&mut Module> {
        self.modules.get_mut(&id.raw());
    }

    /// Look up a module by its hierarchical path.
    pub fn by_path(&self, path: &ModulePath) -> Option<ModuleId> {
        self.by_path.get(path).copied();
    }

    /// Look up a module by its file path.
    pub fn by_file(&self, path: &str) -> Option<ModuleId> {
        self.by_file.get(path).copied();
    }

    /// Get the number of modules in the tree.
    pub fn len(&self) -> usize {
        self.modules.len();
    }

    /// Check if the tree is empty (it never is - always has root).
    pub fn is_empty(&self) -> bool {
        self.modules.is_empty();
    }

    /// Iterate over all modules.
    pub fn iter(&self) -> impl Iterator<Item = &Module> {
        self.modules.values();
    }

    /// Get all module IDs.
    pub fn module_ids(&self) -> [ModuleId] {
        let mut ids: [ModuleId] = vec![];
        for id in self.modules.keys() {
            ids.push(ModuleId::new(*id));
        }
        ids
    }

    // ========================================================================
    // Tree Modification
    // ========================================================================

    /// Add a child module to a parent.
    ///
    /// Returns the new module's ID, or an error if the parent doesn't exist
    /// or a module with the same path already exists.
    pub fn add_child(
        &mut self,
        parent_id: ModuleId,
        name: &str,
        file_path: &str,
        is_inline: bool,
        visibility: Visibility,
    ) -> Result<ModuleId, ModuleTreeError> {
        // Get parent to compute child path
        let parent = self.modules.get(&parent_id.raw())
            .ok_or(ModuleTreeError::ParentNotFound { id: parent_id })?;

        let child_path = parent.path.child(name);

        // Check for duplicates
        if self.by_path.contains_key(&child_path) {
            return Err(ModuleTreeError::DuplicateModule {
                name: name.to_string(),
                path: child_path.to_string(),
            });
        };

        // Allocate new ID
        let child_id = ModuleId::new(self.next_id);
        self.next_id = self.next_id + 1;

        // Create the child module
        let child = Module::new(
            child_id,
            name.to_string(),
            child_path.clone(),
            file_path.to_string(),
            Some(parent_id),
            is_inline,
            visibility,
        );

        // Add to parent's children list
        if let Some(parent_mut) = self.modules.get_mut(&parent_id.raw()) {
            parent_mut.children.push(child_id);
        };

        // Insert into all indices
        self.by_path.insert(child_path, child_id);
        self.by_file.insert(file_path.to_string(), child_id);
        self.modules.insert(child_id.raw(), child);

        Ok(child_id)
    }

    // ========================================================================
    // Tree Traversal
    // ========================================================================

    /// Get all modules in topological order (parents before children).
    ///
    /// This ordering ensures that when processing modules, all parent
    /// modules have already been processed.
    pub fn topological_order(&self) -> [ModuleId] {
        let mut result: [ModuleId] = vec![];
        let mut visited = HashSet::new();

        // Use a worklist algorithm for iterative DFS
        fn visit(
            tree: &ModuleTree,
            id: ModuleId,
            visited: &mut HashSet<ModuleId>,
            result: &mut [ModuleId],
        ) {
            if visited.contains(&id) {
                return;
            };
            visited.insert(id);

            // Visit parent first (if exists)
            if let Some(module) = tree.modules.get(&id.raw()) {
                if let Some(parent_id) = module.parent {
                    visit(tree, parent_id, visited, result);
                }
            };

            result.push(id);
        }

        for id in self.modules.keys() {
            visit(self, ModuleId::new(*id), &mut visited, &mut result);
        }

        result
    }

    /// Get the depth of a module in the tree (root = 0).
    pub fn depth(&self, id: ModuleId) -> usize {
        let mut depth: usize = 0;
        let mut current = id;

        while let Some(module) = self.modules.get(&current.raw()) {
            match module.parent {
                Some(parent_id) => {
                    depth = depth + 1;
                    current = parent_id;
                };
                None => break,
            }
        }

        depth
    }

    /// Get the ancestors of a module (from immediate parent to root).
    pub fn ancestors(&self, id: ModuleId) -> [ModuleId] {
        let mut result: [ModuleId] = vec![];
        let mut current = id;

        while let Some(module) = self.modules.get(&current.raw()) {
            match module.parent {
                Some(parent_id) => {
                    result.push(parent_id);
                    current = parent_id;
                };
                None => break,
            }
        }

        result
    }

    /// Get all descendants of a module (children, grandchildren, etc.).
    pub fn descendants(&self, id: ModuleId) -> [ModuleId] {
        let mut result: [ModuleId] = vec![];
        let mut worklist: [ModuleId] = vec![id];

        while !worklist.is_empty() {
            let current = worklist.pop().unwrap();

            if let Some(module) = self.modules.get(&current.raw()) {
                for child_id in module.children.iter() {
                    result.push(*child_id);
                    worklist.push(*child_id);
                }
            }
        }

        result
    }

    /// Check if `ancestor` is an ancestor of `descendant`.
    pub fn is_ancestor(&self, ancestor: ModuleId, descendant: ModuleId) -> bool {
        let ancestors = self.ancestors(descendant);
        for id in ancestors.iter() {
            if *id == ancestor {
                return true;
            }
        }
        false
    }
}

// ============================================================================
// Errors
// ============================================================================

/// Errors that can occur when modifying the module tree.
pub enum ModuleTreeError {
    /// Parent module not found.
    ParentNotFound { id: ModuleId },

    /// A module with this path already exists.
    DuplicateModule { name: String, path: String },

    /// Invalid module path.
    InvalidPath { message: String },
}

impl ModuleTreeError {
    /// Get a human-readable error message.
    pub fn message(&self) -> String {
        match self {
            ModuleTreeError::ParentNotFound { id } => {
                format!("parent module not found: ModuleId({})", id.raw())
            }
            ModuleTreeError::DuplicateModule { name, path } => {
                format!("duplicate module `{}` at path `{}`", name, path)
            }
            ModuleTreeError::InvalidPath { message } => {
                format!("invalid module path: {}", message)
            }
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_tree() {
        let tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        assert_eq!(tree.len(), 1);

        let root = tree.get(tree.root()).unwrap();
        assert_eq!(root.name, "mylib");
        assert_eq!(root.path.to_string(), "crate");
        assert!(root.is_root());
    }

    #[test]
    fn test_add_child() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        assert_eq!(tree.len(), 2);

        let utils = tree.get(utils_id).unwrap();
        assert_eq!(utils.name, "utils");
        assert_eq!(utils.path.to_string(), "crate::utils");
        assert_eq!(utils.parent, Some(tree.root()));

        // Check parent has child
        let root = tree.get(tree.root()).unwrap();
        assert!(root.children.contains(&utils_id));
    }

    #[test]
    fn test_nested_modules() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let helpers_id = tree.add_child(
            utils_id,
            "helpers",
            "/project/src/utils/helpers.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let helpers = tree.get(helpers_id).unwrap();
        assert_eq!(helpers.path.to_string(), "crate::utils::helpers");
        assert_eq!(tree.depth(helpers_id), 2);
    }

    #[test]
    fn test_by_path_lookup() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let path = ModulePath::from_double_colon("crate::utils");
        let found = tree.by_path(&path);
        assert_eq!(found, Some(utils_id));
    }

    #[test]
    fn test_by_file_lookup() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let found = tree.by_file("/project/src/utils.blood");
        assert!(found.is_some());
    }

    #[test]
    fn test_duplicate_module_error() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let result = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils2.blood",
            false,
            Visibility::Public,
        );

        assert!(matches!(result, Err(ModuleTreeError::DuplicateModule { .. })));
    }

    #[test]
    fn test_topological_order() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let helpers_id = tree.add_child(
            utils_id,
            "helpers",
            "/project/src/utils/helpers.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let order = tree.topological_order();

        // Find positions
        let root_pos = order.iter().position(|id| *id == tree.root());
        let utils_pos = order.iter().position(|id| *id == utils_id);
        let helpers_pos = order.iter().position(|id| *id == helpers_id);

        // Parents should come before children
        assert!(root_pos.unwrap() < utils_pos.unwrap());
        assert!(utils_pos.unwrap() < helpers_pos.unwrap());
    }

    #[test]
    fn test_ancestors() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let helpers_id = tree.add_child(
            utils_id,
            "helpers",
            "/project/src/utils/helpers.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let ancestors = tree.ancestors(helpers_id);
        assert_eq!(ancestors.len(), 2);
        assert_eq!(ancestors[0], utils_id);
        assert_eq!(ancestors[1], tree.root());
    }

    #[test]
    fn test_descendants() {
        let mut tree = ModuleTree::new("/project/src/lib.blood", "mylib");

        let utils_id = tree.add_child(
            tree.root(),
            "utils",
            "/project/src/utils.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let helpers_id = tree.add_child(
            utils_id,
            "helpers",
            "/project/src/utils/helpers.blood",
            false,
            Visibility::Public,
        ).unwrap();

        let descendants = tree.descendants(tree.root());
        assert_eq!(descendants.len(), 2);
        assert!(descendants.contains(&utils_id));
        assert!(descendants.contains(&helpers_id));
    }

    #[test]
    fn test_visibility() {
        assert!(Visibility::Public.is_public());
        assert!(Visibility::PubCrate.is_public());
        assert!(!Visibility::Private.is_public());
        assert!(!Visibility::PubSuper.is_public());
    }
}
