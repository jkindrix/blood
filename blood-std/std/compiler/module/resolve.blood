//! Module File Resolution
//!
//! This module provides the `ModuleResolver` for finding module source files
//! based on `mod` declarations.
//!
//! ## Resolution Rules
//!
//! For a declaration `mod foo;` in `src/main.blood`, the resolver searches:
//!
//! 1. `src/foo.blood` (sibling file)
//! 2. `src/foo/mod.blood` (directory with mod.blood)
//!
//! The first existing file is used. If neither exists, an error is returned.
//!
//! ## Path Convention
//!
//! Blood follows a similar convention to Rust:
//!
//! | Declaration Location | Module Name | Searched Paths |
//! |---------------------|-------------|----------------|
//! | `src/lib.blood` | `foo` | `src/foo.blood`, `src/foo/mod.blood` |
//! | `src/foo/mod.blood` | `bar` | `src/foo/bar.blood`, `src/foo/bar/mod.blood` |

use std.path::{Path, PathBuf};
use std.fs;
use super.path::ModulePath;

// ============================================================================
// ModuleResolver
// ============================================================================

/// Resolver for finding module source files.
///
/// The resolver is stateless and only performs file I/O to check for
/// file existence. This makes it thread-safe and composable.
///
/// ## Example
///
/// ```blood
/// let resolver = ModuleResolver::new("/project");
///
/// // Resolve `mod utils;` from src/lib.blood
/// let utils_path = resolver.resolve_module(
///     "/project/src/lib.blood",
///     "utils"
/// )?;
/// // Returns either "/project/src/utils.blood" or "/project/src/utils/mod.blood"
/// ```
pub struct ModuleResolver {
    /// Project root directory.
    project_root: String,

    /// Source root directory (usually project_root/src).
    source_root: String,
}

impl ModuleResolver {
    /// Create a new module resolver for a project.
    ///
    /// The source root defaults to `{project_root}/src`.
    pub fn new(project_root: &str) -> ModuleResolver {
        let source_root = format!("{}/src", project_root);
        ModuleResolver {
            project_root: project_root.to_string(),
            source_root,
        }
    }

    /// Create a resolver with a custom source root.
    ///
    /// Use this when the source directory is not the standard `src/`.
    pub fn with_source_root(project_root: &str, source_root: &str) -> ModuleResolver {
        ModuleResolver {
            project_root: project_root.to_string(),
            source_root: source_root.to_string(),
        }
    }

    // ========================================================================
    // Accessors
    // ========================================================================

    /// Get the project root directory.
    pub fn project_root(&self) -> &str {
        &self.project_root
    }

    /// Get the source root directory.
    pub fn source_root(&self) -> &str {
        &self.source_root
    }

    // ========================================================================
    // Module Resolution
    // ========================================================================

    /// Resolve a module declaration to a file path.
    ///
    /// For `mod foo;` in `parent_file`, searches:
    /// 1. `{parent_dir}/foo.blood`
    /// 2. `{parent_dir}/foo/mod.blood`
    ///
    /// # Arguments
    /// * `parent_file` - The file containing the `mod` declaration
    /// * `module_name` - The name of the module to resolve
    ///
    /// # Returns
    /// The resolved file path, or an error if not found.
    pub fn resolve_module(
        &self,
        parent_file: &str,
        module_name: &str,
    ) -> Result<String, ResolveError> {
        // Get the parent directory
        let parent_dir = self.get_parent_dir(parent_file);

        // Build candidate paths
        let file_path = format!("{}/{}.blood", parent_dir, module_name);
        let dir_path = format!("{}/{}/mod.blood", parent_dir, module_name);

        // Check which exists
        if self.file_exists(&file_path) {
            Ok(file_path)
        } else if self.file_exists(&dir_path) {
            Ok(dir_path)
        } else {
            Err(ResolveError::ModuleNotFound {
                name: module_name.to_string(),
                searched: vec![file_path, dir_path],
            })
        }
    }

    /// Resolve an absolute module path to a file.
    ///
    /// For `crate::foo::bar`, searches:
    /// 1. `src/foo/bar.blood`
    /// 2. `src/foo/bar/mod.blood`
    ///
    /// # Arguments
    /// * `path` - The absolute module path (must start with "crate")
    ///
    /// # Returns
    /// The resolved file path, or an error if not found.
    pub fn resolve_absolute_path(&self, path: &ModulePath) -> Result<String, ResolveError> {
        if path.is_empty() {
            return Err(ResolveError::InvalidPath {
                message: "empty module path".to_string(),
            });
        };

        // Get segments, skipping "crate" prefix
        let segments = path.segments();
        let start_index: usize = if segments.len() > 0 && segments[0] == "crate" {
            1
        } else {
            0
        };

        // If no segments after "crate", this is the crate root
        if start_index >= segments.len() {
            return self.find_crate_root();
        };

        // Build the directory path
        let mut dir_path = self.source_root.clone();
        let mut i = start_index;
        while i < segments.len() - 1 {
            dir_path = format!("{}/{}", dir_path, segments[i]);
            i = i + 1;
        };

        // The last segment is the module name
        let last = &segments[segments.len() - 1];
        let file_path = format!("{}/{}.blood", dir_path, last);
        let mod_path = format!("{}/{}/mod.blood", dir_path, last);

        // Check which exists
        if self.file_exists(&file_path) {
            Ok(file_path)
        } else if self.file_exists(&mod_path) {
            Ok(mod_path)
        } else {
            Err(ResolveError::ModuleNotFound {
                name: path.to_string(),
                searched: vec![file_path, mod_path],
            })
        }
    }

    /// Find the crate root file.
    ///
    /// Checks for `lib.blood` first, then `main.blood`.
    fn find_crate_root(&self) -> Result<String, ResolveError> {
        let lib_path = format!("{}/lib.blood", self.source_root);
        let main_path = format!("{}/main.blood", self.source_root);

        if self.file_exists(&lib_path) {
            Ok(lib_path)
        } else if self.file_exists(&main_path) {
            Ok(main_path)
        } else {
            Err(ResolveError::ModuleNotFound {
                name: "crate root".to_string(),
                searched: vec![lib_path, main_path],
            })
        }
    }

    // ========================================================================
    // Path Utilities
    // ========================================================================

    /// Get the parent directory of a file path.
    fn get_parent_dir(&self, file_path: &str) -> String {
        // Find the last slash
        let mut last_slash: Option<usize> = None;
        let chars: [char] = file_path.chars().collect();

        let mut i: usize = 0;
        while i < chars.len() {
            if chars[i] == '/' {
                last_slash = Some(i);
            };
            i = i + 1;
        };

        match last_slash {
            Some(pos) => {
                if pos == 0 {
                    "/".to_string()
                } else {
                    file_path[0..pos].to_string()
                }
            };
            None => ".".to_string(),
        }
    }

    /// Check if a file exists.
    fn file_exists(&self, path: &str) -> bool {
        fs::exists(path)
    }

    /// Get the file name from a path.
    pub fn file_name(&self, path: &str) -> String {
        let chars: [char] = path.chars().collect();
        let mut last_slash: Option<usize> = None;

        let mut i: usize = 0;
        while i < chars.len() {
            if chars[i] == '/' {
                last_slash = Some(i);
            };
            i = i + 1;
        };

        match last_slash {
            Some(pos) => path[pos + 1..].to_string(),
            None => path.to_string(),
        }
    }

    /// Get the module name from a file path.
    ///
    /// Extracts the module name from paths like:
    /// - `foo.blood` → `foo`
    /// - `foo/mod.blood` → `foo`
    pub fn module_name_from_file(&self, file_path: &str) -> String {
        let file_name = self.file_name(file_path);

        if file_name == "mod.blood" {
            // Get the parent directory name
            let parent = self.get_parent_dir(file_path);
            self.file_name(&parent);
        } else if file_name.ends_with(".blood") {
            // Strip the .blood extension
            file_name[0..file_name.len() - 6].to_string()
        } else {
            file_name
        }
    }

    /// Check if a path is a mod.blood file.
    pub fn is_mod_file(&self, file_path: &str) -> bool {
        let file_name = self.file_name(file_path);
        file_name == "mod.blood"
    }

    /// Check if a path is a crate root file (lib.blood or main.blood).
    pub fn is_crate_root(&self, file_path: &str) -> bool {
        let file_name = self.file_name(file_path);
        file_name == "lib.blood" || file_name == "main.blood"
    }
}

// ============================================================================
// Errors
// ============================================================================

/// Errors that can occur during module resolution.
pub enum ResolveError {
    /// Module file not found.
    ModuleNotFound {
        name: String,
        searched: [String],
    },

    /// Invalid module path.
    InvalidPath {
        message: String,
    },

    /// I/O error.
    IoError {
        message: String,
    },
}

impl ResolveError {
    /// Get a human-readable error message.
    pub fn message(&self) -> String {
        match self {
            ResolveError::ModuleNotFound { name, searched } => {
                let mut msg = format!("module not found: `{}`\n", name);
                msg = format!("{}searched:", msg);
                for path in searched.iter() {
                    msg = format!("{}\n  - {}", msg, path);
                }
                msg
            }
            ResolveError::InvalidPath { message } => {
                format!("invalid module path: {}", message)
            }
            ResolveError::IoError { message } => {
                format!("I/O error: {}", message)
            }
        }
    }

    /// Check if this is a "not found" error.
    pub fn is_not_found(&self) -> bool {
        matches!(self, ResolveError::ModuleNotFound { .. })
    }
}

impl Clone for ResolveError {
    fn clone(&self) -> ResolveError {
        match self {
            ResolveError::ModuleNotFound { name, searched } => {
                ResolveError::ModuleNotFound {
                    name: name.clone(),
                    searched: searched.clone(),
                }
            }
            ResolveError::InvalidPath { message } => {
                ResolveError::InvalidPath {
                    message: message.clone(),
                }
            }
            ResolveError::IoError { message } => {
                ResolveError::IoError {
                    message: message.clone(),
                }
            }
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_parent_dir() {
        let resolver = ModuleResolver::new("/project");

        assert_eq!(resolver.get_parent_dir("/project/src/lib.blood"), "/project/src");
        assert_eq!(resolver.get_parent_dir("/project/src/foo/mod.blood"), "/project/src/foo");
        assert_eq!(resolver.get_parent_dir("foo.blood"), ".");
        assert_eq!(resolver.get_parent_dir("/foo.blood"), "/");
    }

    #[test]
    fn test_file_name() {
        let resolver = ModuleResolver::new("/project");

        assert_eq!(resolver.file_name("/project/src/lib.blood"), "lib.blood");
        assert_eq!(resolver.file_name("/project/src/foo/mod.blood"), "mod.blood");
        assert_eq!(resolver.file_name("foo.blood"), "foo.blood");
    }

    #[test]
    fn test_module_name_from_file() {
        let resolver = ModuleResolver::new("/project");

        assert_eq!(resolver.module_name_from_file("/project/src/utils.blood"), "utils");
        assert_eq!(resolver.module_name_from_file("/project/src/utils/mod.blood"), "utils");
        assert_eq!(resolver.module_name_from_file("/project/src/lib.blood"), "lib");
    }

    #[test]
    fn test_is_mod_file() {
        let resolver = ModuleResolver::new("/project");

        assert!(resolver.is_mod_file("/project/src/utils/mod.blood"));
        assert!(!resolver.is_mod_file("/project/src/utils.blood"));
        assert!(!resolver.is_mod_file("/project/src/lib.blood"));
    }

    #[test]
    fn test_is_crate_root() {
        let resolver = ModuleResolver::new("/project");

        assert!(resolver.is_crate_root("/project/src/lib.blood"));
        assert!(resolver.is_crate_root("/project/src/main.blood"));
        assert!(!resolver.is_crate_root("/project/src/utils.blood"));
        assert!(!resolver.is_crate_root("/project/src/utils/mod.blood"));
    }

    #[test]
    fn test_error_message() {
        let err = ResolveError::ModuleNotFound {
            name: "utils".to_string(),
            searched: vec![
                "/project/src/utils.blood".to_string(),
                "/project/src/utils/mod.blood".to_string(),
            ],
        };

        let msg = err.message();
        assert!(msg.contains("utils"));
        assert!(msg.contains("utils.blood"));
        assert!(msg.contains("utils/mod.blood"));
    }
}
