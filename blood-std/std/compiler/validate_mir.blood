// Blood Self-Hosted Compiler - MIR Validation
//
// Lightweight MIR validator that checks structural invariants after
// MIR lowering and before codegen. Modeled on rustc's -Z validate-mir.
//
// Checks performed:
// 1. All basic blocks have terminators
// 2. Successor block indices are in range
// 3. Local references in places are in range
// 4. Body has at least one basic block
// 5. Return place (local _0) exists
// 6. Parameter count is consistent with locals

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;

/// Validates a MIR body and returns a list of error messages.
/// An empty list means the MIR is valid.
pub fn validate_body(body: &mir_body::MirBody, fn_name: &str) -> Vec<String> {
    let mut errors: Vec<String> = Vec::new();
    let num_locals = body.locals.len();
    let num_blocks = body.basic_blocks.len();

    // Check 1: Body must have at least one local (return place)
    if num_locals == 0 {
        let mut msg = String::new();
        msg.push_str("no locals (missing return place _0)");
        errors.push(msg);
    }

    // Check 2: Parameter count must be consistent
    let one: usize = 1;
    let param_count_usize: usize = body.param_count as usize;
    let param_end: usize = one + param_count_usize;
    if param_end > num_locals {
        let mut msg = String::new();
        msg.push_str("param_count (");
        push_usize(&mut msg, body.param_count as usize);
        msg.push_str(") exceeds local count (");
        push_usize(&mut msg, num_locals);
        msg.push(')');
        errors.push(msg);
    }

    // Check 3: Body must have at least one basic block
    if num_blocks == 0 {
        let mut msg = String::new();
        msg.push_str("no basic blocks");
        errors.push(msg);
        return errors;
    }

    // Check 4: Every block must have a terminator
    let mut bb_idx: usize = 0;
    while bb_idx < num_blocks {
        let block = &body.basic_blocks[bb_idx];
        match &block.terminator {
            &Option::Some(ref term) => {
                // Check 5: Successor block indices must be in range
                let succs = term.successors();
                let mut si: usize = 0;
                while si < succs.len() {
                    let succ_idx = succs[si].as_usize();
                    if succ_idx >= num_blocks {
                        let mut msg = String::new();
                        msg.push_str("bb");
                        push_usize(&mut msg, bb_idx);
                        msg.push_str(": successor bb");
                        push_usize(&mut msg, succ_idx);
                        msg.push_str(" out of range (");
                        push_usize(&mut msg, num_blocks);
                        msg.push_str(" blocks)");
                        errors.push(msg);
                    }
                    si = si + 1;
                }

                // Check 6: Validate terminator operand local references
                validate_terminator_locals(&mut errors, term, bb_idx, num_locals);
            }
            &Option::None => {
                let mut msg = String::new();
                msg.push_str("bb");
                push_usize(&mut msg, bb_idx);
                msg.push_str(": missing terminator");
                errors.push(msg);
            }
        }

        // Check 7: Validate statement operand local references
        let mut stmt_idx: usize = 0;
        while stmt_idx < block.statements.len() {
            validate_statement_locals(&mut errors, &block.statements[stmt_idx], bb_idx, stmt_idx, num_locals);
            stmt_idx = stmt_idx + 1;
        }

        bb_idx = bb_idx + 1;
    }

    errors
}

/// Validates that all local references in a statement are in range.
fn validate_statement_locals(
    errors: &mut Vec<String>,
    stmt: &mir_stmt::Statement,
    bb_idx: usize,
    stmt_idx: usize,
    num_locals: usize,
) {
    match &stmt.kind {
        &mir_stmt::StatementKind::Assign { ref place, ref rvalue } => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "assign dest");
            validate_rvalue_locals(errors, rvalue, bb_idx, stmt_idx, num_locals);
        }
        &mir_stmt::StatementKind::StorageLive(ref local_id) => {
            check_local_range(errors, local_id.as_usize(), bb_idx, stmt_idx, num_locals, "StorageLive");
        }
        &mir_stmt::StatementKind::StorageDead(ref local_id) => {
            check_local_range(errors, local_id.as_usize(), bb_idx, stmt_idx, num_locals, "StorageDead");
        }
        &mir_stmt::StatementKind::Drop(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Drop");
        }
        &mir_stmt::StatementKind::Deinit(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Deinit");
        }
        &mir_stmt::StatementKind::SetDiscriminant { ref place, variant_idx: _ } => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "SetDiscriminant");
        }
        &mir_stmt::StatementKind::CopyNonOverlapping { ref src, ref dst, count: _ } => {
            validate_operand_local(errors, src, bb_idx, stmt_idx, num_locals, "CopyNonOverlapping src");
            validate_operand_local(errors, dst, bb_idx, stmt_idx, num_locals, "CopyNonOverlapping dst");
        }
        &mir_stmt::StatementKind::PushHandler { handler_id: _, ref state_place, state_kind: _ } => {
            validate_place_local(errors, state_place, bb_idx, stmt_idx, num_locals, "PushHandler state");
        }
        &mir_stmt::StatementKind::PopHandler => {}
        &mir_stmt::StatementKind::PushInlineHandler { effect_id: _, operations: _ } => {}
        &mir_stmt::StatementKind::CallReturnClause {
            handler_id: _,
            handler_name: _,
            ref body_result,
            ref state_place,
            ref destination,
        } => {
            validate_operand_local(errors, body_result, bb_idx, stmt_idx, num_locals, "CallReturnClause result");
            validate_place_local(errors, state_place, bb_idx, stmt_idx, num_locals, "CallReturnClause state");
            validate_place_local(errors, destination, bb_idx, stmt_idx, num_locals, "CallReturnClause dest");
        }
        &mir_stmt::StatementKind::Nop => {}
    }
}

/// Validates that all local references in a terminator are in range.
fn validate_terminator_locals(
    errors: &mut Vec<String>,
    term: &mir_term::Terminator,
    bb_idx: usize,
    num_locals: usize,
) {
    let stmt_idx: usize = 999;
    match &term.kind {
        &mir_term::TerminatorKind::Goto { target: _ } => {}
        &mir_term::TerminatorKind::Return => {}
        &mir_term::TerminatorKind::Unreachable => {}
        &mir_term::TerminatorKind::SwitchInt { ref discr, targets: _ } => {
            validate_operand_local(errors, discr, bb_idx, stmt_idx, num_locals, "SwitchInt discr");
        }
        &mir_term::TerminatorKind::Call { ref func, ref args, ref destination, target: _, unwind: _ } => {
            validate_operand_local(errors, func, bb_idx, stmt_idx, num_locals, "Call func");
            let mut ai: usize = 0;
            while ai < args.len() {
                validate_operand_local(errors, &args[ai], bb_idx, stmt_idx, num_locals, "Call arg");
                ai = ai + 1;
            }
            validate_place_local(errors, destination, bb_idx, stmt_idx, num_locals, "Call dest");
        }
        &mir_term::TerminatorKind::Assert { ref cond, expected: _, msg: _, target: _, unwind: _ } => {
            validate_operand_local(errors, cond, bb_idx, stmt_idx, num_locals, "Assert cond");
        }
        &mir_term::TerminatorKind::Drop { ref place, target: _, unwind: _ } => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Drop");
        }
        &mir_term::TerminatorKind::Perform { effect_id: _, op_index: _, ref args, ref destination, target: _, is_tail_resumptive: _ } => {
            let mut ai: usize = 0;
            while ai < args.len() {
                validate_operand_local(errors, &args[ai], bb_idx, stmt_idx, num_locals, "Perform arg");
                ai = ai + 1;
            }
            validate_place_local(errors, destination, bb_idx, stmt_idx, num_locals, "Perform dest");
        }
        &mir_term::TerminatorKind::Resume { ref value } => {
            match value {
                &Option::Some(ref v) => {
                    validate_operand_local(errors, v, bb_idx, stmt_idx, num_locals, "Resume value");
                }
                &Option::None => {}
            }
        }
    }
}

/// Validates local references in an rvalue.
fn validate_rvalue_locals(
    errors: &mut Vec<String>,
    rvalue: &mir_types::Rvalue,
    bb_idx: usize,
    stmt_idx: usize,
    num_locals: usize,
) {
    match rvalue {
        &mir_types::Rvalue::Use(ref operand) => {
            validate_operand_local(errors, operand, bb_idx, stmt_idx, num_locals, "Use");
        }
        &mir_types::Rvalue::Ref { ref place, mutable: _ } => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Ref");
        }
        &mir_types::Rvalue::AddressOf { ref place, mutable: _ } => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "AddressOf");
        }
        &mir_types::Rvalue::BinaryOp { op: _, ref left, ref right } => {
            validate_operand_local(errors, left, bb_idx, stmt_idx, num_locals, "BinaryOp left");
            validate_operand_local(errors, right, bb_idx, stmt_idx, num_locals, "BinaryOp right");
        }
        &mir_types::Rvalue::UnaryOp { op: _, ref operand } => {
            validate_operand_local(errors, operand, bb_idx, stmt_idx, num_locals, "UnaryOp");
        }
        &mir_types::Rvalue::Cast { ref operand, target_ty: _ } => {
            validate_operand_local(errors, operand, bb_idx, stmt_idx, num_locals, "Cast");
        }
        &mir_types::Rvalue::Aggregate { kind: _, ref operands } => {
            let mut ai: usize = 0;
            while ai < operands.len() {
                validate_operand_local(errors, &operands[ai], bb_idx, stmt_idx, num_locals, "Aggregate elem");
                ai = ai + 1;
            }
        }
        &mir_types::Rvalue::Discriminant(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Discriminant");
        }
        &mir_types::Rvalue::Len(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, "Len");
        }
        &mir_types::Rvalue::ArrayToSlice { ref array_ref, array_len: _ } => {
            validate_operand_local(errors, array_ref, bb_idx, stmt_idx, num_locals, "ArrayToSlice");
        }
        &mir_types::Rvalue::ZeroInit(ref _ty) => {}
    }
}

/// Validates that a place's local is in range.
fn validate_place_local(
    errors: &mut Vec<String>,
    place: &mir_types::Place,
    bb_idx: usize,
    stmt_idx: usize,
    num_locals: usize,
    context: &str,
) {
    check_local_range(errors, place.local.as_usize(), bb_idx, stmt_idx, num_locals, context);
    // Also check Index projections
    let mut pi: usize = 0;
    while pi < place.projection.len() {
        match &place.projection[pi] {
            &mir_types::PlaceElem::Index(ref idx_local) => {
                check_local_range(errors, idx_local.as_usize(), bb_idx, stmt_idx, num_locals, "Index projection");
            }
            &mir_types::PlaceElem::Deref => {}
            &mir_types::PlaceElem::Field(_) => {}
            &mir_types::PlaceElem::ConstantIndex { offset: _, min_length: _, from_end: _ } => {}
            &mir_types::PlaceElem::Subslice { from: _, to: _, from_end: _ } => {}
            &mir_types::PlaceElem::Downcast(_) => {}
        }
        pi = pi + 1;
    }
}

/// Validates that an operand's local is in range.
fn validate_operand_local(
    errors: &mut Vec<String>,
    operand: &mir_types::Operand,
    bb_idx: usize,
    stmt_idx: usize,
    num_locals: usize,
    context: &str,
) {
    match operand {
        &mir_types::Operand::Copy(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, context);
        }
        &mir_types::Operand::Move(ref place) => {
            validate_place_local(errors, place, bb_idx, stmt_idx, num_locals, context);
        }
        &mir_types::Operand::Constant(_) => {}
    }
}

/// Checks if a local index is in range and adds an error if not.
fn check_local_range(
    errors: &mut Vec<String>,
    local_idx: usize,
    bb_idx: usize,
    stmt_idx: usize,
    num_locals: usize,
    context: &str,
) {
    if local_idx >= num_locals {
        let mut msg = String::new();
        msg.push_str("bb");
        push_usize(&mut msg, bb_idx);
        if stmt_idx < 999 {
            msg.push_str("[");
            push_usize(&mut msg, stmt_idx);
            msg.push_str("]");
        } else {
            msg.push_str("[term]");
        }
        msg.push_str(": ");
        msg.push_str(context);
        msg.push_str(" references _");
        push_usize(&mut msg, local_idx);
        msg.push_str(" but only ");
        push_usize(&mut msg, num_locals);
        msg.push_str(" locals exist");
        errors.push(msg);
    }
}

/// Helper to push a usize as decimal digits onto a String.
fn push_usize(s: &mut String, val: usize) {
    if val == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<u8> = Vec::new();
    let mut v = val;
    while v > 0 {
        let digit = (v % 10) as u8;
        digits.push(digit + 48);
        v = v / 10;
    }
    let mut i: usize = digits.len();
    while i > 0 {
        i = i - 1;
        let ch = digits[i] as char;
        s.push(ch);
    }
}
