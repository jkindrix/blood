// Blood Self-Hosted Compiler - Expression and Statement Parsing
//
// This module contains all parsing functions for expressions and statements:
// - Pratt parser for binary operators
// - Prefix expressions (unary operators)
// - Primary expressions (literals, identifiers, etc.)
// - Postfix expressions (calls, indexing, field access)
// - Control flow expressions (if, match, loop, while, for)
// - Closure expressions
// - Path and struct literal expressions
// - Statements (let, expression statements)
// - Block parsing
//
// Dependencies:
// - Type parsing is in parser_type.blood
// - Pattern parsing is in parser_pattern.blood

mod parser_base;
mod common;
mod token;
mod ast;
mod parser_type;
mod parser_pattern;

// ============================================================
// Expression Parsing
// ============================================================

/// Parse an expression.
pub fn parse_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    parse_expr_with_precedence(parser, 1)
}

/// Parse an expression without allowing struct literals.
/// Used in condition contexts to avoid ambiguity.
pub fn parse_expr_no_struct(parser: &mut parser_base::Parser) -> ast::Expr {
    let prev = parser.allow_struct_literal;
    parser.allow_struct_literal = false;
    let expr = parse_expr_with_precedence(parser, 1);
    parser.allow_struct_literal = prev;
    expr
}

/// Parse an expression with a minimum precedence level (Pratt parser).
pub fn parse_expr_with_precedence(parser: &mut parser_base::Parser, min_prec: u8) -> ast::Expr {
    // Parse prefix/primary expression
    let mut left = parse_prefix_expr(parser);

    // Parse infix expressions while precedence allows
    while !parser.is_at_end() {
        let prec = infix_precedence(parser.current.kind);
        if prec < min_prec {
            break;
        }

        left = parse_infix_expr(parser, left, prec);
    }

    left
}

/// Get the precedence of an infix operator.
fn infix_precedence(kind: token::TokenKind) -> u8 {
    match kind {
        // Assignment (right-to-left, lowest)
        token::TokenKind::Eq => 1,

        // Note: Compound assignment (+=, -=, etc.) and range (.., ..=) operators
        // are not included here. Blood lacks compound assignment operators.
        // Range operators are lexed but not used in the compiler source.
        // If needed, add them here WITH corresponding handling in parse_infix_expr
        // to prevent infinite loops in the Pratt parser.

        // Logical or
        token::TokenKind::OrOr => 3,

        // Logical and
        token::TokenKind::AndAnd => 4,

        // Comparison
        token::TokenKind::EqEq => 5,
        token::TokenKind::NotEq => 5,
        token::TokenKind::Lt => 5,
        token::TokenKind::Gt => 5,
        token::TokenKind::LtEq => 5,
        token::TokenKind::GtEq => 5,

        // Bitwise or
        token::TokenKind::Or => 6,

        // Bitwise xor
        token::TokenKind::Caret => 7,

        // Bitwise and
        token::TokenKind::And => 8,

        // Shift
        token::TokenKind::Shl => 9,
        token::TokenKind::Shr => 9,

        // Additive
        token::TokenKind::Plus => 10,
        token::TokenKind::Minus => 10,

        // Multiplicative
        token::TokenKind::Star => 11,
        token::TokenKind::Slash => 11,
        token::TokenKind::Percent => 11,

        // Cast (as)
        token::TokenKind::As => 12,

        // Postfix (call, index, field access)
        token::TokenKind::LParen => 14,
        token::TokenKind::LBracket => 14,
        token::TokenKind::Dot => 14,
        token::TokenKind::Question => 14,

        // Not an infix operator
        _ => 0,
    }
}

/// Parse a prefix expression (unary operators, primary expressions).
fn parse_prefix_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Unary minus
        token::TokenKind::Minus => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13); // Unary precedence
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Neg,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Unary not
        token::TokenKind::Not => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Not,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Dereference
        token::TokenKind::Star => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Deref,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Reference
        token::TokenKind::And => {
            parser.advance();
            let is_mut = parser.try_consume(token::TokenKind::Mut);
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            let unary_op = if is_mut { common::UnaryOp::RefMut } else { common::UnaryOp::Ref };
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: unary_op,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // All other cases fall through to primary expression
        _ => {
            return parse_primary_expr(parser);
        }
    }
}

/// Parse a primary expression (literals, identifiers, parenthesized expressions, etc.).
fn parse_primary_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Integer literal
        token::TokenKind::IntLit => {
            let int_val = parse_int_value_from_span(parser, start);
            let int_suffix = parse_int_suffix_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Int { val: int_val, suffix: int_suffix },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Float literal
        token::TokenKind::FloatLit => {
            let float_bits = parse_float_bits_from_span(parser, start);
            let float_suffix = parse_float_suffix_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Float { bits: float_bits, suffix: float_suffix },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // String literal
        token::TokenKind::StringLit => {
            let str_val = parse_string_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Str(str_val),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Char literal
        token::TokenKind::CharLit => {
            let char_val = parse_char_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Char(char_val),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Boolean literals
        token::TokenKind::True => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(true),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        token::TokenKind::False => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(false),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Parenthesized expression or tuple
        token::TokenKind::LParen => {
            return parse_paren_or_tuple_expr(parser);
        }
        // Array literal
        token::TokenKind::LBracket => {
            return parse_array_expr(parser);
        }
        // Block expression
        token::TokenKind::LBrace => {
            return parse_block_expr(parser);
        }
        // If expression
        token::TokenKind::If => {
            return parse_if_expr(parser);
        }
        // Match expression
        token::TokenKind::Match => {
            return parse_match_expr(parser);
        }
        // Loop expressions
        token::TokenKind::Loop => {
            return parse_loop_expr(parser);
        }
        token::TokenKind::While => {
            return parse_while_expr(parser);
        }
        token::TokenKind::For => {
            return parse_for_expr(parser);
        }
        // Return expression
        token::TokenKind::Return => {
            return parse_return_expr(parser);
        }
        // Break expression
        token::TokenKind::Break => {
            return parse_break_expr(parser);
        }
        // Continue expression
        token::TokenKind::Continue => {
            return parse_continue_expr(parser);
        }
        // Closure
        token::TokenKind::Pipe => {
            return parse_closure_expr(parser);
        }
        token::TokenKind::OrOr => {
            return parse_closure_expr(parser);
        }
        // Identifier or path
        token::TokenKind::Ident => {
            return parse_path_expr(parser);
        }
        token::TokenKind::TypeIdent => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfLower => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfUpper => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Crate => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Super => {
            return parse_path_expr(parser);
        }
        token::TokenKind::ColonColon => {
            return parse_path_expr(parser);
        }
        // Unsafe block: @unsafe { ... }
        token::TokenKind::AtUnsafe => {
            parser.advance();
            let block = parse_block(parser);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unsafe(block),
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Error recovery - return unit tuple as placeholder
        _ => {
            parser.error_expected("expression");
            parser.advance();
            return ast::Expr {
                kind: ast::ExprKind::Tuple(Vec::new()),
                span: start,
            };
        }
    }
}

/// Parse an infix expression.
fn parse_infix_expr(parser: &mut parser_base::Parser, left: ast::Expr, prec: u8) -> ast::Expr {
    let op_span = parser.current.span;
    let op_kind = parser.current.kind;

    match op_kind {
        // Binary operators
        token::TokenKind::Plus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Add,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Minus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Sub,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Star => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Mul,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Slash => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Div,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Percent => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Rem,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Comparison operators
        token::TokenKind::EqEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Eq,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::NotEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ne,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Lt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Lt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Gt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Gt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::LtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Le,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::GtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ge,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Logical operators
        token::TokenKind::AndAnd => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::And,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::OrOr => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Or,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Bitwise operators
        token::TokenKind::And => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitAnd,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Or => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitOr,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Caret => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitXor,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Shl => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Shl,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Shr => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Shr,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Field access or method call
        token::TokenKind::Dot => {
            parser.advance();
            let field_name = parser.parse_spanned_symbol();
            // Check if this is a method call (followed by '(')
            if parser.check(token::TokenKind::LParen) {
                // Method call: x.method(args)
                parser.advance(); // consume '('
                let mut args: Vec<ast::CallArg> = Vec::new();
                while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
                    let arg_start = parser.current.span;
                    let arg_expr = parse_expr(parser);
                    let arg_end = parser.previous.span;
                    let call_arg = ast::CallArg {
                        name: Option::None,
                        val: arg_expr,
                        span: common::Span { start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column },
                    };
                    args.push(call_arg);
                    if !parser.try_consume(token::TokenKind::Comma) {
                        break;
                    }
                }
                parser.expect(token::TokenKind::RParen);
                let end_span = parser.previous.span;
                return ast::Expr {
                    kind: ast::ExprKind::MethodCall {
                        receiver: Box::new(left),
                        method: field_name,
                        type_args: Option::None,
                        args: args,
                    },
                    span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
                };
            }
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Field {
                    base: Box::new(left),
                    field: ast::FieldAccess::Named(field_name),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Function call
        token::TokenKind::LParen => {
            return parse_call_expr(parser, left);
        }
        // Index
        token::TokenKind::LBracket => {
            return parse_index_expr(parser, left);
        }
        // Assignment (right-associative)
        token::TokenKind::Eq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Assign {
                    target: Box::new(left),
                    val: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Type cast
        token::TokenKind::As => {
            parser.advance();
            let ty = parser_type::parse_type(parser);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Cast {
                    expr: Box::new(left),
                    ty: ty,
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Try operator
        token::TokenKind::Question => {
            parser.advance();
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Try(Box::new(left)),
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        _ => {
            // Not an infix operator, return left unchanged
            return left;
        }
    }
}

// ============================================================
// Helper Expression Parsers
// ============================================================

fn parse_paren_or_tuple_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '('

    if parser.check(token::TokenKind::RParen) {
        parser.advance();
        return ast::Expr {
            kind: ast::ExprKind::Tuple(Vec::new()),
            span: common::Span { start: start.start, end: parser.previous.span.end, line: start.line, column: start.column },
        };
    }

    let first = parse_expr(parser);

    if parser.try_consume(token::TokenKind::Comma) {
        let mut elements: Vec<ast::Expr> = Vec::new();
        elements.push(first);

        while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
            elements.push(parse_expr(parser));
            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::RParen);
        let end_span = parser.previous.span;
        return ast::Expr {
            kind: ast::ExprKind::Tuple(elements),
            span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
        };
    }

    parser.expect(token::TokenKind::RParen);
    first
}

fn parse_array_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '['

    let mut elements: Vec<ast::Expr> = Vec::new();

    while !parser.check(token::TokenKind::RBracket) && !parser.is_at_end() {
        elements.push(parse_expr(parser));
        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    let array_expr = ast::ArrayExpr::List(elements);
    ast::Expr {
        kind: ast::ExprKind::Array(array_expr),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Control Flow Expression Parsers
// ============================================================

fn parse_block_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let block = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Block(block),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_if_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'if'

    let condition = parse_expr_no_struct(parser);
    let then_branch = parse_block(parser);

    let else_branch = if parser.try_consume(token::TokenKind::Else) {
        if parser.check(token::TokenKind::If) {
            Option::Some(ast::ElseBranch::If(Box::new(parse_if_expr(parser))))
        } else {
            Option::Some(ast::ElseBranch::Block(parse_block(parser)))
        }
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::If {
            condition: Box::new(condition),
            then_branch: then_branch,
            else_branch: else_branch,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_match_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'match'

    let scrutinee = parse_expr_no_struct(parser);

    parser.expect(token::TokenKind::LBrace);

    let mut arms: Vec<ast::MatchArm> = Vec::new();

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let arm_start = parser.current.span;
        let pattern = parser_pattern::parse_pattern(parser);

        let guard = if parser.try_consume(token::TokenKind::If) {
            Option::Some(parse_expr(parser))
        } else {
            Option::None
        };

        parser.expect(token::TokenKind::FatArrow);
        // For compound expressions (block, if, match, loop, while, for),
        // parse just the compound expression without entering the Pratt
        // loop. Otherwise the Pratt parser would see `&` from the next
        // arm's ref-pattern as the bitwise-AND infix operator and try to
        // extend the body expression, causing an infinite parse.
        let body = if parser.check(token::TokenKind::LBrace)
                   || parser.check(token::TokenKind::If)
                   || parser.check(token::TokenKind::Match)
                   || parser.check(token::TokenKind::Loop)
                   || parser.check(token::TokenKind::While)
                   || parser.check(token::TokenKind::For) {
            parse_prefix_expr(parser)
        } else {
            parse_expr(parser)
        };
        let arm_end = parser.previous.span;

        let arm = ast::MatchArm {
            pattern: pattern,
            guard: guard,
            body: body,
            span: common::Span { start: arm_start.start, end: arm_end.end, line: arm_start.line, column: arm_start.column },
        };
        arms.push(arm);

        // Try to consume trailing comma. Block bodies don't require one.
        if !parser.try_consume(token::TokenKind::Comma) {
            // No comma found. If previous token was '}' (block body), continue
            // parsing — block arms don't need trailing commas. Otherwise break.
            if parser.previous.kind != token::TokenKind::RBrace {
                break;
            }
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Match {
            scrutinee: Box::new(scrutinee),
            arms: arms,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_loop_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'loop'

    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Loop {
            label: Option::None,
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_while_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'while'

    let condition = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::While {
            label: Option::None,
            condition: Box::new(condition),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_for_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'for'

    let pattern = parser_pattern::parse_pattern(parser);
    parser.expect(token::TokenKind::In);
    let iter = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::For {
            label: Option::None,
            pattern: pattern,
            iter: Box::new(iter),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_return_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'return'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Return(val),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_break_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'break'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Break { label: Option::None, val: val },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_continue_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'continue'
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Continue { label: Option::None },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_closure_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    // Parse parameters
    let mut params: Vec<ast::ClosureParam> = Vec::new();

    if parser.try_consume(token::TokenKind::OrOr) {
        // Empty parameter list ||
    } else {
        parser.expect(token::TokenKind::Pipe);

        while !parser.check(token::TokenKind::Pipe) && !parser.is_at_end() {
            let param_start = parser.current.span;
            let pattern = parser_pattern::parse_pattern(parser);
            let ty = if parser.try_consume(token::TokenKind::Colon) {
                Option::Some(parser_type::parse_type(parser))
            } else {
                Option::None
            };
            let param_end = parser.previous.span;

            let param = ast::ClosureParam {
                pattern: pattern,
                ty: ty,
                span: common::Span { start: param_start.start, end: param_end.end, line: param_start.line, column: param_start.column },
            };
            params.push(param);

            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::Pipe);
    }

    // Optional return type
    let return_type = if parser.try_consume(token::TokenKind::Arrow) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    // Body
    let body = parse_expr(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Closure {
            params: params,
            return_type: return_type,
            body: Box::new(body),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Path and Struct Expression Parsers
// ============================================================

fn parse_path_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let path = parse_expr_path(parser);

    // Check for struct literal: Path { ... }
    if parser.allow_struct_literal && parser.check(token::TokenKind::LBrace) {
        // Convert ExprPath to TypePath for struct expression
        let type_path = expr_path_to_type_path(path);
        return parse_struct_expr(parser, type_path);
    }

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Path(path),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Convert an ExprPath to a TypePath (for struct expressions).
fn expr_path_to_type_path(path: ast::ExprPath) -> ast::TypePath {
    let mut segments: Vec<ast::TypePathSegment> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let type_seg = ast::TypePathSegment {
            name: seg.name,
            args: seg.args,
        };
        segments.push(type_seg);
        i = i + 1;
    }
    ast::TypePath {
        segments: segments,
        span: path.span,
    }
}

fn parse_expr_path(parser: &mut parser_base::Parser) -> ast::ExprPath {
    let start = parser.current.span;
    let mut segments: Vec<ast::ExprPathSegment> = Vec::new();

    let first_seg = parse_expr_path_segment(parser);
    segments.push(first_seg);

    while parser.try_consume(token::TokenKind::ColonColon) {
        let seg = parse_expr_path_segment(parser);
        segments.push(seg);
    }

    let end_span = parser.previous.span;
    ast::ExprPath {
        segments: segments,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_expr_path_segment(parser: &mut parser_base::Parser) -> ast::ExprPathSegment {
    let name = parser.parse_spanned_symbol();

    // Check for turbofish ::<T, U>
    let args = if parser.check(token::TokenKind::ColonColon) && parser.check_next(token::TokenKind::Lt) {
        parser.advance(); // consume ::
        Option::Some(parser_type::parse_type_args(parser))
    } else {
        Option::None
    };

    ast::ExprPathSegment { name: name, args: args }
}

fn parse_struct_expr(parser: &mut parser_base::Parser, path: ast::TypePath) -> ast::Expr {
    let start = path.span;
    parser.advance(); // consume '{'

    let mut fields: Vec<ast::RecordExprField> = Vec::new();
    let mut base: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        // Check for base: ..expr
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            base = Option::Some(Box::new(parse_expr(parser)));
            break;
        }

        let field_start = parser.current.span;
        let field_name = parser.parse_spanned_symbol();

        let val = if parser.try_consume(token::TokenKind::Colon) {
            Option::Some(parse_expr(parser))
        } else {
            // Shorthand: val is None means use the field name as the value
            Option::None
        };

        let field_end = parser.previous.span;
        let field = ast::RecordExprField {
            name: field_name,
            val: val,
            span: common::Span { start: field_start.start, end: field_end.end, line: field_start.line, column: field_start.column },
        };
        fields.push(field);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Record {
            path: Option::Some(path),
            fields: fields,
            base: base,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_call_expr(parser: &mut parser_base::Parser, callee: ast::Expr) -> ast::Expr {
    let start = callee.span;
    parser.advance(); // consume '('

    let mut args: Vec<ast::CallArg> = Vec::new();

    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        let arg_start = parser.current.span;
        let arg_expr = parse_expr(parser);
        let arg_end = parser.previous.span;
        let call_arg = ast::CallArg {
            name: Option::None,
            val: arg_expr,
            span: common::Span { start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column },
        };
        args.push(call_arg);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RParen);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Call {
            callee: Box::new(callee),
            args: args,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_index_expr(parser: &mut parser_base::Parser, base: ast::Expr) -> ast::Expr {
    let start = base.span;
    parser.advance(); // consume '['

    let idx = parse_expr(parser);
    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Index {
            base: Box::new(base),
            idx: Box::new(idx),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Statement and Block Parsing
// ============================================================

/// Parse a statement.
pub fn parse_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    // Let statement
    if parser.check(token::TokenKind::Let) {
        return parse_let_statement(parser);
    }

    // Expression statement
    let expr = parse_expr(parser);
    let has_semi = parser.try_consume(token::TokenKind::Semi);

    ast::Statement::Expr {
        expr: expr,
        has_semi: has_semi,
    }
}

/// Parse a let statement.
pub fn parse_let_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    let start = parser.current.span;
    parser.advance(); // consume 'let'

    let pattern = parser_pattern::parse_pattern(parser);

    let ty = if parser.try_consume(token::TokenKind::Colon) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    let init_val = if parser.try_consume(token::TokenKind::Eq) {
        Option::Some(parse_expr(parser))
    } else {
        Option::None
    };

    parser.expect(token::TokenKind::Semi);

    let end_span = parser.previous.span;
    ast::Statement::Let {
        pattern: pattern,
        ty: ty,
        init_val: init_val,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a block and return ast::Block directly.
pub fn parse_block(parser: &mut parser_base::Parser) -> ast::Block {
    let start = parser.current.span;
    parser.expect(token::TokenKind::LBrace);

    let mut stmts: Vec<ast::Statement> = Vec::new();
    let mut final_expr: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let stmt = parse_statement(parser);

        // Check if this is an expression without semicolon at the end of block
        match stmt {
            ast::Statement::Expr { expr, has_semi } => {
                if !has_semi && parser.check(token::TokenKind::RBrace) {
                    // This is the final expression
                    final_expr = Option::Some(Box::new(expr));
                } else {
                    let expr_stmt = ast::Statement::Expr { expr: expr, has_semi: has_semi };
                    stmts.push(expr_stmt);
                }
            }
            ast::Statement::Let { pattern, ty, init_val, span } => {
                let let_stmt = ast::Statement::Let { pattern: pattern, ty: ty, init_val: init_val, span: span };
                stmts.push(let_stmt);
            }
            ast::Statement::Item(decl) => {
                let item_stmt = ast::Statement::Item(decl);
                stmts.push(item_stmt);
            }
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Block {
        statements: stmts,
        expr: final_expr,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Literal Value Extraction from Source Text
// ============================================================

/// Parse an integer value from the source text at the given span.
/// Handles decimal, hex (0x), octal (0o), and binary (0b) formats.
/// Skips underscore separators and stops at suffix characters.
fn parse_int_value_from_span(parser: &mut parser_base::Parser, span: common::Span) -> u128 {
    let start = span.start;
    let end = span.end;
    let mut pos = start;
    let mut val: u128 = 0;
    let mut base: u128 = 10;

    // Check for 0x/0o/0b prefix
    if pos + 1 < end {
        let first = parser.source_byte_at(pos);
        let second = parser.source_byte_at(pos + 1);
        if first == 48 {
            // '0' prefix
            if second == 120 || second == 88 {
                // 'x' or 'X' — hex
                base = 16;
                pos = pos + 2;
            } else if second == 111 || second == 79 {
                // 'o' or 'O' — octal
                base = 8;
                pos = pos + 2;
            } else if second == 98 || second == 66 {
                // 'b' or 'B' — binary
                base = 2;
                pos = pos + 2;
            }
        }
    }

    // Parse digits, stop at suffix or end
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 95 {
            // Underscore separator — skip
            pos = pos + 1;
        } else if b >= 48 && b <= 57 {
            // '0'-'9'
            let digit = (b - 48) as u128;
            if digit < base {
                val = val * base + digit;
            }
            pos = pos + 1;
        } else if base == 16 && b >= 97 && b <= 102 {
            // 'a'-'f' (hex lowercase)
            let digit = (b - 97 + 10) as u128;
            val = val * base + digit;
            pos = pos + 1;
        } else if base == 16 && b >= 65 && b <= 70 {
            // 'A'-'F' (hex uppercase)
            let digit = (b - 65 + 10) as u128;
            val = val * base + digit;
            pos = pos + 1;
        } else {
            // Hit suffix or other non-digit character
            break;
        }
    }

    val
}

/// Extract the integer suffix from the source text at the given span.
/// Integer suffixes start with 'i' or 'u' (e.g., i32, u64, isize, usize).
fn parse_int_suffix_from_span(parser: &mut parser_base::Parser, span: common::Span) -> Option<ast::IntSuffix> {
    let start = span.start;
    let end = span.end;
    let mut pos = start;

    // Skip past 0x/0o/0b prefix
    if pos + 1 < end {
        let first = parser.source_byte_at(pos);
        let second = parser.source_byte_at(pos + 1);
        if first == 48 && (second == 120 || second == 88 || second == 111 || second == 79 || second == 98 || second == 66) {
            pos = pos + 2;
        }
    }

    // Skip past digits and underscores
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 95 || (b >= 48 && b <= 57) {
            // Underscore or decimal digit
            pos = pos + 1;
        } else if b >= 97 && b <= 102 {
            // Could be hex digit or start of suffix
            if b == 105 || b == 117 {
                // 'i' or 'u' — this is a suffix
                break;
            }
            pos = pos + 1;
        } else if b >= 65 && b <= 70 {
            // Uppercase hex digit
            pos = pos + 1;
        } else {
            // Non-digit, non-hex — start of suffix
            break;
        }
    }

    // Parse suffix if present
    if pos >= end {
        return Option::None;
    }

    let first = parser.source_byte_at(pos);
    let suffix_len = end - pos;

    if first == 105 {
        // 'i' prefix
        if suffix_len == 2 && parser.source_byte_at(pos + 1) == 56 {
            // "i8"
            return Option::Some(ast::IntSuffix::I8);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 54 {
            // "i16"
            return Option::Some(ast::IntSuffix::I16);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 51 && parser.source_byte_at(pos + 2) == 50 {
            // "i32"
            return Option::Some(ast::IntSuffix::I32);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 54 && parser.source_byte_at(pos + 2) == 52 {
            // "i64"
            return Option::Some(ast::IntSuffix::I64);
        }
        if suffix_len == 4 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 50 && parser.source_byte_at(pos + 3) == 56 {
            // "i128"
            return Option::Some(ast::IntSuffix::I128);
        }
        if suffix_len == 5 && parser.source_byte_at(pos + 1) == 115 && parser.source_byte_at(pos + 2) == 105 && parser.source_byte_at(pos + 3) == 122 && parser.source_byte_at(pos + 4) == 101 {
            // "isize"
            return Option::Some(ast::IntSuffix::Isize);
        }
    }

    if first == 117 {
        // 'u' prefix
        if suffix_len == 2 && parser.source_byte_at(pos + 1) == 56 {
            // "u8"
            return Option::Some(ast::IntSuffix::U8);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 54 {
            // "u16"
            return Option::Some(ast::IntSuffix::U16);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 51 && parser.source_byte_at(pos + 2) == 50 {
            // "u32"
            return Option::Some(ast::IntSuffix::U32);
        }
        if suffix_len == 3 && parser.source_byte_at(pos + 1) == 54 && parser.source_byte_at(pos + 2) == 52 {
            // "u64"
            return Option::Some(ast::IntSuffix::U64);
        }
        if suffix_len == 4 && parser.source_byte_at(pos + 1) == 49 && parser.source_byte_at(pos + 2) == 50 && parser.source_byte_at(pos + 3) == 56 {
            // "u128"
            return Option::Some(ast::IntSuffix::U128);
        }
        if suffix_len == 5 && parser.source_byte_at(pos + 1) == 115 && parser.source_byte_at(pos + 2) == 105 && parser.source_byte_at(pos + 3) == 122 && parser.source_byte_at(pos + 4) == 101 {
            // "usize"
            return Option::Some(ast::IntSuffix::Usize);
        }
    }

    Option::None
}

/// Parse a float value from the source text and return its bits as u64.
/// Parses the decimal representation and converts to IEEE 754 f64 bits.
fn parse_float_bits_from_span(parser: &mut parser_base::Parser, span: common::Span) -> u64 {
    let start = span.start;
    let end = span.end;

    // Extract the numeric part (before any suffix)
    let mut num_end = start;
    while num_end < end {
        let b = parser.source_byte_at(num_end);
        if (b >= 48 && b <= 57) || b == 46 || b == 95 || b == 101 || b == 69 || b == 43 || b == 45 {
            // digit, '.', '_', 'e', 'E', '+', '-'
            num_end = num_end + 1;
        } else {
            break;
        }
    }

    // Parse integer part
    let mut pos = start;
    let mut int_part: u64 = 0;
    while pos < num_end {
        let b = parser.source_byte_at(pos);
        if b >= 48 && b <= 57 {
            int_part = int_part * 10 + ((b - 48) as u64);
        } else if b == 46 || b == 101 || b == 69 {
            break;
        }
        // Skip underscores
        pos = pos + 1;
    }

    // Parse fractional part
    let mut frac_val: u64 = 0;
    let mut frac_digits: u32 = 0;
    if pos < num_end && parser.source_byte_at(pos) == 46 {
        pos = pos + 1;
        while pos < num_end {
            let b = parser.source_byte_at(pos);
            if b >= 48 && b <= 57 {
                frac_val = frac_val * 10 + ((b - 48) as u64);
                frac_digits = frac_digits + 1;
            } else if b == 101 || b == 69 {
                break;
            }
            // Skip underscores
            pos = pos + 1;
        }
    }

    // Parse exponent
    let mut exp: i32 = 0;
    let mut exp_neg = false;
    if pos < num_end && (parser.source_byte_at(pos) == 101 || parser.source_byte_at(pos) == 69) {
        pos = pos + 1;
        if pos < num_end && parser.source_byte_at(pos) == 45 {
            exp_neg = true;
            pos = pos + 1;
        } else if pos < num_end && parser.source_byte_at(pos) == 43 {
            pos = pos + 1;
        }
        while pos < num_end {
            let b = parser.source_byte_at(pos);
            if b >= 48 && b <= 57 {
                exp = exp * 10 + ((b - 48) as i32);
            }
            pos = pos + 1;
        }
        if exp_neg {
            exp = 0 - exp;
        }
    }

    // Convert to f64 bits
    // Simple approach: construct the value as integer_part.fractional_part * 10^exp
    // Use f64 arithmetic via bit manipulation
    // For now, use a simple decimal-to-f64 conversion
    let mut result: f64 = int_part as f64;

    // Add fractional part
    if frac_digits > 0 {
        let mut divisor: f64 = 1.0;
        let mut d: u32 = 0;
        while d < frac_digits {
            divisor = divisor * 10.0;
            d = d + 1;
        }
        result = result + (frac_val as f64) / divisor;
    }

    // Apply exponent
    if exp > 0 {
        let mut e: i32 = 0;
        while e < exp {
            result = result * 10.0;
            e = e + 1;
        }
    } else if exp < 0 {
        let mut e: i32 = exp;
        while e < 0 {
            result = result / 10.0;
            e = e + 1;
        }
    }

    // Convert f64 to bits
    @unsafe { *(&result as *const u64) }
}

/// Extract the float suffix from the source text (f32 or f64).
fn parse_float_suffix_from_span(parser: &mut parser_base::Parser, span: common::Span) -> Option<ast::FloatSuffix> {
    let end = span.end;

    // Check if span ends with f32 or f64
    if end >= span.start + 3 {
        let b0 = parser.source_byte_at(end - 3);
        let b1 = parser.source_byte_at(end - 2);
        let b2 = parser.source_byte_at(end - 1);
        if b0 == 102 {
            // 'f'
            if b1 == 51 && b2 == 50 {
                // "f32"
                return Option::Some(ast::FloatSuffix::F32);
            }
            if b1 == 54 && b2 == 52 {
                // "f64"
                return Option::Some(ast::FloatSuffix::F64);
            }
        }
    }

    Option::None
}

/// Parse a string literal from the source text (strips quotes, handles escape sequences).
fn parse_string_from_span(parser: &mut parser_base::Parser, span: common::Span) -> String {
    let start = span.start;
    let end = span.end;
    let mut result = String::new();

    // Skip opening quote
    let mut pos = start + 1;

    // Parse until closing quote
    while pos < end {
        let b = parser.source_byte_at(pos);
        if b == 34 {
            // '"' — closing quote
            break;
        }
        if b == 92 && pos + 1 < end {
            // '\' — escape sequence
            pos = pos + 1;
            let esc = parser.source_byte_at(pos);
            if esc == 110 {
                // \n
                result.push(10 as char);
            } else if esc == 116 {
                // \t
                result.push(9 as char);
            } else if esc == 114 {
                // \r
                result.push(13 as char);
            } else if esc == 92 {
                // \\
                result.push(92 as char);
            } else if esc == 34 {
                // \"
                result.push(34 as char);
            } else if esc == 48 {
                // \0
                result.push(0 as char);
            } else if esc == 39 {
                // \'
                result.push(39 as char);
            } else {
                // Unknown escape — include as-is
                result.push(92 as char);
                result.push(esc as char);
            }
        } else {
            result.push(b as char);
        }
        pos = pos + 1;
    }

    result
}

/// Parse a character literal from the source text (strips quotes, handles escapes).
fn parse_char_from_span(parser: &mut parser_base::Parser, span: common::Span) -> char {
    let start = span.start;
    let end = span.end;

    // Skip opening quote '
    let pos = start + 1;

    if pos >= end {
        return '?';
    }

    let b = parser.source_byte_at(pos);
    if b == 92 && pos + 1 < end {
        // Escape sequence
        let esc = parser.source_byte_at(pos + 1);
        if esc == 110 { return 10 as char; }       // \n
        if esc == 116 { return 9 as char; }        // \t
        if esc == 114 { return 13 as char; }       // \r
        if esc == 92 { return 92 as char; }        // \\
        if esc == 39 { return 39 as char; }        // \'
        if esc == 48 { return 0 as char; }         // \0
        if esc == 34 { return 34 as char; }        // \"
        return esc as char;
    }

    b as char
}

