// Blood Self-Hosted Compiler - Expression and Statement Parsing
//
// This module contains all parsing functions for expressions and statements:
// - Pratt parser for binary operators
// - Prefix expressions (unary operators)
// - Primary expressions (literals, identifiers, etc.)
// - Postfix expressions (calls, indexing, field access)
// - Control flow expressions (if, match, loop, while, for)
// - Closure expressions
// - Path and struct literal expressions
// - Statements (let, expression statements)
// - Block parsing
//
// Dependencies:
// - Type parsing is in parser_type.blood
// - Pattern parsing is in parser_pattern.blood

mod parser_base;
mod common;
mod token;
mod ast;
mod parser_type;
mod parser_pattern;

// ============================================================
// Expression Parsing
// ============================================================

/// Parse an expression.
pub fn parse_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    parse_expr_with_precedence(parser, 1)
}

/// Parse an expression without allowing struct literals.
/// Used in condition contexts to avoid ambiguity.
pub fn parse_expr_no_struct(parser: &mut parser_base::Parser) -> ast::Expr {
    let prev = parser.allow_struct_literal;
    parser.allow_struct_literal = false;
    let expr = parse_expr_with_precedence(parser, 1);
    parser.allow_struct_literal = prev;
    expr
}

/// Parse an expression with a minimum precedence level (Pratt parser).
pub fn parse_expr_with_precedence(parser: &mut parser_base::Parser, min_prec: u8) -> ast::Expr {
    // Parse prefix/primary expression
    let mut left = parse_prefix_expr(parser);

    // Parse infix expressions while precedence allows
    while !parser.is_at_end() {
        let prec = infix_precedence(parser.current.kind);
        if prec < min_prec {
            break;
        }

        left = parse_infix_expr(parser, left, prec);
    }

    left
}

/// Get the precedence of an infix operator.
fn infix_precedence(kind: token::TokenKind) -> u8 {
    match kind {
        // Assignment (right-to-left, lowest)
        token::TokenKind::Eq => 1,
        token::TokenKind::PlusEq => 1,
        token::TokenKind::MinusEq => 1,
        token::TokenKind::StarEq => 1,
        token::TokenKind::SlashEq => 1,
        token::TokenKind::PercentEq => 1,
        token::TokenKind::AndEq => 1,
        token::TokenKind::OrEq => 1,
        token::TokenKind::CaretEq => 1,
        token::TokenKind::ShlEq => 1,
        token::TokenKind::ShrEq => 1,

        // Range
        token::TokenKind::DotDot => 2,
        token::TokenKind::DotDotEq => 2,

        // Logical or
        token::TokenKind::OrOr => 3,

        // Logical and
        token::TokenKind::AndAnd => 4,

        // Comparison
        token::TokenKind::EqEq => 5,
        token::TokenKind::NotEq => 5,
        token::TokenKind::Lt => 5,
        token::TokenKind::Gt => 5,
        token::TokenKind::LtEq => 5,
        token::TokenKind::GtEq => 5,

        // Bitwise or
        token::TokenKind::Or => 6,

        // Bitwise xor
        token::TokenKind::Caret => 7,

        // Bitwise and
        token::TokenKind::And => 8,

        // Shift
        token::TokenKind::Shl => 9,
        token::TokenKind::Shr => 9,

        // Additive
        token::TokenKind::Plus => 10,
        token::TokenKind::Minus => 10,

        // Multiplicative
        token::TokenKind::Star => 11,
        token::TokenKind::Slash => 11,
        token::TokenKind::Percent => 11,

        // Cast (as)
        token::TokenKind::As => 12,

        // Postfix (call, index, field access)
        token::TokenKind::LParen => 14,
        token::TokenKind::LBracket => 14,
        token::TokenKind::Dot => 14,
        token::TokenKind::Question => 14,

        // Not an infix operator
        _ => 0,
    }
}

/// Parse a prefix expression (unary operators, primary expressions).
fn parse_prefix_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Unary minus
        token::TokenKind::Minus => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13); // Unary precedence
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Neg,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Unary not
        token::TokenKind::Not => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Not,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Dereference
        token::TokenKind::Star => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Deref,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Reference
        token::TokenKind::And => {
            parser.advance();
            let is_mut = parser.try_consume(token::TokenKind::Mut);
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            let unary_op = if is_mut { common::UnaryOp::RefMut } else { common::UnaryOp::Ref };
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: unary_op,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // All other cases fall through to primary expression
        _ => {
            return parse_primary_expr(parser);
        }
    }
}

/// Parse a primary expression (literals, identifiers, parenthesized expressions, etc.).
fn parse_primary_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Integer literal
        token::TokenKind::IntLit => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Int { val: 0, suffix: Option::None },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Float literal
        token::TokenKind::FloatLit => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Float { bits: 0, suffix: Option::None },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // String literal
        token::TokenKind::StringLit => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Str(String::new()),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Char literal
        token::TokenKind::CharLit => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Char('?'),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Boolean literals
        token::TokenKind::True => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(true),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        token::TokenKind::False => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(false),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Parenthesized expression or tuple
        token::TokenKind::LParen => {
            return parse_paren_or_tuple_expr(parser);
        }
        // Array literal
        token::TokenKind::LBracket => {
            return parse_array_expr(parser);
        }
        // Block expression
        token::TokenKind::LBrace => {
            return parse_block_expr(parser);
        }
        // If expression
        token::TokenKind::If => {
            return parse_if_expr(parser);
        }
        // Match expression
        token::TokenKind::Match => {
            return parse_match_expr(parser);
        }
        // Loop expressions
        token::TokenKind::Loop => {
            return parse_loop_expr(parser);
        }
        token::TokenKind::While => {
            return parse_while_expr(parser);
        }
        token::TokenKind::For => {
            return parse_for_expr(parser);
        }
        // Return expression
        token::TokenKind::Return => {
            return parse_return_expr(parser);
        }
        // Break expression
        token::TokenKind::Break => {
            return parse_break_expr(parser);
        }
        // Continue expression
        token::TokenKind::Continue => {
            return parse_continue_expr(parser);
        }
        // Closure
        token::TokenKind::Pipe => {
            return parse_closure_expr(parser);
        }
        token::TokenKind::OrOr => {
            return parse_closure_expr(parser);
        }
        // Identifier or path
        token::TokenKind::Ident => {
            return parse_path_expr(parser);
        }
        token::TokenKind::TypeIdent => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfLower => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfUpper => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Crate => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Super => {
            return parse_path_expr(parser);
        }
        token::TokenKind::ColonColon => {
            return parse_path_expr(parser);
        }
        // Error recovery - return unit tuple as placeholder
        _ => {
            parser.error_expected("expression");
            parser.advance();
            return ast::Expr {
                kind: ast::ExprKind::Tuple(Vec::new()),
                span: start,
            };
        }
    }
}

/// Parse an infix expression.
fn parse_infix_expr(parser: &mut parser_base::Parser, left: ast::Expr, prec: u8) -> ast::Expr {
    let op_span = parser.current.span;
    let op_kind = parser.current.kind;

    match op_kind {
        // Binary operators
        token::TokenKind::Plus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Add,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Minus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Sub,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Star => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Mul,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Slash => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Div,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Percent => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Rem,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Comparison operators
        token::TokenKind::EqEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Eq,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::NotEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ne,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Lt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Lt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Gt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Gt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::LtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Le,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::GtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ge,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Logical operators
        token::TokenKind::AndAnd => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::And,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::OrOr => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Or,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Field access
        token::TokenKind::Dot => {
            parser.advance();
            let field_name = parser.parse_spanned_symbol();
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Field {
                    base: Box::new(left),
                    field: ast::FieldAccess::Named(field_name),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Function call
        token::TokenKind::LParen => {
            return parse_call_expr(parser, left);
        }
        // Index
        token::TokenKind::LBracket => {
            return parse_index_expr(parser, left);
        }
        // Assignment (right-associative)
        token::TokenKind::Eq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Assign {
                    target: Box::new(left),
                    val: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Type cast
        token::TokenKind::As => {
            parser.advance();
            let ty = parser_type::parse_type(parser);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Cast {
                    expr: Box::new(left),
                    ty: ty,
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Try operator
        token::TokenKind::Question => {
            parser.advance();
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Try(Box::new(left)),
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        _ => {
            // Not an infix operator, return left unchanged
            return left;
        }
    }
}

// ============================================================
// Helper Expression Parsers
// ============================================================

fn parse_paren_or_tuple_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '('

    if parser.check(token::TokenKind::RParen) {
        parser.advance();
        return ast::Expr {
            kind: ast::ExprKind::Tuple(Vec::new()),
            span: common::Span { start: start.start, end: parser.previous.span.end, line: start.line, column: start.column },
        };
    }

    let first = parse_expr(parser);

    if parser.try_consume(token::TokenKind::Comma) {
        let mut elements: Vec<ast::Expr> = Vec::new();
        elements.push(first);

        while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
            elements.push(parse_expr(parser));
            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::RParen);
        let end_span = parser.previous.span;
        return ast::Expr {
            kind: ast::ExprKind::Tuple(elements),
            span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
        };
    }

    parser.expect(token::TokenKind::RParen);
    first
}

fn parse_array_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '['

    let mut elements: Vec<ast::Expr> = Vec::new();

    while !parser.check(token::TokenKind::RBracket) && !parser.is_at_end() {
        elements.push(parse_expr(parser));
        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    let array_expr = ast::ArrayExpr::List(elements);
    ast::Expr {
        kind: ast::ExprKind::Array(array_expr),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Control Flow Expression Parsers
// ============================================================

fn parse_block_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let block = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Block(block),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_if_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'if'

    let condition = parse_expr_no_struct(parser);
    let then_branch = parse_block(parser);

    let else_branch = if parser.try_consume(token::TokenKind::Else) {
        if parser.check(token::TokenKind::If) {
            Option::Some(ast::ElseBranch::If(Box::new(parse_if_expr(parser))))
        } else {
            Option::Some(ast::ElseBranch::Block(parse_block(parser)))
        }
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::If {
            condition: Box::new(condition),
            then_branch: then_branch,
            else_branch: else_branch,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_match_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'match'

    let scrutinee = parse_expr_no_struct(parser);

    parser.expect(token::TokenKind::LBrace);

    let mut arms: Vec<ast::MatchArm> = Vec::new();

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let arm_start = parser.current.span;
        let pattern = parser_pattern::parse_pattern(parser);

        let guard = if parser.try_consume(token::TokenKind::If) {
            Option::Some(parse_expr(parser))
        } else {
            Option::None
        };

        parser.expect(token::TokenKind::FatArrow);
        let body = parse_expr(parser);
        let arm_end = parser.previous.span;

        let arm = ast::MatchArm {
            pattern: pattern,
            guard: guard,
            body: body,
            span: common::Span { start: arm_start.start, end: arm_end.end, line: arm_start.line, column: arm_start.column },
        };
        arms.push(arm);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Match {
            scrutinee: Box::new(scrutinee),
            arms: arms,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_loop_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'loop'

    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Loop {
            label: Option::None,
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_while_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'while'

    let condition = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::While {
            label: Option::None,
            condition: Box::new(condition),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_for_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'for'

    let pattern = parser_pattern::parse_pattern(parser);
    parser.expect(token::TokenKind::In);
    let iter = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::For {
            label: Option::None,
            pattern: pattern,
            iter: Box::new(iter),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_return_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'return'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Return(val),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_break_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'break'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Break { label: Option::None, val: val },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_continue_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'continue'
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Continue { label: Option::None },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_closure_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    // Parse parameters
    let mut params: Vec<ast::ClosureParam> = Vec::new();

    if parser.try_consume(token::TokenKind::OrOr) {
        // Empty parameter list ||
    } else {
        parser.expect(token::TokenKind::Pipe);

        while !parser.check(token::TokenKind::Pipe) && !parser.is_at_end() {
            let param_start = parser.current.span;
            let pattern = parser_pattern::parse_pattern(parser);
            let ty = if parser.try_consume(token::TokenKind::Colon) {
                Option::Some(parser_type::parse_type(parser))
            } else {
                Option::None
            };
            let param_end = parser.previous.span;

            let param = ast::ClosureParam {
                pattern: pattern,
                ty: ty,
                span: common::Span { start: param_start.start, end: param_end.end, line: param_start.line, column: param_start.column },
            };
            params.push(param);

            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::Pipe);
    }

    // Optional return type
    let return_type = if parser.try_consume(token::TokenKind::Arrow) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    // Body
    let body = parse_expr(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Closure {
            params: params,
            return_type: return_type,
            body: Box::new(body),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Path and Struct Expression Parsers
// ============================================================

fn parse_path_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let path = parse_expr_path(parser);

    // Check for struct literal: Path { ... }
    if parser.allow_struct_literal && parser.check(token::TokenKind::LBrace) {
        // Convert ExprPath to TypePath for struct expression
        let type_path = expr_path_to_type_path(path);
        return parse_struct_expr(parser, type_path);
    }

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Path(path),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Convert an ExprPath to a TypePath (for struct expressions).
fn expr_path_to_type_path(path: ast::ExprPath) -> ast::TypePath {
    let mut segments: Vec<ast::TypePathSegment> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let type_seg = ast::TypePathSegment {
            name: seg.name,
            args: seg.args,
        };
        segments.push(type_seg);
        i = i + 1;
    }
    ast::TypePath {
        segments: segments,
        span: path.span,
    }
}

fn parse_expr_path(parser: &mut parser_base::Parser) -> ast::ExprPath {
    let start = parser.current.span;
    let mut segments: Vec<ast::ExprPathSegment> = Vec::new();

    let first_seg = parse_expr_path_segment(parser);
    segments.push(first_seg);

    while parser.try_consume(token::TokenKind::ColonColon) {
        let seg = parse_expr_path_segment(parser);
        segments.push(seg);
    }

    let end_span = parser.previous.span;
    ast::ExprPath {
        segments: segments,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_expr_path_segment(parser: &mut parser_base::Parser) -> ast::ExprPathSegment {
    let name = parser.parse_spanned_symbol();

    // Check for turbofish ::<T, U>
    let args = if parser.check(token::TokenKind::ColonColon) && parser.check_next(token::TokenKind::Lt) {
        parser.advance(); // consume ::
        Option::Some(parser_type::parse_type_args(parser))
    } else {
        Option::None
    };

    ast::ExprPathSegment { name: name, args: args }
}

fn parse_struct_expr(parser: &mut parser_base::Parser, path: ast::TypePath) -> ast::Expr {
    let start = path.span;
    parser.advance(); // consume '{'

    let mut fields: Vec<ast::RecordExprField> = Vec::new();
    let mut base: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        // Check for base: ..expr
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            base = Option::Some(Box::new(parse_expr(parser)));
            break;
        }

        let field_start = parser.current.span;
        let field_name = parser.parse_spanned_symbol();

        let val = if parser.try_consume(token::TokenKind::Colon) {
            Option::Some(parse_expr(parser))
        } else {
            // Shorthand: val is None means use the field name as the value
            Option::None
        };

        let field_end = parser.previous.span;
        let field = ast::RecordExprField {
            name: field_name,
            val: val,
            span: common::Span { start: field_start.start, end: field_end.end, line: field_start.line, column: field_start.column },
        };
        fields.push(field);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Record {
            path: Option::Some(path),
            fields: fields,
            base: base,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_call_expr(parser: &mut parser_base::Parser, callee: ast::Expr) -> ast::Expr {
    let start = callee.span;
    parser.advance(); // consume '('

    let mut args: Vec<ast::CallArg> = Vec::new();

    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        let arg_start = parser.current.span;
        let arg_expr = parse_expr(parser);
        let arg_end = parser.previous.span;
        let call_arg = ast::CallArg {
            name: Option::None,
            val: arg_expr,
            span: common::Span { start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column },
        };
        args.push(call_arg);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RParen);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Call {
            callee: Box::new(callee),
            args: args,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_index_expr(parser: &mut parser_base::Parser, base: ast::Expr) -> ast::Expr {
    let start = base.span;
    parser.advance(); // consume '['

    let idx = parse_expr(parser);
    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Index {
            base: Box::new(base),
            idx: Box::new(idx),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Statement and Block Parsing
// ============================================================

/// Parse a statement.
pub fn parse_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    // Let statement
    if parser.check(token::TokenKind::Let) {
        return parse_let_statement(parser);
    }

    // Expression statement
    let expr = parse_expr(parser);
    let has_semi = parser.try_consume(token::TokenKind::Semi);

    ast::Statement::Expr {
        expr: expr,
        has_semi: has_semi,
    }
}

/// Parse a let statement.
pub fn parse_let_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    let start = parser.current.span;
    parser.advance(); // consume 'let'

    let pattern = parser_pattern::parse_pattern(parser);

    let ty = if parser.try_consume(token::TokenKind::Colon) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    let init_val = if parser.try_consume(token::TokenKind::Eq) {
        Option::Some(parse_expr(parser))
    } else {
        Option::None
    };

    parser.expect(token::TokenKind::Semi);

    let end_span = parser.previous.span;
    ast::Statement::Let {
        pattern: pattern,
        ty: ty,
        init_val: init_val,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a block and return ast::Block directly.
pub fn parse_block(parser: &mut parser_base::Parser) -> ast::Block {
    let start = parser.current.span;
    parser.expect(token::TokenKind::LBrace);

    let mut stmts: Vec<ast::Statement> = Vec::new();
    let mut final_expr: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let stmt = parse_statement(parser);

        // Check if this is an expression without semicolon at the end of block
        match stmt {
            ast::Statement::Expr { expr, has_semi } => {
                if !has_semi && parser.check(token::TokenKind::RBrace) {
                    // This is the final expression
                    final_expr = Option::Some(Box::new(expr));
                } else {
                    let expr_stmt = ast::Statement::Expr { expr: expr, has_semi: has_semi };
                    stmts.push(expr_stmt);
                }
            }
            ast::Statement::Let { pattern, ty, init_val, span } => {
                let let_stmt = ast::Statement::Let { pattern: pattern, ty: ty, init_val: init_val, span: span };
                stmts.push(let_stmt);
            }
            ast::Statement::Item(decl) => {
                let item_stmt = ast::Statement::Item(decl);
                stmts.push(item_stmt);
            }
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Block {
        statements: stmts,
        expr: final_expr,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}
