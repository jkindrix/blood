// Blood Self-Hosted Compiler - Expression and Statement Parsing
//
// This module contains all parsing functions for expressions and statements:
// - Pratt parser for binary operators
// - Prefix expressions (unary operators)
// - Primary expressions (literals, identifiers, etc.)
// - Postfix expressions (calls, indexing, field access)
// - Control flow expressions (if, match, loop, while, for)
// - Closure expressions
// - Path and struct literal expressions
// - Statements (let, expression statements)
// - Block parsing
//
// Dependencies:
// - Type parsing is in parser_type.blood
// - Pattern parsing is in parser_pattern.blood

mod parser_base;
mod common;
mod token;
mod ast;
mod parser_type;
mod parser_pattern;

// ============================================================
// Expression Parsing
// ============================================================

/// Parse an expression.
pub fn parse_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    parse_expr_with_precedence(parser, 1)
}

/// Parse an expression without allowing struct literals.
/// Used in condition contexts to avoid ambiguity.
pub fn parse_expr_no_struct(parser: &mut parser_base::Parser) -> ast::Expr {
    let prev = parser.allow_struct_literal;
    parser.allow_struct_literal = false;
    let expr = parse_expr_with_precedence(parser, 1);
    parser.allow_struct_literal = prev;
    expr
}

/// Returns true if the expression is block-like (ends with a `}`).
/// Used to prevent treating `(` after block-like expressions as function calls.
fn is_block_like_expr(expr: &ast::Expr) -> bool {
    match &expr.kind {
        &ast::ExprKind::Block(ref _b) => true,
        &ast::ExprKind::If { condition: _, then_branch: _, else_branch: _ } => true,
        &ast::ExprKind::IfLet { pattern: _, scrutinee: _, then_branch: _, else_branch: _ } => true,
        &ast::ExprKind::Match { scrutinee: _, arms: _ } => true,
        &ast::ExprKind::Loop { label: _, body: _ } => true,
        &ast::ExprKind::While { label: _, condition: _, body: _ } => true,
        &ast::ExprKind::WhileLet { label: _, pattern: _, scrutinee: _, body: _ } => true,
        &ast::ExprKind::For { label: _, pattern: _, iter: _, body: _ } => true,
        &ast::ExprKind::Unsafe(ref _b) => true,
        _ => false,
    }
}

/// Parse an expression with a minimum precedence level (Pratt parser).
pub fn parse_expr_with_precedence(parser: &mut parser_base::Parser, min_prec: u8) -> ast::Expr {
    // Parse prefix/primary expression
    let mut left = parse_prefix_expr(parser);

    // Parse infix expressions while precedence allows
    while !parser.is_at_end() {
        let prec = infix_precedence(parser.current.kind);
        if prec < min_prec {
            break;
        }

        // Do not treat '(' or '[' as call/index after block-like expressions.
        // This prevents parsing `while { ... }(tuple)` as a call.
        if is_block_like_expr(&left) {
            match parser.current.kind {
                token::TokenKind::LParen => { break; }
                token::TokenKind::LBracket => { break; }
                _ => {}
            }
        }

        left = parse_infix_expr(parser, left, prec);
    }

    left
}

/// Get the precedence of an infix operator.
fn infix_precedence(kind: token::TokenKind) -> u8 {
    match kind {
        // Assignment (right-to-left, lowest)
        token::TokenKind::Eq => 1,

        // Note: Compound assignment (+=, -=, etc.) and range (.., ..=) operators
        // are not included here. Blood lacks compound assignment operators.
        // Range operators are lexed but not used in the compiler source.
        // If needed, add them here WITH corresponding handling in parse_infix_expr
        // to prevent infinite loops in the Pratt parser.

        // Logical or
        token::TokenKind::OrOr => 3,

        // Logical and
        token::TokenKind::AndAnd => 4,

        // Comparison
        token::TokenKind::EqEq => 5,
        token::TokenKind::NotEq => 5,
        token::TokenKind::Lt => 5,
        token::TokenKind::Gt => 5,
        token::TokenKind::LtEq => 5,
        token::TokenKind::GtEq => 5,

        // Bitwise or
        token::TokenKind::Or => 6,

        // Bitwise xor
        token::TokenKind::Caret => 7,

        // Bitwise and
        token::TokenKind::And => 8,

        // Shift
        token::TokenKind::Shl => 9,
        token::TokenKind::Shr => 9,

        // Additive
        token::TokenKind::Plus => 10,
        token::TokenKind::Minus => 10,

        // Multiplicative
        token::TokenKind::Star => 11,
        token::TokenKind::Slash => 11,
        token::TokenKind::Percent => 11,

        // Cast (as)
        token::TokenKind::As => 12,

        // Postfix (call, index, field access)
        token::TokenKind::LParen => 14,
        token::TokenKind::LBracket => 14,
        token::TokenKind::Dot => 14,
        token::TokenKind::Question => 14,

        // Not an infix operator
        _ => 0,
    }
}

/// Parse a prefix expression (unary operators, primary expressions).
fn parse_prefix_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Unary minus
        token::TokenKind::Minus => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13); // Unary precedence
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Neg,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Unary not
        token::TokenKind::Not => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Not,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Dereference
        token::TokenKind::Star => {
            parser.advance();
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: common::UnaryOp::Deref,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Reference
        token::TokenKind::And => {
            parser.advance();
            let is_mut = parser.try_consume(token::TokenKind::Mut);
            let operand = parse_expr_with_precedence(parser, 13);
            let end_span = parser.previous.span;
            let unary_op = if is_mut { common::UnaryOp::RefMut } else { common::UnaryOp::Ref };
            return ast::Expr {
                kind: ast::ExprKind::Unary {
                    op: unary_op,
                    operand: Box::new(operand),
                },
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // All other cases fall through to primary expression
        _ => {
            return parse_primary_expr(parser);
        }
    }
}

/// Parse a primary expression (literals, identifiers, parenthesized expressions, etc.).
fn parse_primary_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    match parser.current.kind {
        // Integer literal
        token::TokenKind::IntLit => {
            let int_val = parser_base::parse_int_value_from_span(parser, start);
            let int_suffix = parser_base::parse_int_suffix_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Int { val: int_val, suffix: int_suffix },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Float literal
        token::TokenKind::FloatLit => {
            let float_bits = parser_base::parse_float_bits_from_span(parser, start);
            let float_suffix = parser_base::parse_float_suffix_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Float { bits: float_bits, suffix: float_suffix },
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // String literal
        token::TokenKind::StringLit => {
            let str_val = parser_base::parse_string_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Str(str_val),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Char literal
        token::TokenKind::CharLit => {
            let char_val = parser_base::parse_char_from_span(parser, start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Char(char_val),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Boolean literals
        token::TokenKind::True => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(true),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        token::TokenKind::False => {
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(false),
                span: start,
            };
            return ast::Expr {
                kind: ast::ExprKind::Literal(lit),
                span: start,
            };
        }
        // Parenthesized expression or tuple
        token::TokenKind::LParen => {
            return parse_paren_or_tuple_expr(parser);
        }
        // Array literal
        token::TokenKind::LBracket => {
            return parse_array_expr(parser);
        }
        // Block expression
        token::TokenKind::LBrace => {
            return parse_block_expr(parser);
        }
        // If expression
        token::TokenKind::If => {
            return parse_if_expr(parser);
        }
        // Match expression
        token::TokenKind::Match => {
            return parse_match_expr(parser);
        }
        // Loop expressions
        token::TokenKind::Loop => {
            return parse_loop_expr(parser);
        }
        token::TokenKind::While => {
            return parse_while_expr(parser);
        }
        token::TokenKind::For => {
            return parse_for_expr(parser);
        }
        // Return expression
        token::TokenKind::Return => {
            return parse_return_expr(parser);
        }
        // Break expression
        token::TokenKind::Break => {
            return parse_break_expr(parser);
        }
        // Continue expression
        token::TokenKind::Continue => {
            return parse_continue_expr(parser);
        }
        // Closure
        token::TokenKind::Or => {
            return parse_closure_expr(parser);
        }
        token::TokenKind::OrOr => {
            return parse_closure_expr(parser);
        }
        // Identifier or path
        token::TokenKind::Ident => {
            return parse_path_expr(parser);
        }
        token::TokenKind::TypeIdent => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfLower => {
            return parse_path_expr(parser);
        }
        token::TokenKind::SelfUpper => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Crate => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Super => {
            return parse_path_expr(parser);
        }
        token::TokenKind::ColonColon => {
            return parse_path_expr(parser);
        }
        // Keywords that can be used as identifiers in expression position
        token::TokenKind::Default => {
            return parse_path_expr(parser);
        }
        token::TokenKind::Handle => {
            return parse_path_expr(parser);
        }
        // Unsafe block: @unsafe { ... }
        token::TokenKind::AtUnsafe => {
            parser.advance();
            let block = parse_block(parser);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Unsafe(block),
                span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
            };
        }
        // Effect expressions
        token::TokenKind::Perform => {
            return parse_perform_expr(parser);
        }
        token::TokenKind::Resume => {
            return parse_resume_expr(parser);
        }
        token::TokenKind::With => {
            return parse_with_handle_expr(parser);
        }
        token::TokenKind::Try => {
            return parse_try_with_expr(parser);
        }
        token::TokenKind::Region => {
            return parse_region_expr(parser);
        }
        // Error recovery - return unit tuple as placeholder
        _ => {
            parser.error_expected("expression");
            parser.advance();
            return ast::Expr {
                kind: ast::ExprKind::Tuple(Vec::new()),
                span: start,
            };
        }
    }
}

/// Parse an infix expression.
fn parse_infix_expr(parser: &mut parser_base::Parser, left: ast::Expr, prec: u8) -> ast::Expr {
    let op_span = parser.current.span;
    let op_kind = parser.current.kind;

    match op_kind {
        // Binary operators
        token::TokenKind::Plus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Add,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Minus => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Sub,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Star => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Mul,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Slash => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Div,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Percent => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Rem,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Comparison operators
        token::TokenKind::EqEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Eq,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::NotEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ne,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Lt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Lt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Gt => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Gt,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::LtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Le,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::GtEq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Ge,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Logical operators
        token::TokenKind::AndAnd => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::And,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::OrOr => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Or,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Bitwise operators
        token::TokenKind::And => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitAnd,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Or => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitOr,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Caret => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::BitXor,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Shl => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Shl,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        token::TokenKind::Shr => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec + 1);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Binary {
                    op: common::BinOp::Shr,
                    left: Box::new(left),
                    right: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Field access or method call
        token::TokenKind::Dot => {
            parser.advance();
            // Check for tuple index access (e.g., expr.0, expr.1)
            if parser.check(token::TokenKind::IntLit) {
                let idx_span = parser.current.span;
                let idx_val = parser_base::parse_int_value_from_span(parser, idx_span) as u32;
                parser.advance();
                let end_span = parser.previous.span;
                return ast::Expr {
                    kind: ast::ExprKind::Field {
                        base: Box::new(left),
                        field: ast::FieldAccess::Index(idx_val, idx_span),
                    },
                    span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
                };
            }
            let field_name = parser.parse_spanned_symbol();
            // Check if this is a method call (followed by '(')
            if parser.check(token::TokenKind::LParen) {
                // Method call: x.method(args)
                parser.advance(); // consume '('
                let mut args: Vec<ast::CallArg> = Vec::new();
                while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
                    let arg_start = parser.current.span;
                    let arg_expr = parse_expr(parser);
                    let arg_end = parser.previous.span;
                    let call_arg = ast::CallArg {
                        name: Option::None,
                        val: arg_expr,
                        span: common::Span { start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column },
                    };
                    args.push(call_arg);
                    if !parser.try_consume(token::TokenKind::Comma) {
                        break;
                    }
                }
                parser.expect(token::TokenKind::RParen);
                let end_span = parser.previous.span;
                return ast::Expr {
                    kind: ast::ExprKind::MethodCall {
                        receiver: Box::new(left),
                        method: field_name,
                        type_args: Option::None,
                        args: args,
                    },
                    span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
                };
            }
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Field {
                    base: Box::new(left),
                    field: ast::FieldAccess::Named(field_name),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Function call
        token::TokenKind::LParen => {
            return parse_call_expr(parser, left);
        }
        // Index
        token::TokenKind::LBracket => {
            return parse_index_expr(parser, left);
        }
        // Assignment (right-associative)
        token::TokenKind::Eq => {
            parser.advance();
            let right = parse_expr_with_precedence(parser, prec);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Assign {
                    target: Box::new(left),
                    val: Box::new(right),
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Type cast
        token::TokenKind::As => {
            parser.advance();
            let ty = parser_type::parse_type(parser);
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Cast {
                    expr: Box::new(left),
                    ty: ty,
                },
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        // Try operator
        token::TokenKind::Question => {
            parser.advance();
            let end_span = parser.previous.span;
            return ast::Expr {
                kind: ast::ExprKind::Try(Box::new(left)),
                span: common::Span { start: left.span.start, end: end_span.end, line: left.span.line, column: left.span.column },
            };
        }
        _ => {
            // Not an infix operator, return left unchanged
            return left;
        }
    }
}

// ============================================================
// Helper Expression Parsers
// ============================================================

fn parse_paren_or_tuple_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '('

    if parser.check(token::TokenKind::RParen) {
        parser.advance();
        return ast::Expr {
            kind: ast::ExprKind::Tuple(Vec::new()),
            span: common::Span { start: start.start, end: parser.previous.span.end, line: start.line, column: start.column },
        };
    }

    let first = parse_expr(parser);

    if parser.try_consume(token::TokenKind::Comma) {
        let mut elements: Vec<ast::Expr> = Vec::new();
        elements.push(first);

        while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
            elements.push(parse_expr(parser));
            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::RParen);
        let end_span = parser.previous.span;
        return ast::Expr {
            kind: ast::ExprKind::Tuple(elements),
            span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
        };
    }

    parser.expect(token::TokenKind::RParen);
    first
}

fn parse_array_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume '['

    // Empty array
    if parser.check(token::TokenKind::RBracket) {
        parser.advance();
        let end_span = parser.previous.span;
        return ast::Expr {
            kind: ast::ExprKind::Array(ast::ArrayExpr::List(Vec::new())),
            span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
        };
    }

    // Parse first element
    let first = parse_expr(parser);

    // Check for repeat syntax: [expr; count]
    if parser.try_consume(token::TokenKind::Semi) {
        let count = parse_expr(parser);
        parser.expect(token::TokenKind::RBracket);
        let end_span = parser.previous.span;
        return ast::Expr {
            kind: ast::ExprKind::Array(ast::ArrayExpr::Repeat {
                val: Box::new(first),
                count: Box::new(count),
            }),
            span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
        };
    }

    // List syntax: [expr, expr, ...]
    let mut elements: Vec<ast::Expr> = Vec::new();
    elements.push(first);
    while parser.try_consume(token::TokenKind::Comma) {
        if parser.check(token::TokenKind::RBracket) {
            break; // trailing comma
        }
        elements.push(parse_expr(parser));
    }

    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Array(ast::ArrayExpr::List(elements)),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Control Flow Expression Parsers
// ============================================================

fn parse_block_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let block = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Block(block),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_if_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'if'

    let condition = parse_expr_no_struct(parser);
    let then_branch = parse_block(parser);

    let else_branch = if parser.try_consume(token::TokenKind::Else) {
        if parser.check(token::TokenKind::If) {
            Option::Some(ast::ElseBranch::If(Box::new(parse_if_expr(parser))))
        } else {
            Option::Some(ast::ElseBranch::Block(parse_block(parser)))
        }
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::If {
            condition: Box::new(condition),
            then_branch: then_branch,
            else_branch: else_branch,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_match_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'match'

    let scrutinee = parse_expr_no_struct(parser);

    parser.expect(token::TokenKind::LBrace);

    let mut arms: Vec<ast::MatchArm> = Vec::new();

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let arm_start = parser.current.span;
        let pattern = parser_pattern::parse_pattern(parser);

        let guard = if parser.try_consume(token::TokenKind::If) {
            Option::Some(parse_expr(parser))
        } else {
            Option::None
        };

        parser.expect(token::TokenKind::FatArrow);
        // For compound expressions (block, if, match, loop, while, for),
        // parse just the compound expression without entering the Pratt
        // loop. Otherwise the Pratt parser would see `&` from the next
        // arm's ref-pattern as the bitwise-AND infix operator and try to
        // extend the body expression, causing an infinite parse.
        let body = if parser.check(token::TokenKind::LBrace)
                   || parser.check(token::TokenKind::If)
                   || parser.check(token::TokenKind::Match)
                   || parser.check(token::TokenKind::Loop)
                   || parser.check(token::TokenKind::While)
                   || parser.check(token::TokenKind::For) {
            parse_prefix_expr(parser)
        } else {
            parse_expr(parser)
        };
        let arm_end = parser.previous.span;

        let arm = ast::MatchArm {
            pattern: pattern,
            guard: guard,
            body: body,
            span: common::Span { start: arm_start.start, end: arm_end.end, line: arm_start.line, column: arm_start.column },
        };
        arms.push(arm);

        // Try to consume trailing comma. Block bodies don't require one.
        if !parser.try_consume(token::TokenKind::Comma) {
            // No comma found. If previous token was '}' (block body), continue
            // parsing — block arms don't need trailing commas. Otherwise break.
            if parser.previous.kind != token::TokenKind::RBrace {
                break;
            }
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Match {
            scrutinee: Box::new(scrutinee),
            arms: arms,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_loop_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'loop'

    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Loop {
            label: Option::None,
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_while_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'while'

    let condition = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::While {
            label: Option::None,
            condition: Box::new(condition),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_for_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'for'

    let pattern = parser_pattern::parse_pattern(parser);
    parser.expect(token::TokenKind::In);
    let iter = parse_expr_no_struct(parser);
    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::For {
            label: Option::None,
            pattern: pattern,
            iter: Box::new(iter),
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_return_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'return'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Return(val),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_break_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'break'

    let val = if !parser.check(token::TokenKind::Semi) && !parser.check(token::TokenKind::RBrace) {
        Option::Some(Box::new(parse_expr(parser)))
    } else {
        Option::None
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Break { label: Option::None, val: val },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_continue_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'continue'
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Continue { label: Option::None },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_closure_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;

    // Parse parameters
    let mut params: Vec<ast::ClosureParam> = Vec::new();

    if parser.try_consume(token::TokenKind::OrOr) {
        // Empty parameter list ||
    } else {
        parser.expect(token::TokenKind::Or);

        while !parser.check(token::TokenKind::Or) && !parser.is_at_end() {
            let param_start = parser.current.span;
            let pattern = parser_pattern::parse_pattern(parser);
            let ty = if parser.try_consume(token::TokenKind::Colon) {
                Option::Some(parser_type::parse_type(parser))
            } else {
                Option::None
            };
            let param_end = parser.previous.span;

            let param = ast::ClosureParam {
                pattern: pattern,
                ty: ty,
                span: common::Span { start: param_start.start, end: param_end.end, line: param_start.line, column: param_start.column },
            };
            params.push(param);

            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }

        parser.expect(token::TokenKind::Or);
    }

    // Optional return type
    let return_type = if parser.try_consume(token::TokenKind::Arrow) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    // Optional effects clause: / {Effect1, Effect2}
    let effects: Option<ast::EffectRow> = if parser.check(token::TokenKind::Slash) {
        Option::Some(parser_type::parse_fn_type_effect_row(parser))
    } else {
        Option::None
    };

    // Body
    let body = parse_expr(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Closure {
            is_move: false,
            params: params,
            return_type: return_type,
            effects: effects,
            body: Box::new(body),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Effect Expression Parsers
// ============================================================

/// Parse a perform expression: `perform Effect.operation(args)` or `perform operation(args)`
fn parse_perform_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'perform'

    // Parse the effect path (could be Effect.op or just op)
    let path = parser_type::parse_type_path(parser);

    let effect_path: Option<ast::TypePath>;
    let operation: common::SpannedSymbol;

    if parser.try_consume(token::TokenKind::Dot) {
        // Dot syntax: Effect.operation
        effect_path = Option::Some(path);
        if parser.check_ident() || parser.check(token::TokenKind::TypeIdent) {
            operation = parser.parse_spanned_symbol();
        } else {
            parser.error_expected("operation name");
            operation = common::SpannedSymbol {
                symbol: common::Symbol::new(0),
                span: parser.current.span,
            };
        }
    } else {
        // No dot: path is just the operation name (single segment)
        effect_path = Option::None;
        if path.segments.len() > 0 {
            operation = path.segments[0].name;
        } else {
            operation = common::SpannedSymbol {
                symbol: common::Symbol::new(0),
                span: start,
            };
        }
    }

    // Parse arguments
    parser.expect(token::TokenKind::LParen);
    let mut args: Vec<ast::Expr> = Vec::new();
    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        args.push(parse_expr(parser));
        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }
    parser.expect(token::TokenKind::RParen);

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Perform {
            effect: effect_path,
            operation: operation,
            args: args,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a resume expression: `resume(value)`
fn parse_resume_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'resume'
    parser.expect(token::TokenKind::LParen);
    let value = parse_expr(parser);
    parser.expect(token::TokenKind::RParen);
    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Resume(Box::new(value)),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a with-handle expression: `with handler handle { body }`
fn parse_with_handle_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'with'

    let handler_expr = parse_expr(parser);

    parser.expect(token::TokenKind::Handle);

    let body = if parser.check(token::TokenKind::LBrace) {
        let block = parse_block(parser);
        let block_span = block.span;
        ast::Expr {
            kind: ast::ExprKind::Block(block),
            span: block_span,
        }
    } else {
        parse_expr(parser)
    };

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::WithHandle {
            handler: Box::new(handler_expr),
            body: Box::new(body),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a try-with expression: `try { body } with { Effect.op(params) => { handler_body }, ... }`
fn parse_try_with_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'try'

    // Parse the body block
    let body = parse_block(parser);

    // Expect 'with'
    parser.expect(token::TokenKind::With);

    // Parse handler clauses in braces
    parser.expect(token::TokenKind::LBrace);

    let mut handlers: Vec<ast::TryWithHandler> = Vec::new();
    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let handler_start = parser.current.span;

        // Parse Effect.operation or Effect::operation pattern
        let effect_path = parser_type::parse_type_path(parser);

        let handler_effect: ast::TypePath;
        let handler_operation: common::SpannedSymbol;

        if parser.try_consume(token::TokenKind::Dot) {
            // Dot syntax: Effect.operation
            handler_effect = effect_path;
            if parser.check_ident() || parser.check(token::TokenKind::TypeIdent) {
                handler_operation = parser.parse_spanned_symbol();
            } else {
                parser.error_expected("operation name after '.'");
                handler_operation = common::SpannedSymbol {
                    symbol: common::Symbol::new(0),
                    span: parser.current.span,
                };
            }
        } else if effect_path.segments.len() >= 2 {
            // Path syntax: Effect::operation — last segment is operation
            let seg_len = effect_path.segments.len();
            handler_operation = effect_path.segments[seg_len - 1].name;
            // Build effect path from all but last segment
            let mut effect_segs: Vec<ast::TypePathSegment> = Vec::new();
            let mut si: usize = 0;
            while si < seg_len - 1 {
                effect_segs.push(ast::TypePathSegment {
                    name: effect_path.segments[si].name,
                    args: Option::None,
                });
                si = si + 1;
            }
            handler_effect = ast::TypePath {
                segments: effect_segs,
                span: effect_path.span,
            };
        } else if effect_path.segments.len() == 1 {
            // Single segment — just the operation name, no effect path
            handler_operation = effect_path.segments[0].name;
            handler_effect = ast::TypePath {
                segments: Vec::new(),
                span: effect_path.span,
            };
        } else {
            parser.error_expected("Effect.operation pattern");
            handler_operation = common::SpannedSymbol {
                symbol: common::Symbol::new(0),
                span: parser.current.span,
            };
            handler_effect = ast::TypePath {
                segments: Vec::new(),
                span: parser.current.span,
            };
        }

        // Parse parameters
        parser.expect(token::TokenKind::LParen);
        let mut params: Vec<ast::Pattern> = Vec::new();
        while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
            let pat = parser_pattern::parse_pattern(parser);
            params.push(pat);
            if !parser.try_consume(token::TokenKind::Comma) {
                break;
            }
        }
        parser.expect(token::TokenKind::RParen);

        // Expect '=>' or ':'
        if parser.check(token::TokenKind::FatArrow) || parser.check(token::TokenKind::Colon) {
            parser.advance();
        } else {
            parser.expect(token::TokenKind::FatArrow);
        }

        // Parse handler body
        let handler_body = parse_block(parser);
        let handler_end = parser.previous.span;

        handlers.push(ast::TryWithHandler {
            effect: handler_effect,
            operation: handler_operation,
            params: params,
            body: handler_body,
            span: common::Span { start: handler_start.start, end: handler_end.end, line: handler_start.line, column: handler_start.column },
        });

        // Consume optional comma between handlers
        parser.try_consume(token::TokenKind::Comma);
    }

    parser.expect(token::TokenKind::RBrace);

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::TryWith {
            body: body,
            handlers: handlers,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a region expression: `region 'name { body }` or `region { body }`
fn parse_region_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    parser.advance(); // consume 'region'

    let region_name = if parser.check(token::TokenKind::Lifetime) {
        let name = parser.parse_spanned_symbol();
        Option::Some(name)
    } else {
        Option::None
    };

    let body = parse_block(parser);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Region {
            name: region_name,
            body: body,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Path and Struct Expression Parsers
// ============================================================

fn parse_path_expr(parser: &mut parser_base::Parser) -> ast::Expr {
    let start = parser.current.span;
    let path = parse_expr_path(parser);

    // Check for struct literal: Path { ... }
    if parser.allow_struct_literal && parser.check(token::TokenKind::LBrace) {
        // Convert ExprPath to TypePath for struct expression
        let type_path = expr_path_to_type_path(path);
        return parse_struct_expr(parser, type_path);
    }

    let end_span = parser.previous.span;
    ast::Expr {
        kind: ast::ExprKind::Path(path),
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Convert an ExprPath to a TypePath (for struct expressions).
fn expr_path_to_type_path(path: ast::ExprPath) -> ast::TypePath {
    let mut segments: Vec<ast::TypePathSegment> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let type_seg = ast::TypePathSegment {
            name: seg.name,
            args: seg.args,
        };
        segments.push(type_seg);
        i = i + 1;
    }
    ast::TypePath {
        segments: segments,
        span: path.span,
    }
}

fn parse_expr_path(parser: &mut parser_base::Parser) -> ast::ExprPath {
    let start = parser.current.span;
    let mut segments: Vec<ast::ExprPathSegment> = Vec::new();

    let first_seg = parse_expr_path_segment(parser);
    segments.push(first_seg);

    while parser.try_consume(token::TokenKind::ColonColon) {
        let seg = parse_expr_path_segment(parser);
        segments.push(seg);
    }

    let end_span = parser.previous.span;
    ast::ExprPath {
        segments: segments,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_expr_path_segment(parser: &mut parser_base::Parser) -> ast::ExprPathSegment {
    let name = parser.parse_spanned_symbol();

    // Check for turbofish ::<T, U>
    let args = if parser.check(token::TokenKind::ColonColon) && parser.check_next(token::TokenKind::Lt) {
        parser.advance(); // consume ::
        Option::Some(parser_type::parse_type_args(parser))
    } else {
        Option::None
    };

    ast::ExprPathSegment { name: name, args: args }
}

fn parse_struct_expr(parser: &mut parser_base::Parser, path: ast::TypePath) -> ast::Expr {
    let start = path.span;
    parser.advance(); // consume '{'

    let mut fields: Vec<ast::RecordExprField> = Vec::new();
    let mut base: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        // Check for base: ..expr
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            base = Option::Some(Box::new(parse_expr(parser)));
            break;
        }

        let field_start = parser.current.span;
        let field_name = parser.parse_spanned_symbol();

        let val = if parser.try_consume(token::TokenKind::Colon) {
            Option::Some(parse_expr(parser))
        } else {
            // Shorthand: val is None means use the field name as the value
            Option::None
        };

        let field_end = parser.previous.span;
        let field = ast::RecordExprField {
            name: field_name,
            val: val,
            span: common::Span { start: field_start.start, end: field_end.end, line: field_start.line, column: field_start.column },
        };
        fields.push(field);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Record {
            path: Option::Some(path),
            fields: fields,
            base: base,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_call_expr(parser: &mut parser_base::Parser, callee: ast::Expr) -> ast::Expr {
    let start = callee.span;
    parser.advance(); // consume '('

    let mut args: Vec<ast::CallArg> = Vec::new();

    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        let arg_start = parser.current.span;
        let arg_expr = parse_expr(parser);
        let arg_end = parser.previous.span;
        let call_arg = ast::CallArg {
            name: Option::None,
            val: arg_expr,
            span: common::Span { start: arg_start.start, end: arg_end.end, line: arg_start.line, column: arg_start.column },
        };
        args.push(call_arg);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RParen);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Call {
            callee: Box::new(callee),
            args: args,
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

fn parse_index_expr(parser: &mut parser_base::Parser, base: ast::Expr) -> ast::Expr {
    let start = base.span;
    parser.advance(); // consume '['

    let idx = parse_expr(parser);
    parser.expect(token::TokenKind::RBracket);
    let end_span = parser.previous.span;

    ast::Expr {
        kind: ast::ExprKind::Index {
            base: Box::new(base),
            idx: Box::new(idx),
        },
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Statement and Block Parsing
// ============================================================

/// Parse a statement.
pub fn parse_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    // Let statement
    if parser.check(token::TokenKind::Let) {
        return parse_let_statement(parser);
    }

    // Expression statement
    let expr = parse_expr(parser);
    let has_semi = parser.try_consume(token::TokenKind::Semi);

    ast::Statement::Expr {
        expr: expr,
        has_semi: has_semi,
    }
}

/// Parse a let statement.
pub fn parse_let_statement(parser: &mut parser_base::Parser) -> ast::Statement {
    let start = parser.current.span;
    parser.advance(); // consume 'let'

    let pattern = parser_pattern::parse_pattern(parser);

    let ty = if parser.try_consume(token::TokenKind::Colon) {
        Option::Some(parser_type::parse_type(parser))
    } else {
        Option::None
    };

    let init_val = if parser.try_consume(token::TokenKind::Eq) {
        Option::Some(parse_expr(parser))
    } else {
        Option::None
    };

    parser.expect(token::TokenKind::Semi);

    let end_span = parser.previous.span;
    ast::Statement::Let {
        pattern: pattern,
        ty: ty,
        init_val: init_val,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

/// Parse a block and return ast::Block directly.
pub fn parse_block(parser: &mut parser_base::Parser) -> ast::Block {
    let start = parser.current.span;
    parser.expect(token::TokenKind::LBrace);

    let mut stmts: Vec<ast::Statement> = Vec::new();
    let mut final_expr: Option<Box<ast::Expr>> = Option::None;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        let stmt = parse_statement(parser);

        // Check if this is an expression without semicolon at the end of block
        match stmt {
            ast::Statement::Expr { expr, has_semi } => {
                if !has_semi && parser.check(token::TokenKind::RBrace) {
                    // This is the final expression
                    final_expr = Option::Some(Box::new(expr));
                } else {
                    let expr_stmt = ast::Statement::Expr { expr: expr, has_semi: has_semi };
                    stmts.push(expr_stmt);
                }
            }
            ast::Statement::Let { pattern, ty, init_val, span } => {
                let let_stmt = ast::Statement::Let { pattern: pattern, ty: ty, init_val: init_val, span: span };
                stmts.push(let_stmt);
            }
            ast::Statement::Item(decl) => {
                let item_stmt = ast::Statement::Item(decl);
                stmts.push(item_stmt);
            }
        }
    }

    parser.expect(token::TokenKind::RBrace);
    let end_span = parser.previous.span;

    ast::Block {
        statements: stmts,
        expr: final_expr,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    }
}

// ============================================================
// Literal Value Extraction — delegated to parser_base
// ============================================================

// The following functions have been moved to parser_base.blood
// so both parser_expr and parser_pattern can use them:
//   parser_base::parse_int_value_from_span
//   parser_base::parse_int_suffix_from_span
//   parser_base::parse_float_bits_from_span
//   parser_base::parse_float_suffix_from_span
//   parser_base::parse_string_from_span
//   parser_base::parse_char_from_span

