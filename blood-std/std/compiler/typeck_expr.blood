// Blood Self-Hosted Compiler - Expression Type Checking
//
// This module implements type checking for HIR expressions.
// It provides both inference (infer type from expression) and
// checking (verify expression has expected type) modes.
//
// The main entry points are:
// - infer_expr: Infer the type of an expression
// - check_expr: Check an expression against an expected type

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir;
mod unify;
mod typeck;

// ============================================================
// Main Entry Points
// ============================================================

/// Infers the type of an expression.
/// Returns the inferred type (may contain inference variables).
pub fn infer_expr(checker: &mut typeck::TypeChecker, expr: &hir_expr::Expr) -> hir_ty::Type {
    match &expr.kind {
        &hir_expr::ExprKind::Literal(ref lit) => infer_literal(checker, lit),
        &hir_expr::ExprKind::Local(id) => infer_local(checker, id, expr.span),
        &hir_expr::ExprKind::Path(ref path) => infer_path(checker, path, expr.span),
        &hir_expr::ExprKind::Binary { op: bin_op, ref left, ref right } => {
            infer_binary(checker, bin_op, left.as_ref(), right.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Unary { op: un_op, ref operand } => {
            infer_unary(checker, un_op, operand.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Call { ref callee, ref args } => {
            infer_call(checker, callee.as_ref(), args, expr.span)
        }
        &hir_expr::ExprKind::MethodCall { ref receiver, ref method, ref method_def, ref type_args, ref args } => {
            infer_method_call(checker, receiver.as_ref(), method, method_def, type_args, args, expr.span)
        }
        &hir_expr::ExprKind::Field { ref base, ref field } => {
            infer_field(checker, base.as_ref(), field, expr.span)
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            infer_index(checker, base.as_ref(), idx.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Tuple(ref exprs) => infer_tuple(checker, exprs, expr.span),
        &hir_expr::ExprKind::Array(ref arr) => infer_array(checker, arr, expr.span),
        &hir_expr::ExprKind::Struct { ref path, ref fields, ref base } => {
            infer_struct(checker, path, fields, base, expr.span)
        }
        &hir_expr::ExprKind::Range { ref start, ref end_val, inclusive } => {
            infer_range(checker, start, end_val, inclusive, expr.span)
        }
        &hir_expr::ExprKind::Cast { expr: ref inner, ty: ref cast_ty } => {
            infer_cast(checker, inner.as_ref(), cast_ty, expr.span)
        }
        &hir_expr::ExprKind::Assign { ref target, ref val } => {
            infer_assign(checker, target.as_ref(), val.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::AssignOp { op: assign_op, ref target, ref val } => {
            infer_assign_op(checker, assign_op, target.as_ref(), val.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::AddrOf { mutable, expr: ref inner } => {
            infer_addr_of(checker, mutable, inner.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Block(ref block) => infer_block(checker, block, expr.span),
        &hir_expr::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            infer_if(checker, condition.as_ref(), then_branch.as_ref(), else_branch, expr.span)
        }
        &hir_expr::ExprKind::Match { ref scrutinee, ref arms } => {
            infer_match(checker, scrutinee.as_ref(), arms, expr.span)
        }
        &hir_expr::ExprKind::Loop { ref label, ref body } => {
            infer_loop(checker, label, body.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Return(ref val) => infer_return(checker, val, expr.span),
        &hir_expr::ExprKind::Break { ref label, ref val } => {
            infer_break(checker, label, val, expr.span)
        }
        &hir_expr::ExprKind::Continue { ref label } => {
            infer_continue(checker, label, expr.span)
        }
        &hir_expr::ExprKind::Closure { ref captures, ref params, ref return_ty, ref body, body_id } => {
            infer_closure(checker, captures, params, return_ty, body.as_ref(), body_id, expr.span)
        }
        &hir_expr::ExprKind::WithHandle { ref handler, ref body } => {
            infer_with_handle(checker, handler.as_ref(), body.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Perform { effect_def, op_def, ref args } => {
            infer_perform(checker, effect_def, op_def, args, expr.span)
        }
        &hir_expr::ExprKind::Resume(ref val) => infer_resume(checker, val.as_ref(), expr.span),
        &hir_expr::ExprKind::Try(ref inner) => infer_try(checker, inner.as_ref(), expr.span),
        &hir_expr::ExprKind::Unsafe(ref inner) => infer_expr(checker, inner.as_ref()),
        &hir_expr::ExprKind::Error => hir_ty::Type::error(),
    }
}

/// Checks an expression against an expected type.
/// Returns true if the expression has the expected type.
/// Attempts coercion if direct unification fails.
pub fn check_expr(
    checker: &mut typeck::TypeChecker,
    expr: &hir_expr::Expr,
    expected: &hir_ty::Type,
) -> bool {
    let inferred = infer_expr(checker, expr);

    // First try direct unification
    if checker.unify(&inferred, expected, expr.span) {
        return true;
    }

    // If unification fails, try coercion
    match try_coerce(checker, &inferred, expected, expr.span) {
        typeck::CoercionResult::Ok(_coercion) => true,
        typeck::CoercionResult::Err => false,
    }
}

// ============================================================
// Type Coercion
// ============================================================

/// Attempts to coerce a type to another type.
/// Returns CoercionResult::Ok with the coercion if successful.
pub fn try_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    // Resolve any inference variables
    let from_resolved = checker.resolve(from_ty);
    let to_resolved = checker.resolve(to_ty);

    // Check for identity coercion (already same type)
    if types_equal(&from_resolved, &to_resolved) {
        return typeck::CoercionResult::Ok(typeck::Coercion::None);
    }

    // Check for Never type coercion: ! -> T
    if is_never_type(&from_resolved) {
        return typeck::CoercionResult::Ok(typeck::Coercion::NeverToAny);
    }

    // Check for reference coercion: &mut T -> &T
    match try_ref_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // Check for unsizing coercion: [T; N] -> [T]
    match try_unsize_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // Check for function pointer coercion
    match try_fn_pointer_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // No coercion found
    typeck::CoercionResult::Err
}

/// Attempts reference coercion: &mut T -> &T
fn try_ref_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // &mut T -> &T (mutable to immutable reference)
        (&hir_ty::TypeKind::Ref { ref inner, mutable: true },
         &hir_ty::TypeKind::Ref { inner: ref to_inner, mutable: false }) => {
            // The inner types must unify
            if checker.unify(inner.as_ref(), to_inner.as_ref(), span) {
                return typeck::CoercionResult::Ok(typeck::Coercion::RefCoerce);
            }
        }
        // *mut T -> *const T (mutable to immutable pointer)
        (&hir_ty::TypeKind::Ptr { ref inner, mutable: true },
         &hir_ty::TypeKind::Ptr { inner: ref to_inner, mutable: false }) => {
            if checker.unify(inner.as_ref(), to_inner.as_ref(), span) {
                return typeck::CoercionResult::Ok(typeck::Coercion::RefCoerce);
            }
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Attempts unsizing coercion: [T; N] -> [T]
fn try_unsize_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // &[T; N] -> &[T] (array reference to slice reference)
        (&hir_ty::TypeKind::Ref { ref inner, mutable: from_mut },
         &hir_ty::TypeKind::Ref { inner: ref to_inner, mutable: to_mut }) => {
            // Mutability must be compatible (mut -> immut ok, immut -> mut not ok)
            if from_mut || !to_mut {
                match (&inner.as_ref().kind, &to_inner.as_ref().kind) {
                    (&hir_ty::TypeKind::Array { ref element, size: _ },
                     &hir_ty::TypeKind::Slice { element: ref slice_elem }) => {
                        if checker.unify(element.as_ref(), slice_elem.as_ref(), span) {
                            return typeck::CoercionResult::Ok(typeck::Coercion::Unsize);
                        }
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Attempts function pointer coercion: fn item/closure -> fn pointer
fn try_fn_pointer_coerce(
    _checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    _span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // Fn type to fn pointer (when signatures match)
        (&hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ },
         &hir_ty::TypeKind::Fn { params: ref to_params, ret: ref to_ret, effects: _ }) => {
            // Check parameter count matches
            if params.len() != to_params.len() {
                return typeck::CoercionResult::Err;
            }
            // For now, accept if lengths match (full check would verify each param)
            // This is simplified - a full implementation would check param subtyping
            let _ = ret;
            let _ = to_ret;
            return typeck::CoercionResult::Ok(typeck::Coercion::FnPointer);
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Checks if a type is the never type (!).
fn is_never_type(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Never => true,
        _ => false,
    }
}

/// Checks if two types are structurally equal (without unification).
fn types_equal(a: &hir_ty::Type, b: &hir_ty::Type) -> bool {
    match (&a.kind, &b.kind) {
        (&hir_ty::TypeKind::Never, &hir_ty::TypeKind::Never) => true,
        (&hir_ty::TypeKind::Error, &hir_ty::TypeKind::Error) => true,
        (&hir_ty::TypeKind::Primitive(ref pa), &hir_ty::TypeKind::Primitive(ref pb)) => {
            primitive_equal(pa, pb)
        }
        (&hir_ty::TypeKind::Tuple(ref elems_a), &hir_ty::TypeKind::Tuple(ref elems_b)) => {
            if elems_a.len() != elems_b.len() {
                return false;
            }
            let mut i: usize = 0;
            while i < elems_a.len() {
                if !types_equal(&elems_a[i], &elems_b[i]) {
                    return false;
                }
                i = i + 1;
            }
            true
        }
        (&hir_ty::TypeKind::Ref { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ref { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Ptr { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ptr { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Array { ref element, size: sa },
         &hir_ty::TypeKind::Array { element: ref elem_b, size: sb }) => {
            sa == sb && types_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Slice { ref element },
         &hir_ty::TypeKind::Slice { element: ref elem_b }) => {
            types_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Adt { def_id: da, args: _ },
         &hir_ty::TypeKind::Adt { def_id: db, args: _ }) => {
            da.index == db.index
        }
        _ => false,
    }
}

/// Checks if two primitive types are equal.
fn primitive_equal(a: &hir_ty::PrimitiveTy, b: &hir_ty::PrimitiveTy) -> bool {
    match (a, b) {
        (&hir_ty::PrimitiveTy::Bool, &hir_ty::PrimitiveTy::Bool) => true,
        (&hir_ty::PrimitiveTy::Char, &hir_ty::PrimitiveTy::Char) => true,
        (&hir_ty::PrimitiveTy::I8, &hir_ty::PrimitiveTy::I8) => true,
        (&hir_ty::PrimitiveTy::I16, &hir_ty::PrimitiveTy::I16) => true,
        (&hir_ty::PrimitiveTy::I32, &hir_ty::PrimitiveTy::I32) => true,
        (&hir_ty::PrimitiveTy::I64, &hir_ty::PrimitiveTy::I64) => true,
        (&hir_ty::PrimitiveTy::I128, &hir_ty::PrimitiveTy::I128) => true,
        (&hir_ty::PrimitiveTy::Isize, &hir_ty::PrimitiveTy::Isize) => true,
        (&hir_ty::PrimitiveTy::U8, &hir_ty::PrimitiveTy::U8) => true,
        (&hir_ty::PrimitiveTy::U16, &hir_ty::PrimitiveTy::U16) => true,
        (&hir_ty::PrimitiveTy::U32, &hir_ty::PrimitiveTy::U32) => true,
        (&hir_ty::PrimitiveTy::U64, &hir_ty::PrimitiveTy::U64) => true,
        (&hir_ty::PrimitiveTy::U128, &hir_ty::PrimitiveTy::U128) => true,
        (&hir_ty::PrimitiveTy::Usize, &hir_ty::PrimitiveTy::Usize) => true,
        (&hir_ty::PrimitiveTy::F32, &hir_ty::PrimitiveTy::F32) => true,
        (&hir_ty::PrimitiveTy::F64, &hir_ty::PrimitiveTy::F64) => true,
        (&hir_ty::PrimitiveTy::Str, &hir_ty::PrimitiveTy::Str) => true,
        _ => false,
    }
}

// ============================================================
// Lvalue Checking
// ============================================================

/// Checks if a unary operator produces an lvalue (only Deref does).
fn is_deref_op(uop: common::UnaryOp) -> bool {
    match uop {
        common::UnaryOp::Deref => true,
        common::UnaryOp::Neg => false,
        common::UnaryOp::Not => false,
        common::UnaryOp::Ref => false,
        common::UnaryOp::RefMut => false,
    }
}

/// Checks if an expression is a valid lvalue (can be assigned to).
///
/// Valid lvalues are:
/// - Local variables
/// - Field access on an lvalue
/// - Index access
/// - Dereference operations
fn is_lvalue(expr: &hir_expr::Expr) -> bool {
    match &expr.kind {
        // Local variables are always lvalues
        &hir_expr::ExprKind::Local(_) => true,
        // Field access is lvalue if the base is lvalue
        &hir_expr::ExprKind::Field { ref base, field: _ } => is_lvalue(base.as_ref()),
        // Index access is lvalue if the base is lvalue
        &hir_expr::ExprKind::Index { ref base, idx: _ } => is_lvalue(base.as_ref()),
        // Dereference is always an lvalue
        &hir_expr::ExprKind::Unary { op: uop, operand: _ } => is_deref_op(uop),
        // Path to static is an lvalue (for mutable statics)
        &hir_expr::ExprKind::Path(_) => true,
        // Other expressions are not lvalues
        &hir_expr::ExprKind::Literal(_) => false,
        &hir_expr::ExprKind::Binary { op: _, left: _, right: _ } => false,
        &hir_expr::ExprKind::Call { callee: _, args: _ } => false,
        &hir_expr::ExprKind::MethodCall { receiver: _, method: _, method_def: _, type_args: _, args: _ } => false,
        &hir_expr::ExprKind::Tuple(_) => false,
        &hir_expr::ExprKind::Array(_) => false,
        &hir_expr::ExprKind::Struct { path: _, fields: _, base: _ } => false,
        &hir_expr::ExprKind::Range { start: _, end_val: _, inclusive: _ } => false,
        &hir_expr::ExprKind::Cast { expr: _, ty: _ } => false,
        &hir_expr::ExprKind::Block(_) => false,
        &hir_expr::ExprKind::If { condition: _, then_branch: _, else_branch: _ } => false,
        &hir_expr::ExprKind::Match { scrutinee: _, arms: _ } => false,
        &hir_expr::ExprKind::Loop { label: _, body: _ } => false,
        &hir_expr::ExprKind::Return(ref _val) => false,
        &hir_expr::ExprKind::Break { label: _, val: _ } => false,
        &hir_expr::ExprKind::Continue { label: _ } => false,
        &hir_expr::ExprKind::Assign { target: _, val: _ } => false,
        &hir_expr::ExprKind::AssignOp { op: _, target: _, val: _ } => false,
        &hir_expr::ExprKind::AddrOf { mutable: _, expr: _ } => false,
        &hir_expr::ExprKind::Closure { captures: _, params: _, return_ty: _, body: _, body_id: _ } => false,
        &hir_expr::ExprKind::WithHandle { handler: _, body: _ } => false,
        &hir_expr::ExprKind::Perform { effect_def: _, op_def: _, args: _ } => false,
        &hir_expr::ExprKind::Resume(ref _val) => false,
        &hir_expr::ExprKind::Try(ref _inner) => false,
        &hir_expr::ExprKind::Unsafe(ref _inner) => false,
        &hir_expr::ExprKind::Error => false,
    }
}

// ============================================================
// Literal Type Inference
// ============================================================

/// Infers the type of a literal.
fn infer_literal(checker: &mut typeck::TypeChecker, lit: &hir_expr::Literal) -> hir_ty::Type {
    match &lit.kind {
        &hir_expr::LiteralKind::Int { val: _, ref ty } => {
            match ty {
                &Some(prim_ty) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(prim_ty)),
                &None => {
                    // Unsuffixed integer literal - create inference variable
                    // Default to i32 if not constrained
                    checker.fresh_infer()
                }
            }
        }
        &hir_expr::LiteralKind::Float { bits: _, ref ty } => {
            match ty {
                &Some(prim_ty) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(prim_ty)),
                &None => {
                    // Unsuffixed float literal - create inference variable
                    // Default to f64 if not constrained
                    checker.fresh_infer()
                }
            }
        }
        &hir_expr::LiteralKind::Str(ref _s) => {
            // String literals have type &str
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str))),
                mutable: false,
            })
        }
        &hir_expr::LiteralKind::ByteStr(ref _bytes) => {
            // Byte string literals have type &[u8]
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Slice {
                    element: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8))),
                })),
                mutable: false,
            })
        }
        &hir_expr::LiteralKind::Char(_c) => {
            hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char))
        }
        &hir_expr::LiteralKind::Bool(_b) => {
            hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool))
        }
    }
}

// ============================================================
// Variable and Path Type Inference
// ============================================================

/// Infers the type of a local variable reference.
fn infer_local(checker: &mut typeck::TypeChecker, id: hir_def::LocalId, span: common::Span) -> hir_ty::Type {
    match checker.get_local_ty(id) {
        Some(ty) => ty,
        Option::None => {
            checker.error(typeck::TypeErrorKind::UndefinedVariable, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of a path reference.
fn infer_path(checker: &mut typeck::TypeChecker, path: &hir_def::ResolvedPath, span: common::Span) -> hir_ty::Type {
    let def_id = path.def_id;

    // Check if it's a function
    match checker.get_fn_sig(def_id) {
        Some(fn_info) => {
            // If the function has type parameters, create fresh inference variables
            // and substitute them into the parameter and return types
            if fn_info.num_generics > 0 {
                return instantiate_fn_sig(checker, fn_info);
            }

            // Non-generic function - build the function type directly
            let mut param_tys: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < fn_info.param_tys.len() {
                param_tys.push(hir_ty::copy_type(&fn_info.param_tys[i]));
                i = i + 1;
            }
            return hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: param_tys,
                ret: Box::new(hir_ty::copy_type(&fn_info.return_ty)),
                effects: hir_ty::EffectRow::empty(),
            });
        }
        Option::None => {}
    }

    // Check if it's a const
    match checker.get_const(def_id) {
        Some(const_info) => {
            return hir_ty::copy_type(&const_info.ty);
        }
        Option::None => {}
    }

    // Check if it's a static
    match checker.get_static(def_id) {
        Some(static_info) => {
            return hir_ty::copy_type(&static_info.ty);
        }
        Option::None => {}
    }

    // Check if it's an enum variant (returns the enum ADT type)
    // Enum variants are looked up via the enum registry
    // For now, if we can't resolve the path, return an inference variable
    // A more complete implementation would also check for struct constructors,
    // type aliases, etc.
    checker.fresh_infer()
}

/// Instantiates a generic function signature with fresh inference variables.
/// Creates a TypeParamSubst mapping each type parameter to a fresh inference variable,
/// then substitutes through the parameter types and return type.
fn instantiate_fn_sig(checker: &mut typeck::TypeChecker, fn_info: &typeck::FnSigInfo) -> hir_ty::Type {
    // Create fresh inference variables for each type parameter
    let mut subst = unify::TypeParamSubst::new();
    let mut i: u32 = 0;
    while i < fn_info.num_generics {
        let fresh_var = checker.fresh_infer();
        subst.add(i, fresh_var);
        i = i + 1;
    }

    // Substitute in parameter types
    let mut param_tys: Vec<hir_ty::Type> = Vec::new();
    let mut j: usize = 0;
    while j < fn_info.param_tys.len() {
        param_tys.push(unify::substitute_type_params(&fn_info.param_tys[j], &subst));
        j = j + 1;
    }

    // Substitute in return type
    let ret_ty = unify::substitute_type_params(&fn_info.return_ty, &subst);

    hir_ty::Type::new(hir_ty::TypeKind::Fn {
        params: param_tys,
        ret: Box::new(ret_ty),
        effects: hir_ty::EffectRow::empty(),
    })
}

// ============================================================
// Operator Type Inference
// ============================================================

/// Infers the type of a binary operation.
fn infer_binary(
    checker: &mut typeck::TypeChecker,
    bin_op: common::BinOp,
    left: &hir_expr::Expr,
    right: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let left_ty = infer_expr(checker, left);
    let right_ty = infer_expr(checker, right);

    // Unify operand types for most operators
    checker.unify(&left_ty, &right_ty, span);

    // Determine result type based on operator
    match bin_op {
        // Comparison operators return bool
        common::BinOp::Eq => hir_ty::Type::bool_ty(),
        common::BinOp::Ne => hir_ty::Type::bool_ty(),
        common::BinOp::Lt => hir_ty::Type::bool_ty(),
        common::BinOp::Le => hir_ty::Type::bool_ty(),
        common::BinOp::Gt => hir_ty::Type::bool_ty(),
        common::BinOp::Ge => hir_ty::Type::bool_ty(),
        // Logical operators return bool and expect bool operands
        common::BinOp::And => {
            let bool_ty = hir_ty::Type::bool_ty();
            checker.unify(&left_ty, &bool_ty, span);
            hir_ty::Type::bool_ty()
        }
        common::BinOp::Or => {
            let bool_ty = hir_ty::Type::bool_ty();
            checker.unify(&left_ty, &bool_ty, span);
            hir_ty::Type::bool_ty()
        }
        // Arithmetic operators return the operand type
        common::BinOp::Add => checker.resolve(&left_ty),
        common::BinOp::Sub => checker.resolve(&left_ty),
        common::BinOp::Mul => checker.resolve(&left_ty),
        common::BinOp::Div => checker.resolve(&left_ty),
        common::BinOp::Rem => checker.resolve(&left_ty),
        // Bitwise operators return the operand type
        common::BinOp::BitAnd => checker.resolve(&left_ty),
        common::BinOp::BitOr => checker.resolve(&left_ty),
        common::BinOp::BitXor => checker.resolve(&left_ty),
        common::BinOp::Shl => checker.resolve(&left_ty),
        common::BinOp::Shr => checker.resolve(&left_ty),
        // Pipe operator: left |> right where right is a function
        common::BinOp::Pipe => {
            // Pipe operator: the result is the return type of the function on the right
            // For now, return an inference variable since we'd need to resolve the function type
            checker.fresh_infer()
        }
    }
}

/// Infers the type of a unary operation.
fn infer_unary(
    checker: &mut typeck::TypeChecker,
    un_op: common::UnaryOp,
    operand: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let operand_ty = infer_expr(checker, operand);

    match un_op {
        common::UnaryOp::Neg => {
            // Negation returns the same type (must be numeric)
            checker.resolve(&operand_ty)
        }
        common::UnaryOp::Not => {
            // Logical not returns bool for bool, same type for integers (bitwise)
            checker.resolve(&operand_ty)
        }
        common::UnaryOp::Deref => {
            // Dereference: *T -> U where T is a reference/pointer type
            let resolved = checker.resolve(&operand_ty);
            match &resolved.kind {
                &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
                    hir_ty::copy_type(inner.as_ref())
                }
                &hir_ty::TypeKind::Ptr { ref inner, mutable: _ } => {
                    hir_ty::copy_type(inner.as_ref())
                }
                _ => {
                    checker.error(typeck::TypeErrorKind::TypeMismatch, span);
                    hir_ty::Type::error()
                }
            }
        }
        common::UnaryOp::Ref => {
            // Reference: &T where T is the operand type
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(checker.resolve(&operand_ty)),
                mutable: false,
            })
        }
        common::UnaryOp::RefMut => {
            // Mutable reference: &mut T where T is the operand type
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(checker.resolve(&operand_ty)),
                mutable: true,
            })
        }
    }
}

// ============================================================
// Call Type Inference
// ============================================================

/// Infers the type of a function call.
fn infer_call(
    checker: &mut typeck::TypeChecker,
    callee: &hir_expr::Expr,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let callee_ty = infer_expr(checker, callee);
    let resolved_callee = checker.resolve(&callee_ty);

    match &resolved_callee.kind {
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            // Check arity
            if params.len() != args.len() {
                checker.error(typeck::TypeErrorKind::ArityMismatch, span);
                return hir_ty::Type::error();
            }

            // Check each argument against parameter type
            let mut i: usize = 0;
            while i < args.len() {
                check_expr(checker, &args[i], &params[i]);
                i = i + 1;
            }

            // Return the return type
            hir_ty::copy_type(ret.as_ref())
        }
        &hir_ty::TypeKind::Infer(_) => {
            // Callee type not yet known - create fresh return type
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NotCallable, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of a method call.
fn infer_method_call(
    checker: &mut typeck::TypeChecker,
    receiver: &hir_expr::Expr,
    method: &common::SpannedSymbol,
    _method_def: &Option<hir_def::DefId>,
    type_args: &Vec<hir_ty::Type>,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let receiver_ty = infer_expr(checker, receiver);
    let resolved_receiver = checker.resolve(&receiver_ty);

    // Look up the method on the receiver type
    match checker.lookup_method(&resolved_receiver, method.symbol) {
        Some(lookup_result) => {
            // Get method info from the lookup
            let method_info = checker.get_method_from_lookup(&lookup_result);
            let impl_info = checker.get_impl_from_lookup(&lookup_result);

            // Build type argument substitution
            // If explicit type args provided, use them; otherwise infer
            let mut subst = unify::TypeParamSubst::new();
            if type_args.len() > 0 {
                let mut i: usize = 0;
                while i < type_args.len() {
                    subst.add(i as u32, hir_ty::copy_type(&type_args[i]));
                    i = i + 1;
                }
            } else if impl_info.num_generics > 0 {
                // Create fresh inference variables for impl's type parameters
                let mut i: u32 = 0;
                while i < impl_info.num_generics {
                    subst.add(i, checker.fresh_infer());
                    i = i + 1;
                }
            }

            // Check arity (excluding self parameter)
            if method_info.param_tys.len() != args.len() {
                checker.error(typeck::TypeErrorKind::ArityMismatch, span);
                return hir_ty::Type::error();
            }

            // Check each argument against parameter type (after substitution)
            let mut i: usize = 0;
            while i < args.len() {
                let param_ty = unify::substitute_type_params(&method_info.param_tys[i], &subst);
                check_expr(checker, &args[i], &param_ty);
                i = i + 1;
            }

            // Return the return type after substitution
            unify::substitute_type_params(&method_info.return_ty, &subst)
        }
        Option::None => {
            // Method not found - report error
            checker.error(typeck::TypeErrorKind::NoSuchMethod, span);

            // Still infer types for all arguments
            let mut i: usize = 0;
            while i < args.len() {
                infer_expr(checker, &args[i]);
                i = i + 1;
            }

            hir_ty::Type::error()
        }
    }
}

// ============================================================
// Field and Index Type Inference
// ============================================================

/// Infers the type of a field access.
fn infer_field(
    checker: &mut typeck::TypeChecker,
    base: &hir_expr::Expr,
    field: &hir_expr::FieldAccess,
    span: common::Span,
) -> hir_ty::Type {
    let base_ty = infer_expr(checker, base);
    let resolved_base = checker.resolve(&base_ty);

    match &resolved_base.kind {
        &hir_ty::TypeKind::Tuple(ref types) => {
            // Tuple field access by index
            match field {
                &hir_expr::FieldAccess::Index(idx) => {
                    let idx_usize = idx as usize;
                    if idx_usize < types.len() {
                        hir_ty::copy_type(&types[idx_usize])
                    } else {
                        checker.error(typeck::TypeErrorKind::NoSuchField, span);
                        hir_ty::Type::error()
                    }
                }
                &hir_expr::FieldAccess::Named { name: _, field_idx: _ } => {
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
            }
        }
        &hir_ty::TypeKind::Record { ref fields, row_var: _ } => {
            // Record field access by name
            match field {
                &hir_expr::FieldAccess::Named { ref name, field_idx: _ } => {
                    let mut i: usize = 0;
                    while i < fields.len() {
                        if fields[i].name.index == name.symbol.index {
                            return hir_ty::copy_type(&fields[i].ty);
                        }
                        i = i + 1;
                    }
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
                &hir_expr::FieldAccess::Index(_) => {
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
            }
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // ADT field access - look up struct definition
            match field {
                &hir_expr::FieldAccess::Named { ref name, field_idx: _ } => {
                    // Look up the field type from the struct definition
                    match checker.get_struct_field_ty(def_id, name.symbol) {
                        Some(field_ty) => {
                            // If the struct has type arguments, substitute them
                            if args.len() > 0 {
                                let subst = unify::TypeParamSubst::from_types(args);
                                unify::substitute_type_params(&field_ty, &subst)
                            } else {
                                field_ty
                            }
                        }
                        Option::None => {
                            checker.error(typeck::TypeErrorKind::NoSuchField, span);
                            hir_ty::Type::error()
                        }
                    }
                }
                &hir_expr::FieldAccess::Index(idx) => {
                    // Tuple-like struct field access by index
                    match checker.get_struct(def_id) {
                        Some(struct_info) => {
                            let idx_usize = idx as usize;
                            if idx_usize < struct_info.fields.len() {
                                let field_ty = hir_ty::copy_type(&struct_info.fields[idx_usize].ty);
                                if args.len() > 0 {
                                    let subst = unify::TypeParamSubst::from_types(args);
                                    unify::substitute_type_params(&field_ty, &subst)
                                } else {
                                    field_ty
                                }
                            } else {
                                checker.error(typeck::TypeErrorKind::NoSuchField, span);
                                hir_ty::Type::error()
                            }
                        }
                        Option::None => {
                            // Not a struct - might be an enum
                            checker.error(typeck::TypeErrorKind::NoSuchField, span);
                            hir_ty::Type::error()
                        }
                    }
                }
            }
        }
        &hir_ty::TypeKind::Infer(_) => {
            // Base type not yet known
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NoSuchField, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of an index operation.
fn infer_index(
    checker: &mut typeck::TypeChecker,
    base: &hir_expr::Expr,
    idx: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let base_ty = infer_expr(checker, base);
    let idx_ty = infer_expr(checker, idx);
    let resolved_base = checker.resolve(&base_ty);

    // Index should be usize
    let usize_ty = hir_ty::Type::usize_ty();
    checker.unify(&idx_ty, &usize_ty, idx.span);

    match &resolved_base.kind {
        &hir_ty::TypeKind::Array { ref element, size: _ } => {
            hir_ty::copy_type(element.as_ref())
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::copy_type(element.as_ref())
        }
        &hir_ty::TypeKind::Infer(_) => {
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NotIndexable, span);
            hir_ty::Type::error()
        }
    }
}

// ============================================================
// Compound Expression Type Inference
// ============================================================

/// Infers the type of a tuple expression.
fn infer_tuple(
    checker: &mut typeck::TypeChecker,
    exprs: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let mut types: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < exprs.len() {
        types.push(infer_expr(checker, &exprs[i]));
        i = i + 1;
    }
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(types))
}

/// Infers the type of an array expression.
fn infer_array(
    checker: &mut typeck::TypeChecker,
    arr: &hir_expr::ArrayExpr,
    span: common::Span,
) -> hir_ty::Type {
    match arr {
        &hir_expr::ArrayExpr::List(ref exprs) => {
            if exprs.len() == 0 {
                // Empty array - element type is inference variable
                let elem_ty = checker.fresh_infer();
                hir_ty::Type::new(hir_ty::TypeKind::Array {
                    element: Box::new(elem_ty),
                    size: 0,
                })
            } else {
                // Infer element type from first element, unify all others
                let elem_ty = infer_expr(checker, &exprs[0]);
                let mut i: usize = 1;
                while i < exprs.len() {
                    let ty = infer_expr(checker, &exprs[i]);
                    checker.unify(&ty, &elem_ty, exprs[i].span);
                    i = i + 1;
                }
                hir_ty::Type::new(hir_ty::TypeKind::Array {
                    element: Box::new(checker.resolve(&elem_ty)),
                    size: exprs.len() as u64,
                })
            }
        }
        &hir_expr::ArrayExpr::Repeat { ref val, count } => {
            let elem_ty = infer_expr(checker, val.as_ref());
            // count is already a u64 (const evaluated at lowering time)
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(checker.resolve(&elem_ty)),
                size: count,
            })
        }
    }
}

/// Infers the type of a struct expression.
fn infer_struct(
    checker: &mut typeck::TypeChecker,
    path: &hir_def::ResolvedPath,
    fields: &Vec<hir_expr::FieldExpr>,
    base: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    // Check all field expressions
    let mut i: usize = 0;
    while i < fields.len() {
        infer_expr(checker, &fields[i].val);
        i = i + 1;
    }

    // Check base expression if present
    match base {
        &Some(ref b) => {
            infer_expr(checker, b.as_ref());
        }
        &None => {}
    }

    // Return the ADT type
    // Generate inference variables for type arguments
    // (actual types will be unified during type checking)
    let mut args: Vec<hir_ty::Type> = Vec::new();
    let mut i: u32 = 0;
    while i < path.type_arg_count {
        args.push(checker.fresh_infer());
        i = i + 1;
    }
    hir_ty::Type::new(hir_ty::TypeKind::Adt {
        def_id: path.def_id,
        args: args,
    })
}

/// Infers the type of a range expression.
fn infer_range(
    checker: &mut typeck::TypeChecker,
    start: &Option<Box<hir_expr::Expr>>,
    end_val: &Option<Box<hir_expr::Expr>>,
    inclusive: bool,
    span: common::Span,
) -> hir_ty::Type {
    // Infer bound types and unify them
    let bound_ty = match (start, end_val) {
        (&Some(ref s), &Some(ref e)) => {
            let start_ty = infer_expr(checker, s.as_ref());
            let end_ty = infer_expr(checker, e.as_ref());
            checker.unify(&start_ty, &end_ty, span);
            checker.resolve(&start_ty)
        }
        (&Some(ref s), &None) => infer_expr(checker, s.as_ref()),
        (&None, &Some(ref e)) => infer_expr(checker, e.as_ref()),
        (&None, &None) => checker.fresh_infer(),
    };

    // Range types are ADTs in std - for now return inference variable
    checker.fresh_infer()
}

/// Infers the type of a cast expression.
fn infer_cast(
    checker: &mut typeck::TypeChecker,
    expr: &hir_expr::Expr,
    ty: &hir_ty::Type,
    span: common::Span,
) -> hir_ty::Type {
    // Check the source expression
    let src_ty = infer_expr(checker, expr);
    let resolved_src = checker.resolve(&src_ty);
    let resolved_dst = checker.resolve(ty);

    // Validate that the cast is valid
    if !is_valid_cast(&resolved_src, &resolved_dst) {
        checker.error(typeck::TypeErrorKind::InvalidCast, span);
    }

    // Return the target type
    hir_ty::copy_type(ty)
}

/// Checks if a cast from src_ty to dst_ty is valid.
///
/// Valid casts include:
/// - Numeric to numeric (integer/float coercions)
/// - Pointer to usize/isize
/// - Reference to raw pointer
/// - Same type (no-op cast)
fn is_valid_cast(src_ty: &hir_ty::Type, dst_ty: &hir_ty::Type) -> bool {
    match (&src_ty.kind, &dst_ty.kind) {
        // Same type is always valid
        (&hir_ty::TypeKind::Primitive(src_prim), &hir_ty::TypeKind::Primitive(dst_prim)) => {
            // Numeric to numeric casts are always valid
            is_numeric_primitive(src_prim) && is_numeric_primitive(dst_prim)
        }
        // Raw pointer to usize/isize
        (&hir_ty::TypeKind::Ptr { inner: _, mutable: _ }, &hir_ty::TypeKind::Primitive(dst_prim)) => {
            match dst_prim {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        // usize/isize to raw pointer
        (&hir_ty::TypeKind::Primitive(src_prim), &hir_ty::TypeKind::Ptr { inner: _, mutable: _ }) => {
            match src_prim {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        // Reference to raw pointer
        (&hir_ty::TypeKind::Ref { inner: _, mutable: src_mut }, &hir_ty::TypeKind::Ptr { inner: _, mutable: dst_mut }) => {
            // Can cast &T to *const T or &mut T to *mut T
            // Also &mut T can be cast to *const T
            !dst_mut || src_mut
        }
        // Pointer to pointer (with same or less mutability)
        (&hir_ty::TypeKind::Ptr { inner: _, mutable: src_mut }, &hir_ty::TypeKind::Ptr { inner: _, mutable: dst_mut }) => {
            !dst_mut || src_mut
        }
        // Error types can be cast to anything
        (&hir_ty::TypeKind::Error, _) => true,
        (_, &hir_ty::TypeKind::Error) => true,
        // Other casts are invalid
        _ => false,
    }
}

/// Checks if a primitive type is numeric (integer or float).
fn is_numeric_primitive(prim: hir_ty::PrimitiveTy) -> bool {
    match prim {
        hir_ty::PrimitiveTy::I8 => true,
        hir_ty::PrimitiveTy::I16 => true,
        hir_ty::PrimitiveTy::I32 => true,
        hir_ty::PrimitiveTy::I64 => true,
        hir_ty::PrimitiveTy::I128 => true,
        hir_ty::PrimitiveTy::Isize => true,
        hir_ty::PrimitiveTy::U8 => true,
        hir_ty::PrimitiveTy::U16 => true,
        hir_ty::PrimitiveTy::U32 => true,
        hir_ty::PrimitiveTy::U64 => true,
        hir_ty::PrimitiveTy::U128 => true,
        hir_ty::PrimitiveTy::Usize => true,
        hir_ty::PrimitiveTy::F32 => true,
        hir_ty::PrimitiveTy::F64 => true,
        hir_ty::PrimitiveTy::Bool => false,
        hir_ty::PrimitiveTy::Char => false,
        hir_ty::PrimitiveTy::Str => false,
    }
}

// ============================================================
// Assignment Type Inference
// ============================================================

/// Infers the type of an assignment expression.
fn infer_assign(
    checker: &mut typeck::TypeChecker,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let target_ty = infer_expr(checker, target);
    let val_ty = infer_expr(checker, val);

    // Value type must match target type
    checker.unify(&val_ty, &target_ty, span);

    // Check that target is a valid lvalue
    if !is_lvalue(target) {
        checker.error(typeck::TypeErrorKind::InvalidLValue, target.span);
    }

    // Assignment returns unit
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
}

/// Infers the type of a compound assignment expression.
fn infer_assign_op(
    checker: &mut typeck::TypeChecker,
    assign_op: common::BinOp,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let target_ty = infer_expr(checker, target);
    let val_ty = infer_expr(checker, val);

    // For most operators, types should match
    checker.unify(&val_ty, &target_ty, span);

    // Check that target is a valid lvalue (mutable check would require borrow checker)
    if !is_lvalue(target) {
        checker.error(typeck::TypeErrorKind::InvalidLValue, target.span);
    }

    // Compound assignment returns unit
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
}

/// Infers the type of an address-of expression.
fn infer_addr_of(
    checker: &mut typeck::TypeChecker,
    mutable: bool,
    expr: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let inner_ty = infer_expr(checker, expr);
    hir_ty::Type::new(hir_ty::TypeKind::Ref {
        inner: Box::new(checker.resolve(&inner_ty)),
        mutable: mutable,
    })
}

// ============================================================
// Block and Control Flow Type Inference
// ============================================================

/// Infers the type of a block expression.
fn infer_block(
    checker: &mut typeck::TypeChecker,
    block: &hir_expr::Block,
    span: common::Span,
) -> hir_ty::Type {
    // Process all statements
    let mut i: usize = 0;
    while i < block.stmts.len() {
        infer_stmt(checker, &block.stmts[i]);
        i = i + 1;
    }

    // Block type is the type of the final expression, or unit
    match &block.expr {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
    }
}

/// Infers the type of a statement.
fn infer_stmt(checker: &mut typeck::TypeChecker, stmt: &hir_expr::Stmt) {
    match stmt {
        &hir_expr::Stmt::Let { ref pattern, ref ty, ref init, span: _ } => {
            // Infer or check initializer type
            let init_ty = match init {
                &Some(ref e) => infer_expr(checker, e),
                &None => checker.fresh_infer(),
            };

            // Unify with declared type if present
            match ty {
                &Some(ref declared) => {
                    checker.unify(&init_ty, declared, pattern.span);
                }
                &None => {}
            }

            // Add bindings from pattern
            // For now, just handle simple patterns
            // Full pattern type checking would be separate
        }
        &hir_expr::Stmt::Expr { ref expr, has_semi: _ } => {
            infer_expr(checker, expr);
        }
        &hir_expr::Stmt::Item(_def_id) => {
            // Item statements are handled during item collection
        }
    }
}

/// Infers the type of an if expression.
fn infer_if(
    checker: &mut typeck::TypeChecker,
    condition: &hir_expr::Expr,
    then_branch: &hir_expr::Expr,
    else_branch: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    // Condition must be bool
    let cond_ty = infer_expr(checker, condition);
    let bool_ty = hir_ty::Type::bool_ty();
    checker.unify(&cond_ty, &bool_ty, condition.span);

    // Infer branch types
    let then_ty = infer_expr(checker, then_branch);

    match else_branch {
        &Some(ref e) => {
            let else_ty = infer_expr(checker, e.as_ref());
            // Both branches must have same type
            checker.unify(&then_ty, &else_ty, span);
            checker.resolve(&then_ty)
        }
        &None => {
            // No else branch - then branch must be unit, or whole if is unit
            let unit_ty = hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()));
            checker.unify(&then_ty, &unit_ty, then_branch.span);
            unit_ty
        }
    }
}

/// Infers the type of a match expression.
fn infer_match(
    checker: &mut typeck::TypeChecker,
    scrutinee: &hir_expr::Expr,
    arms: &Vec<hir_expr::MatchArm>,
    span: common::Span,
) -> hir_ty::Type {
    let scrut_ty = infer_expr(checker, scrutinee);

    if arms.len() == 0 {
        // Empty match - type is never (or error)
        return hir_ty::Type::never();
    }

    // Infer type from first arm, unify all others
    let result_ty = infer_expr(checker, &arms[0].body);

    let mut i: usize = 1;
    while i < arms.len() {
        let arm_ty = infer_expr(checker, &arms[i].body);
        checker.unify(&arm_ty, &result_ty, arms[i].body.span);
        i = i + 1;
    }

    // Check pattern exhaustiveness
    let exhaustiveness = typeck::check_exhaustiveness_arms(checker, &scrut_ty, arms, span);
    if !exhaustiveness.is_exhaustive() {
        checker.error(typeck::TypeErrorKind::NonExhaustive, span);
    }

    checker.resolve(&result_ty)
}

/// Infers the type of a loop expression.
fn infer_loop(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    body: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    // Loop type is determined by break values
    let loop_ty = checker.fresh_infer();

    // Enter loop context
    let prev_in_loop = checker.in_loop;
    let prev_loop_ty = copy_option_type(&checker.loop_ty);
    checker.enter_loop(hir_ty::copy_type(&loop_ty));

    // Check body
    infer_expr(checker, body);

    // Restore context
    checker.in_loop = prev_in_loop;
    checker.loop_ty = prev_loop_ty;

    // If no break with value, loop has type !
    // For now, return the inference variable
    checker.resolve(&loop_ty)
}

/// Infers the type of a return expression.
fn infer_return(
    checker: &mut typeck::TypeChecker,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    let val_ty = match val {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
    };

    // Unify with function return type
    match &checker.return_ty {
        &Some(ref ret_ty) => {
            let ret_copy = hir_ty::copy_type(ret_ty);
            checker.unify(&val_ty, &ret_copy, span);
        }
        &None => {
            checker.error(typeck::TypeErrorKind::InvalidControl, span);
        }
    }

    // Return expression has type Never
    hir_ty::Type::never()
}

/// Infers the type of a break expression.
fn infer_break(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    if !checker.in_loop {
        checker.error(typeck::TypeErrorKind::InvalidControl, span);
        return hir_ty::Type::never();
    }

    let val_ty = match val {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
    };

    // Unify with loop type
    match &checker.loop_ty {
        &Some(ref loop_ty) => {
            let loop_copy = hir_ty::copy_type(loop_ty);
            checker.unify(&val_ty, &loop_copy, span);
        }
        &None => {}
    }

    hir_ty::Type::never()
}

/// Infers the type of a continue expression.
fn infer_continue(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    span: common::Span,
) -> hir_ty::Type {
    if !checker.in_loop {
        checker.error(typeck::TypeErrorKind::InvalidControl, span);
    }
    hir_ty::Type::never()
}

// ============================================================
// Closure Type Inference
// ============================================================

/// Infers the type of a closure expression.
fn infer_closure(
    checker: &mut typeck::TypeChecker,
    captures: &Vec<hir_expr::Capture>,
    params: &Vec<hir_expr::ClosureParam>,
    return_ty: &hir_ty::Type,
    body: &hir_expr::Expr,
    _body_id: hir_def::BodyId,
    span: common::Span,
) -> hir_ty::Type {
    // Build parameter types
    let mut param_types: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() {
        param_types.push(hir_ty::copy_type(&params[i].ty));
        i = i + 1;
    }

    // Set up closure context
    let prev_return = copy_option_type(&checker.return_ty);
    checker.set_return_ty(hir_ty::copy_type(return_ty));

    // Check body
    let body_ty = infer_expr(checker, body);
    checker.unify(&body_ty, return_ty, body.span);

    // Restore context
    checker.return_ty = prev_return;

    // Return function type
    hir_ty::Type::new(hir_ty::TypeKind::Fn {
        params: param_types,
        ret: Box::new(hir_ty::copy_type(return_ty)),
        effects: hir_ty::EffectRow::empty(),
    })
}

// ============================================================
// Effect System Type Inference
// ============================================================

/// Infers the type of a with-handle expression.
fn infer_with_handle(
    checker: &mut typeck::TypeChecker,
    handler_expr: &hir_expr::Expr,
    body: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    // Check handler and body
    infer_expr(checker, handler_expr);
    infer_expr(checker, body)
}

/// Infers the type of an effect operation invocation.
fn infer_perform(
    checker: &mut typeck::TypeChecker,
    _effect_def: hir_def::DefId,
    _op_def: hir_def::DefId,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    // Check all arguments
    let mut i: usize = 0;
    while i < args.len() {
        infer_expr(checker, &args[i]);
        i = i + 1;
    }

    // Return type depends on effect operation - need to look up
    checker.fresh_infer()
}

/// Infers the type of a resume expression.
fn infer_resume(
    checker: &mut typeck::TypeChecker,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    infer_expr(checker, val);
    // Resume's return type depends on context
    checker.fresh_infer()
}

/// Infers the type of a try expression.
fn infer_try(
    checker: &mut typeck::TypeChecker,
    inner: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let inner_ty = infer_expr(checker, inner);
    // ? operator extracts from Result/Option
    // For now, return inference variable
    checker.fresh_infer()
}

// ============================================================
// Type Copying Helper
// ============================================================

/// Creates a copy of an Option<Type>.
fn copy_option_type(opt: &Option<hir_ty::Type>) -> Option<hir_ty::Type> {
    match opt {
        &Some(ref ty) => Some(hir_ty::copy_type(ty)),
        &None => Option::None,
    }
}
