// Blood Self-Hosted Compiler - Expression Type Checking
//
// This module implements type checking for HIR expressions.
// It provides both inference (infer type from expression) and
// checking (verify expression has expected type) modes.
//
// The main entry points are:
// - infer_expr: Infer the type of an expression
// - check_expr: Check an expression against an expected type

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir;
mod unify;
mod typeck;

// ============================================================
// Main Entry Points
// ============================================================

/// Infers the type of an expression.
/// Returns the inferred type (may contain inference variables).
pub fn infer_expr(checker: &mut typeck::TypeChecker, expr: &hir_expr::Expr) -> hir_ty::Type {
    let result = match &expr.kind {
        &hir_expr::ExprKind::Literal(ref lit) => infer_literal(checker, lit),
        &hir_expr::ExprKind::Local(id) => infer_local(checker, id, expr.span),
        &hir_expr::ExprKind::Path(ref path) => infer_path(checker, path, expr.span),
        &hir_expr::ExprKind::Binary { op: bin_op, ref left, ref right } => {
            infer_binary(checker, bin_op, left.as_ref(), right.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Unary { op: un_op, ref operand } => {
            infer_unary(checker, un_op, operand.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Call { ref callee, ref args } => {
            infer_call(checker, callee.as_ref(), args, expr.span)
        }
        &hir_expr::ExprKind::MethodCall { ref receiver, ref method, ref method_def, ref type_args, ref args } => {
            infer_method_call(checker, receiver.as_ref(), method, method_def, type_args, args, expr.span)
        }
        &hir_expr::ExprKind::Field { ref base, ref field } => {
            infer_field(checker, base.as_ref(), field, expr.span)
        }
        &hir_expr::ExprKind::Index { ref base, ref idx } => {
            infer_index(checker, base.as_ref(), idx.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Tuple(ref exprs) => infer_tuple(checker, exprs, expr.span),
        &hir_expr::ExprKind::Array(ref arr) => infer_array(checker, arr, expr.span),
        &hir_expr::ExprKind::Struct { ref path, ref fields, ref base } => {
            infer_struct(checker, path, fields, base, expr.span)
        }
        &hir_expr::ExprKind::AnonRecord { ref fields } => {
            infer_anon_record(checker, fields, expr.span)
        }
        &hir_expr::ExprKind::Range { ref start, ref end_val, inclusive } => {
            infer_range(checker, start, end_val, inclusive, expr.span)
        }
        &hir_expr::ExprKind::Cast { expr: ref inner, ty: ref cast_ty } => {
            infer_cast(checker, inner.as_ref(), cast_ty, expr.span)
        }
        &hir_expr::ExprKind::Assign { ref target, ref val } => {
            infer_assign(checker, target.as_ref(), val.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::AssignOp { op: assign_op, ref target, ref val } => {
            infer_assign_op(checker, assign_op, target.as_ref(), val.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::AddrOf { mutable, expr: ref inner } => {
            infer_addr_of(checker, mutable, inner.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Block(ref block) => infer_block(checker, block, expr.span),
        &hir_expr::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            infer_if(checker, condition.as_ref(), then_branch.as_ref(), else_branch, expr.span)
        }
        &hir_expr::ExprKind::Match { ref scrutinee, ref arms } => {
            infer_match(checker, scrutinee.as_ref(), arms, expr.span)
        }
        &hir_expr::ExprKind::Loop { ref label, ref body } => {
            infer_loop(checker, label, body.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Return(ref val) => infer_return(checker, val, expr.span),
        &hir_expr::ExprKind::Break { ref label, ref val } => {
            infer_break(checker, label, val, expr.span)
        }
        &hir_expr::ExprKind::Continue { ref label } => {
            infer_continue(checker, label, expr.span)
        }
        &hir_expr::ExprKind::Closure { ref captures, ref params, ref return_ty, ref effects, ref body, body_id } => {
            infer_closure(checker, captures, params, return_ty, effects, body.as_ref(), body_id, expr.span)
        }
        &hir_expr::ExprKind::WithHandle { handler: ref handler_expr, body: ref body_expr } => {
            infer_with_handle(checker, handler_expr.as_ref(), body_expr.as_ref(), expr.span)
        }
        &hir_expr::ExprKind::Perform { effect_def, op_def, op_name, ref args } => {
            infer_perform(checker, effect_def, op_def, op_name, args, expr.span)
        }
        &hir_expr::ExprKind::Resume(ref val) => infer_resume(checker, val.as_ref(), expr.span),
        &hir_expr::ExprKind::Try(ref inner) => infer_try(checker, inner.as_ref(), expr.span),
        &hir_expr::ExprKind::Unsafe(ref inner) => infer_expr(checker, inner.as_ref()),
        &hir_expr::ExprKind::Default => {
            // Default expression type comes from context; return expression's type variable
            hir_ty::copy_type(&expr.ty)
        }
        &hir_expr::ExprKind::Error => hir_ty::Type::error(),
    };

    // Record the mapping from the HIR's type variable to the concrete inferred type.
    // During HIR lowering, every expression gets a fresh Infer(TyVarId) type.
    // We unify the inferred type with the expression's type variable so that
    // MIR lowering can resolve expression types via apply_substs.
    checker.unify(&result, &expr.ty, expr.span);

    result
}

/// Checks an expression against an expected type.
/// Returns true if the expression has the expected type.
/// Attempts coercion if direct unification fails.
pub fn check_expr(
    checker: &mut typeck::TypeChecker,
    expr: &hir_expr::Expr,
    expected: &hir_ty::Type,
) -> bool {
    let inferred = infer_expr(checker, expr);

    // First try direct unification
    if checker.unify(&inferred, expected, expr.span) {
        return true;
    }

    // If unification fails, try coercion
    match try_coerce(checker, &inferred, expected, expr.span) {
        typeck::CoercionResult::Ok(_coercion) => true,
        typeck::CoercionResult::Err => false,
    }
}

// ============================================================
// Type Coercion
// ============================================================

/// Attempts to coerce a type to another type.
/// Returns CoercionResult::Ok with the coercion if successful.
pub fn try_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    // Resolve any inference variables
    let from_resolved = checker.resolve(from_ty);
    let to_resolved = checker.resolve(to_ty);

    // Check for identity coercion (already same type)
    if types_equal(&from_resolved, &to_resolved) {
        return typeck::CoercionResult::Ok(typeck::Coercion::None);
    }

    // Check for Never type coercion: ! -> T
    if is_never_type(&from_resolved) {
        return typeck::CoercionResult::Ok(typeck::Coercion::NeverToAny);
    }

    // Check for reference coercion: &mut T -> &T
    match try_ref_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // Check for unsizing coercion: [T; N] -> [T]
    match try_unsize_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // Check for function pointer coercion
    match try_fn_pointer_coerce(checker, &from_resolved, &to_resolved, span) {
        typeck::CoercionResult::Ok(c) => return typeck::CoercionResult::Ok(c),
        typeck::CoercionResult::Err => {}
    }

    // No coercion found
    typeck::CoercionResult::Err
}

/// Attempts reference coercion: &mut T -> &T
fn try_ref_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // &mut T -> &T (mutable to immutable reference)
        (&hir_ty::TypeKind::Ref { ref inner, mutable: true },
         &hir_ty::TypeKind::Ref { inner: ref to_inner, mutable: false }) => {
            // The inner types must unify
            if checker.unify(inner.as_ref(), to_inner.as_ref(), span) {
                return typeck::CoercionResult::Ok(typeck::Coercion::RefCoerce);
            }
        }
        // *mut T -> *const T (mutable to immutable pointer)
        (&hir_ty::TypeKind::Ptr { ref inner, mutable: true },
         &hir_ty::TypeKind::Ptr { inner: ref to_inner, mutable: false }) => {
            if checker.unify(inner.as_ref(), to_inner.as_ref(), span) {
                return typeck::CoercionResult::Ok(typeck::Coercion::RefCoerce);
            }
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Attempts unsizing coercion: [T; N] -> [T]
fn try_unsize_coerce(
    checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // &[T; N] -> &[T] (array reference to slice reference)
        (&hir_ty::TypeKind::Ref { ref inner, mutable: from_mut },
         &hir_ty::TypeKind::Ref { inner: ref to_inner, mutable: to_mut }) => {
            // Mutability must be compatible (mut -> immut ok, immut -> mut not ok)
            if from_mut || !to_mut {
                match (&inner.as_ref().kind, &to_inner.as_ref().kind) {
                    (&hir_ty::TypeKind::Array { ref element, size: _ },
                     &hir_ty::TypeKind::Slice { element: ref slice_elem }) => {
                        if checker.unify(element.as_ref(), slice_elem.as_ref(), span) {
                            return typeck::CoercionResult::Ok(typeck::Coercion::Unsize);
                        }
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Attempts function pointer coercion: fn item/closure -> fn pointer
fn try_fn_pointer_coerce(
    _checker: &mut typeck::TypeChecker,
    from_ty: &hir_ty::Type,
    to_ty: &hir_ty::Type,
    _span: common::Span,
) -> typeck::CoercionResult {
    match (&from_ty.kind, &to_ty.kind) {
        // Fn type to fn pointer (when signatures match)
        (&hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ },
         &hir_ty::TypeKind::Fn { params: ref to_params, ret: ref to_ret, effects: _ }) => {
            // Check parameter count matches
            if params.len() != to_params.len() {
                return typeck::CoercionResult::Err;
            }
            // For now, accept if lengths match (full check would verify each param)
            // This is simplified - a full implementation would check param subtyping
            let _ = ret;
            let _ = to_ret;
            return typeck::CoercionResult::Ok(typeck::Coercion::FnPointer);
        }
        _ => {}
    }
    typeck::CoercionResult::Err
}

/// Checks if a type is the never type (!).
fn is_never_type(ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Never => true,
        _ => false,
    }
}

/// Checks if two types are structurally equal (without unification).
fn types_equal(a: &hir_ty::Type, b: &hir_ty::Type) -> bool {
    match (&a.kind, &b.kind) {
        (&hir_ty::TypeKind::Never, &hir_ty::TypeKind::Never) => true,
        (&hir_ty::TypeKind::Error, &hir_ty::TypeKind::Error) => true,
        (&hir_ty::TypeKind::Primitive(ref pa), &hir_ty::TypeKind::Primitive(ref pb)) => {
            primitive_equal(pa, pb)
        }
        (&hir_ty::TypeKind::Tuple(ref elems_a), &hir_ty::TypeKind::Tuple(ref elems_b)) => {
            if elems_a.len() != elems_b.len() {
                return false;
            }
            let mut i: usize = 0;
            while i < elems_a.len() {
                if !types_equal(&elems_a[i], &elems_b[i]) {
                    return false;
                }
                i = i + 1;
            }
            true
        }
        (&hir_ty::TypeKind::Ref { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ref { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Ptr { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ptr { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Array { ref element, size: sa },
         &hir_ty::TypeKind::Array { element: ref elem_b, size: sb }) => {
            sa == sb && types_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Slice { ref element },
         &hir_ty::TypeKind::Slice { element: ref elem_b }) => {
            types_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Adt { def_id: da, args: _ },
         &hir_ty::TypeKind::Adt { def_id: db, args: _ }) => {
            da.index == db.index
        }
        // Ownership types - compare qualifier and inner type
        (&hir_ty::TypeKind::Ownership { qualifier: qa, ref inner },
         &hir_ty::TypeKind::Ownership { qualifier: qb, inner: ref inner_b }) => {
            qa == qb && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        _ => false,
    }
}

/// Checks if two primitive types are equal.
fn primitive_equal(a: &hir_ty::PrimitiveTy, b: &hir_ty::PrimitiveTy) -> bool {
    match (a, b) {
        (&hir_ty::PrimitiveTy::Bool, &hir_ty::PrimitiveTy::Bool) => true,
        (&hir_ty::PrimitiveTy::Char, &hir_ty::PrimitiveTy::Char) => true,
        (&hir_ty::PrimitiveTy::I8, &hir_ty::PrimitiveTy::I8) => true,
        (&hir_ty::PrimitiveTy::I16, &hir_ty::PrimitiveTy::I16) => true,
        (&hir_ty::PrimitiveTy::I32, &hir_ty::PrimitiveTy::I32) => true,
        (&hir_ty::PrimitiveTy::I64, &hir_ty::PrimitiveTy::I64) => true,
        (&hir_ty::PrimitiveTy::I128, &hir_ty::PrimitiveTy::I128) => true,
        (&hir_ty::PrimitiveTy::Isize, &hir_ty::PrimitiveTy::Isize) => true,
        (&hir_ty::PrimitiveTy::U8, &hir_ty::PrimitiveTy::U8) => true,
        (&hir_ty::PrimitiveTy::U16, &hir_ty::PrimitiveTy::U16) => true,
        (&hir_ty::PrimitiveTy::U32, &hir_ty::PrimitiveTy::U32) => true,
        (&hir_ty::PrimitiveTy::U64, &hir_ty::PrimitiveTy::U64) => true,
        (&hir_ty::PrimitiveTy::U128, &hir_ty::PrimitiveTy::U128) => true,
        (&hir_ty::PrimitiveTy::Usize, &hir_ty::PrimitiveTy::Usize) => true,
        (&hir_ty::PrimitiveTy::F32, &hir_ty::PrimitiveTy::F32) => true,
        (&hir_ty::PrimitiveTy::F64, &hir_ty::PrimitiveTy::F64) => true,
        (&hir_ty::PrimitiveTy::Str, &hir_ty::PrimitiveTy::Str) => true,
        _ => false,
    }
}

/// Strips reference wrappers from a type for auto-dereference.
/// &T -> T, &&T -> T, &mut T -> T, T -> T (unchanged).
pub fn strip_refs(ty: &hir_ty::Type) -> hir_ty::Type {
    match &ty.kind {
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            strip_refs(inner.as_ref())
        }
        _ => hir_ty::copy_type(ty),
    }
}

// ============================================================
// Lvalue Checking
// ============================================================

/// Checks if a unary operator produces an lvalue (only Deref does).
fn is_deref_op(uop: common::UnaryOp) -> bool {
    match uop {
        common::UnaryOp::Deref => true,
        common::UnaryOp::Neg => false,
        common::UnaryOp::Not => false,
        common::UnaryOp::Ref => false,
        common::UnaryOp::RefMut => false,
    }
}

/// Checks if an expression is a valid lvalue (can be assigned to).
///
/// Valid lvalues are:
/// - Local variables
/// - Field access on an lvalue
/// - Index access
/// - Dereference operations
fn is_lvalue(expr: &hir_expr::Expr) -> bool {
    match &expr.kind {
        // Local variables are always lvalues
        &hir_expr::ExprKind::Local(_) => true,
        // Field access is lvalue if the base is lvalue
        &hir_expr::ExprKind::Field { ref base, field: _ } => is_lvalue(base.as_ref()),
        // Index access is lvalue if the base is lvalue
        &hir_expr::ExprKind::Index { ref base, idx: _ } => is_lvalue(base.as_ref()),
        // Dereference is always an lvalue
        &hir_expr::ExprKind::Unary { op: uop, operand: _ } => is_deref_op(uop),
        // Path to static is an lvalue (for mutable statics)
        &hir_expr::ExprKind::Path(_) => true,
        // Other expressions are not lvalues
        &hir_expr::ExprKind::Literal(_) => false,
        &hir_expr::ExprKind::Binary { op: _, left: _, right: _ } => false,
        &hir_expr::ExprKind::Call { callee: _, args: _ } => false,
        &hir_expr::ExprKind::MethodCall { receiver: _, method: _, method_def: _, type_args: _, args: _ } => false,
        &hir_expr::ExprKind::Tuple(_) => false,
        &hir_expr::ExprKind::Array(_) => false,
        &hir_expr::ExprKind::Struct { path: _, fields: _, base: _ } => false,
        &hir_expr::ExprKind::AnonRecord { fields: _ } => false,
        &hir_expr::ExprKind::Range { start: _, end_val: _, inclusive: _ } => false,
        &hir_expr::ExprKind::Cast { expr: _, ty: _ } => false,
        &hir_expr::ExprKind::Block(_) => false,
        &hir_expr::ExprKind::If { condition: _, then_branch: _, else_branch: _ } => false,
        &hir_expr::ExprKind::Match { scrutinee: _, arms: _ } => false,
        &hir_expr::ExprKind::Loop { label: _, body: _ } => false,
        &hir_expr::ExprKind::Return(ref _val) => false,
        &hir_expr::ExprKind::Break { label: _, val: _ } => false,
        &hir_expr::ExprKind::Continue { label: _ } => false,
        &hir_expr::ExprKind::Assign { target: _, val: _ } => false,
        &hir_expr::ExprKind::AssignOp { op: _, target: _, val: _ } => false,
        &hir_expr::ExprKind::AddrOf { mutable: _, expr: _ } => false,
        &hir_expr::ExprKind::Closure { captures: _, params: _, return_ty: _, effects: _, body: _, body_id: _ } => false,
        &hir_expr::ExprKind::WithHandle { handler: _, body: _ } => false,
        &hir_expr::ExprKind::Perform { effect_def: _, op_def: _, op_name: _, args: _ } => false,
        &hir_expr::ExprKind::Resume(ref _val) => false,
        &hir_expr::ExprKind::Try(ref _inner) => false,
        &hir_expr::ExprKind::Unsafe(ref _inner) => false,
        &hir_expr::ExprKind::Default => false,
        &hir_expr::ExprKind::Error => false,
    }
}

// ============================================================
// Literal Type Inference
// ============================================================

/// Infers the type of a literal.
fn infer_literal(checker: &mut typeck::TypeChecker, lit: &hir_expr::Literal) -> hir_ty::Type {
    match &lit.kind {
        &hir_expr::LiteralKind::Int { val: _, ref ty } => {
            match ty {
                &Some(prim_ty) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(prim_ty)),
                &None => {
                    // Unsuffixed integer literal - create inference variable
                    // Default to i32 if not constrained
                    checker.fresh_infer()
                }
            }
        }
        &hir_expr::LiteralKind::Float { bits: _, ref ty } => {
            match ty {
                &Some(prim_ty) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(prim_ty)),
                &None => {
                    // Unsuffixed float literal - create inference variable
                    // Default to f64 if not constrained
                    checker.fresh_infer()
                }
            }
        }
        &hir_expr::LiteralKind::Str(ref _s) => {
            // String literals have type &str
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str))),
                mutable: false,
            })
        }
        &hir_expr::LiteralKind::ByteStr(ref _bytes) => {
            // Byte string literals have type &[u8]
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Slice {
                    element: Box::new(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8))),
                })),
                mutable: false,
            })
        }
        &hir_expr::LiteralKind::Char(_c) => {
            hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char))
        }
        &hir_expr::LiteralKind::Bool(_b) => {
            hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool))
        }
    }
}

// ============================================================
// Variable and Path Type Inference
// ============================================================

/// Infers the type of a local variable reference.
fn infer_local(checker: &mut typeck::TypeChecker, id: hir_def::LocalId, span: common::Span) -> hir_ty::Type {
    match checker.get_local_ty(id) {
        Some(ty) => ty,
        Option::None => {
            checker.error(typeck::TypeErrorKind::UndefinedVariable, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of a path reference.
fn infer_path(checker: &mut typeck::TypeChecker, path: &hir_def::ResolvedPath, span: common::Span) -> hir_ty::Type {
    let def_id = path.def_id;

    // Check if it's a function
    match checker.get_fn_sig(def_id) {
        Some(fn_info) => {
            // If the function has type parameters, create fresh inference variables
            // and substitute them into the parameter and return types
            if fn_info.num_generics > 0 {
                return instantiate_fn_sig(checker, fn_info);
            }

            // Non-generic function - build the function type directly
            let mut param_tys: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < fn_info.param_tys.len() {
                param_tys.push(hir_ty::copy_type(&fn_info.param_tys[i]));
                i = i + 1;
            }
            return hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: param_tys,
                ret: Box::new(hir_ty::copy_type(&fn_info.return_ty)),
                effects: hir_ty::EffectRow::empty(),
            });
        }
        Option::None => {}
    }

    // Check if it's a const
    match checker.get_const(def_id) {
        Some(const_info) => {
            return hir_ty::copy_type(&const_info.ty);
        }
        Option::None => {}
    }

    // Check if it's a static
    match checker.get_static(def_id) {
        Some(static_info) => {
            return hir_ty::copy_type(&static_info.ty);
        }
        Option::None => {}
    }

    // Check if it's an enum variant
    match checker.find_enum_for_variant(def_id) {
        Option::Some(ref lookup) => {
            // Build the ADT type for the parent enum
            let mut type_args: Vec<hir_ty::Type> = Vec::new();
            let mut subst = unify::TypeParamSubst::new();
            let mut g: u32 = 0;
            while g < lookup.num_generics {
                let fresh = checker.fresh_infer();
                type_args.push(hir_ty::copy_type(&fresh));
                subst.add(g, fresh);
                g = g + 1;
            }
            let adt_ty = hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: lookup.enum_def_id,
                args: type_args,
            });

            if lookup.field_tys.len() == 0 {
                // Unit variant - return the enum ADT type directly
                return adt_ty;
            } else {
                // Tuple variant - return a function type (field_tys) -> Adt
                let mut param_tys: Vec<hir_ty::Type> = Vec::new();
                let mut fi: usize = 0;
                while fi < lookup.field_tys.len() {
                    param_tys.push(unify::substitute_type_params(&lookup.field_tys[fi], &subst));
                    fi = fi + 1;
                }
                return hir_ty::Type::new(hir_ty::TypeKind::Fn {
                    params: param_tys,
                    ret: Box::new(adt_ty),
                    effects: hir_ty::EffectRow::empty(),
                });
            }
        }
        Option::None => {}
    }

    // Check if it's a struct constructor (unit struct)
    match checker.get_struct(def_id) {
        Option::Some(ref struct_info) => {
            let mut type_args: Vec<hir_ty::Type> = Vec::new();
            let mut g: u32 = 0;
            while g < struct_info.num_generics {
                type_args.push(checker.fresh_infer());
                g = g + 1;
            }
            return hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: type_args,
            });
        }
        Option::None => {}
    }

    // Unresolved path - return inference variable
    checker.fresh_infer()
}

/// Instantiates a generic function signature with fresh inference variables.
/// Creates a TypeParamSubst mapping each type parameter to a fresh inference variable,
/// then substitutes through the parameter types and return type.
fn instantiate_fn_sig(checker: &mut typeck::TypeChecker, fn_info: &typeck::FnSigInfo) -> hir_ty::Type {
    // Create fresh inference variables for each type parameter
    let mut subst = unify::TypeParamSubst::new();
    let mut i: u32 = 0;
    while i < fn_info.num_generics {
        let fresh_var = checker.fresh_infer();
        subst.add(i, fresh_var);
        i = i + 1;
    }

    // Substitute in parameter types
    let mut param_tys: Vec<hir_ty::Type> = Vec::new();
    let mut j: usize = 0;
    while j < fn_info.param_tys.len() {
        param_tys.push(unify::substitute_type_params(&fn_info.param_tys[j], &subst));
        j = j + 1;
    }

    // Substitute in return type
    let ret_ty = unify::substitute_type_params(&fn_info.return_ty, &subst);

    hir_ty::Type::new(hir_ty::TypeKind::Fn {
        params: param_tys,
        ret: Box::new(ret_ty),
        effects: hir_ty::EffectRow::empty(),
    })
}

// ============================================================
// Operator Type Inference
// ============================================================

/// Infers the type of a binary operation.
fn infer_binary(
    checker: &mut typeck::TypeChecker,
    bin_op: common::BinOp,
    left: &hir_expr::Expr,
    right: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let left_ty = infer_expr(checker, left);
    let right_ty = infer_expr(checker, right);

    // Unify operand types for most operators
    checker.unify(&left_ty, &right_ty, span);

    // Determine result type based on operator
    match bin_op {
        // Comparison operators return bool
        common::BinOp::Eq => hir_ty::Type::bool_ty(),
        common::BinOp::Ne => hir_ty::Type::bool_ty(),
        common::BinOp::Lt => hir_ty::Type::bool_ty(),
        common::BinOp::Le => hir_ty::Type::bool_ty(),
        common::BinOp::Gt => hir_ty::Type::bool_ty(),
        common::BinOp::Ge => hir_ty::Type::bool_ty(),
        // Logical operators return bool and expect bool operands
        common::BinOp::And => {
            let bool_ty = hir_ty::Type::bool_ty();
            checker.unify(&left_ty, &bool_ty, span);
            hir_ty::Type::bool_ty()
        }
        common::BinOp::Or => {
            let bool_ty = hir_ty::Type::bool_ty();
            checker.unify(&left_ty, &bool_ty, span);
            hir_ty::Type::bool_ty()
        }
        // Arithmetic operators return the operand type
        common::BinOp::Add => checker.resolve(&left_ty),
        common::BinOp::Sub => checker.resolve(&left_ty),
        common::BinOp::Mul => checker.resolve(&left_ty),
        common::BinOp::Div => checker.resolve(&left_ty),
        common::BinOp::Rem => checker.resolve(&left_ty),
        // Bitwise operators return the operand type
        common::BinOp::BitAnd => checker.resolve(&left_ty),
        common::BinOp::BitOr => checker.resolve(&left_ty),
        common::BinOp::BitXor => checker.resolve(&left_ty),
        common::BinOp::Shl => checker.resolve(&left_ty),
        common::BinOp::Shr => checker.resolve(&left_ty),
        // Pipe operator: left |> right where right is a function
        common::BinOp::Pipe => {
            // Pipe operator: the result is the return type of the function on the right
            // For now, return an inference variable since we'd need to resolve the function type
            checker.fresh_infer()
        }
    }
}

/// Infers the type of a unary operation.
fn infer_unary(
    checker: &mut typeck::TypeChecker,
    un_op: common::UnaryOp,
    operand: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let operand_ty = infer_expr(checker, operand);

    match un_op {
        common::UnaryOp::Neg => {
            // Negation returns the same type (must be numeric)
            checker.resolve(&operand_ty)
        }
        common::UnaryOp::Not => {
            // Logical not returns bool for bool, same type for integers (bitwise)
            checker.resolve(&operand_ty)
        }
        common::UnaryOp::Deref => {
            // Dereference: *T -> U where T is a reference/pointer type
            let resolved = checker.resolve(&operand_ty);
            match &resolved.kind {
                &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
                    hir_ty::copy_type(inner.as_ref())
                }
                &hir_ty::TypeKind::Ptr { ref inner, mutable: _ } => {
                    hir_ty::copy_type(inner.as_ref())
                }
                _ => {
                    checker.error(typeck::TypeErrorKind::TypeMismatch, span);
                    hir_ty::Type::error()
                }
            }
        }
        common::UnaryOp::Ref => {
            // Reference: &T where T is the operand type
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(checker.resolve(&operand_ty)),
                mutable: false,
            })
        }
        common::UnaryOp::RefMut => {
            // Mutable reference: &mut T where T is the operand type
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(checker.resolve(&operand_ty)),
                mutable: true,
            })
        }
    }
}

// ============================================================
// Call Type Inference
// ============================================================

/// Infers the type of a function call.
fn infer_call(
    checker: &mut typeck::TypeChecker,
    callee: &hir_expr::Expr,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let callee_ty = infer_expr(checker, callee);
    let resolved_callee = checker.resolve(&callee_ty);

    match &resolved_callee.kind {
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            // Check arity
            if params.len() != args.len() {
                checker.error(typeck::TypeErrorKind::ArityMismatch, span);
                return hir_ty::Type::error();
            }

            // Check each argument against parameter type
            let mut i: usize = 0;
            while i < args.len() {
                check_expr(checker, &args[i], &params[i]);
                i = i + 1;
            }

            // Return the return type
            hir_ty::copy_type(ret.as_ref())
        }
        &hir_ty::TypeKind::Infer(_) => {
            // Callee type not yet known - create fresh return type
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NotCallable, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of a method call.
fn infer_method_call(
    checker: &mut typeck::TypeChecker,
    receiver: &hir_expr::Expr,
    method: &common::SpannedSymbol,
    _method_def: &Option<hir_def::DefId>,
    type_args: &Vec<hir_ty::Type>,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let receiver_ty = infer_expr(checker, receiver);
    let resolved_receiver_raw = checker.resolve(&receiver_ty);
    let resolved_receiver = strip_refs(&resolved_receiver_raw);

    // If receiver type is still an unresolved inference variable, we cannot
    // reliably look up methods because types_match_for_impl would match ANY
    // impl. Infer all arg types and record a pending call for deferred resolution.
    match &resolved_receiver.kind {
        &hir_ty::TypeKind::Infer(ref var_id) => {
            let mut i: usize = 0;
            while i < args.len() {
                infer_expr(checker, &args[i]);
                i = i + 1;
            }
            let return_ty = checker.fresh_infer();
            let return_var = match &return_ty.kind {
                &hir_ty::TypeKind::Infer(ref ret_var) => ret_var.index,
                _ => 0,
            };
            checker.record_pending_method_call(span.start, var_id.index, method.symbol, return_var);
            return return_ty;
        }
        _ => {}
    }

    // Look up the method on the receiver type
    match checker.lookup_method(&resolved_receiver, method.symbol) {
        Some(lookup_result) => {
            // Get method info from the lookup
            let method_info = checker.get_method_from_lookup(&lookup_result);
            let impl_info = checker.get_impl_from_lookup(&lookup_result);

            // Build type argument substitution
            // If explicit type args provided, use them; otherwise extract from receiver
            let mut subst = unify::TypeParamSubst::new();
            if type_args.len() > 0 {
                let mut i: usize = 0;
                while i < type_args.len() {
                    subst.add(i as u32, hir_ty::copy_type(&type_args[i]));
                    i = i + 1;
                }
            } else if impl_info.num_generics > 0 {
                // Extract type params by matching impl's self_ty against actual receiver
                unify::extract_type_params_from_self_ty(&impl_info.self_ty, &resolved_receiver, &mut subst);
                // Fill in any remaining params with fresh inference variables
                let mut i: u32 = 0;
                while i < impl_info.num_generics {
                    match subst.lookup(i) {
                        Option::Some(_) => {}
                        Option::None => {
                            subst.add(i, checker.fresh_infer());
                        }
                    }
                    i = i + 1;
                }
            }

            // Check arity (excluding self parameter)
            if method_info.param_tys.len() != args.len() {
                checker.error(typeck::TypeErrorKind::ArityMismatch, span);
                return hir_ty::Type::error();
            }

            // Check each argument against parameter type (after substitution)
            let mut i: usize = 0;
            while i < args.len() {
                let param_ty = unify::substitute_type_params(&method_info.param_tys[i], &subst);
                check_expr(checker, &args[i], &param_ty);
                i = i + 1;
            }

            // Record the resolved method DefId for MIR lowering
            checker.record_method_resolution(span.start, method_info.def_id.index);

            // Return the return type after substitution
            unify::substitute_type_params(&method_info.return_ty, &subst)
        }
        Option::None => {
            // Method not found - report error
            checker.error(typeck::TypeErrorKind::NoSuchMethod, span);

            // Still infer types for all arguments
            let mut i: usize = 0;
            while i < args.len() {
                infer_expr(checker, &args[i]);
                i = i + 1;
            }

            hir_ty::Type::error()
        }
    }
}

// ============================================================
// Field and Index Type Inference
// ============================================================

/// Infers the type of a field access.
fn infer_field(
    checker: &mut typeck::TypeChecker,
    base: &hir_expr::Expr,
    field: &hir_expr::FieldAccess,
    span: common::Span,
) -> hir_ty::Type {
    let base_ty = infer_expr(checker, base);
    let resolved_base_raw = checker.resolve(&base_ty);
    let resolved_base = strip_refs(&resolved_base_raw);

    match &resolved_base.kind {
        &hir_ty::TypeKind::Tuple(ref types) => {
            // Tuple field access by index
            match field {
                &hir_expr::FieldAccess::Index(idx) => {
                    let idx_usize = idx as usize;
                    if idx_usize < types.len() {
                        hir_ty::copy_type(&types[idx_usize])
                    } else {
                        checker.error(typeck::TypeErrorKind::NoSuchField, span);
                        hir_ty::Type::error()
                    }
                }
                &hir_expr::FieldAccess::Named { name: _, field_idx: _ } => {
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
            }
        }
        &hir_ty::TypeKind::Record { ref fields, row_var: _ } => {
            // Record field access by name
            match field {
                &hir_expr::FieldAccess::Named { ref name, field_idx: _ } => {
                    let mut i: usize = 0;
                    while i < fields.len() {
                        if fields[i].name.index == name.symbol.index {
                            return hir_ty::copy_type(&fields[i].ty);
                        }
                        i = i + 1;
                    }
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
                &hir_expr::FieldAccess::Index(_) => {
                    checker.error(typeck::TypeErrorKind::NoSuchField, span);
                    hir_ty::Type::error()
                }
            }
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // ADT field access - look up struct definition
            match field {
                &hir_expr::FieldAccess::Named { ref name, field_idx: _ } => {
                    // Look up the field type from the struct definition
                    match checker.get_struct_field_ty(def_id, name.symbol) {
                        Some(field_ty) => {
                            // If the struct has type arguments, substitute them
                            if args.len() > 0 {
                                let subst = unify::TypeParamSubst::from_types(args);
                                unify::substitute_type_params(&field_ty, &subst)
                            } else {
                                field_ty
                            }
                        }
                        Option::None => {
                            checker.error(typeck::TypeErrorKind::NoSuchField, span);
                            hir_ty::Type::error()
                        }
                    }
                }
                &hir_expr::FieldAccess::Index(idx) => {
                    // Tuple-like struct field access by index
                    match checker.get_struct(def_id) {
                        Some(struct_info) => {
                            let idx_usize = idx as usize;
                            if idx_usize < struct_info.fields.len() {
                                let field_ty = hir_ty::copy_type(&struct_info.fields[idx_usize].ty);
                                if args.len() > 0 {
                                    let subst = unify::TypeParamSubst::from_types(args);
                                    unify::substitute_type_params(&field_ty, &subst)
                                } else {
                                    field_ty
                                }
                            } else {
                                checker.error(typeck::TypeErrorKind::NoSuchField, span);
                                hir_ty::Type::error()
                            }
                        }
                        Option::None => {
                            // Not a struct - might be an enum
                            checker.error(typeck::TypeErrorKind::NoSuchField, span);
                            hir_ty::Type::error()
                        }
                    }
                }
            }
        }
        &hir_ty::TypeKind::Infer(_) => {
            // Base type not yet known
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NoSuchField, span);
            hir_ty::Type::error()
        }
    }
}

/// Infers the type of an index operation.
fn infer_index(
    checker: &mut typeck::TypeChecker,
    base: &hir_expr::Expr,
    idx: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let base_ty = infer_expr(checker, base);
    let idx_ty = infer_expr(checker, idx);
    let resolved_base_raw = checker.resolve(&base_ty);
    let resolved_base = strip_refs(&resolved_base_raw);

    // Index must be an integer type. Accept any integer (signed or unsigned),
    // matching blood-rust's behavior. Default inference variables to usize.
    let resolved_idx = checker.resolve(&idx_ty);
    match &resolved_idx.kind {
        &hir_ty::TypeKind::Primitive(prim) => {
            match prim {
                hir_ty::PrimitiveTy::I8 => {}
                hir_ty::PrimitiveTy::I16 => {}
                hir_ty::PrimitiveTy::I32 => {}
                hir_ty::PrimitiveTy::I64 => {}
                hir_ty::PrimitiveTy::I128 => {}
                hir_ty::PrimitiveTy::Isize => {}
                hir_ty::PrimitiveTy::U8 => {}
                hir_ty::PrimitiveTy::U16 => {}
                hir_ty::PrimitiveTy::U32 => {}
                hir_ty::PrimitiveTy::U64 => {}
                hir_ty::PrimitiveTy::U128 => {}
                hir_ty::PrimitiveTy::Usize => {}
                _ => {
                    checker.error(typeck::TypeErrorKind::TypeMismatch, idx.span);
                }
            }
        }
        &hir_ty::TypeKind::Infer(_) => {
            let usize_ty = hir_ty::Type::usize_ty();
            checker.unify(&idx_ty, &usize_ty, idx.span);
        }
        &hir_ty::TypeKind::Error => {}
        _ => {
            checker.error(typeck::TypeErrorKind::TypeMismatch, idx.span);
        }
    }

    match &resolved_base.kind {
        &hir_ty::TypeKind::Array { ref element, size: _ } => {
            hir_ty::copy_type(element.as_ref())
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::copy_type(element.as_ref())
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Vec<T>[usize] -> T
            let is_vec = match &checker.builtin_vec_def {
                &Option::Some(ref vec_def) => def_id.index == vec_def.index,
                &Option::None => false,
            };
            if is_vec && args.len() > 0 {
                hir_ty::copy_type(&args[0])
            } else {
                // String[usize] -> u8
                let is_string = match &checker.builtin_string_def {
                    &Option::Some(ref str_def) => def_id.index == str_def.index,
                    &Option::None => false,
                };
                if is_string {
                    hir_ty::Type::u8_ty()
                } else {
                    checker.error(typeck::TypeErrorKind::NotIndexable, span);
                    hir_ty::Type::error()
                }
            }
        }
        &hir_ty::TypeKind::Infer(_) => {
            checker.fresh_infer()
        }
        &hir_ty::TypeKind::Error => {
            hir_ty::Type::error()
        }
        _ => {
            checker.error(typeck::TypeErrorKind::NotIndexable, span);
            hir_ty::Type::error()
        }
    }
}

// ============================================================
// Compound Expression Type Inference
// ============================================================

/// Infers the type of a tuple expression.
fn infer_tuple(
    checker: &mut typeck::TypeChecker,
    exprs: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    let mut types: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < exprs.len() {
        types.push(infer_expr(checker, &exprs[i]));
        i = i + 1;
    }
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(types))
}

/// Infers the type of an array expression.
fn infer_array(
    checker: &mut typeck::TypeChecker,
    arr: &hir_expr::ArrayExpr,
    span: common::Span,
) -> hir_ty::Type {
    match arr {
        &hir_expr::ArrayExpr::List(ref exprs) => {
            if exprs.len() == 0 {
                // Empty array - element type is inference variable
                let elem_ty = checker.fresh_infer();
                hir_ty::Type::new(hir_ty::TypeKind::Array {
                    element: Box::new(elem_ty),
                    size: 0,
                })
            } else {
                // Infer element type from first element, unify all others
                let elem_ty = infer_expr(checker, &exprs[0]);
                let mut i: usize = 1;
                while i < exprs.len() {
                    let ty = infer_expr(checker, &exprs[i]);
                    checker.unify(&ty, &elem_ty, exprs[i].span);
                    i = i + 1;
                }
                hir_ty::Type::new(hir_ty::TypeKind::Array {
                    element: Box::new(checker.resolve(&elem_ty)),
                    size: exprs.len() as u64,
                })
            }
        }
        &hir_expr::ArrayExpr::Repeat { ref val, count } => {
            let elem_ty = infer_expr(checker, val.as_ref());
            // count is already a u64 (const evaluated at lowering time)
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(checker.resolve(&elem_ty)),
                size: count,
            })
        }
    }
}

/// Infers the type of a struct expression.
fn infer_struct(
    checker: &mut typeck::TypeChecker,
    path: &hir_def::ResolvedPath,
    fields: &Vec<hir_expr::FieldExpr>,
    base: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    // Check all field expressions
    let mut i: usize = 0;
    while i < fields.len() {
        infer_expr(checker, &fields[i].val);
        i = i + 1;
    }

    // Check base expression if present
    match base {
        &Some(ref b) => {
            infer_expr(checker, b.as_ref());
        }
        &None => {}
    }

    // Check if the path refers to an enum variant (record variant construction)
    match checker.find_enum_for_variant(path.def_id) {
        Option::Some(ref lookup) => {
            // Build ADT type using the parent enum's DefId
            let mut args: Vec<hir_ty::Type> = Vec::new();
            let mut g: u32 = 0;
            while g < lookup.num_generics {
                args.push(checker.fresh_infer());
                g = g + 1;
            }
            return hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: lookup.enum_def_id,
                args: args,
            });
        }
        Option::None => {}
    }

    // Regular struct construction
    // Look up the struct definition's actual number of generics, rather than
    // relying on explicit type args at the call site (which may be omitted).
    // This matches blood-rust's behavior of always creating the right number
    // of fresh inference variables for generic structs.
    //
    // Uses has_struct + get_struct_num_generics (value-type returns) instead of
    // get_struct (Option<&StructInfo>) to avoid blood-rust reference return bugs.
    let num_gen = if checker.has_struct(path.def_id) {
        checker.get_struct_num_generics(path.def_id)
    } else {
        path.type_arg_count
    };
    let mut args: Vec<hir_ty::Type> = Vec::new();
    let mut ta: u32 = 0;
    while ta < num_gen {
        args.push(checker.fresh_infer());
        ta = ta + 1;
    }
    hir_ty::Type::new(hir_ty::TypeKind::Adt {
        def_id: path.def_id,
        args: args,
    })
}

/// Infers the type of an anonymous record expression.
fn infer_anon_record(
    checker: &mut typeck::TypeChecker,
    fields: &Vec<hir_expr::AnonRecordField>,
    span: common::Span,
) -> hir_ty::Type {
    // Build the record type from field expressions
    let mut record_fields: Vec<hir_ty::RecordField> = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let field = &fields[i];
        let field_ty = infer_expr(checker, &field.val);
        record_fields.push(hir_ty::RecordField::new(
            field.name.symbol,
            field_ty,
        ));
        i = i + 1;
    }

    // Create a closed record type (no row variable)
    hir_ty::Type::new(hir_ty::TypeKind::Record {
        fields: record_fields,
        row_var: Option::None,
    })
}

/// Infers the type of a range expression.
fn infer_range(
    checker: &mut typeck::TypeChecker,
    start: &Option<Box<hir_expr::Expr>>,
    end_val: &Option<Box<hir_expr::Expr>>,
    inclusive: bool,
    span: common::Span,
) -> hir_ty::Type {
    // Infer bound types and unify them
    let bound_ty = match (start, end_val) {
        (&Some(ref s), &Some(ref e)) => {
            let start_ty = infer_expr(checker, s.as_ref());
            let end_ty = infer_expr(checker, e.as_ref());
            checker.unify(&start_ty, &end_ty, span);
            checker.resolve(&start_ty)
        }
        (&Some(ref s), &None) => infer_expr(checker, s.as_ref()),
        (&None, &Some(ref e)) => infer_expr(checker, e.as_ref()),
        (&None, &None) => checker.fresh_infer(),
    };

    // Range types are ADTs in std - for now return inference variable
    checker.fresh_infer()
}

/// Infers the type of a cast expression.
fn infer_cast(
    checker: &mut typeck::TypeChecker,
    expr: &hir_expr::Expr,
    ty: &hir_ty::Type,
    span: common::Span,
) -> hir_ty::Type {
    // Check the source expression
    let src_ty = infer_expr(checker, expr);
    let resolved_src = checker.resolve(&src_ty);
    let resolved_dst = checker.resolve(ty);

    // Validate that the cast is valid
    if !is_valid_cast(&resolved_src, &resolved_dst) {
        checker.error(typeck::TypeErrorKind::InvalidCast, span);
    }

    // Return the target type
    hir_ty::copy_type(ty)
}

/// Checks if a cast from src_ty to dst_ty is valid.
///
/// Valid casts include:
/// - Numeric to numeric (integer/float coercions)
/// - Pointer to usize/isize
/// - Reference to raw pointer
/// - Same type (no-op cast)
fn is_valid_cast(src_ty: &hir_ty::Type, dst_ty: &hir_ty::Type) -> bool {
    match (&src_ty.kind, &dst_ty.kind) {
        // If either type is an unresolved inference variable, accept the cast.
        // The actual validity will depend on what the variable resolves to.
        // This handles cases like `10 as char` where the literal's type is
        // still Infer($x) at cast-checking time.
        (&hir_ty::TypeKind::Infer(_), _) => true,
        (_, &hir_ty::TypeKind::Infer(_)) => true,
        // Primitive to primitive casts
        (&hir_ty::TypeKind::Primitive(src_prim), &hir_ty::TypeKind::Primitive(dst_prim)) => {
            // Numeric to numeric casts are always valid
            if is_numeric_primitive(src_prim) && is_numeric_primitive(dst_prim) {
                return true;
            }
            // Integer to char (u8 as char, u32 as char, etc.)
            if is_numeric_primitive(src_prim) && is_char_primitive(dst_prim) {
                return true;
            }
            // Char to integer (char as u32, char as u8, etc.)
            if is_char_primitive(src_prim) && is_numeric_primitive(dst_prim) {
                return true;
            }
            // Bool to integer (bool as u8, etc.)
            if is_bool_primitive(src_prim) && is_numeric_primitive(dst_prim) {
                return true;
            }
            false
        }
        // Raw pointer to usize/isize
        (&hir_ty::TypeKind::Ptr { inner: _, mutable: _ }, &hir_ty::TypeKind::Primitive(dst_prim)) => {
            match dst_prim {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        // usize/isize to raw pointer
        (&hir_ty::TypeKind::Primitive(src_prim), &hir_ty::TypeKind::Ptr { inner: _, mutable: _ }) => {
            match src_prim {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        // Reference to raw pointer
        (&hir_ty::TypeKind::Ref { inner: _, mutable: src_mut }, &hir_ty::TypeKind::Ptr { inner: _, mutable: dst_mut }) => {
            // Can cast &T to *const T or &mut T to *mut T
            // Also &mut T can be cast to *const T
            !dst_mut || src_mut
        }
        // Pointer to pointer (with same or less mutability)
        (&hir_ty::TypeKind::Ptr { inner: _, mutable: src_mut }, &hir_ty::TypeKind::Ptr { inner: _, mutable: dst_mut }) => {
            !dst_mut || src_mut
        }
        // Error types can be cast to anything
        (&hir_ty::TypeKind::Error, _) => true,
        (_, &hir_ty::TypeKind::Error) => true,
        // Ownership types - check inner types
        (&hir_ty::TypeKind::Ownership { qualifier: _, ref inner }, _) => {
            is_valid_cast(inner.as_ref(), dst_ty)
        }
        (_, &hir_ty::TypeKind::Ownership { qualifier: _, ref inner }) => {
            is_valid_cast(src_ty, inner.as_ref())
        }
        // Other casts are invalid
        _ => false,
    }
}

/// Checks if a primitive type is numeric (integer or float).
fn is_numeric_primitive(prim: hir_ty::PrimitiveTy) -> bool {
    match prim {
        hir_ty::PrimitiveTy::I8 => true,
        hir_ty::PrimitiveTy::I16 => true,
        hir_ty::PrimitiveTy::I32 => true,
        hir_ty::PrimitiveTy::I64 => true,
        hir_ty::PrimitiveTy::I128 => true,
        hir_ty::PrimitiveTy::Isize => true,
        hir_ty::PrimitiveTy::U8 => true,
        hir_ty::PrimitiveTy::U16 => true,
        hir_ty::PrimitiveTy::U32 => true,
        hir_ty::PrimitiveTy::U64 => true,
        hir_ty::PrimitiveTy::U128 => true,
        hir_ty::PrimitiveTy::Usize => true,
        hir_ty::PrimitiveTy::F32 => true,
        hir_ty::PrimitiveTy::F64 => true,
        hir_ty::PrimitiveTy::Bool => false,
        hir_ty::PrimitiveTy::Char => false,
        hir_ty::PrimitiveTy::Str => false,
    }
}

/// Checks if a primitive type is char.
fn is_char_primitive(prim: hir_ty::PrimitiveTy) -> bool {
    match prim {
        hir_ty::PrimitiveTy::Char => true,
        hir_ty::PrimitiveTy::I8 => false,
        hir_ty::PrimitiveTy::I16 => false,
        hir_ty::PrimitiveTy::I32 => false,
        hir_ty::PrimitiveTy::I64 => false,
        hir_ty::PrimitiveTy::I128 => false,
        hir_ty::PrimitiveTy::Isize => false,
        hir_ty::PrimitiveTy::U8 => false,
        hir_ty::PrimitiveTy::U16 => false,
        hir_ty::PrimitiveTy::U32 => false,
        hir_ty::PrimitiveTy::U64 => false,
        hir_ty::PrimitiveTy::U128 => false,
        hir_ty::PrimitiveTy::Usize => false,
        hir_ty::PrimitiveTy::F32 => false,
        hir_ty::PrimitiveTy::F64 => false,
        hir_ty::PrimitiveTy::Bool => false,
        hir_ty::PrimitiveTy::Str => false,
    }
}

/// Checks if a primitive type is bool.
fn is_bool_primitive(prim: hir_ty::PrimitiveTy) -> bool {
    match prim {
        hir_ty::PrimitiveTy::Bool => true,
        hir_ty::PrimitiveTy::I8 => false,
        hir_ty::PrimitiveTy::I16 => false,
        hir_ty::PrimitiveTy::I32 => false,
        hir_ty::PrimitiveTy::I64 => false,
        hir_ty::PrimitiveTy::I128 => false,
        hir_ty::PrimitiveTy::Isize => false,
        hir_ty::PrimitiveTy::U8 => false,
        hir_ty::PrimitiveTy::U16 => false,
        hir_ty::PrimitiveTy::U32 => false,
        hir_ty::PrimitiveTy::U64 => false,
        hir_ty::PrimitiveTy::U128 => false,
        hir_ty::PrimitiveTy::Usize => false,
        hir_ty::PrimitiveTy::F32 => false,
        hir_ty::PrimitiveTy::F64 => false,
        hir_ty::PrimitiveTy::Char => false,
        hir_ty::PrimitiveTy::Str => false,
    }
}

// ============================================================
// Assignment Type Inference
// ============================================================

/// Infers the type of an assignment expression.
fn infer_assign(
    checker: &mut typeck::TypeChecker,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let target_ty = infer_expr(checker, target);
    let val_ty = infer_expr(checker, val);

    // Value type must match target type
    checker.unify(&val_ty, &target_ty, span);

    // Check that target is a valid lvalue
    if !is_lvalue(target) {
        checker.error(typeck::TypeErrorKind::InvalidLValue, target.span);
    }

    // Assignment returns unit
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
}

/// Infers the type of a compound assignment expression.
fn infer_assign_op(
    checker: &mut typeck::TypeChecker,
    assign_op: common::BinOp,
    target: &hir_expr::Expr,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let target_ty = infer_expr(checker, target);
    let val_ty = infer_expr(checker, val);

    // For most operators, types should match
    checker.unify(&val_ty, &target_ty, span);

    // Check that target is a valid lvalue (mutable check would require borrow checker)
    if !is_lvalue(target) {
        checker.error(typeck::TypeErrorKind::InvalidLValue, target.span);
    }

    // Compound assignment returns unit
    hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
}

/// Infers the type of an address-of expression.
fn infer_addr_of(
    checker: &mut typeck::TypeChecker,
    mutable: bool,
    expr: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let inner_ty = infer_expr(checker, expr);
    hir_ty::Type::new(hir_ty::TypeKind::Ref {
        inner: Box::new(checker.resolve(&inner_ty)),
        mutable: mutable,
    })
}

// ============================================================
// Block and Control Flow Type Inference
// ============================================================

/// Infers the type of a block expression.
fn infer_block(
    checker: &mut typeck::TypeChecker,
    block: &hir_expr::Block,
    span: common::Span,
) -> hir_ty::Type {
    // Process all statements, tracking the last statement's type
    let mut last_stmt_ty: hir_ty::Type = hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()));
    let mut i: usize = 0;
    while i < block.stmts.len() {
        last_stmt_ty = infer_stmt(checker, &block.stmts[i]);
        i = i + 1;
    }

    // Block type is the type of the final expression, or unit.
    // Exception: if there's no trailing expression but the last statement
    // diverges (Never type from return/break/continue/panic), the block
    // type is Never  this allows match arms with `return` to not
    // poison the match expression's type as `()`.
    match &block.expr {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => {
            match &last_stmt_ty.kind {
                &hir_ty::TypeKind::Never => hir_ty::Type::never(),
                &hir_ty::TypeKind::Error => hir_ty::Type::error(),
                _ => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
            }
        }
    }
}

/// Infers the type of a statement.
fn infer_stmt(checker: &mut typeck::TypeChecker, stmt: &hir_expr::Stmt) -> hir_ty::Type {
    match stmt {
        &hir_expr::Stmt::Let { ref pattern, ref ty, ref init, span: _ } => {
            // Infer or check initializer type
            let init_ty = match init {
                &Some(ref e) => infer_expr(checker, e),
                &None => checker.fresh_infer(),
            };

            // Unify with declared type if present
            match ty {
                &Some(ref declared) => {
                    checker.unify(&init_ty, declared, pattern.span);
                }
                &None => {}
            }

            // Propagate the init type through the pattern structure.
            // This unifies the pattern's type variable with the concrete
            // type AND walks sub-patterns (struct fields, ref bindings, etc.)
            // to ensure all inner inference variables are properly constrained.
            propagate_pattern_types(checker, pattern, &init_ty);
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
        }
        &hir_expr::Stmt::Expr { ref expr, has_semi: _ } => {
            infer_expr(checker, expr)
        }
        &hir_expr::Stmt::Item(_def_id) => {
            // Item statements are handled during item collection
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()))
        }
    }
}

/// Infers the type of an if expression.
fn infer_if(
    checker: &mut typeck::TypeChecker,
    condition: &hir_expr::Expr,
    then_branch: &hir_expr::Expr,
    else_branch: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    // Condition must be bool
    let cond_ty = infer_expr(checker, condition);
    let bool_ty = hir_ty::Type::bool_ty();
    checker.unify(&cond_ty, &bool_ty, condition.span);

    // Infer branch types
    let then_ty = infer_expr(checker, then_branch);

    match else_branch {
        &Some(ref e) => {
            let else_ty = infer_expr(checker, e.as_ref());
            // Handle diverging branches: if one branch is Never,
            // the if-expression's type is the other branch's type.
            match (&then_ty.kind, &else_ty.kind) {
                (&hir_ty::TypeKind::Never, _) => {
                    // Then branch diverges; use else branch type
                    checker.resolve(&else_ty)
                }
                (_, &hir_ty::TypeKind::Never) => {
                    // Else branch diverges; use then branch type
                    checker.resolve(&then_ty)
                }
                _ => {
                    // Both branches must have same type
                    checker.unify(&then_ty, &else_ty, span);
                    checker.resolve(&then_ty)
                }
            }
        }
        &None => {
            // No else branch - then branch must be unit, or whole if is unit
            let unit_ty = hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new()));
            checker.unify(&then_ty, &unit_ty, then_branch.span);
            unit_ty
        }
    }
}

/// Infers the type of a match expression.
fn infer_match(
    checker: &mut typeck::TypeChecker,
    scrutinee: &hir_expr::Expr,
    arms: &Vec<hir_expr::MatchArm>,
    span: common::Span,
) -> hir_ty::Type {
    let scrut_ty_raw = infer_expr(checker, scrutinee);
    let scrut_ty = strip_refs(&scrut_ty_raw);

    if arms.len() == 0 {
        // Empty match - type is never (or error)
        return hir_ty::Type::never();
    }

    // Propagate types through each pattern using match ergonomics.
    // This unifies each pattern's type with the scrutinee type AND
    // walks sub-patterns (struct fields, ref bindings, etc.) to ensure
    // all inner inference variables are properly constrained.
    // The raw scrutinee type (with refs) is passed so match ergonomics
    // can auto-strip refs for non-Ref patterns.
    let mut pat_i: usize = 0;
    while pat_i < arms.len() {
        propagate_match_pattern_types(checker, &arms[pat_i].pattern, &scrut_ty_raw);
        pat_i = pat_i + 1;
    }

    // Infer type from first arm, unify all others.
    // When an arm diverges (Never type from return/break/panic),
    // adopt the next non-diverging arm's type as the result.
    let mut result_ty = infer_expr(checker, &arms[0].body);

    let mut i: usize = 1;
    while i < arms.len() {
        let arm_ty = infer_expr(checker, &arms[i].body);
        match &result_ty.kind {
            &hir_ty::TypeKind::Never => {
                // Previous result was Never (diverging); adopt this arm's type
                result_ty = arm_ty;
            }
            _ => {
                checker.unify(&arm_ty, &result_ty, arms[i].body.span);
            }
        }
        i = i + 1;
    }

    // Check pattern exhaustiveness (resolve inference variables first)
    let resolved_scrut = checker.resolve(&scrut_ty);
    let exhaustiveness = typeck::check_exhaustiveness_arms(checker, &resolved_scrut, arms, span);
    if !exhaustiveness.is_exhaustive() {
        checker.error(typeck::TypeErrorKind::NonExhaustive, span);
    }

    checker.resolve(&result_ty)
}

/// Infers the type of a loop expression.
fn infer_loop(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    body: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    // Loop type is determined by break values
    let loop_ty = checker.fresh_infer();

    // Enter loop context
    let prev_in_loop = checker.in_loop;
    let prev_loop_ty = copy_option_type(&checker.loop_ty);
    checker.enter_loop(hir_ty::copy_type(&loop_ty));

    // Check body
    infer_expr(checker, body);

    // Restore context
    checker.in_loop = prev_in_loop;
    checker.loop_ty = prev_loop_ty;

    // If no break with value, loop has type !
    // For now, return the inference variable
    checker.resolve(&loop_ty)
}

/// Infers the type of a return expression.
fn infer_return(
    checker: &mut typeck::TypeChecker,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    let val_ty = match val {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
    };

    // Unify with function return type
    match &checker.return_ty {
        &Some(ref ret_ty) => {
            let ret_copy = hir_ty::copy_type(ret_ty);
            checker.unify(&val_ty, &ret_copy, span);
        }
        &None => {
            checker.error(typeck::TypeErrorKind::InvalidControl, span);
        }
    }

    // Return expression has type Never
    hir_ty::Type::never()
}

/// Infers the type of a break expression.
fn infer_break(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    val: &Option<Box<hir_expr::Expr>>,
    span: common::Span,
) -> hir_ty::Type {
    if !checker.in_loop {
        checker.error(typeck::TypeErrorKind::InvalidControl, span);
        return hir_ty::Type::never();
    }

    let val_ty = match val {
        &Some(ref e) => infer_expr(checker, e.as_ref()),
        &None => hir_ty::Type::new(hir_ty::TypeKind::Tuple(Vec::new())),
    };

    // Unify with loop type
    match &checker.loop_ty {
        &Some(ref loop_ty) => {
            let loop_copy = hir_ty::copy_type(loop_ty);
            checker.unify(&val_ty, &loop_copy, span);
        }
        &None => {}
    }

    hir_ty::Type::never()
}

/// Infers the type of a continue expression.
fn infer_continue(
    checker: &mut typeck::TypeChecker,
    _label: &Option<common::Symbol>,
    span: common::Span,
) -> hir_ty::Type {
    if !checker.in_loop {
        checker.error(typeck::TypeErrorKind::InvalidControl, span);
    }
    hir_ty::Type::never()
}

// ============================================================
// Closure Type Inference
// ============================================================

/// Infers the type of a closure expression.
fn infer_closure(
    checker: &mut typeck::TypeChecker,
    captures: &Vec<hir_expr::Capture>,
    params: &Vec<hir_expr::ClosureParam>,
    return_ty: &hir_ty::Type,
    effects: &hir_ty::EffectRow,
    body: &hir_expr::Expr,
    _body_id: hir_def::BodyId,
    span: common::Span,
) -> hir_ty::Type {
    // Build parameter types
    let mut param_types: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() {
        param_types.push(hir_ty::copy_type(&params[i].ty));
        i = i + 1;
    }

    // Set up closure context
    let prev_return = copy_option_type(&checker.return_ty);
    checker.set_return_ty(hir_ty::copy_type(return_ty));

    // Check body
    let body_ty = infer_expr(checker, body);
    checker.unify(&body_ty, return_ty, body.span);

    // Restore context
    checker.return_ty = prev_return;

    // Return function type
    hir_ty::Type::new(hir_ty::TypeKind::Fn {
        params: param_types,
        ret: Box::new(hir_ty::copy_type(return_ty)),
        effects: hir_ty::copy_effect_row(effects),
    })
}

// ============================================================
// Effect System Type Inference
// ============================================================

/// Infers the type of a with-handle expression.
fn infer_with_handle(
    checker: &mut typeck::TypeChecker,
    handler_expr: &hir_expr::Expr,
    body: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    // Check handler and body
    infer_expr(checker, handler_expr);
    infer_expr(checker, body)
}

/// Infers the type of an effect operation invocation.
fn infer_perform(
    checker: &mut typeck::TypeChecker,
    effect_def: hir_def::DefId,
    _op_def: hir_def::DefId,
    op_name: common::Symbol,
    args: &Vec<hir_expr::Expr>,
    span: common::Span,
) -> hir_ty::Type {
    // Infer argument types first
    let mut arg_tys: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg_ty = infer_expr(checker, &args[i]);
        arg_tys.push(arg_ty);
        i = i + 1;
    }

    // Look up the effect to find the operation
    if checker.has_effect(effect_def) {
        let def_idx = effect_def.index as usize;
        // Find the matching operation by name
        let num_ops = checker.get_effect_num_ops(effect_def);

        // Check if the effect has generic parameters  if so, we cannot
        // unify concrete argument types against uninstantiated generic param types.
        // Fall back to arity checking only for generic effects.
        let mut effect_is_generic = false;
        match &checker.effects[def_idx] {
            &Some(ref info) => {
                if info.num_generics > 0 {
                    effect_is_generic = true;
                }
            }
            &None => {}
        }

        let mut found = false;
        let mut result_ty = checker.fresh_infer();
        let mut oi: u32 = 0;
        while oi < num_ops {
            let oi_usize = oi as usize;
            match &checker.effects[def_idx] {
                &Some(ref info) => {
                    let effect_op = &info.operations[oi_usize];
                    if effect_op.name.index == op_name.index {
                        // Found the operation - check argument count
                        if arg_tys.len() != effect_op.param_tys.len() {
                            checker.error(typeck::TypeErrorKind::ArityMismatch, span);
                        } else if !effect_is_generic {
                            // Only unify when the effect is non-generic
                            let mut ai: usize = 0;
                            while ai < arg_tys.len() {
                                checker.unify(&arg_tys[ai], &effect_op.param_tys[ai], span);
                                ai = ai + 1;
                            }
                        }
                        if effect_is_generic {
                            // Generic effect  return type has uninstantiated params,
                            // use fresh inference variable instead
                            result_ty = checker.fresh_infer();
                        } else {
                            result_ty = hir_ty::copy_type(&effect_op.return_ty);
                        }
                        found = true;
                    }
                }
                &None => {}
            }
            oi = oi + 1;
        }
        if !found {
            // Operation not found in effect - report error
            checker.error(typeck::TypeErrorKind::UnhandledEffect, span);
        }
        result_ty
    } else {
        // Effect not registered (cross-module or unknown) - fall back to inference
        checker.fresh_infer()
    }
}

/// Infers the type of a resume expression.
fn infer_resume(
    checker: &mut typeck::TypeChecker,
    val: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    infer_expr(checker, val);
    // Resume's return type depends on context
    checker.fresh_infer()
}

/// Infers the type of a try expression.
fn infer_try(
    checker: &mut typeck::TypeChecker,
    inner: &hir_expr::Expr,
    span: common::Span,
) -> hir_ty::Type {
    let inner_ty = infer_expr(checker, inner);
    // ? operator extracts from Result/Option
    // For now, return inference variable
    checker.fresh_infer()
}

// ============================================================
// Type Copying Helper
// ============================================================

/// Creates a copy of an Option<Type>.
fn copy_option_type(opt: &Option<hir_ty::Type>) -> Option<hir_ty::Type> {
    match opt {
        &Some(ref ty) => Some(hir_ty::copy_type(ty)),
        &None => Option::None,
    }
}

// ============================================================
// Pattern Type Propagation
// ============================================================

/// Propagates type information from a resolved type down through a pattern's
/// sub-patterns. After unifying a pattern's top-level type with the scrutinee
/// or initializer, this function walks the pattern structure to ensure all
/// inner patterns (bindings, fields, ref patterns, etc.) also have their
/// inference variables unified with the correct concrete types.
///
/// Without this propagation, inner bindings remain as unconstrained Infer
/// variables, causing method lookup to match incorrect impls and producing
/// cascading type errors.
pub fn propagate_pattern_types(
    checker: &mut typeck::TypeChecker,
    pattern: &hir_expr::Pattern,
    expected_ty: &hir_ty::Type,
) {
    propagate_pattern_types_inner(checker, pattern, expected_ty, false);
}

/// Propagates types with match ergonomics (auto-deref for non-ref patterns).
/// Used by match expressions where the scrutinee's raw type (with refs) is passed.
/// This unifies the top-level pattern type  use propagate_match_sub_patterns
/// when the top-level type is already set (e.g., by infer_match Phase 1).
pub fn propagate_match_pattern_types(
    checker: &mut typeck::TypeChecker,
    pattern: &hir_expr::Pattern,
    expected_ty: &hir_ty::Type,
) {
    propagate_pattern_types_inner(checker, pattern, expected_ty, true);
}

/// Propagates types through a match pattern's SUB-patterns only.
/// The top-level pattern type is NOT modified (already set by the caller).
/// This is used by infer_match's Phase 2: after Phase 1 sets pattern.ty to
/// the stripped scrutinee (for exhaustiveness), this function walks the pattern
/// tree to assign correct types to bindings, struct fields, etc.
///
/// The raw_scrutinee includes reference layers so Ref patterns can strip them.
fn propagate_match_sub_patterns(
    checker: &mut typeck::TypeChecker,
    pattern: &hir_expr::Pattern,
    raw_scrutinee: &hir_ty::Type,
) {
    // Determine the value type for sub-pattern propagation.
    // For Ref patterns, use the raw type (they strip one layer).
    // For non-Ref patterns, strip refs (match ergonomics auto-deref).
    let is_ref_pattern = match &pattern.kind {
        &hir_expr::PatternKind::Ref { mutable: _, inner: _ } => true,
        _ => false,
    };

    let value_ty = if is_ref_pattern {
        hir_ty::copy_type(raw_scrutinee)
    } else {
        strip_refs(raw_scrutinee)
    };

    let resolved = checker.resolve(&value_ty);

    match &pattern.kind {
        &hir_expr::PatternKind::Binding {
            local_id: _,
            ref name,
            ref mode,
            ref subpattern,
        } => {
            let _ = name;
            let _ = mode;
            // Binding type was set by Phase 1 unification.
            // Propagate to subpattern if present.
            match subpattern {
                &Some(ref sub) => {
                    propagate_pattern_types(checker, sub.as_ref(), &resolved);
                }
                &None => {}
            }
        }

        &hir_expr::PatternKind::Ref { mutable: _, ref inner } => {
            // Strip one reference layer and propagate to inner pattern.
            let deref_ty = strip_one_ref(&resolved);
            match deref_ty {
                Option::Some(ref dt) => {
                    // Inner pattern gets the dereferenced type with full unification.
                    propagate_pattern_types(checker, inner.as_ref(), dt);
                }
                Option::None => {
                    // Raw scrutinee is not a reference  can't strip
                }
            }
        }

        &hir_expr::PatternKind::Struct {
            ref path,
            ref fields,
            has_rest: _,
        } => {
            propagate_struct_pattern_fields(checker, &resolved, path, fields);
        }

        &hir_expr::PatternKind::TupleStruct {
            ref path,
            ref fields,
        } => {
            propagate_tuple_struct_pattern_fields(checker, &resolved, path, fields);
        }

        &hir_expr::PatternKind::Tuple(ref pats) => {
            match &resolved.kind {
                &hir_ty::TypeKind::Tuple(ref elem_tys) => {
                    let mut i: usize = 0;
                    let limit = if pats.len() < elem_tys.len() { pats.len() } else { elem_tys.len() };
                    while i < limit {
                        propagate_pattern_types(checker, &pats[i], &elem_tys[i]);
                        i = i + 1;
                    }
                }
                _ => {}
            }
        }

        &hir_expr::PatternKind::Slice {
            ref prefix,
            ref rest,
            ref suffix,
        } => {
            let elem_ty = get_element_type(&resolved);
            match elem_ty {
                Option::Some(ref et) => {
                    let mut i: usize = 0;
                    while i < prefix.len() {
                        propagate_pattern_types(checker, &prefix[i], et);
                        i = i + 1;
                    }
                    match rest {
                        &Some(ref r) => {
                            propagate_pattern_types(checker, r.as_ref(), &resolved);
                        }
                        &None => {}
                    }
                    let mut j: usize = 0;
                    while j < suffix.len() {
                        propagate_pattern_types(checker, &suffix[j], et);
                        j = j + 1;
                    }
                }
                Option::None => {}
            }
        }

        &hir_expr::PatternKind::Or(ref alternatives) => {
            // Each alternative sees the same raw scrutinee
            let mut i: usize = 0;
            while i < alternatives.len() {
                propagate_match_sub_patterns(checker, &alternatives[i], raw_scrutinee);
                i = i + 1;
            }
        }

        // These pattern kinds have no sub-patterns that need propagation
        &hir_expr::PatternKind::Wildcard => {}
        &hir_expr::PatternKind::Rest => {}
        &hir_expr::PatternKind::Literal(_) => {}
        &hir_expr::PatternKind::Range { ref start, ref end_val, inclusive: _ } => {
            let _ = start;
            let _ = end_val;
        }
        &hir_expr::PatternKind::Path(_) => {}
        &hir_expr::PatternKind::Error => {}
    }
}

fn propagate_pattern_types_inner(
    checker: &mut typeck::TypeChecker,
    pattern: &hir_expr::Pattern,
    expected_ty: &hir_ty::Type,
    match_ergonomics: bool,
) {
    // Handle match ergonomics: if the expected type is a reference but the
    // pattern is not a Ref pattern, auto-strip refs (like Rust's match ergonomics).
    // Ref patterns explicitly consume one reference layer.
    // This ONLY applies when match_ergonomics is true (match expressions).
    // For let patterns, types are used as-is.
    let is_ref_pattern = match &pattern.kind {
        &hir_expr::PatternKind::Ref { mutable: _, inner: _ } => true,
        _ => false,
    };

    let effective_ty = if match_ergonomics && !is_ref_pattern {
        // Auto-deref: strip all reference layers for non-ref patterns
        strip_refs(expected_ty)
    } else {
        hir_ty::copy_type(expected_ty)
    };

    // Unify this pattern's type with the effective type
    checker.unify(&pattern.ty, &effective_ty, pattern.span);

    // Resolve to get the concrete type for sub-pattern propagation
    let resolved = checker.resolve(&effective_ty);

    match &pattern.kind {
        &hir_expr::PatternKind::Binding {
            local_id: _,
            ref name,
            ref mode,
            ref subpattern,
        } => {
            // The binding's local type was already set during HIR lowering:
            // - ByValue: local_ty = Infer($x) (same as pattern.ty)
            // - ByRef: local_ty = &Infer($x)
            // - ByMutRef: local_ty = &mut Infer($x)
            // Since pattern.ty was unified with expected_ty above,
            // Infer($x) now resolves to the correct concrete type,
            // and the local's reference wrapper works automatically.
            let _ = name;

            // Propagate to subpattern if present
            match subpattern {
                &Some(ref sub) => {
                    propagate_pattern_types(checker, sub.as_ref(), &resolved);
                }
                &None => {}
            }
        }

        &hir_expr::PatternKind::Ref { mutable: _, ref inner } => {
            // &pat or &mut pat: strip one reference layer from the expected type
            // (not the resolved type which was auto-stripped).
            // The effective_ty for Ref patterns kept references, so strip one layer.
            let deref_ty = strip_one_ref(&resolved);
            match deref_ty {
                Option::Some(ref dt) => {
                    // Pass the deref'd type to the inner pattern.
                    // The inner pattern will handle further auto-deref if needed.
                    propagate_pattern_types(checker, inner.as_ref(), dt);
                }
                Option::None => {
                    // Type doesn't have reference structure  don't propagate
                }
            }
        }

        &hir_expr::PatternKind::Struct {
            ref path,
            ref fields,
            has_rest: _,
        } => {
            propagate_struct_pattern_fields(checker, &resolved, path, fields);
        }

        &hir_expr::PatternKind::TupleStruct {
            ref path,
            ref fields,
        } => {
            propagate_tuple_struct_pattern_fields(checker, &resolved, path, fields);
        }

        &hir_expr::PatternKind::Tuple(ref pats) => {
            match &resolved.kind {
                &hir_ty::TypeKind::Tuple(ref elem_tys) => {
                    let mut i: usize = 0;
                    let limit = if pats.len() < elem_tys.len() { pats.len() } else { elem_tys.len() };
                    while i < limit {
                        propagate_pattern_types(checker, &pats[i], &elem_tys[i]);
                        i = i + 1;
                    }
                }
                _ => {}
            }
        }

        &hir_expr::PatternKind::Slice {
            ref prefix,
            ref rest,
            ref suffix,
        } => {
            let elem_ty = get_element_type(&resolved);
            match elem_ty {
                Option::Some(ref et) => {
                    let mut i: usize = 0;
                    while i < prefix.len() {
                        propagate_pattern_types(checker, &prefix[i], et);
                        i = i + 1;
                    }
                    match rest {
                        &Some(ref r) => {
                            // rest pattern matches the whole slice/array type
                            propagate_pattern_types(checker, r.as_ref(), &resolved);
                        }
                        &None => {}
                    }
                    let mut j: usize = 0;
                    while j < suffix.len() {
                        propagate_pattern_types(checker, &suffix[j], et);
                        j = j + 1;
                    }
                }
                Option::None => {}
            }
        }

        &hir_expr::PatternKind::Or(ref alternatives) => {
            let mut i: usize = 0;
            while i < alternatives.len() {
                propagate_pattern_types(checker, &alternatives[i], &resolved);
                i = i + 1;
            }
        }

        // These pattern kinds have no sub-patterns to propagate to
        &hir_expr::PatternKind::Wildcard => {}
        &hir_expr::PatternKind::Rest => {}
        &hir_expr::PatternKind::Literal(_) => {}
        &hir_expr::PatternKind::Range { ref start, ref end_val, inclusive: _ } => {
            let _ = start;
            let _ = end_val;
        }
        &hir_expr::PatternKind::Path(_) => {}
        &hir_expr::PatternKind::Error => {}
    }
}

/// Strips one layer of reference from a type.
/// Returns the inner type if the type is a reference, None otherwise.
fn strip_one_ref(ty: &hir_ty::Type) -> Option<hir_ty::Type> {
    match &ty.kind {
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            Some(hir_ty::copy_type(inner.as_ref()))
        }
        _ => Option::None,
    }
}

/// Extracts the element type from an array or slice type.
fn get_element_type(ty: &hir_ty::Type) -> Option<hir_ty::Type> {
    match &ty.kind {
        &hir_ty::TypeKind::Array { ref element, size: _ } => {
            Some(hir_ty::copy_type(element.as_ref()))
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            Some(hir_ty::copy_type(element.as_ref()))
        }
        _ => Option::None,
    }
}

/// Propagates types through a struct pattern's fields.
/// Handles both struct patterns and record enum variant patterns.
fn propagate_struct_pattern_fields(
    checker: &mut typeck::TypeChecker,
    resolved_ty: &hir_ty::Type,
    path: &hir_def::ResolvedPath,
    fields: &Vec<hir_expr::FieldPattern>,
) {
    let def_id = path.def_id;

    // Build a type parameter substitution from the ADT's type args
    let subst = match &resolved_ty.kind {
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            unify::TypeParamSubst::from_types(args)
        }
        _ => unify::TypeParamSubst::new(),
    };

    // Try as a struct first
    let is_struct = match checker.get_struct(def_id) {
        Some(_) => true,
        None => false,
    };

    if is_struct {
        // Struct pattern  look up field types by name
        let mut i: usize = 0;
        while i < fields.len() {
            let field_name = fields[i].name.symbol;
            match checker.get_struct_field_ty(def_id, field_name) {
                Some(raw_ty) => {
                    let concrete_ty = unify::substitute_type_params(&raw_ty, &subst);
                    propagate_pattern_types(checker, &fields[i].pattern, &concrete_ty);
                }
                Option::None => {
                    // Field not found  type checker will report the error elsewhere
                }
            }
            i = i + 1;
        }
        return;
    }

    // Try as an enum variant (record variant)
    match checker.find_enum_for_variant(def_id) {
        Option::Some(ref lookup) => {
            // Build substitution from the enum's generic args
            let enum_subst = match &resolved_ty.kind {
                &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
                    unify::TypeParamSubst::from_types(args)
                }
                _ => unify::TypeParamSubst::new(),
            };

            // Match field patterns by name against variant's field_names
            let mut i: usize = 0;
            while i < fields.len() {
                let field_name = fields[i].name.symbol;
                // Find matching field name in variant
                let mut found: bool = false;
                let mut k: usize = 0;
                while k < lookup.field_names.len() {
                    if lookup.field_names[k].index == field_name.index {
                        // Found matching field  get its type
                        if k < lookup.field_tys.len() {
                            let raw_ty = &lookup.field_tys[k];
                            let concrete_ty = unify::substitute_type_params(raw_ty, &enum_subst);
                            propagate_pattern_types(checker, &fields[i].pattern, &concrete_ty);
                        }
                        found = true;
                    }
                    k = k + 1;
                }
                let _ = found;
                i = i + 1;
            }
        }
        Option::None => {
            // Neither struct nor known variant  cannot propagate
        }
    }
}

/// Propagates types through a tuple struct pattern's fields.
/// Handles enum variants with tuple payloads.
fn propagate_tuple_struct_pattern_fields(
    checker: &mut typeck::TypeChecker,
    resolved_ty: &hir_ty::Type,
    path: &hir_def::ResolvedPath,
    fields: &Vec<hir_expr::Pattern>,
) {
    let def_id = path.def_id;

    // Build a type parameter substitution from the ADT's type args
    let subst = match &resolved_ty.kind {
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            unify::TypeParamSubst::from_types(args)
        }
        _ => unify::TypeParamSubst::new(),
    };

    // Look up the variant's field types
    match checker.find_enum_for_variant(def_id) {
        Option::Some(ref lookup) => {
            let limit = if fields.len() < lookup.field_tys.len() { fields.len() } else { lookup.field_tys.len() };
            let mut i: usize = 0;
            while i < limit {
                let raw_ty = &lookup.field_tys[i];
                let concrete_ty = unify::substitute_type_params(raw_ty, &subst);
                propagate_pattern_types(checker, &fields[i], &concrete_ty);
                i = i + 1;
            }
        }
        Option::None => {
            // Variant not found  type checker will report the error elsewhere
        }
    }
}

