// Blood Self-Hosted Compiler - HIR Type Lowering
//
// This module handles lowering AST types to HIR types:
// - Type lowering (all AST type kinds)
// - Type path resolution
// - Generic parameter lowering
// - Effect row lowering
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod interner;
mod const_eval;

// ============================================================
// Type Lowering
// ============================================================

/// Lower an AST type to an HIR type.
pub fn lower_type(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> hir_ty::Type {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            lower_type_path(ctx, path)
        }
        &ast::TypeKind::Reference { lifetime: _, is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Pointer { is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Array { ref element, ref size } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            let array_size = const_eval::eval_array_size_u64(size.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(elem_ty),
                size: array_size,
            })
        }
        &ast::TypeKind::Slice { ref element } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(elem_ty),
            })
        }
        &ast::TypeKind::Tuple(ref types) => {
            let mut lowered: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let t = lower_type(ctx, &types[i]);
                lowered.push(t);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(lowered))
        }
        &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {
            let mut param_tys: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let t = lower_type(ctx, &params[i]);
                param_tys.push(t);
                i = i + 1;
            }
            let ret_ty = lower_type(ctx, return_type.as_ref());
            let effect_row = match effects {
                &Some(ref eff) => lower_effect_row(ctx, eff),
                &None => hir_ty::EffectRow::empty(),
            };
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: param_tys,
                ret: Box::new(ret_ty),
                effects: effect_row,
            })
        }
        &ast::TypeKind::Record { ref fields, rest: _ } => {
            let mut hir_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let f = &fields[i];
                let field_ty = lower_type(ctx, &f.ty);
                let hir_field = hir_ty::RecordField::new(f.name.symbol, field_ty);
                hir_fields.push(hir_field);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: hir_fields,
                row_var: Option::None, // TODO: Handle row polymorphism
            })
        }
        &ast::TypeKind::Ownership { qualifier: _, ref inner } => {
            // For now, just lower the inner type
            // TODO: Track ownership qualifiers
            lower_type(ctx, inner.as_ref())
        }
        &ast::TypeKind::Forall { ref params, ref body } => {
            // Lower forall type: forall<T, U> Body
            //
            // For each type parameter, allocate a type variable ID.
            // These become the quantified parameters in the Forall type.
            //
            // NOTE: Currently, the body type cannot properly reference these
            // parameters by name because they are not added to the resolver scope.
            // Full forall type support would require:
            // 1. Pushing a type parameter scope before lowering body
            // 2. Adding each parameter name -> TyVarId mapping
            // 3. Popping the scope after lowering
            // 4. Making type path resolution check type parameter scope first
            //
            // For now, we create the structure but body type param references
            // won't resolve correctly.

            let mut param_ids: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let var_id = ctx.alloc_ty_var();
                param_ids.push(var_id);
                i = i + 1;
            }

            let body_ty = lower_type(ctx, body.as_ref());

            hir_ty::Type::new(hir_ty::TypeKind::Forall {
                params: param_ids,
                body: Box::new(body_ty),
            })
        }
        &ast::TypeKind::Never => {
            hir_ty::Type::never()
        }
        &ast::TypeKind::Infer => {
            let var_id = ctx.alloc_ty_var();
            hir_ty::Type::infer(var_id)
        }
        &ast::TypeKind::Paren(ref inner) => {
            lower_type(ctx, inner.as_ref())
        }
    }
}

/// Lower a type path to an HIR type.
fn lower_type_path(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath) -> hir_ty::Type {
    // Handle built-in primitive types
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            let prim = try_primitive_type(seg.name.symbol);
            if prim.is_some() {
                return prim.unwrap();
            }
        }
    }

    // Look up the type in the resolver
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        let lookup = ctx.resolver.lookup(seg.name.symbol);
        if lookup.is_some() {
            let result = lookup.unwrap();
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
            let def_id = binding.def_id;

            // Lower type arguments if present
            let type_args = match &seg.args {
                &Some(ref args) => lower_type_args(ctx, args),
                &None => Vec::new(),
            };

            return hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: type_args,
            });
        } else {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown type"),
                seg.name.span,
            );
            return hir_ty::Type::error();
        }
    }

    // Multi-segment paths (e.g., module::Type)
    // Extract the names from path segments
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        names.push(path.segments[i].name);
        i = i + 1;
    }

    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_args = match &last_seg.args {
            &Some(ref args) => lower_type_args(ctx, args),
            &None => Vec::new(),
        };

        return hir_ty::Type::new(hir_ty::TypeKind::Adt {
            def_id: result.def_id,
            args: type_args,
        });
    }

    // Not found - report error
    ctx.error(
        hir::DiagnosticCode::E0102,
        common::make_string("undefined qualified type path"),
        path.span,
    );
    hir_ty::Type::error()
}

/// Try to convert a symbol to a primitive type.
///
/// Compares the symbol index against pre-interned primitive type names.
/// Returns the corresponding HIR type if the symbol is a primitive, None otherwise.
fn try_primitive_type(sym: common::Symbol) -> Option<hir_ty::Type> {
    let index = sym.index;

    // Check against pre-interned primitive type indices (41-57)
    if index == interner::Primitives::bool_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)));
    }
    if index == interner::Primitives::i8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I8)));
    }
    if index == interner::Primitives::i16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I16)));
    }
    if index == interner::Primitives::i32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I32)));
    }
    if index == interner::Primitives::i64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I64)));
    }
    if index == interner::Primitives::i128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I128)));
    }
    if index == interner::Primitives::isize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Isize)));
    }
    if index == interner::Primitives::u8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8)));
    }
    if index == interner::Primitives::u16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U16)));
    }
    if index == interner::Primitives::u32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U32)));
    }
    if index == interner::Primitives::u64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U64)));
    }
    if index == interner::Primitives::u128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U128)));
    }
    if index == interner::Primitives::usize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Usize)));
    }
    if index == interner::Primitives::f32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F32)));
    }
    if index == interner::Primitives::f64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F64)));
    }
    if index == interner::Primitives::char_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    }
    if index == interner::Primitives::str_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str)));
    }

    // Not a primitive type
    Option::None
}

/// Lower type arguments.
pub fn lower_type_args(ctx: &mut hir_lower_ctx::LoweringCtx, args: &ast::TypeArgs) -> Vec<hir_ty::Type> {
    let mut result: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < args.args.len() {
        match &args.args[i] {
            &ast::TypeArg::Type(ref ty) => {
                let t = lower_type(ctx, ty);
                result.push(t);
            }
            &ast::TypeArg::Lifetime(_) => {
                // Lifetimes don't produce types in our representation
            }
            &ast::TypeArg::Const(ref expr) => {
                // Const generic argument: evaluate the expression
                //
                // NOTE: Full const generics support would require:
                // 1. A representation for const generic values in type args
                //    (currently ADT only stores Vec<Type>, not Vec<GenericArg>)
                // 2. Const parameter resolution in type paths
                // 3. Const expression evaluation and comparison during unification
                //
                // For now, we evaluate the expression but don't store it.
                // This allows the compiler to verify the expression is const-evaluable.
                let _value = const_eval::eval_const_expr(expr);

                // We could emit a diagnostic if the value is an error:
                // if value.is_error() { ... }
            }
        }
        i = i + 1;
    }
    result
}

// ============================================================
// Effect Row Lowering
// ============================================================

/// Lower an effect row.
pub fn lower_effect_row(ctx: &mut hir_lower_ctx::LoweringCtx, row: &ast::EffectRow) -> hir_ty::EffectRow {
    match &row.kind {
        &ast::EffectRowKind::Pure => {
            hir_ty::EffectRow::empty()
        }
        &ast::EffectRowKind::Effects { ref effects, rest: _ } => {
            let mut hir_effects: Vec<hir_ty::EffectRef> = Vec::new();
            let mut i: usize = 0;
            while i < effects.len() {
                let eff = lower_effect_ref(ctx, &effects[i]);
                if eff.is_some() {
                    hir_effects.push(eff.unwrap());
                }
                i = i + 1;
            }
            hir_ty::EffectRow::with_effects(hir_effects)
        }
        &ast::EffectRowKind::Var(_) => {
            // TODO: Handle effect row variables
            hir_ty::EffectRow::empty()
        }
    }
}

/// Lower an effect reference from a type.
fn lower_effect_ref(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> Option<hir_ty::EffectRef> {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            if path.segments.len() == 1 {
                let seg = &path.segments[0];
                let lookup = ctx.resolver.lookup(seg.name.symbol);
                if lookup.is_some() {
                    let result = lookup.unwrap();
                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                    let def_id = binding.def_id;

                    let type_args = match &seg.args {
                        &Some(ref args) => lower_type_args(ctx, args),
                        &None => Vec::new(),
                    };

                    return Some(hir_ty::EffectRef::new(def_id, type_args));
                }
            }
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown effect"),
                ty.span,
            );
            Option::None
        }
        _ => {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("invalid effect type"),
                ty.span,
            );
            Option::None
        }
    }
}

// ============================================================
// Generics Lowering
// ============================================================

/// Lower AST type parameters to HIR generics.
pub fn lower_generics(ctx: &mut hir_lower_ctx::LoweringCtx, type_params: &Option<ast::TypeParams>, where_clause: &Option<ast::WhereClause>) -> hir_ty::Generics {
    let mut params: Vec<hir_ty::GenericParam> = Vec::new();
    let mut where_predicates: Vec<hir_ty::WherePredicate> = Vec::new();

    match type_params {
        &Some(ref tp) => {
            let mut i: usize = 0;
            while i < tp.params.len() {
                match &tp.params[i] {
                    &ast::GenericParam::Type(ref type_param) => {
                        let var_id = ctx.alloc_ty_var();
                        let type_param_def = hir_ty::TypeParamDef::new(
                            type_param.name.symbol,
                            var_id,
                            type_param.span,
                        );
                        let param = hir_ty::GenericParam::TypeParam(type_param_def);
                        params.push(param);

                        // If there are bounds, add them as where predicates
                        if type_param.bounds.len() > 0 {
                            let param_ty = hir_ty::Type::new(hir_ty::TypeKind::Param(var_id));
                            let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                            let mut j: usize = 0;
                            while j < type_param.bounds.len() {
                                let bound_ty = lower_type(ctx, &type_param.bounds[j]);
                                // Convert the bound type to a TraitRef
                                let trait_ref = type_to_trait_ref(&bound_ty, type_param.bounds[j].span);
                                if trait_ref.is_some() {
                                    trait_refs.push(trait_ref.unwrap());
                                }
                                j = j + 1;
                            }
                            if trait_refs.len() > 0 {
                                let pred = hir_ty::WherePredicate::TypeBound {
                                    ty: param_ty,
                                    bounds: trait_refs,
                                    span: type_param.span,
                                };
                                where_predicates.push(pred);
                            }
                        }
                    }
                    &ast::GenericParam::Lifetime(ref lifetime_param) => {
                        let lifetime_def = hir_ty::LifetimeParamDef::new(
                            lifetime_param.name.symbol,
                            lifetime_param.span,
                        );
                        let param = hir_ty::GenericParam::LifetimeParam(lifetime_def);
                        params.push(param);
                    }
                    &ast::GenericParam::Const(ref const_param) => {
                        let ty = lower_type(ctx, &const_param.ty);
                        let const_def = hir_ty::ConstParamDef::new(
                            const_param.name.symbol,
                            ty,
                            const_param.span,
                        );
                        let param = hir_ty::GenericParam::ConstParam(const_def);
                        params.push(param);
                    }
                }
                i = i + 1;
            }
        }
        &None => {}
    }

    // Lower explicit where clause predicates
    match where_clause {
        &Some(ref wc) => {
            let mut i: usize = 0;
            while i < wc.predicates.len() {
                match &wc.predicates[i] {
                    &ast::WherePredicate::TypeBound { ref ty, ref bounds, span } => {
                        let lowered_ty = lower_type(ctx, ty);
                        let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                        let mut j: usize = 0;
                        while j < bounds.len() {
                            let bound_ty = lower_type(ctx, &bounds[j]);
                            let trait_ref = type_to_trait_ref(&bound_ty, bounds[j].span);
                            if trait_ref.is_some() {
                                trait_refs.push(trait_ref.unwrap());
                            }
                            j = j + 1;
                        }
                        if trait_refs.len() > 0 {
                            let pred = hir_ty::WherePredicate::TypeBound {
                                ty: lowered_ty,
                                bounds: trait_refs,
                                span,
                            };
                            where_predicates.push(pred);
                        }
                    }
                    &ast::WherePredicate::Lifetime { ref lifetime, ref bound, span } => {
                        let pred = hir_ty::WherePredicate::LifetimeBound {
                            lifetime: lifetime.symbol,
                            bound: bound.symbol,
                            span,
                        };
                        where_predicates.push(pred);
                    }
                }
                i = i + 1;
            }
        }
        &None => {}
    }

    hir_ty::Generics { params, where_predicates }
}

/// Convert a type to a TraitRef if it's a path type referring to a trait.
fn type_to_trait_ref(ty: &hir_ty::Type, span: common::Span) -> Option<hir_ty::TraitRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Manually copy the args vector since Blood doesn't have clone
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Some(hir_ty::TraitRef::new(def_id, args_copy, span))
        }
        _ => {
            // Other types can't be used as trait bounds directly
            Option::None
        }
    }
}
