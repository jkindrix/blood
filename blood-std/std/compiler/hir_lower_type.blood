// Blood Self-Hosted Compiler - HIR Type Lowering
//
// This module handles lowering AST types to HIR types:
// - Type lowering (all AST type kinds)
// - Type path resolution
// - Generic parameter lowering
// - Effect row lowering
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod interner;
mod const_eval;

// ============================================================
// Type Lowering
// ============================================================

/// Lower an AST type to an HIR type.
pub fn lower_type(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> hir_ty::Type {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            lower_type_path(ctx, path)
        }
        &ast::TypeKind::Reference { lifetime: _, is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Pointer { is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Array { ref element, ref size } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            let array_size = const_eval::eval_array_size_u64(size.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(elem_ty),
                size: array_size,
            })
        }
        &ast::TypeKind::Slice { ref element } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(elem_ty),
            })
        }
        &ast::TypeKind::Tuple(ref types) => {
            let mut lowered: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let t = lower_type(ctx, &types[i]);
                lowered.push(t);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(lowered))
        }
        &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {
            let mut param_tys: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let t = lower_type(ctx, &params[i]);
                param_tys.push(t);
                i = i + 1;
            }
            let ret_ty = lower_type(ctx, return_type.as_ref());
            let effect_row = match effects {
                &Some(ref eff) => lower_effect_row(ctx, eff),
                &None => hir_ty::EffectRow::empty(),
            };
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: param_tys,
                ret: Box::new(ret_ty),
                effects: effect_row,
            })
        }
        &ast::TypeKind::Record { ref fields, ref rest } => {
            let mut hir_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let f = &fields[i];
                let field_ty = lower_type(ctx, &f.ty);
                let hir_field = hir_ty::RecordField::new(f.name.symbol, field_ty);
                hir_fields.push(hir_field);
                i = i + 1;
            }
            // Handle row polymorphism: if `rest` is Some, this is an open record
            // with a row variable (e.g., { x: i32, ..r })
            let row_var = match rest {
                &Option::Some(ref _row_var_name) => {
                    // Allocate a fresh record row variable
                    // Note: The row variable name is not currently tracked in the scope.
                    // Full row polymorphism would require adding it to a type parameter scope.
                    Option::Some(ctx.alloc_record_row_var())
                }
                &Option::None => Option::None,
            };
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: hir_fields,
                row_var: row_var,
            })
        }
        &ast::TypeKind::Ownership { ref qualifier, ref inner } => {
            // Convert AST ownership qualifier to HIR ownership qualifier
            let hir_qualifier = match qualifier {
                &ast::OwnershipQualifier::Linear => hir_ty::OwnershipQualifier::Linear,
                &ast::OwnershipQualifier::Affine => hir_ty::OwnershipQualifier::Affine,
            };
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ownership {
                qualifier: hir_qualifier,
                inner: Box::new(inner_ty),
            })
        }
        &ast::TypeKind::Forall { ref params, ref body } => {
            // Lower forall type: forall<T, U> Body
            //
            // For each type parameter, allocate a type variable ID and
            // register it in the resolver scope so the body type can
            // reference the parameters by name.

            // Push a type parameter scope
            ctx.resolver.push_scope(resolve::ScopeKind::TypeParams);

            // Allocate type variables and register them in scope
            let mut param_ids: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let var_id = ctx.alloc_ty_var();
                param_ids.push(var_id);

                // Register the type parameter in the scope
                let param = &params[i];
                let _ = ctx.resolver.define_type_param(param.symbol, var_id);
                i = i + 1;
            }

            // Lower the body type (now type params can be resolved)
            let body_ty = lower_type(ctx, body.as_ref());

            // Pop the type parameter scope
            ctx.resolver.pop_scope();

            hir_ty::Type::new(hir_ty::TypeKind::Forall {
                params: param_ids,
                body: Box::new(body_ty),
            })
        }
        &ast::TypeKind::Never => {
            hir_ty::Type::never()
        }
        &ast::TypeKind::Infer => {
            let var_id = ctx.alloc_ty_var();
            hir_ty::Type::infer(var_id)
        }
        &ast::TypeKind::Paren(ref inner) => {
            lower_type(ctx, inner.as_ref())
        }
    }
}

/// Lower a type path to an HIR type.
fn lower_type_path(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath) -> hir_ty::Type {
    // Handle built-in primitive types
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            // Use span-based lookup instead of symbol index comparison
            let prim = try_primitive_type_by_span(ctx, seg.name.span);
            if prim.is_some() {
                return prim.unwrap();
            }
        }
    }

    // Check for type parameter (single-segment, no args)
    // Type parameters take precedence over other type definitions
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            let type_param = ctx.resolver.lookup_type_param(seg.name.symbol);
            if type_param.is_some() {
                let ty_var_id = type_param.unwrap();
                return hir_ty::Type::new(hir_ty::TypeKind::Infer(ty_var_id));
            }
        }
    }

    // Look up the type in the resolver
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        // Re-intern from span for consistent symbol indices
        let name_str = ctx.span_to_string(seg.name.span);
        let lookup_symbol = ctx.intern(name_str.as_str());
        let lookup = ctx.resolver.lookup(lookup_symbol);
        if lookup.is_some() {
            let result = lookup.unwrap();
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
            let def_id = binding.def_id;

            // Lower type arguments if present
            let type_args = match &seg.args {
                &Some(ref args) => lower_type_args(ctx, args),
                &None => Vec::new(),
            };

            return hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: type_args,
            });
        } else {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown type"),
                seg.name.span,
            );
            return hir_ty::Type::error();
        }
    }

    // Multi-segment paths (e.g., module::Type)
    // Extract the names from path segments, re-interning for consistent indices
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let name_str = ctx.span_to_string(seg.name.span);
        let re_interned = ctx.intern(name_str.as_str());
        names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
        i = i + 1;
    }

    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_args = match &last_seg.args {
            &Some(ref args) => lower_type_args(ctx, args),
            &None => Vec::new(),
        };

        return hir_ty::Type::new(hir_ty::TypeKind::Adt {
            def_id: result.def_id,
            args: type_args,
        });
    }

    // Not found - report error
    ctx.error(
        hir::DiagnosticCode::E0102,
        common::make_string("undefined qualified type path"),
        path.span,
    );
    hir_ty::Type::error()
}

/// Try to convert a span to a primitive type by looking up the actual string content.
///
/// Uses the source text from the context to get the type name string,
/// then compares against known primitive type names.
/// Returns the corresponding HIR type if the name is a primitive, None otherwise.
fn try_primitive_type_by_span(ctx: &mut hir_lower_ctx::LoweringCtx, span: common::Span) -> Option<hir_ty::Type> {
    let name = ctx.span_to_string(span);

    // Compare against primitive type names using string content
    if str_eq(&name, "bool") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)));
    }
    if str_eq(&name, "i8") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I8)));
    }
    if str_eq(&name, "i16") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I16)));
    }
    if str_eq(&name, "i32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I32)));
    }
    if str_eq(&name, "i64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I64)));
    }
    if str_eq(&name, "i128") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I128)));
    }
    if str_eq(&name, "isize") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Isize)));
    }
    if str_eq(&name, "u8") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8)));
    }
    if str_eq(&name, "u16") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U16)));
    }
    if str_eq(&name, "u32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U32)));
    }
    if str_eq(&name, "u64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U64)));
    }
    if str_eq(&name, "u128") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U128)));
    }
    if str_eq(&name, "usize") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Usize)));
    }
    if str_eq(&name, "f32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F32)));
    }
    if str_eq(&name, "f64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F64)));
    }
    if str_eq(&name, "char") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    }
    if str_eq(&name, "str") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str)));
    }

    // Not a primitive type
    Option::None
}

/// Helper function to compare a String with a &str.
fn str_eq(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();
    if bytes.len() != other_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Try to convert a symbol to a primitive type (deprecated - use try_primitive_type_by_span).
///
/// Compares the symbol index against pre-interned primitive type names.
/// Returns the corresponding HIR type if the symbol is a primitive, None otherwise.
fn try_primitive_type(sym: common::Symbol) -> Option<hir_ty::Type> {
    let index = sym.index;

    // Check against pre-interned primitive type indices (41-57)
    if index == interner::Primitives::bool_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)));
    }
    if index == interner::Primitives::i8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I8)));
    }
    if index == interner::Primitives::i16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I16)));
    }
    if index == interner::Primitives::i32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I32)));
    }
    if index == interner::Primitives::i64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I64)));
    }
    if index == interner::Primitives::i128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I128)));
    }
    if index == interner::Primitives::isize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Isize)));
    }
    if index == interner::Primitives::u8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8)));
    }
    if index == interner::Primitives::u16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U16)));
    }
    if index == interner::Primitives::u32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U32)));
    }
    if index == interner::Primitives::u64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U64)));
    }
    if index == interner::Primitives::u128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U128)));
    }
    if index == interner::Primitives::usize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Usize)));
    }
    if index == interner::Primitives::f32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F32)));
    }
    if index == interner::Primitives::f64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F64)));
    }
    if index == interner::Primitives::char_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    }
    if index == interner::Primitives::str_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str)));
    }

    // Not a primitive type
    Option::None
}

/// Lower type arguments.
pub fn lower_type_args(ctx: &mut hir_lower_ctx::LoweringCtx, args: &ast::TypeArgs) -> Vec<hir_ty::Type> {
    let mut result: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < args.args.len() {
        match &args.args[i] {
            &ast::TypeArg::Type(ref ty) => {
                let t = lower_type(ctx, ty);
                result.push(t);
            }
            &ast::TypeArg::Lifetime(_) => {
                // Lifetimes don't produce types in our representation
            }
            &ast::TypeArg::Const(ref expr) => {
                // Const generic argument: evaluate the expression
                //
                // NOTE: Full const generics support would require:
                // 1. A representation for const generic values in type args
                //    (currently ADT only stores Vec<Type>, not Vec<GenericArg>)
                // 2. Const parameter resolution in type paths
                // 3. Const expression evaluation and comparison during unification
                //
                // For now, we evaluate the expression but don't store it.
                // This allows the compiler to verify the expression is const-evaluable.
                let _value = const_eval::eval_const_expr(expr);

                // We could emit a diagnostic if the value is an error:
                // if value.is_error() { ... }
            }
        }
        i = i + 1;
    }
    result
}

// ============================================================
// Effect Row Lowering
// ============================================================

/// Lower an effect row.
pub fn lower_effect_row(ctx: &mut hir_lower_ctx::LoweringCtx, row: &ast::EffectRow) -> hir_ty::EffectRow {
    match &row.kind {
        &ast::EffectRowKind::Pure => {
            hir_ty::EffectRow::empty()
        }
        &ast::EffectRowKind::Effects { ref effects, ref rest } => {
            let mut hir_effects: Vec<hir_ty::EffectRef> = Vec::new();
            let mut i: usize = 0;
            while i < effects.len() {
                let eff = lower_effect_ref(ctx, &effects[i]);
                if eff.is_some() {
                    hir_effects.push(eff.unwrap());
                }
                i = i + 1;
            }
            // Handle row polymorphism: if `rest` is Some, this is an open effect row
            // with a row variable (e.g., Read, Write | r)
            match rest {
                &Option::Some(ref _row_var_name) => {
                    // Allocate a fresh effect row variable
                    let row_var = ctx.alloc_effect_row_var();
                    hir_ty::EffectRow::with_effects_and_var(hir_effects, row_var)
                }
                &Option::None => {
                    hir_ty::EffectRow::with_effects(hir_effects)
                }
            }
        }
        &ast::EffectRowKind::Var(ref _var_name) => {
            // Effect row variable reference (e.g., just `e` in a type)
            // Allocate a fresh effect row variable
            let row_var = ctx.alloc_effect_row_var();
            hir_ty::EffectRow::polymorphic(row_var)
        }
    }
}

/// Lower an effect reference from a type.
fn lower_effect_ref(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> Option<hir_ty::EffectRef> {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            if path.segments.len() == 1 {
                let seg = &path.segments[0];
                // Re-intern from span for consistent symbol indices
                let name_str = ctx.span_to_string(seg.name.span);
                let lookup_symbol = ctx.intern(name_str.as_str());
                let lookup = ctx.resolver.lookup(lookup_symbol);
                if lookup.is_some() {
                    let result = lookup.unwrap();
                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                    let def_id = binding.def_id;

                    let type_args = match &seg.args {
                        &Some(ref args) => lower_type_args(ctx, args),
                        &None => Vec::new(),
                    };

                    return Some(hir_ty::EffectRef::new(def_id, type_args));
                }
            }
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown effect"),
                ty.span,
            );
            Option::None
        }
        _ => {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("invalid effect type"),
                ty.span,
            );
            Option::None
        }
    }
}

// ============================================================
// Generics Lowering
// ============================================================

/// Lower AST type parameters to HIR generics.
pub fn lower_generics(ctx: &mut hir_lower_ctx::LoweringCtx, type_params: &Option<ast::TypeParams>, where_clause: &Option<ast::WhereClause>) -> hir_ty::Generics {
    println_str("[lower_generics] Starting...");
    let mut params: Vec<hir_ty::GenericParam> = Vec::new();
    println_str("[lower_generics] Created params vec");
    let mut where_predicates: Vec<hir_ty::WherePredicate> = Vec::new();
    println_str("[lower_generics] Created where_predicates vec");

    println_str("[lower_generics] Matching type_params...");
    println_str("[lower_generics] About to check is_some on type_params...");
    let tp_is_some = type_params.is_some();
    print_str("[lower_generics] type_params.is_some() = ");
    if tp_is_some { println_str("true"); } else { println_str("false"); }
    println_str("[lower_generics] Starting match...");
    match type_params {
        &Some(ref tp) => {
            let mut i: usize = 0;
            while i < tp.params.len() {
                match &tp.params[i] {
                    &ast::GenericParam::Type(ref type_param) => {
                        let var_id = ctx.alloc_ty_var();
                        let type_param_def = hir_ty::TypeParamDef::new(
                            type_param.name.symbol,
                            var_id,
                            type_param.span,
                        );
                        let param = hir_ty::GenericParam::TypeParam(type_param_def);
                        params.push(param);

                        // If there are bounds, add them as where predicates
                        if type_param.bounds.len() > 0 {
                            let param_ty = hir_ty::Type::new(hir_ty::TypeKind::Param(var_id));
                            let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                            let mut j: usize = 0;
                            while j < type_param.bounds.len() {
                                let bound_ty = lower_type(ctx, &type_param.bounds[j]);
                                // Convert the bound type to a TraitRef
                                let trait_ref = type_to_trait_ref(&bound_ty, type_param.bounds[j].span);
                                if trait_ref.is_some() {
                                    trait_refs.push(trait_ref.unwrap());
                                }
                                j = j + 1;
                            }
                            if trait_refs.len() > 0 {
                                let pred = hir_ty::WherePredicate::TypeBound {
                                    ty: param_ty,
                                    bounds: trait_refs,
                                    span: type_param.span,
                                };
                                where_predicates.push(pred);
                            }
                        }
                    }
                    &ast::GenericParam::Lifetime(ref lifetime_param) => {
                        let lifetime_def = hir_ty::LifetimeParamDef::new(
                            lifetime_param.name.symbol,
                            lifetime_param.span,
                        );
                        let param = hir_ty::GenericParam::LifetimeParam(lifetime_def);
                        params.push(param);
                    }
                    &ast::GenericParam::Const(ref const_param) => {
                        let ty = lower_type(ctx, &const_param.ty);
                        let const_def = hir_ty::ConstParamDef::new(
                            const_param.name.symbol,
                            ty,
                            const_param.span,
                        );
                        let param = hir_ty::GenericParam::ConstParam(const_def);
                        params.push(param);
                    }
                }
                i = i + 1;
            }
        }
        &None => {
            println_str("[lower_generics] type_params is None");
        }
    }
    println_str("[lower_generics] After type_params match");

    // Lower explicit where clause predicates
    println_str("[lower_generics] Matching where_clause...");
    println_str("[lower_generics] Checking is_some...");
    let is_some = where_clause.is_some();
    print_str("[lower_generics] is_some = ");
    if is_some { println_str("true"); } else { println_str("false"); }
    if is_some {
        println_str("[lower_generics] where_clause is Some, getting wc...");
        let wc = where_clause.as_ref().unwrap();
        let pred_len = wc.predicates.len();
        print_str("[lower_generics] wc.predicates.len() = ");
        println_int(pred_len as i32);
        println_str("[lower_generics] About to enter loop block...");
        {
            println_str("[lower_generics] Inside loop block");
            let mut i: usize = 0;
            print_str("[lower_generics] i = ");
            println_int(i as i32);
            print_str("[lower_generics] pred_len = ");
            println_int(pred_len as i32);
            println_str("[lower_generics] About to check i < pred_len...");
            while i < pred_len {
                println_str("[lower_generics] Inside while loop");
                match &wc.predicates[i] {
                    &ast::WherePredicate::TypeBound { ref ty, ref bounds, span } => {
                        let lowered_ty = lower_type(ctx, ty);
                        let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                        let mut j: usize = 0;
                        while j < bounds.len() {
                            let bound_ty = lower_type(ctx, &bounds[j]);
                            let trait_ref = type_to_trait_ref(&bound_ty, bounds[j].span);
                            if trait_ref.is_some() {
                                trait_refs.push(trait_ref.unwrap());
                            }
                            j = j + 1;
                        }
                        if trait_refs.len() > 0 {
                            let pred = hir_ty::WherePredicate::TypeBound {
                                ty: lowered_ty,
                                bounds: trait_refs,
                                span,
                            };
                            where_predicates.push(pred);
                        }
                    }
                    &ast::WherePredicate::Lifetime { ref lifetime, ref bound, span } => {
                        let pred = hir_ty::WherePredicate::LifetimeBound {
                            lifetime: lifetime.symbol,
                            bound: bound.symbol,
                            span,
                        };
                        where_predicates.push(pred);
                    }
                }
                i = i + 1;
            }
            println_str("[lower_generics] After loop");
        }
        println_str("[lower_generics] After block");
    } else {
        println_str("[lower_generics] where_clause is None");
    }
    println_str("[lower_generics] Creating result...");

    hir_ty::Generics { params, where_predicates }
}

/// Convert a type to a TraitRef if it's a path type referring to a trait.
fn type_to_trait_ref(ty: &hir_ty::Type, span: common::Span) -> Option<hir_ty::TraitRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Manually copy the args vector since Blood doesn't have clone
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Some(hir_ty::TraitRef::new(def_id, args_copy, span))
        }
        _ => {
            // Other types can't be used as trait bounds directly
            Option::None
        }
    }
}
