// Blood Self-Hosted Compiler - HIR Type Lowering
//
// This module handles lowering AST types to HIR types:
// - Type lowering (all AST type kinds)
// - Type path resolution
// - Generic parameter lowering
// - Effect row lowering
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod interner;
mod const_eval;
mod hir_item;
mod type_intern;

// ============================================================
// Type Lowering — TyId-returning versions
// ============================================================

/// Lower an AST type directly to an interned TyId.
pub fn lower_type_id(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> type_intern::TyId {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            lower_type_path_id(ctx, path)
        }
        &ast::TypeKind::Reference { lifetime: _, is_mut, ref inner } => {
            let inner_id = lower_type_id(ctx, inner.as_ref());
            type_intern::type_interner().mk_ref(inner_id, is_mut)
        }
        &ast::TypeKind::Pointer { is_mut, ref inner } => {
            let inner_id = lower_type_id(ctx, inner.as_ref());
            type_intern::type_interner().mk_ptr(inner_id, is_mut)
        }
        &ast::TypeKind::Array { ref element, ref size } => {
            let elem_id = lower_type_id(ctx, element.as_ref());
            let array_size = const_eval::eval_array_size_u64(size.as_ref());
            type_intern::type_interner().mk_array(elem_id, array_size)
        }
        &ast::TypeKind::Slice { ref element } => {
            let elem_id = lower_type_id(ctx, element.as_ref());
            type_intern::type_interner().mk_slice(elem_id)
        }
        &ast::TypeKind::Tuple(ref types) => {
            let mut ids: Vec<type_intern::TyId> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let t = lower_type_id(ctx, &types[i]);
                ids.push(t);
                i = i + 1;
            }
            let list_id = type_intern::type_interner().intern_ty_list(&ids);
            type_intern::type_interner().mk_tuple(list_id)
        }
        &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {
            let mut param_ids: Vec<type_intern::TyId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let t = lower_type_id(ctx, &params[i]);
                param_ids.push(t);
                i = i + 1;
            }
            let ret_id = lower_type_id(ctx, return_type.as_ref());
            let effect_row_id = match effects {
                &Some(ref eff) => {
                    let row = lower_effect_row(ctx, eff);
                    type_intern::intern_effect_row(&row)
                }
                &None => type_intern::EffectRowId::new(0),
            };
            let param_list = type_intern::type_interner().intern_ty_list(&param_ids);
            type_intern::type_interner().mk_fn(param_list, ret_id, effect_row_id)
        }
        &ast::TypeKind::Record { ref fields, ref rest } => {
            let mut interned_fields: Vec<type_intern::InternedRecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let f = &fields[i];
                let field_id = lower_type_id(ctx, &f.ty);
                interned_fields.push(type_intern::InternedRecordField::new(f.name.symbol, field_id));
                i = i + 1;
            }
            let row_var = match rest {
                &Option::Some(ref _row_var_name) => {
                    Option::Some(ctx.alloc_record_row_var())
                }
                &Option::None => Option::None,
            };
            let field_list = type_intern::InternedRecordFieldList::new(interned_fields);
            let field_list_id = type_intern::type_interner().intern_record_field_list(field_list);
            type_intern::type_interner().intern(type_intern::InternedTypeKind::Record { fields: field_list_id, row_var: row_var })
        }
        &ast::TypeKind::Ownership { ref qualifier, ref inner } => {
            let hir_qualifier = match qualifier {
                &ast::OwnershipQualifier::Linear => hir_ty::OwnershipQualifier::Linear,
                &ast::OwnershipQualifier::Affine => hir_ty::OwnershipQualifier::Affine,
            };
            let inner_id = lower_type_id(ctx, inner.as_ref());
            type_intern::type_interner().mk_ownership(hir_qualifier, inner_id)
        }
        &ast::TypeKind::Forall { ref params, ref body } => {
            ctx.resolver.push_scope(resolve::ScopeKind::TypeParams);

            let mut param_ids: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let var_id = ctx.alloc_ty_var();
                param_ids.push(var_id);
                let param = &params[i];
                let _ = ctx.resolver.define_type_param(param.symbol, var_id);
                i = i + 1;
            }

            let body_id = lower_type_id(ctx, body.as_ref());

            ctx.resolver.pop_scope();

            type_intern::type_interner().intern(type_intern::InternedTypeKind::Forall { params: param_ids, body: body_id })
        }
        &ast::TypeKind::Never => {
            type_intern::CommonTypes::never()
        }
        &ast::TypeKind::Infer => {
            let var_id = ctx.alloc_ty_var();
            type_intern::type_interner().mk_infer(var_id)
        }
        &ast::TypeKind::Paren(ref inner) => {
            lower_type_id(ctx, inner.as_ref())
        }
    }
}

/// Lower an AST type to an HIR type.
pub fn lower_type(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> hir_ty::Type {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            lower_type_path(ctx, path)
        }
        &ast::TypeKind::Reference { lifetime: _, is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Pointer { is_mut, ref inner } => {
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(inner_ty),
                mutable: is_mut,
            })
        }
        &ast::TypeKind::Array { ref element, ref size } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            let array_size = const_eval::eval_array_size_u64(size.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(elem_ty),
                size: array_size,
            })
        }
        &ast::TypeKind::Slice { ref element } => {
            let elem_ty = lower_type(ctx, element.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(elem_ty),
            })
        }
        &ast::TypeKind::Tuple(ref types) => {
            let mut lowered: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let t = lower_type(ctx, &types[i]);
                lowered.push(t);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(lowered))
        }
        &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {
            let mut param_tys: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let t = lower_type(ctx, &params[i]);
                param_tys.push(t);
                i = i + 1;
            }
            let ret_ty = lower_type(ctx, return_type.as_ref());
            let effect_row = match effects {
                &Some(ref eff) => lower_effect_row(ctx, eff),
                &None => hir_ty::EffectRow::empty(),
            };
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: param_tys,
                ret: Box::new(ret_ty),
                effects: effect_row,
            })
        }
        &ast::TypeKind::Record { ref fields, ref rest } => {
            let mut hir_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let f = &fields[i];
                let field_ty = lower_type(ctx, &f.ty);
                let hir_field = hir_ty::RecordField::new(f.name.symbol, field_ty);
                hir_fields.push(hir_field);
                i = i + 1;
            }
            let row_var = match rest {
                &Option::Some(ref _row_var_name) => {
                    Option::Some(ctx.alloc_record_row_var())
                }
                &Option::None => Option::None,
            };
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: hir_fields,
                row_var: row_var,
            })
        }
        &ast::TypeKind::Ownership { ref qualifier, ref inner } => {
            let hir_qualifier = match qualifier {
                &ast::OwnershipQualifier::Linear => hir_ty::OwnershipQualifier::Linear,
                &ast::OwnershipQualifier::Affine => hir_ty::OwnershipQualifier::Affine,
            };
            let inner_ty = lower_type(ctx, inner.as_ref());
            hir_ty::Type::new(hir_ty::TypeKind::Ownership {
                qualifier: hir_qualifier,
                inner: Box::new(inner_ty),
            })
        }
        &ast::TypeKind::Forall { ref params, ref body } => {
            ctx.resolver.push_scope(resolve::ScopeKind::TypeParams);

            let mut param_ids: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                let var_id = ctx.alloc_ty_var();
                param_ids.push(var_id);
                let param = &params[i];
                let _ = ctx.resolver.define_type_param(param.symbol, var_id);
                i = i + 1;
            }

            let body_ty = lower_type(ctx, body.as_ref());

            ctx.resolver.pop_scope();

            hir_ty::Type::new(hir_ty::TypeKind::Forall {
                params: param_ids,
                body: Box::new(body_ty),
            })
        }
        &ast::TypeKind::Never => {
            hir_ty::Type::never()
        }
        &ast::TypeKind::Infer => {
            let var_id = ctx.alloc_ty_var();
            hir_ty::Type::infer(var_id)
        }
        &ast::TypeKind::Paren(ref inner) => {
            lower_type(ctx, inner.as_ref())
        }
    }
}

// ============================================================
// Type Path Lowering — TyId-returning version
// ============================================================

/// Lower a type path directly to an interned TyId.
fn lower_type_path_id(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath) -> type_intern::TyId {
    // Handle built-in primitive types
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            let prim = try_primitive_type_by_span_id(ctx, seg.name.span);
            if prim.is_some() {
                return prim.unwrap();
            }
        }
    }

    // Check for Self type (single-segment, no args)
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            let name_str = ctx.span_to_string(seg.name.span);
            if str_eq(&name_str, "Self") || str_eq(&name_str, "self") {
                match &ctx.current_self_type {
                    &Option::Some(ref self_ty) => {
                        return type_intern::type_to_ty_id(self_ty);
                    }
                    &Option::None => {
                        ctx.error(
                            hir::DiagnosticCode::E0102,
                            common::make_string("Self used outside of impl block"),
                            seg.name.span,
                        );
                        return type_intern::CommonTypes::error();
                    }
                }
            }
        }
    }

    // Check for type parameter (single-segment, no args)
    // Type parameters take precedence over other type definitions.
    // Try both the raw AST symbol and a re-interned symbol to handle
    // any symbol index mismatches between parser and interner.
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            // First try the raw AST symbol
            let type_param = ctx.resolver.lookup_type_param(seg.name.symbol);
            if type_param.is_some() {
                let ty_var_id = type_param.unwrap();
                return type_intern::type_interner().mk_infer(ty_var_id);
            }
            // Then try re-interned symbol
            let tp_name_str = ctx.span_to_string(seg.name.span);
            let tp_symbol = ctx.intern(tp_name_str.as_str());
            let type_param2 = ctx.resolver.lookup_type_param(tp_symbol);
            if type_param2.is_some() {
                let ty_var_id2 = type_param2.unwrap();
                return type_intern::type_interner().mk_infer(ty_var_id2);
            }
        }
    }

    // Look up the type in the resolver
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        // Re-intern from span for consistent symbol indices
        let name_str = ctx.span_to_string(seg.name.span);
        let lookup_symbol = ctx.intern(name_str.as_str());
        let lookup = ctx.resolver.lookup(lookup_symbol);
        if lookup.is_some() {
            let result = lookup.unwrap();
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
            let def_id = binding.def_id;

            // Check if this is a type alias — resolve to the underlying type
            // Also validate that the DefKind is appropriate for type position
            let def_info_opt = ctx.resolver.get_def_info(def_id);
            match &def_info_opt {
                &Option::Some(ref info) => {
                    match info.kind {
                        hir_def::DefKind::TypeAlias => {
                            let item_entry = ctx.get_item(def_id);
                            match &item_entry {
                                &Option::Some(ref entry) => {
                                    match &entry.item.kind {
                                        &hir_item::ItemKind::TypeAlias(ref alias_def) => {
                                            return type_intern::type_to_ty_id(&alias_def.ty);
                                        }
                                        _ => {}
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        hir_def::DefKind::Struct => {}
                        hir_def::DefKind::Enum => {}
                        hir_def::DefKind::Trait => {}
                        hir_def::DefKind::Effect => {}
                        hir_def::DefKind::TypeParam => {}
                        hir_def::DefKind::AssocType => {}
                        _ => {
                            // Not a valid type — report error
                            let mut tmsg = common::make_string("not a type: `");
                            let tname_str = ctx.span_to_string(seg.name.span);
                            tmsg.push_str(tname_str.as_str());
                            tmsg.push_str("` is not a type");
                            ctx.error(
                                hir::DiagnosticCode::E0102,
                                tmsg,
                                seg.name.span,
                            );
                            return type_intern::CommonTypes::error();
                        }
                    }
                }
                &Option::None => {}
            }

            // Lower type arguments if present
            let type_arg_ids = match &seg.args {
                &Some(ref args) => lower_type_args_id(ctx, args),
                &None => Vec::new(),
            };
            let arg_list = type_intern::type_interner().intern_ty_list(&type_arg_ids);
            return type_intern::type_interner().mk_adt(def_id, arg_list);
        } else {
            let mut tmsg = common::make_string("unknown type: ");
            let tname_str = ctx.span_to_string(seg.name.span);
            tmsg.push_str(tname_str.as_str());
            ctx.error(
                hir::DiagnosticCode::E0102,
                tmsg,
                seg.name.span,
            );
            return type_intern::CommonTypes::error();
        }
    }

    // Multi-segment paths (e.g., module::Type)
    // Extract the names from path segments, re-interning for consistent indices
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let name_str = ctx.span_to_string(seg.name.span);
        let re_interned = ctx.intern(name_str.as_str());
        names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
        i = i + 1;
    }

    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_arg_ids = match &last_seg.args {
            &Some(ref args) => lower_type_args_id(ctx, args),
            &None => Vec::new(),
        };
        let arg_list = type_intern::type_interner().intern_ty_list(&type_arg_ids);
        return type_intern::type_interner().mk_adt(result.def_id, arg_list);
    }

    // Not found - report error with path details for debugging
    let mut msg = common::make_string("undefined qualified type path: ");
    let mut j: usize = 0;
    while j < names.len() {
        if j > 0 {
            msg.push_str("::");
        }
        let seg_str = ctx.span_to_string(names[j].span);
        msg.push_str(seg_str.as_str());
        j = j + 1;
    }
    ctx.error(
        hir::DiagnosticCode::E0102,
        msg,
        path.span,
    );
    type_intern::CommonTypes::error()
}

/// Lower a type path to an HIR type.
fn lower_type_path(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath) -> hir_ty::Type {
    // Handle built-in primitive types
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            // Use span-based lookup instead of symbol index comparison
            let prim = try_primitive_type_by_span(ctx, seg.name.span);
            if prim.is_some() {
                return prim.unwrap();
            }
        }
    }

    // Check for Self type (single-segment, no args)
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            let name_str = ctx.span_to_string(seg.name.span);
            if str_eq(&name_str, "Self") || str_eq(&name_str, "self") {
                match &ctx.current_self_type {
                    &Option::Some(ref self_ty) => {
                        return hir_ty::copy_type(self_ty);
                    }
                    &Option::None => {
                        ctx.error(
                            hir::DiagnosticCode::E0102,
                            common::make_string("Self used outside of impl block"),
                            seg.name.span,
                        );
                        return hir_ty::Type::error();
                    }
                }
            }
        }
    }

    // Check for type parameter (single-segment, no args)
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        if seg.args.is_none() {
            // First try the raw AST symbol
            let type_param = ctx.resolver.lookup_type_param(seg.name.symbol);
            if type_param.is_some() {
                let ty_var_id = type_param.unwrap();
                return hir_ty::Type::new(hir_ty::TypeKind::Infer(ty_var_id));
            }
            // Then try re-interned symbol
            let tp_name_str = ctx.span_to_string(seg.name.span);
            let tp_symbol = ctx.intern(tp_name_str.as_str());
            let type_param2 = ctx.resolver.lookup_type_param(tp_symbol);
            if type_param2.is_some() {
                let ty_var_id2 = type_param2.unwrap();
                return hir_ty::Type::new(hir_ty::TypeKind::Infer(ty_var_id2));
            }
        }
    }

    // Look up the type in the resolver
    if path.segments.len() == 1 {
        let seg = &path.segments[0];
        // Re-intern from span for consistent symbol indices
        let name_str = ctx.span_to_string(seg.name.span);
        let lookup_symbol = ctx.intern(name_str.as_str());
        let lookup = ctx.resolver.lookup(lookup_symbol);
        if lookup.is_some() {
            let result = lookup.unwrap();
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
            let def_id = binding.def_id;

            // Check if this is a type alias — resolve to the underlying type
            let def_info_opt = ctx.resolver.get_def_info(def_id);
            match &def_info_opt {
                &Option::Some(ref info) => {
                    match info.kind {
                        hir_def::DefKind::TypeAlias => {
                            let item_entry = ctx.get_item(def_id);
                            match &item_entry {
                                &Option::Some(ref entry) => {
                                    match &entry.item.kind {
                                        &hir_item::ItemKind::TypeAlias(ref alias_def) => {
                                            return hir_ty::copy_type(&alias_def.ty);
                                        }
                                        _ => {}
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        hir_def::DefKind::Struct => {}
                        hir_def::DefKind::Enum => {}
                        hir_def::DefKind::Trait => {}
                        hir_def::DefKind::Effect => {}
                        hir_def::DefKind::TypeParam => {}
                        hir_def::DefKind::AssocType => {}
                        _ => {
                            // Not a valid type — report error
                            let mut tmsg = common::make_string("not a type: `");
                            let tname_str = ctx.span_to_string(seg.name.span);
                            tmsg.push_str(tname_str.as_str());
                            tmsg.push_str("` is not a type");
                            ctx.error(
                                hir::DiagnosticCode::E0102,
                                tmsg,
                                seg.name.span,
                            );
                            return hir_ty::Type::error();
                        }
                    }
                }
                &Option::None => {}
            }

            // Lower type arguments if present
            let type_args = match &seg.args {
                &Some(ref args) => lower_type_args(ctx, args),
                &None => Vec::new(),
            };

            return hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: type_args,
            });
        } else {
            let mut tmsg = common::make_string("unknown type: ");
            let tname_str = ctx.span_to_string(seg.name.span);
            tmsg.push_str(tname_str.as_str());
            ctx.error(
                hir::DiagnosticCode::E0102,
                tmsg,
                seg.name.span,
            );
            return hir_ty::Type::error();
        }
    }

    // Multi-segment paths (e.g., module::Type)
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let name_str = ctx.span_to_string(seg.name.span);
        let re_interned = ctx.intern(name_str.as_str());
        names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
        i = i + 1;
    }

    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_args = match &last_seg.args {
            &Some(ref args) => lower_type_args(ctx, args),
            &None => Vec::new(),
        };

        return hir_ty::Type::new(hir_ty::TypeKind::Adt {
            def_id: result.def_id,
            args: type_args,
        });
    }

    // Not found - report error
    let mut msg = common::make_string("undefined qualified type path: ");
    let mut j: usize = 0;
    while j < names.len() {
        if j > 0 {
            msg.push_str("::");
        }
        let seg_str = ctx.span_to_string(names[j].span);
        msg.push_str(seg_str.as_str());
        j = j + 1;
    }
    ctx.error(
        hir::DiagnosticCode::E0102,
        msg,
        path.span,
    );
    hir_ty::Type::error()
}

// ============================================================
// Primitive Type Lookup — TyId-returning version
// ============================================================

/// Try to convert a span to a primitive TyId.
fn try_primitive_type_by_span_id(ctx: &mut hir_lower_ctx::LoweringCtx, span: common::Span) -> Option<type_intern::TyId> {
    let name = ctx.span_to_string(span);

    if str_eq(&name, "bool") { return Option::Some(type_intern::CommonTypes::bool_ty()); }
    if str_eq(&name, "i8") { return Option::Some(type_intern::CommonTypes::i8_ty()); }
    if str_eq(&name, "i16") { return Option::Some(type_intern::CommonTypes::i16_ty()); }
    if str_eq(&name, "i32") { return Option::Some(type_intern::CommonTypes::i32_ty()); }
    if str_eq(&name, "i64") { return Option::Some(type_intern::CommonTypes::i64_ty()); }
    if str_eq(&name, "i128") { return Option::Some(type_intern::CommonTypes::i128_ty()); }
    if str_eq(&name, "isize") { return Option::Some(type_intern::CommonTypes::isize_ty()); }
    if str_eq(&name, "u8") { return Option::Some(type_intern::CommonTypes::u8_ty()); }
    if str_eq(&name, "u16") { return Option::Some(type_intern::CommonTypes::u16_ty()); }
    if str_eq(&name, "u32") { return Option::Some(type_intern::CommonTypes::u32_ty()); }
    if str_eq(&name, "u64") { return Option::Some(type_intern::CommonTypes::u64_ty()); }
    if str_eq(&name, "u128") { return Option::Some(type_intern::CommonTypes::u128_ty()); }
    if str_eq(&name, "usize") { return Option::Some(type_intern::CommonTypes::usize_ty()); }
    if str_eq(&name, "f32") { return Option::Some(type_intern::CommonTypes::f32_ty()); }
    if str_eq(&name, "f64") { return Option::Some(type_intern::CommonTypes::f64_ty()); }
    if str_eq(&name, "char") { return Option::Some(type_intern::CommonTypes::char_ty()); }
    if str_eq(&name, "str") { return Option::Some(type_intern::CommonTypes::str_ty()); }

    Option::None
}

/// Try to convert a span to a primitive type by looking up the actual string content.
fn try_primitive_type_by_span(ctx: &mut hir_lower_ctx::LoweringCtx, span: common::Span) -> Option<hir_ty::Type> {
    let name = ctx.span_to_string(span);

    if str_eq(&name, "bool") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)));
    }
    if str_eq(&name, "i8") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I8)));
    }
    if str_eq(&name, "i16") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I16)));
    }
    if str_eq(&name, "i32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I32)));
    }
    if str_eq(&name, "i64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I64)));
    }
    if str_eq(&name, "i128") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I128)));
    }
    if str_eq(&name, "isize") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Isize)));
    }
    if str_eq(&name, "u8") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8)));
    }
    if str_eq(&name, "u16") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U16)));
    }
    if str_eq(&name, "u32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U32)));
    }
    if str_eq(&name, "u64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U64)));
    }
    if str_eq(&name, "u128") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U128)));
    }
    if str_eq(&name, "usize") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Usize)));
    }
    if str_eq(&name, "f32") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F32)));
    }
    if str_eq(&name, "f64") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F64)));
    }
    if str_eq(&name, "char") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    }
    if str_eq(&name, "str") {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str)));
    }

    Option::None
}

/// Helper function to compare a String with a &str.
fn str_eq(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();
    if bytes.len() != other_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Try to convert a symbol to a primitive type (deprecated - use try_primitive_type_by_span).
///
/// Compares the symbol index against pre-interned primitive type names.
/// Returns the corresponding HIR type if the symbol is a primitive, None otherwise.
fn try_primitive_type(sym: common::Symbol) -> Option<hir_ty::Type> {
    let index = sym.index;

    // Check against pre-interned primitive type indices (41-57)
    if index == interner::Primitives::bool_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)));
    }
    if index == interner::Primitives::i8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I8)));
    }
    if index == interner::Primitives::i16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I16)));
    }
    if index == interner::Primitives::i32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I32)));
    }
    if index == interner::Primitives::i64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I64)));
    }
    if index == interner::Primitives::i128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::I128)));
    }
    if index == interner::Primitives::isize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Isize)));
    }
    if index == interner::Primitives::u8_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U8)));
    }
    if index == interner::Primitives::u16_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U16)));
    }
    if index == interner::Primitives::u32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U32)));
    }
    if index == interner::Primitives::u64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U64)));
    }
    if index == interner::Primitives::u128_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::U128)));
    }
    if index == interner::Primitives::usize_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Usize)));
    }
    if index == interner::Primitives::f32_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F32)));
    }
    if index == interner::Primitives::f64_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::F64)));
    }
    if index == interner::Primitives::char_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)));
    }
    if index == interner::Primitives::str_sym().index {
        return Option::Some(hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Str)));
    }

    // Not a primitive type
    Option::None
}

// ============================================================
// Type Arguments — TyId-returning version
// ============================================================

/// Lower type arguments directly to Vec<TyId>.
pub fn lower_type_args_id(ctx: &mut hir_lower_ctx::LoweringCtx, args: &ast::TypeArgs) -> Vec<type_intern::TyId> {
    let mut result: Vec<type_intern::TyId> = Vec::new();
    let mut i: usize = 0;
    while i < args.args.len() {
        match &args.args[i] {
            &ast::TypeArg::Type(ref ty) => {
                let t = lower_type_id(ctx, ty);
                result.push(t);
            }
            &ast::TypeArg::Lifetime(_) => {
                // Lifetimes don't produce types in our representation
            }
            &ast::TypeArg::Const(ref expr) => {
                let _value = const_eval::eval_const_expr(expr);
            }
        }
        i = i + 1;
    }
    result
}

/// Lower type arguments to a Vec of HIR types.
pub fn lower_type_args(ctx: &mut hir_lower_ctx::LoweringCtx, args: &ast::TypeArgs) -> Vec<hir_ty::Type> {
    let mut result: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < args.args.len() {
        match &args.args[i] {
            &ast::TypeArg::Type(ref ty) => {
                let t = lower_type(ctx, ty);
                result.push(t);
            }
            &ast::TypeArg::Lifetime(_) => {
                // Lifetimes don't produce types in our representation
            }
            &ast::TypeArg::Const(ref expr) => {
                let _value = const_eval::eval_const_expr(expr);
            }
        }
        i = i + 1;
    }
    result
}

// ============================================================
// Effect Row Lowering
// ============================================================

/// Lower an effect row.
pub fn lower_effect_row(ctx: &mut hir_lower_ctx::LoweringCtx, row: &ast::EffectRow) -> hir_ty::EffectRow {
    match &row.kind {
        &ast::EffectRowKind::Pure => {
            hir_ty::EffectRow::empty()
        }
        &ast::EffectRowKind::Effects { ref effects, ref rest } => {
            let mut hir_effects: Vec<hir_ty::EffectRef> = Vec::new();
            let mut i: usize = 0;
            while i < effects.len() {
                let eff = lower_effect_ref(ctx, &effects[i]);
                if eff.is_some() {
                    hir_effects.push(eff.unwrap());
                }
                i = i + 1;
            }
            // Handle row polymorphism: if `rest` is Some, this is an open effect row
            // with a row variable (e.g., Read, Write | r)
            match rest {
                &Option::Some(ref _row_var_name) => {
                    // Allocate a fresh effect row variable
                    let row_var = ctx.alloc_effect_row_var();
                    hir_ty::EffectRow::with_effects_and_var(hir_effects, row_var)
                }
                &Option::None => {
                    hir_ty::EffectRow::with_effects(hir_effects)
                }
            }
        }
        &ast::EffectRowKind::Var(ref _var_name) => {
            // Effect row variable reference (e.g., just `e` in a type)
            // Allocate a fresh effect row variable
            let row_var = ctx.alloc_effect_row_var();
            hir_ty::EffectRow::polymorphic(row_var)
        }
    }
}

/// Lower an effect reference from a type.
fn lower_effect_ref(ctx: &mut hir_lower_ctx::LoweringCtx, ty: &ast::Type) -> Option<hir_ty::EffectRef> {
    match &ty.kind {
        &ast::TypeKind::Path(ref path) => {
            if path.segments.len() == 1 {
                let seg = &path.segments[0];
                // Re-intern from span for consistent symbol indices
                let name_str = ctx.span_to_string(seg.name.span);
                let lookup_symbol = ctx.intern(name_str.as_str());
                let lookup = ctx.resolver.lookup(lookup_symbol);
                if lookup.is_some() {
                    let result = lookup.unwrap();
                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                    let def_id = binding.def_id;

                    // Check if the resolved item is definitely NOT an effect
                    match ctx.get_item(def_id) {
                        Option::Some(ref entry) => {
                            match &entry.item.kind {
                                &hir_item::ItemKind::Effect(_) => {
                                    // Good — this is an effect
                                }
                                _ => {
                                    // Not an effect — report error
                                    ctx.error(
                                        hir::DiagnosticCode::E0102,
                                        common::make_string("not an effect type"),
                                        ty.span,
                                    );
                                    return Option::None;
                                }
                            }
                        }
                        Option::None => {
                            // Item not yet lowered — assume it might be an effect
                        }
                    }

                    let type_args = match &seg.args {
                        &Some(ref args) => lower_type_args(ctx, args),
                        &None => Vec::new(),
                    };

                    return Some(hir_ty::EffectRef::new(def_id, type_args));
                }
            }
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown effect"),
                ty.span,
            );
            Option::None
        }
        _ => {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("invalid effect type"),
                ty.span,
            );
            Option::None
        }
    }
}

// ============================================================
// Generics Lowering
// ============================================================

/// Lower AST type parameters to HIR generics.
/// Always pushes a TypeParams scope that the caller MUST pop
/// by calling ctx.resolver.pop_scope() after lowering all
/// types that may reference the generic parameters.
pub fn lower_generics(ctx: &mut hir_lower_ctx::LoweringCtx, type_params: &Option<ast::TypeParams>, where_clause: &Option<ast::WhereClause>) -> hir_ty::Generics {
    let mut params: Vec<hir_ty::GenericParam> = Vec::new();
    let mut where_predicates: Vec<hir_ty::WherePredicate> = Vec::new();

    // Always push a type parameter scope. Even for items without generics,
    // an empty scope is harmless and simplifies the caller contract.
    ctx.resolver.push_scope(resolve::ScopeKind::TypeParams);

    match type_params {
        &Some(ref tp) => {
            let mut i: usize = 0;
            while i < tp.params.len() {
                match &tp.params[i] {
                    &ast::GenericParam::Type(ref type_param) => {
                        let var_id = ctx.alloc_ty_var();
                        let type_param_def = hir_ty::TypeParamDef::new(
                            type_param.name.symbol,
                            var_id,
                            type_param.span,
                        );
                        let param = hir_ty::GenericParam::TypeParam(type_param_def);
                        params.push(param);

                        // Register type param in resolver scope so it can be looked up.
                        // Use both the AST symbol AND a re-interned symbol to ensure
                        // consistent lookup regardless of which symbol index is used.
                        let _ = ctx.resolver.define_type_param(type_param.name.symbol, var_id);
                        let param_name_str = ctx.span_to_string(type_param.name.span);
                        let param_symbol = ctx.intern(param_name_str.as_str());
                        if param_symbol.index != type_param.name.symbol.index {
                            let _ = ctx.resolver.define_type_param(param_symbol, var_id);
                        }

                        // If there are bounds, add them as where predicates
                        if type_param.bounds.len() > 0 {
                            let param_ty = hir_ty::Type::new(hir_ty::TypeKind::Param(var_id));
                            let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                            let mut j: usize = 0;
                            while j < type_param.bounds.len() {
                                let bound_ty = lower_type(ctx, &type_param.bounds[j]);
                                // Convert the bound type to a TraitRef
                                let trait_ref = type_to_trait_ref(&bound_ty, type_param.bounds[j].span);
                                if trait_ref.is_some() {
                                    trait_refs.push(trait_ref.unwrap());
                                }
                                j = j + 1;
                            }
                            if trait_refs.len() > 0 {
                                let pred = hir_ty::WherePredicate::TypeBound {
                                    ty: param_ty,
                                    bounds: trait_refs,
                                    span: type_param.span,
                                };
                                where_predicates.push(pred);
                            }
                        }
                    }
                    &ast::GenericParam::Lifetime(ref lifetime_param) => {
                        let lifetime_def = hir_ty::LifetimeParamDef::new(
                            lifetime_param.name.symbol,
                            lifetime_param.span,
                        );
                        let param = hir_ty::GenericParam::LifetimeParam(lifetime_def);
                        params.push(param);
                    }
                    &ast::GenericParam::Const(ref const_param) => {
                        let ty = lower_type(ctx, &const_param.ty);
                        let const_def = hir_ty::ConstParamDef::new(
                            const_param.name.symbol,
                            ty,
                            const_param.span,
                        );
                        let param = hir_ty::GenericParam::ConstParam(const_def);
                        params.push(param);
                    }
                }
                i = i + 1;
            }
        }
        &None => {}
    }

    // Lower explicit where clause predicates
    if where_clause.is_some() {
        let wc = where_clause.as_ref().unwrap();
        let pred_len = wc.predicates.len();
        {
            let mut i: usize = 0;
            while i < pred_len {
                match &wc.predicates[i] {
                    &ast::WherePredicate::TypeBound { ref ty, ref bounds, span } => {
                        let lowered_ty = lower_type(ctx, ty);
                        let mut trait_refs: Vec<hir_ty::TraitRef> = Vec::new();
                        let mut j: usize = 0;
                        while j < bounds.len() {
                            let bound_ty = lower_type(ctx, &bounds[j]);
                            let trait_ref = type_to_trait_ref(&bound_ty, bounds[j].span);
                            if trait_ref.is_some() {
                                trait_refs.push(trait_ref.unwrap());
                            }
                            j = j + 1;
                        }
                        if trait_refs.len() > 0 {
                            let pred = hir_ty::WherePredicate::TypeBound {
                                ty: lowered_ty,
                                bounds: trait_refs,
                                span,
                            };
                            where_predicates.push(pred);
                        }
                    }
                    &ast::WherePredicate::Lifetime { ref lifetime, ref bound, span } => {
                        let pred = hir_ty::WherePredicate::LifetimeBound {
                            lifetime: lifetime.symbol,
                            bound: bound.symbol,
                            span,
                        };
                        where_predicates.push(pred);
                    }
                }
                i = i + 1;
            }
        }
    }

    hir_ty::Generics { params, where_predicates }
}

/// Convert a type to a TraitRef if it's a path type referring to a trait.
fn type_to_trait_ref(ty: &hir_ty::Type, span: common::Span) -> Option<hir_ty::TraitRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Manually copy the args vector since Blood doesn't have clone
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Some(hir_ty::TraitRef::new(def_id, args_copy, span))
        }
        _ => {
            // Other types can't be used as trait bounds directly
            Option::None
        }
    }
}
