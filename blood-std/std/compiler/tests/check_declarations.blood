// FileCheck test: runtime function declarations
// Verifies that the self-hosted compiler emits correct calling conventions
// for all runtime functions. Run with:
//   ./first_gen build tests/check_declarations.blood -o /tmp/check_decl.ll
//   FileCheck-14 --input-file=/tmp/check_decl.ll tests/check_declarations.blood
//
// String runtime: push_str takes (ptr, ptr), as_str/as_bytes return { ptr, i64 }
// CHECK-DAG: declare void @string_push_str(ptr, ptr)
// CHECK-DAG: declare { ptr, i64 } @string_as_str(ptr)
// CHECK-DAG: declare { ptr, i64 } @string_as_bytes(ptr)
// CHECK-DAG: declare { ptr, i64 } @str_as_bytes(ptr)
//
// Vec runtime: push takes (ptr, ptr, i64)
// CHECK-DAG: declare void @vec_push(ptr, ptr, i64)
// CHECK-DAG: declare void @vec_new(i64, ptr)
// CHECK-DAG: declare i64 @vec_len(ptr)
//
// String creation
// CHECK-DAG: declare void @string_new(ptr)
//
// Print/panic take fat pointer { ptr, i64 }
// CHECK-DAG: declare void @println_str({ ptr, i64 })
// CHECK-DAG: declare void @panic({ ptr, i64 })
fn main() -> i32 {
    // Exercise string operations to trigger their declarations
    let mut s = String::new();
    s.push_str("hello ");
    s.push_str("world");
    let slice = s.as_str();
    let bytes = s.as_bytes();
    let sbytes = slice.as_bytes();
    println(slice);

    // Exercise vec operations
    let mut v: Vec<i32> = Vec::new();
    v.push(42);
    let len = v.len();

    0
}
