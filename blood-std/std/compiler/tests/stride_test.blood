// Test Vec<NestedStruct> indexing stride correctness
// Mirrors ExprPathSegment = { SpannedSymbol, Option<TypeArgs> }

struct Symbol {
    pub index: u32,
}

struct Span {
    pub start: u64,
    pub end: u64,
    pub line: u32,
    pub column: u32,
}

struct SpannedSymbol {
    pub symbol: Symbol,
    pub span: Span,
}

struct TypeArgs {
    pub args: Vec<u32>,
    pub span: Span,
}

// Mirrors ExprPathSegment
struct Segment {
    pub name: SpannedSymbol,
    pub targs: Option<TypeArgs>,
}

fn main() -> i32 {
    let mut v: Vec<Segment> = Vec::new();

    let sym1 = Symbol { index: 42 };
    let sp1 = Span { start: 0, end: 10, line: 1, column: 0 };
    let name1 = SpannedSymbol { symbol: sym1, span: sp1 };
    let seg1 = Segment { name: name1, targs: Option::None };
    v.push(seg1);

    let sym2 = Symbol { index: 99 };
    let sp2 = Span { start: 20, end: 30, line: 2, column: 0 };
    let name2 = SpannedSymbol { symbol: sym2, span: sp2 };
    let seg2 = Segment { name: name2, targs: Option::None };
    v.push(seg2);

    // Should be 99 if stride is correct
    let elem = v[1];
    elem.name.symbol.index as i32
}
