// Blood Self-Hosted Compiler - MIR Lowering Context
//
// This module defines the context used during HIR to MIR lowering.
// It tracks the mapping from HIR locals to MIR locals, loop contexts
// for break/continue, and the current block being built.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod unify;
mod hashmap;

// ============================================================
// MIR Lowering Context
// ============================================================

/// Context for lowering a single function body from HIR to MIR.
pub struct MirLowerCtx {
    /// The MIR body being built.
    pub builder: mir_body::MirBodyBuilder,
    /// Mapping from HIR LocalId to MIR MirLocalId.
    /// Stored as pairs (hir_index, mir_index) for simplicity.
    local_map: Vec<LocalMapping>,
    /// Stack of loop contexts for break/continue.
    loop_stack: Vec<LoopContext>,
    /// Counter for generating unique temporary names.
    temp_counter: u32,
    /// Tracks moved places for use-after-move detection.
    pub move_tracker: MoveTracker,
    /// Substitution table from type inference.
    /// Used to resolve TypeKind::Infer variables to concrete types.
    pub subst_table: unify::SubstTable,
    /// Method resolution side table from type checking.
    /// Maps (body_def_id, span_start) to resolved method DefIds.
    pub method_resolutions: Vec<common::MethodResEntry>,
    /// Field resolution side table from type checking.
    /// Maps field access expression span starts to resolved field indices.
    pub field_resolutions: Vec<common::FieldResEntry>,
    /// The DefId of the current function body being lowered.
    /// Used to scope method resolution lookups to this body.
    pub body_def_id: u32,
    /// Hash-based index for O(1) method resolution lookup.
    /// Key: combined (body_def_id, span_start), Value: def_id_index
    method_hash: hashmap::HashMapU64U32,
    /// Hash-based index for O(1) field resolution lookup.
    /// Key: span_start, Value: field_idx
    field_hash: hashmap::HashMapU64U32,
}

/// Mapping from an HIR local to a MIR local.
struct LocalMapping {
    hir_id: u32,
    mir_id: mir_def::MirLocalId,
}

impl MirLowerCtx {
    /// Creates a new lowering context for a function.
    pub fn new(
        def_id: hir_def::DefId,
        return_ty: hir_ty::Type,
        span: common::Span,
        subst_table: unify::SubstTable,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
    ) -> MirLowerCtx {
        // Build hash indexes for O(1) lookup
        let mut method_hash = hashmap::HashMapU64U32::with_capacity(method_resolutions.len());
        let mut i: usize = 0;
        while i < method_resolutions.len() {
            let key = hashmap::combine_u32_usize(
                method_resolutions[i].body_def_id,
                method_resolutions[i].span_start
            );
            method_hash.insert(key, method_resolutions[i].def_id_index);
            i = i + 1;
        }

        let mut field_hash = hashmap::HashMapU64U32::with_capacity(field_resolutions.len());
        i = 0;
        while i < field_resolutions.len() {
            let key = field_resolutions[i].span_start as u64;
            field_hash.insert(key, field_resolutions[i].field_idx);
            i = i + 1;
        }

        MirLowerCtx {
            builder: mir_body::MirBodyBuilder::new(def_id, return_ty, span),
            local_map: Vec::new(),
            loop_stack: Vec::new(),
            temp_counter: 0,
            move_tracker: MoveTracker::new(),
            subst_table: subst_table,
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
            body_def_id: def_id.index,
            method_hash: method_hash,
            field_hash: field_hash,
        }
    }

    // ======== Local Management ========

    /// Registers a mapping from an HIR local to a MIR local.
    pub fn register_local(self: &mut MirLowerCtx, hir_id: hir_def::LocalId, mir_id: mir_def::MirLocalId) {
        self.local_map.push(LocalMapping {
            hir_id: hir_id.index,
            mir_id: mir_id,
        });
    }

    /// Looks up the MIR local for an HIR local.
    pub fn lookup_local(self: &MirLowerCtx, hir_id: hir_def::LocalId) -> Option<mir_def::MirLocalId> {
        let mut i: usize = 0;
        while i < self.local_map.len() {
            if self.local_map[i].hir_id == hir_id.index {
                return Option::Some(self.local_map[i].mir_id);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Resolves type inference variables to concrete types using the substitution table.
    /// This must be called on all types from HIR before they are used in MIR construction.
    pub fn resolve_type(self: &Self, ty: &hir_ty::Type) -> hir_ty::Type {
        unify::apply_substs(&self.subst_table, ty)
    }

    /// Looks up a resolved method DefId by the body's DefId and expression's span start.
    /// Returns the DefId if the type checker recorded a resolution for this body+span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    /// Filters by both body_def_id and span_start to handle span collisions across files
    /// (each file's spans start at byte 0, so span_start alone is not unique).
    pub fn lookup_method_def(self: &MirLowerCtx, span_start: usize) -> Option<hir_def::DefId> {
        // Fast path: hash-based lookup
        let key = hashmap::combine_u32_usize(self.body_def_id, span_start);
        match self.method_hash.get(key) {
            Option::Some(def_id_index) => {
                return Option::Some(hir_def::DefId::new(def_id_index));
            }
            Option::None => {}
        }

        // Hash lookup failed - fall back to linear scan for debugging
        let mut i: usize = 0;
        while i < self.method_resolutions.len() {
            if self.method_resolutions[i].body_def_id == self.body_def_id &&
               self.method_resolutions[i].span_start == span_start {
                return Option::Some(hir_def::DefId::new(self.method_resolutions[i].def_id_index));
            }
            i = i + 1;
        }
        // DEBUG: Print on lookup failure
        print_str("[MIR LOOKUP FAILED] body_def_id=");
        print_u64(self.body_def_id as u64);
        print_str(" span_start=");
        print_u64(span_start as u64);
        print_str(" checked ");
        print_u64(self.method_resolutions.len() as u64);
        print_str(" entries\n");
        // Print entries that partially match (same body OR same span)
        i = 0;
        while i < self.method_resolutions.len() {
            if self.method_resolutions[i].body_def_id == self.body_def_id {
                print_str("  SAME BODY [");
                print_u64(i as u64);
                print_str("]: span=");
                print_u64(self.method_resolutions[i].span_start as u64);
                print_str("\n");
            }
            if self.method_resolutions[i].span_start == span_start {
                print_str("  SAME SPAN [");
                print_u64(i as u64);
                print_str("]: body=");
                print_u64(self.method_resolutions[i].body_def_id as u64);
                print_str("\n");
            }
            i = i + 1;
        }
        Option::None
    }

    /// Looks up a resolved field index by the expression's span start.
    /// Returns the field index if the type checker recorded a resolution for this span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    pub fn lookup_field_idx(self: &MirLowerCtx, span_start: usize) -> Option<u32> {
        // Fast path: hash-based lookup
        let key = span_start as u64;
        match self.field_hash.get(key) {
            Option::Some(field_idx) => {
                return Option::Some(field_idx);
            }
            Option::None => {}
        }

        // Fallback to linear scan (should not happen with correct hash population)
        let mut i: usize = 0;
        while i < self.field_resolutions.len() {
            if self.field_resolutions[i].span_start == span_start {
                return Option::Some(self.field_resolutions[i].field_idx);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Creates a new temporary and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_temp(self: &mut MirLowerCtx, ty: hir_ty::Type, span: common::Span) -> mir_def::MirLocalId {
        self.temp_counter = self.temp_counter + 1;
        let resolved = unify::apply_substs(&self.subst_table, &ty);
        self.builder.new_temp(resolved, span)
    }

    /// Creates a new user variable and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_var(
        self: &mut MirLowerCtx,
        ty: hir_ty::Type,
        name: String,
        mutable: bool,
        span: common::Span,
    ) -> mir_def::MirLocalId {
        let resolved = unify::apply_substs(&self.subst_table, &ty);
        self.builder.new_var(resolved, name, mutable, span)
    }

    // ======== Block Management ========

    /// Creates a new basic block.
    pub fn new_block(self: &mut MirLowerCtx) -> mir_def::BasicBlockId {
        self.builder.new_block()
    }

    /// Returns the current block.
    pub fn current_block(self: &MirLowerCtx) -> mir_def::BasicBlockId {
        self.builder.current_block()
    }

    /// Sets the current block.
    pub fn set_current_block(self: &mut MirLowerCtx, block: mir_def::BasicBlockId) {
        self.builder.set_current_block(block);
    }

    /// Returns true if the current block is already terminated.
    pub fn is_terminated(self: &MirLowerCtx) -> bool {
        self.builder.is_terminated()
    }

    // ======== Statement Emission ========

    /// Emits a statement to the current block.
    pub fn emit_stmt(self: &mut MirLowerCtx, stmt: mir_stmt::Statement) {
        self.builder.push_stmt(stmt);
    }

    /// Emits an assignment statement.
    pub fn emit_assign(
        self: &mut MirLowerCtx,
        place: mir_types::Place,
        rvalue: mir_types::Rvalue,
        span: common::Span,
    ) {
        self.builder.push_assign(place, rvalue, span);
    }

    /// Emits a storage live marker.
    pub fn emit_storage_live(self: &mut MirLowerCtx, local: mir_def::MirLocalId, span: common::Span) {
        self.emit_stmt(mir_stmt::Statement::storage_live(local, span));
    }

    /// Emits a storage dead marker.
    pub fn emit_storage_dead(self: &mut MirLowerCtx, local: mir_def::MirLocalId, span: common::Span) {
        self.emit_stmt(mir_stmt::Statement::storage_dead(local, span));
    }

    // ======== Terminator Emission ========

    /// Terminates with an unconditional goto.
    pub fn terminate_goto(self: &mut MirLowerCtx, target: mir_def::BasicBlockId, span: common::Span) {
        self.builder.terminate(mir_term::Terminator::goto(target, span));
    }

    /// Terminates with a return.
    pub fn terminate_return(self: &mut MirLowerCtx, span: common::Span) {
        self.builder.terminate_return(span);
    }

    /// Terminates with a conditional branch.
    pub fn terminate_if(
        self: &mut MirLowerCtx,
        cond: mir_types::Operand,
        true_block: mir_def::BasicBlockId,
        false_block: mir_def::BasicBlockId,
        span: common::Span,
    ) {
        self.builder.terminate_if(cond, true_block, false_block, span);
    }

    /// Terminates with a switch.
    pub fn terminate_switch(
        self: &mut MirLowerCtx,
        discr: mir_types::Operand,
        targets: mir_types::SwitchTargets,
        span: common::Span,
    ) {
        self.builder.terminate(mir_term::Terminator::new(
            mir_term::TerminatorKind::SwitchInt { discr, targets },
            span,
        ));
    }

    /// Terminates with a function call.
    pub fn terminate_call(
        self: &mut MirLowerCtx,
        func: mir_types::Operand,
        args: Vec<mir_types::Operand>,
        destination: mir_types::Place,
        target: mir_def::BasicBlockId,
        span: common::Span,
    ) {
        self.builder.terminate(mir_term::call(func, args, destination, target, span));
    }

    /// Terminates with unreachable.
    pub fn terminate_unreachable(self: &mut MirLowerCtx, span: common::Span) {
        self.builder.terminate(mir_term::Terminator::unreachable(span));
    }

    // ======== Loop Context ========

    /// Pushes a loop context.
    pub fn push_loop(
        self: &mut MirLowerCtx,
        label: Option<common::Symbol>,
        break_block: mir_def::BasicBlockId,
        continue_block: mir_def::BasicBlockId,
        result_dest: Destination,
    ) {
        self.loop_stack.push(LoopContext {
            label: label,
            break_block: break_block,
            continue_block: continue_block,
            result_dest: result_dest,
        });
    }

    /// Pops the current loop context.
    pub fn pop_loop(self: &mut MirLowerCtx) {
        if self.loop_stack.len() > 0 {
            self.loop_stack.pop();
        }
    }

    /// Finds the break block for the given label (or innermost loop if None).
    pub fn find_break_block(self: &MirLowerCtx, label: Option<common::Symbol>) -> Option<mir_def::BasicBlockId> {
        match label {
            Option::Some(lbl) => {
                // Search for matching label from innermost to outermost
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option::Some(self.loop_stack[i].break_block);
                            }
                        }
                        &Option::None => {}
                    }
                }
                Option::None
            }
            Option::None => {
                // Use innermost loop
                if self.loop_stack.len() > 0 {
                    Option::Some(self.loop_stack[self.loop_stack.len() - 1].break_block)
                } else {
                    Option::None
                }
            }
        }
    }

    /// Finds the continue block for the given label (or innermost loop if None).
    pub fn find_continue_block(self: &MirLowerCtx, label: Option<common::Symbol>) -> Option<mir_def::BasicBlockId> {
        match label {
            Option::Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option::Some(self.loop_stack[i].continue_block);
                            }
                        }
                        &Option::None => {}
                    }
                }
                Option::None
            }
            Option::None => {
                if self.loop_stack.len() > 0 {
                    Option::Some(self.loop_stack[self.loop_stack.len() - 1].continue_block)
                } else {
                    Option::None
                }
            }
        }
    }

    /// Finds the result destination for the given label (or innermost loop if None).
    pub fn find_break_dest(self: &MirLowerCtx, label: Option<common::Symbol>) -> Destination {
        match label {
            Option::Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return self.loop_stack[i].result_dest.clone();
                            }
                        }
                        &Option::None => {}
                    }
                }
                Destination::Ignore
            }
            Option::None => {
                if self.loop_stack.len() > 0 {
                    self.loop_stack[self.loop_stack.len() - 1].result_dest.clone()
                } else {
                    Destination::Ignore
                }
            }
        }
    }

    // ======== Finalization ========

    /// Finishes building and returns the MIR body.
    pub fn finish(self: MirLowerCtx) -> mir_body::MirBody {
        self.builder.finish()
    }
}

// ============================================================
// Loop Context
// ============================================================

/// Context for a loop, tracking break and continue targets.
pub struct LoopContext {
    /// Optional label for this loop.
    pub label: Option<common::Symbol>,
    /// The block to jump to on break.
    pub break_block: mir_def::BasicBlockId,
    /// The block to jump to on continue.
    pub continue_block: mir_def::BasicBlockId,
    /// The destination where break values should be stored.
    pub result_dest: Destination,
}

// ============================================================
// Destination
// ============================================================
// This is the canonical definition of Destination. Other modules use
// standalone helper functions (destination_local, destination_ignore,
// destination_return_place) for cross-module access since blood-rust
// doesn't support cross-module associated function calls on enums.

/// The destination for an expression's value.
///
/// When lowering expressions, we need to know where to put the result.
/// This can be a specific place or we can ignore the result.
pub enum Destination {
    /// Write the result to this place.
    Place(mir_types::Place),
    /// Ignore the result (expression is used for side effects only).
    Ignore,
}

impl Destination {
    /// Creates a destination for a local.
    pub fn local(id: mir_def::MirLocalId) -> Destination {
        Destination::Place(mir_types::Place::local(id))
    }

    /// Creates a destination for the return place.
    pub fn return_place() -> Destination {
        Destination::Place(mir_types::Place::return_place())
    }

    /// Creates an ignore destination.
    pub fn ignore() -> Destination {
        Destination::Ignore
    }

    /// Returns the place if this is a Place destination.
    pub fn as_place(self: &Destination) -> Option<mir_types::Place> {
        match self {
            &Destination::Place(ref p) => Option::Some(p.clone()),
            &Destination::Ignore => Option::None,
        }
    }

    /// Clone the destination.
    pub fn clone(self: &Destination) -> Destination {
        match self {
            &Destination::Place(ref p) => Destination::Place(p.clone()),
            &Destination::Ignore => Destination::Ignore,
        }
    }
}

// ============================================================
// Destination Standalone Helper Functions
// ============================================================
// These standalone functions allow cross-module use because
// blood-rust doesn't support cross-module associated function calls
// (e.g., mir_lower_ctx::Destination::local(...) fails).
// Use these helpers instead: mir_lower_ctx::destination_local(...), etc.

/// Creates a destination for a local variable.
pub fn destination_local(id: mir_def::MirLocalId) -> Destination {
    Destination::Place(mir_types::Place::local(id))
}

/// Creates a destination for the return place.
pub fn destination_return_place() -> Destination {
    Destination::Place(mir_types::Place::return_place())
}

/// Creates an ignore destination.
pub fn destination_ignore() -> Destination {
    Destination::Ignore
}

// ============================================================
// Clone implementations
// ============================================================

// mir_types::Place needs clone for Destination
impl mir_types::Place {
    pub fn clone(self: &mir_types::Place) -> mir_types::Place {
        let mut proj = Vec::new();
        let mut i: usize = 0;
        while i < self.projection.len() {
            proj.push(self.projection[i].clone());
            i = i + 1;
        }
        mir_types::Place {
            local: self.local,
            projection: proj,
        }
    }
}

impl mir_types::PlaceElem {
    pub fn clone(self: &mir_types::PlaceElem) -> mir_types::PlaceElem {
        match self {
            &mir_types::PlaceElem::Deref => mir_types::PlaceElem::Deref,
            &mir_types::PlaceElem::Field(idx) => mir_types::PlaceElem::Field(idx),
            &mir_types::PlaceElem::Index(ref local) => mir_types::PlaceElem::Index(*local),
            &mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end } => {
                mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end }
            }
            &mir_types::PlaceElem::Subslice { from, to, from_end } => {
                mir_types::PlaceElem::Subslice { from, to, from_end }
            }
            &mir_types::PlaceElem::Downcast(idx) => mir_types::PlaceElem::Downcast(idx),
        }
    }
}

// ============================================================
// Move Tracking Infrastructure
// ============================================================
//
// This section provides infrastructure for tracking moved values
// to detect use-after-move errors.
//
// # Architecture
//
// Move tracking operates in two phases:
// 1. During MIR lowering: Record when Move operands are created
// 2. During MIR analysis: Check that moved places aren't used again
//
// # Current Status
//
// MoveTracker is integrated into MirLowerCtx:
// - MirLowerCtx has a `move_tracker` field
// - `operand_from_place_tracked()` in mir_lower_util.blood checks for
//   use-after-move before creating operands and tracks moves
// - `clear_move_on_assign()` resets move status after reassignment
//
// # Usage
//
// Use `operand_from_place_tracked()` instead of `operand_from_place()`
// to enable move tracking. The function will return Option::None if
// the place has been moved from, allowing the caller to report an error.

/// Tracks which places have been moved from.
///
/// This is a simplified representation. A full implementation would
/// track partial moves (e.g., moving a struct field) and handle
/// re-assignment which allows reuse.
pub struct MoveTracker {
    /// Places that have been moved from.
    /// Stored as (local_index, moved) pairs.
    moved_locals: Vec<MovedLocal>,
}

/// A local that has been moved from.
struct MovedLocal {
    /// The local's index.
    local_index: u32,
    /// The span where the move occurred (for error messages).
    move_span: common::Span,
}

impl MoveTracker {
    /// Creates a new move tracker.
    pub fn new() -> MoveTracker {
        MoveTracker {
            moved_locals: Vec::new(),
        }
    }

    /// Records that a local has been moved.
    pub fn track_move(self: &mut Self, local: mir_def::MirLocalId, span: common::Span) {
        self.moved_locals.push(MovedLocal {
            local_index: local.index,
            move_span: span,
        });
    }

    /// Checks if a local has been moved.
    /// Returns Some(span) if moved, None otherwise.
    pub fn check_moved(self: &Self, local: mir_def::MirLocalId) -> Option<common::Span> {
        let mut i: usize = 0;
        while i < self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                return Option::Some(self.moved_locals[i].move_span);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Clears the moved status of a local (after re-assignment).
    pub fn clear_move(self: &mut Self, local: mir_def::MirLocalId) {
        let mut i: usize = 0;
        while i < self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                // Remove by swapping with last and popping
                let last = self.moved_locals.len() - 1;
                if i != last {
                    self.moved_locals[i] = MovedLocal {
                        local_index: self.moved_locals[last].local_index,
                        move_span: self.moved_locals[last].move_span,
                    };
                }
                self.moved_locals.pop();
                return;
            }
            i = i + 1;
        }
    }

    /// Resets all move tracking (for a new function body).
    pub fn reset(self: &mut Self) {
        while self.moved_locals.len() > 0 {
            self.moved_locals.pop();
        }
    }
}

// force recompile
