/// Blood Type Checker - Third step toward self-hosting
///
/// This module implements bidirectional type checking with Hindley-Milner-style
/// type inference. Part of Phase 6: Self-Hosting.
///
/// # Type Checking Process
///
/// 1. **Name Resolution** - Resolve all identifiers to definitions
/// 2. **Type Collection** - Gather type signatures for all items
/// 3. **Type Checking** - Check function bodies against signatures
/// 4. **Inference** - Fill in inferred types via unification

use std.compiler.parser::{
    Program, Declaration, FnDecl, StructDecl, EnumDecl, EffectDecl,
    TraitDecl, ImplBlock, ImplItem, Type as AstType, TypeKind as AstTypeKind,
    Expr, ExprKind, Pattern, PatternKind, Block, Statement, Span, Spanned,
    TypeParams, StructBody, EnumVariant, EffectOp, Param, Path, PathSegment,
    MatchArm, Handler, OpHandler, FieldInit, FieldPattern, Literal, BinOp, UnOp,
    EffectRow as AstEffectRow, EffectRef as AstEffectRef, AssocConst, AssocType,
};
use std.compiler.lexer::{Token, TokenKind};
use std.collections::{HashMap, HashSet};

// ============================================================
// Type Variable IDs
// ============================================================

/// Unique identifier for type variables used in inference.
struct TyVarId {
    id: u32,
}

impl TyVarId {
    fn new(id: u32) -> TyVarId {
        TyVarId { id }
    }
}

/// Unique identifier for definition (function, struct, etc.)
struct DefId {
    id: u32,
}

impl DefId {
    fn new(id: u32) -> DefId {
        DefId { id }
    }
}

/// Unique identifier for record row variables (for row polymorphism).
struct RecordRowVarId {
    id: u32,
}

impl RecordRowVarId {
    fn new(id: u32) -> RecordRowVarId {
        RecordRowVarId { id }
    }
}

/// Unique identifier for effect row variables.
struct EffectRowVarId {
    id: u32,
}

impl EffectRowVarId {
    fn new(id: u32) -> EffectRowVarId {
        EffectRowVarId { id }
    }
}

// ============================================================
// Primitive Types
// ============================================================

/// Primitive types built into the language.
enum PrimitiveTy {
    // Integers
    I8,
    I16,
    I32,
    I64,
    I128,
    Isize,
    U8,
    U16,
    U32,
    U64,
    U128,
    Usize,
    // Floats
    F32,
    F64,
    // Other
    Bool,
    Char,
    String,
    Unit,
}

impl PrimitiveTy {
    /// Get the name of this primitive type.
    fn name(&self) -> &str {
        match self {
            PrimitiveTy::I8 => "i8",
            PrimitiveTy::I16 => "i16",
            PrimitiveTy::I32 => "i32",
            PrimitiveTy::I64 => "i64",
            PrimitiveTy::I128 => "i128",
            PrimitiveTy::Isize => "isize",
            PrimitiveTy::U8 => "u8",
            PrimitiveTy::U16 => "u16",
            PrimitiveTy::U32 => "u32",
            PrimitiveTy::U64 => "u64",
            PrimitiveTy::U128 => "u128",
            PrimitiveTy::Usize => "usize",
            PrimitiveTy::F32 => "f32",
            PrimitiveTy::F64 => "f64",
            PrimitiveTy::Bool => "bool",
            PrimitiveTy::Char => "char",
            PrimitiveTy::String => "String",
            PrimitiveTy::Unit => "()",
        }
    }

    /// Check if this is an integer type.
    fn is_integer(&self) -> bool {
        match self {
            PrimitiveTy::I8 | PrimitiveTy::I16 | PrimitiveTy::I32 | PrimitiveTy::I64 |
            PrimitiveTy::I128 | PrimitiveTy::Isize | PrimitiveTy::U8 | PrimitiveTy::U16 |
            PrimitiveTy::U32 | PrimitiveTy::U64 | PrimitiveTy::U128 | PrimitiveTy::Usize => true,
            _ => false,
        }
    }

    /// Check if this is a signed integer type.
    fn is_signed(&self) -> bool {
        match self {
            PrimitiveTy::I8 | PrimitiveTy::I16 | PrimitiveTy::I32 |
            PrimitiveTy::I64 | PrimitiveTy::I128 | PrimitiveTy::Isize => true,
            _ => false,
        }
    }

    /// Check if this is a floating point type.
    fn is_float(&self) -> bool {
        match self {
            PrimitiveTy::F32 | PrimitiveTy::F64 => true,
            _ => false,
        }
    }

    /// Check if this is a numeric type (integer or float).
    fn is_numeric(&self) -> bool {
        self.is_integer() || self.is_float()
    }
}

// ============================================================
// Ownership Qualifiers
// ============================================================

/// Ownership qualifiers for types.
enum Ownership {
    /// Linear: must be used exactly once
    Linear,
    /// Affine: can be used at most once
    Affine,
    /// Default (no qualifier)
    Default,
}

// ============================================================
// Type Representation
// ============================================================

/// A semantic type in Blood.
struct Type {
    kind: TypeKind,
}

impl Type {
    /// Create a new type from a kind.
    fn new(kind: TypeKind) -> Type {
        Type { kind }
    }

    /// Get the kind of this type.
    fn kind(&self) -> &TypeKind {
        &self.kind
    }

    /// Check if this type is a primitive.
    fn is_primitive(&self) -> bool {
        match &self.kind {
            TypeKind::Primitive(_) => true,
            _ => false,
        }
    }

    /// Check if this type is the unit type.
    fn is_unit(&self) -> bool {
        match &self.kind {
            TypeKind::Tuple(tys) => tys.len() == 0,
            TypeKind::Primitive(PrimitiveTy::Unit) => true,
            _ => false,
        }
    }

    /// Check if this type is the never type.
    fn is_never(&self) -> bool {
        match &self.kind {
            TypeKind::Never => true,
            _ => false,
        }
    }

    /// Check if this type is a reference.
    fn is_ref(&self) -> bool {
        match &self.kind {
            TypeKind::Ref { inner: _, mutable: _ } => true,
            _ => false,
        }
    }

    /// Check if this type is a function.
    fn is_fn(&self) -> bool {
        match &self.kind {
            TypeKind::Fn { params: _, ret: _, effect: _ } => true,
            _ => false,
        }
    }

    /// Check if this type is an error type.
    fn is_error(&self) -> bool {
        match &self.kind {
            TypeKind::Error => true,
            _ => false,
        }
    }

    /// Check if this type is an inference variable.
    fn is_infer(&self) -> bool {
        match &self.kind {
            TypeKind::Infer(_) => true,
            _ => false,
        }
    }

    // Convenience constructors

    /// Create the unit type `()`.
    fn unit() -> Type {
        Type::new(TypeKind::Tuple(vec![]))
    }

    /// Create the never type `!`.
    fn never() -> Type {
        Type::new(TypeKind::Never)
    }

    /// Create an error type (used for error recovery).
    fn error() -> Type {
        Type::new(TypeKind::Error)
    }

    /// Create a boolean type.
    fn bool_type() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Bool))
    }

    /// Create an i32 type.
    fn i32_type() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::I32))
    }

    /// Create an i64 type.
    fn i64_type() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::I64))
    }

    /// Create a string type.
    fn string_type() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::String))
    }

    /// Create an inference variable.
    fn infer(id: TyVarId) -> Type {
        Type::new(TypeKind::Infer(id))
    }

    /// Create a type parameter.
    fn param(id: TyVarId) -> Type {
        Type::new(TypeKind::Param(id))
    }
}

/// The kind of a type (its structure).
enum TypeKind {
    /// Primitive types: i32, bool, etc.
    Primitive(PrimitiveTy),

    /// Never type: !
    Never,

    /// Tuple type: (T1, T2, ...)
    Tuple([Type]),

    /// Array type: [T; N]
    Array { element: Type, size: u64 },

    /// Slice type: [T]
    Slice { element: Type },

    /// Reference type: &T or &mut T
    Ref { inner: Type, mutable: bool },

    /// Raw pointer type: *const T or *mut T
    Ptr { inner: Type, mutable: bool },

    /// Function type: fn(T1, T2) -> R / Effects
    Fn { params: [Type], ret: Type, effect: Option<EffectRow> },

    /// Closure type (function with captures)
    Closure { params: [Type], ret: Type, effect: Option<EffectRow], captures: [Type] },

    /// Algebraic data type (struct or enum): Foo<T1, T2>
    Adt { def_id: DefId, args: [Type] },

    /// Range type: Range<T>
    Range { element: Type, inclusive: bool },

    /// Dynamic trait object: dyn Trait
    DynTrait { trait_id: DefId },

    /// Record type (anonymous struct with row polymorphism)
    Record { fields: [RecordField], row_var: Option<RecordRowVarId> },

    /// Universal quantification: forall<T>. Type
    Forall { params: [TyVarId], body: Type },

    /// Ownership-qualified type
    Ownership { inner: Type, ownership: Ownership },

    /// Type inference variable (unresolved)
    Infer(TyVarId),

    /// Type parameter (bound by forall or generic)
    Param(TyVarId),

    /// Error type (for error recovery)
    Error,
}

/// A field in a record type.
struct RecordField {
    name: String,
    ty: Type,
}

// ============================================================
// Effect Types
// ============================================================

/// An effect row: {Effect1, Effect2, ..E}
struct EffectRow {
    effects: [EffectInstance],
    row_var: Option<EffectRowVarId>,
}

impl EffectRow {
    fn new(effects: [EffectInstance], row_var: Option<EffectRowVarId>) -> EffectRow {
        EffectRow { effects, row_var }
    }

    /// Create a pure effect row (no effects).
    fn pure() -> EffectRow {
        EffectRow { effects: vec![], row_var: None }
    }

    /// Check if this effect row is pure (no effects).
    fn is_pure(&self) -> bool {
        self.effects.len() == 0 && self.row_var.is_none()
    }
}

/// An instance of an effect with type arguments.
struct EffectInstance {
    def_id: DefId,
    args: [Type],
}

// ============================================================
// Type Errors
// ============================================================

/// A type checking error.
struct TypeError {
    kind: TypeErrorKind,
    span: Span,
}

impl TypeError {
    fn new(kind: TypeErrorKind, span: Span) -> TypeError {
        TypeError { kind, span }
    }
}

/// The kind of type error.
enum TypeErrorKind {
    /// Type mismatch: expected X, found Y
    Mismatch { expected: Type, found: Type },

    /// Cannot find name in scope
    UnresolvedName { name: String },

    /// Cannot find type in scope
    UnresolvedType { name: String },

    /// Wrong number of type arguments
    WrongArity { expected: u32, found: u32 },

    /// Cannot unify types (occurs check failure)
    OccursCheck { var: TyVarId, ty: Type },

    /// Effect not handled
    UnhandledEffect { effect: EffectInstance },

    /// Invalid effect operation
    InvalidEffectOp { effect: String, op: String },

    /// Duplicate definition
    DuplicateDefinition { name: String },

    /// Missing field in struct
    MissingField { struct_name: String, field: String },

    /// Unknown field in struct
    UnknownField { struct_name: String, field: String },

    /// Pattern type mismatch
    PatternMismatch { expected: Type, found: Type },

    /// Non-exhaustive patterns
    NonExhaustive { missing: [String] },

    /// Other error with message
    Other { message: String },
}

// ============================================================
// Unifier - Type Unification
// ============================================================

/// The unifier maintains type variable substitutions.
struct Unifier {
    /// Type variable substitutions.
    substitutions: HashMap<u32, Type>,
    /// The next type variable ID to assign.
    next_var: u32,
    /// Row variable substitutions for record types.
    row_substitutions: HashMap<u32, ([RecordField], Option<RecordRowVarId>)>,
    /// The next row variable ID.
    next_row_var: u32,
    /// Effect row variable substitutions.
    effect_row_substitutions: HashMap<u32, EffectRow>,
    /// The next effect row variable ID.
    next_effect_row_var: u32,
}

impl Unifier {
    /// Create a new unifier.
    fn new() -> Unifier {
        Unifier {
            substitutions: HashMap::new(),
            next_var: 0,
            row_substitutions: HashMap::new(),
            next_row_var: 0,
            effect_row_substitutions: HashMap::new(),
            next_effect_row_var: 0,
        }
    }

    /// Create a fresh type variable.
    fn fresh_var(&mut self) -> Type {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        Type::infer(id)
    }

    /// Create multiple fresh type variables.
    fn fresh_vars(&mut self, count: u32) -> [Type] {
        let mut vars: [Type] = vec![];
        let mut i: u32 = 0;
        while i < count {
            vars.push(self.fresh_var());
            i = i + 1;
        }
        vars
    }

    /// Create a fresh row variable for record types.
    fn fresh_row_var(&mut self) -> RecordRowVarId {
        let id = RecordRowVarId::new(self.next_row_var);
        self.next_row_var = self.next_row_var + 1;
        id
    }

    /// Create a fresh effect row variable.
    fn fresh_effect_row_var(&mut self) -> EffectRowVarId {
        let id = EffectRowVarId::new(self.next_effect_row_var);
        self.next_effect_row_var = self.next_effect_row_var + 1;
        id
    }

    /// Create a fresh type variable for a forall-bound parameter.
    fn fresh_forall_var(&mut self) -> TyVarId {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        id
    }

    /// Resolve a type by following substitutions.
    fn resolve(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id) {
                    Some(resolved) => self.resolve(resolved),
                    None => ty.clone(),
                }
            }
            _ => ty.clone(),
        }
    }

    /// Unify two types, recording substitutions.
    ///
    /// Returns Ok(()) if unification succeeds, Err if types are incompatible.
    fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        // Resolve any existing substitutions
        let t1 = self.resolve(t1);
        let t2 = self.resolve(t2);

        match (&t1.kind, &t2.kind) {
            // Same primitive types
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                if self.primitive_eq(p1, p2) {
                    Ok(())
                } else {
                    Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ))
                }
            }

            // Same ADT with unifiable arguments
            (TypeKind::Adt { def_id: d1, args: a1 }, TypeKind::Adt { def_id: d2, args: a2 }) => {
                if d1.id != d2.id {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                if a1.len() != a2.len() {
                    return Err(TypeError::new(
                        TypeErrorKind::WrongArity { expected: a1.len() as u32, found: a2.len() as u32 },
                        span,
                    ));
                }
                let mut i: usize = 0;
                while i < a1.len() {
                    self.unify(&a1[i], &a2[i], span)?;
                    i = i + 1;
                }
                Ok(())
            }

            // Tuples with same length
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() != ts2.len() {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                let mut i: usize = 0;
                while i < ts1.len() {
                    self.unify(&ts1[i], &ts2[i], span)?;
                    i = i + 1;
                }
                Ok(())
            }

            // Arrays with same size
            (TypeKind::Array { element: e1, size: s1 }, TypeKind::Array { element: e2, size: s2 }) => {
                if s1 != s2 {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                self.unify(e1, e2, span)
            }

            // Slices
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.unify(e1, e2, span)
            }

            // References with same mutability
            (TypeKind::Ref { inner: i1, mutable: m1 }, TypeKind::Ref { inner: i2, mutable: m2 }) => {
                if m1 != m2 {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                self.unify(i1, i2, span)
            }

            // Pointers with same mutability
            (TypeKind::Ptr { inner: i1, mutable: m1 }, TypeKind::Ptr { inner: i2, mutable: m2 }) => {
                if m1 != m2 {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                self.unify(i1, i2, span)
            }

            // Function types
            (TypeKind::Fn { params: p1, ret: r1, effect: e1 }, TypeKind::Fn { params: p2, ret: r2, effect: e2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::new(
                        TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                        span,
                    ));
                }
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                }
                self.unify(r1, r2, span)?;
                self.unify_effects(e1, e2, span)
            }

            // Type variable on left - bind it
            (TypeKind::Infer(id), _) => {
                if self.occurs_in(id, &t2) {
                    return Err(TypeError::new(
                        TypeErrorKind::OccursCheck { var: id.clone(), ty: t2.clone() },
                        span,
                    ));
                }
                self.substitutions.insert(id.id, t2.clone());
                Ok(())
            }

            // Type variable on right - bind it
            (_, TypeKind::Infer(id)) => {
                if self.occurs_in(id, &t1) {
                    return Err(TypeError::new(
                        TypeErrorKind::OccursCheck { var: id.clone(), ty: t1.clone() },
                        span,
                    ));
                }
                self.substitutions.insert(id.id, t1.clone());
                Ok(())
            }

            // Never type unifies with anything
            (TypeKind::Never, _) => Ok(()),
            (_, TypeKind::Never) => Ok(()),

            // Error type unifies with anything (for error recovery)
            (TypeKind::Error, _) => Ok(()),
            (_, TypeKind::Error) => Ok(()),

            // No match
            _ => Err(TypeError::new(
                TypeErrorKind::Mismatch { expected: t1.clone(), found: t2.clone() },
                span,
            )),
        }
    }

    /// Check if a type variable occurs in a type (for occurs check).
    fn occurs_in(&self, var: &TyVarId, ty: &Type) -> bool {
        let ty = self.resolve(ty);
        match &ty.kind {
            TypeKind::Infer(id) => id.id == var.id,
            TypeKind::Param(id) => id.id == var.id,
            TypeKind::Primitive(_) | TypeKind::Never | TypeKind::Error => false,
            TypeKind::Tuple(tys) => {
                let mut i: usize = 0;
                while i < tys.len() {
                    if self.occurs_in(var, &tys[i]) {
                        return true;
                    }
                    i = i + 1;
                }
                false
            }
            TypeKind::Array { element, size: _ } => self.occurs_in(var, element),
            TypeKind::Slice { element } => self.occurs_in(var, element),
            TypeKind::Ref { inner, mutable: _ } => self.occurs_in(var, inner),
            TypeKind::Ptr { inner, mutable: _ } => self.occurs_in(var, inner),
            TypeKind::Fn { params, ret, effect: _ } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    }
                    i = i + 1;
                }
                self.occurs_in(var, ret)
            }
            TypeKind::Closure { params, ret, effect: _, captures } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    }
                    i = i + 1;
                }
                if self.occurs_in(var, ret) {
                    return true;
                }
                i = 0;
                while i < captures.len() {
                    if self.occurs_in(var, &captures[i]) {
                        return true;
                    }
                    i = i + 1;
                }
                false
            }
            TypeKind::Adt { def_id: _, args } => {
                let mut i: usize = 0;
                while i < args.len() {
                    if self.occurs_in(var, &args[i]) {
                        return true;
                    }
                    i = i + 1;
                }
                false
            }
            TypeKind::Range { element, inclusive: _ } => self.occurs_in(var, element),
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields, row_var: _ } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    if self.occurs_in(var, &fields[i].ty) {
                        return true;
                    }
                    i = i + 1;
                }
                false
            }
            TypeKind::Forall { params: _, body } => self.occurs_in(var, body),
            TypeKind::Ownership { inner, ownership: _ } => self.occurs_in(var, inner),
        }
    }

    /// Check if two primitive types are equal.
    fn primitive_eq(&self, p1: &PrimitiveTy, p2: &PrimitiveTy) -> bool {
        match (p1, p2) {
            (PrimitiveTy::I8, PrimitiveTy::I8) => true,
            (PrimitiveTy::I16, PrimitiveTy::I16) => true,
            (PrimitiveTy::I32, PrimitiveTy::I32) => true,
            (PrimitiveTy::I64, PrimitiveTy::I64) => true,
            (PrimitiveTy::I128, PrimitiveTy::I128) => true,
            (PrimitiveTy::Isize, PrimitiveTy::Isize) => true,
            (PrimitiveTy::U8, PrimitiveTy::U8) => true,
            (PrimitiveTy::U16, PrimitiveTy::U16) => true,
            (PrimitiveTy::U32, PrimitiveTy::U32) => true,
            (PrimitiveTy::U64, PrimitiveTy::U64) => true,
            (PrimitiveTy::U128, PrimitiveTy::U128) => true,
            (PrimitiveTy::Usize, PrimitiveTy::Usize) => true,
            (PrimitiveTy::F32, PrimitiveTy::F32) => true,
            (PrimitiveTy::F64, PrimitiveTy::F64) => true,
            (PrimitiveTy::Bool, PrimitiveTy::Bool) => true,
            (PrimitiveTy::Char, PrimitiveTy::Char) => true,
            (PrimitiveTy::String, PrimitiveTy::String) => true,
            (PrimitiveTy::Unit, PrimitiveTy::Unit) => true,
            _ => false,
        }
    }

    /// Unify two effect rows.
    fn unify_effects(&mut self, e1: &Option<EffectRow>, e2: &Option<EffectRow>, span: Span) -> Result<(), TypeError> {
        match (e1, e2) {
            (None, None) => Ok(()),
            (Some(r1), Some(r2)) => self.unify_effect_rows(r1, r2, span),
            // If one is None (pure), the other must also be pure
            (None, Some(r2)) => {
                if r2.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::new(
                        TypeErrorKind::Other { message: "Effect mismatch: expected pure, found effectful".to_string() },
                        span,
                    ))
                }
            }
            (Some(r1), None) => {
                if r1.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::new(
                        TypeErrorKind::Other { message: "Effect mismatch: expected effectful, found pure".to_string() },
                        span,
                    ))
                }
            }
        }
    }

    /// Unify two effect rows.
    fn unify_effect_rows(&mut self, r1: &EffectRow, r2: &EffectRow, span: Span) -> Result<(), TypeError> {
        // For now, simple structural check
        // Full row polymorphism would need more sophisticated handling
        if r1.effects.len() != r2.effects.len() {
            return Err(TypeError::new(
                TypeErrorKind::Other { message: "Effect row length mismatch".to_string() },
                span,
            ));
        }

        // Check that all effects in r1 are in r2
        let mut i: usize = 0;
        while i < r1.effects.len() {
            if !self.effect_in_row(&r1.effects[i], r2) {
                return Err(TypeError::new(
                    TypeErrorKind::Other { message: "Effect not found in row".to_string() },
                    span,
                ));
            }
            i = i + 1;
        }

        Ok(())
    }

    /// Check if an effect instance is in an effect row.
    fn effect_in_row(&self, effect: &EffectInstance, row: &EffectRow) -> bool {
        let mut i: usize = 0;
        while i < row.effects.len() {
            if row.effects[i].def_id.id == effect.def_id.id {
                // TODO: also check type args match
                return true;
            }
            i = i + 1;
        }
        false
    }

    /// Apply substitutions to a type.
    fn apply(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id) {
                    Some(resolved) => self.apply(resolved),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) | TypeKind::Never | TypeKind::Error | TypeKind::Param(_) => ty.clone(),
            TypeKind::Tuple(tys) => {
                let mut applied: [Type] = vec![];
                let mut i: usize = 0;
                while i < tys.len() {
                    applied.push(self.apply(&tys[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Tuple(applied))
            }
            TypeKind::Array { element, size } => {
                Type::new(TypeKind::Array { element: self.apply(element), size: *size })
            }
            TypeKind::Slice { element } => {
                Type::new(TypeKind::Slice { element: self.apply(element) })
            }
            TypeKind::Ref { inner, mutable } => {
                Type::new(TypeKind::Ref { inner: self.apply(inner), mutable: *mutable })
            }
            TypeKind::Ptr { inner, mutable } => {
                Type::new(TypeKind::Ptr { inner: self.apply(inner), mutable: *mutable })
            }
            TypeKind::Fn { params, ret, effect } => {
                let mut applied_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    applied_params.push(self.apply(&params[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Fn {
                    params: applied_params,
                    ret: self.apply(ret),
                    effect: effect.clone(),
                })
            }
            TypeKind::Adt { def_id, args } => {
                let mut applied_args: [Type] = vec![];
                let mut i: usize = 0;
                while i < args.len() {
                    applied_args.push(self.apply(&args[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Adt { def_id: def_id.clone(), args: applied_args })
            }
            _ => ty.clone(), // TODO: handle other cases
        }
    }
}

// ============================================================
// Scope and Name Resolution
// ============================================================

/// A scope for name resolution.
struct Scope {
    /// Variables in this scope: name -> type
    variables: HashMap<String, Type>,
    /// Types in this scope: name -> DefId
    types: HashMap<String, DefId>,
    /// Parent scope (if any)
    parent: Option<Box<Scope>>,
}

impl Scope {
    /// Create a new empty scope.
    fn new() -> Scope {
        Scope {
            variables: HashMap::new(),
            types: HashMap::new(),
            parent: None,
        }
    }

    /// Create a child scope.
    fn child(&self) -> Scope {
        Scope {
            variables: HashMap::new(),
            types: HashMap::new(),
            parent: Some(Box::new(self.clone())),
        }
    }

    /// Look up a variable in this scope or parents.
    fn lookup_var(&self, name: &str) -> Option<Type> {
        match self.variables.get(name) {
            Some(ty) => Some(ty.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_var(name),
                    None => None,
                }
            }
        }
    }

    /// Look up a type in this scope or parents.
    fn lookup_type(&self, name: &str) -> Option<DefId> {
        match self.types.get(name) {
            Some(id) => Some(id.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_type(name),
                    None => None,
                }
            }
        }
    }

    /// Define a variable in this scope.
    fn define_var(&mut self, name: String, ty: Type) {
        self.variables.insert(name, ty);
    }

    /// Define a type in this scope.
    fn define_type(&mut self, name: String, id: DefId) {
        self.types.insert(name, id);
    }
}

// ============================================================
// Type Context - Main Type Checker
// ============================================================

/// The main type checking context.
struct TypeContext {
    /// Unifier for type inference
    unifier: Unifier,
    /// Current scope
    scope: Scope,
    /// All defined types
    type_defs: HashMap<u32, TypeDef>,
    /// All defined functions
    fn_defs: HashMap<u32, FnDef>,
    /// All defined effects
    effect_defs: HashMap<u32, EffectDef>,
    /// Trait resolver for method lookup and bound checking
    trait_resolver: TraitResolver,
    /// Next definition ID
    next_def_id: u32,
    /// Collected errors
    errors: [TypeError],
    /// Expected return type for current function (for checking return statements)
    current_return_type: Option<Type>,
    /// Current loop expected break type
    current_loop_type: Option<Type>,
    /// Current function's declared effect row (for tracking perform operations)
    current_effect_context: EffectContext,
    /// Stack of handled effects (for effect handlers)
    handled_effects: [EffectRow],
}

/// Tracks effect information during type checking.
struct EffectContext {
    /// Effects declared in the current function signature
    declared: Option<EffectRow>,
    /// Effects actually used in the function body
    used: [EffectInstance],
}

impl EffectContext {
    fn new() -> EffectContext {
        EffectContext {
            declared: None,
            used: vec![],
        }
    }

    fn with_declared(declared: Option<EffectRow>) -> EffectContext {
        EffectContext {
            declared,
            used: vec![],
        }
    }

    /// Record that an effect was used.
    fn use_effect(&mut self, effect: EffectInstance) {
        self.used.push(effect);
    }

    /// Check if an effect is declared or handled.
    fn is_effect_available(&self, effect_id: DefId, handled: &[EffectRow]) -> bool {
        // Check if declared in current function
        match &self.declared {
            Some(row) => {
                let mut i: usize = 0;
                while i < row.effects.len() {
                    if row.effects[i].def_id.id == effect_id.id {
                        return true;
                    }
                    i = i + 1;
                }
            }
            None => {}
        }

        // Check if handled by an enclosing handler
        let mut i: usize = 0;
        while i < handled.len() {
            let mut j: usize = 0;
            while j < handled[i].effects.len() {
                if handled[i].effects[j].def_id.id == effect_id.id {
                    return true;
                }
                j = j + 1;
            }
            i = i + 1;
        }

        false
    }
}

/// A type definition (struct or enum).
struct TypeDef {
    name: String,
    type_params: [TyVarId],
    kind: TypeDefKind,
}

enum TypeDefKind {
    Struct { fields: [StructFieldDef] },
    Enum { variants: [EnumVariantDef] },
}

struct StructFieldDef {
    name: String,
    ty: Type,
}

struct EnumVariantDef {
    name: String,
    payload: Option<Type>,
}

/// A function definition.
struct FnDef {
    name: String,
    type_params: [TyVarId],
    params: [Type],
    ret: Type,
    effect: Option<EffectRow>,
}

/// An effect definition.
struct EffectDef {
    name: String,
    type_params: [TyVarId],
    operations: [EffectOpDef],
}

struct EffectOpDef {
    name: String,
    params: [Type],
    ret: Type,
}

/// A trait definition.
struct TraitDef {
    name: String,
    def_id: DefId,
    type_params: [TyVarId],
    supertraits: [DefId],
    methods: [TraitMethodDef],
    assoc_types: [TraitAssocTypeDef],
}

/// A method signature in a trait.
struct TraitMethodDef {
    name: String,
    type_params: [TyVarId],
    params: [Type],    // First param is Self if method
    ret: Type,
    has_default: bool,
}

/// An associated type in a trait.
struct TraitAssocTypeDef {
    name: String,
    bounds: [DefId], // Trait bounds on the associated type
}

/// An implementation of a trait for a type.
struct ImplDef {
    def_id: DefId,
    trait_id: Option<DefId>,  // None for inherent impls
    self_type: Type,
    type_params: [TyVarId],
    methods: HashMap<String, ImplMethodDef>,
    assoc_types: HashMap<String, Type>,
}

/// A method implementation.
struct ImplMethodDef {
    name: String,
    type_params: [TyVarId],
    params: [Type],
    ret: Type,
}

/// Trait bounds on a type parameter.
struct TraitBound {
    trait_id: DefId,
    args: [Type],
}

// ============================================================
// Trait Resolution
// ============================================================

/// Resolves trait implementations and method lookup.
struct TraitResolver {
    /// All trait definitions
    trait_defs: HashMap<u32, TraitDef>,
    /// All implementations
    impl_defs: [ImplDef],
    /// Cache of resolved implementations
    impl_cache: HashMap<(u32, u32), Option<DefId>>, // (trait_id, type_hash) -> impl_id
}

impl TraitResolver {
    fn new() -> TraitResolver {
        TraitResolver {
            trait_defs: HashMap::new(),
            impl_defs: vec![],
            impl_cache: HashMap::new(),
        }
    }

    /// Register a trait definition.
    fn register_trait(&mut self, trait_def: TraitDef) {
        self.trait_defs.insert(trait_def.def_id.id, trait_def);
    }

    /// Register an implementation.
    fn register_impl(&mut self, impl_def: ImplDef) {
        self.impl_defs.push(impl_def);
    }

    /// Find an implementation of a trait for a type.
    fn find_impl(&self, trait_id: DefId, ty: &Type, unifier: &Unifier) -> Option<ImplDef> {
        let mut i: usize = 0;
        while i < self.impl_defs.len() {
            let impl_def = &self.impl_defs[i];

            // Check if this impl is for the right trait
            match &impl_def.trait_id {
                Some(tid) => {
                    if tid.id != trait_id.id {
                        i = i + 1;
                        continue;
                    }
                }
                None => {
                    i = i + 1;
                    continue;
                }
            }

            // Check if the type matches
            if self.type_matches(&impl_def.self_type, ty, unifier) {
                return Some(impl_def.clone());
            }

            i = i + 1;
        }
        None
    }

    /// Find an inherent impl for a type (non-trait impl).
    fn find_inherent_impl(&self, ty: &Type, unifier: &Unifier) -> Option<ImplDef> {
        let mut i: usize = 0;
        while i < self.impl_defs.len() {
            let impl_def = &self.impl_defs[i];

            // Skip trait impls
            match &impl_def.trait_id {
                Some(_) => {
                    i = i + 1;
                    continue;
                }
                None => {}
            }

            // Check if the type matches
            if self.type_matches(&impl_def.self_type, ty, unifier) {
                return Some(impl_def.clone());
            }

            i = i + 1;
        }
        None
    }

    /// Check if an impl type matches a concrete type.
    fn type_matches(&self, impl_ty: &Type, concrete_ty: &Type, unifier: &Unifier) -> bool {
        let resolved_impl = unifier.resolve(impl_ty);
        let resolved_concrete = unifier.resolve(concrete_ty);

        match (&resolved_impl.kind, &resolved_concrete.kind) {
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                self.primitives_equal(p1, p2)
            }
            (TypeKind::Adt { def_id: d1, args: a1 }, TypeKind::Adt { def_id: d2, args: a2 }) => {
                if d1.id != d2.id {
                    return false;
                }
                if a1.len() != a2.len() {
                    return false;
                }
                let mut i: usize = 0;
                while i < a1.len() {
                    if !self.type_matches(&a1[i], &a2[i], unifier) {
                        return false;
                    }
                    i = i + 1;
                }
                true
            }
            (TypeKind::Tuple(t1), TypeKind::Tuple(t2)) => {
                if t1.len() != t2.len() {
                    return false;
                }
                let mut i: usize = 0;
                while i < t1.len() {
                    if !self.type_matches(&t1[i], &t2[i], unifier) {
                        return false;
                    }
                    i = i + 1;
                }
                true
            }
            (TypeKind::Ref { inner: i1, mutable: m1 }, TypeKind::Ref { inner: i2, mutable: m2 }) => {
                m1 == m2 && self.type_matches(i1, i2, unifier)
            }
            (TypeKind::Param(_), _) => {
                // Type parameter in impl - matches any type
                true
            }
            _ => false,
        }
    }

    fn primitives_equal(&self, p1: &PrimitiveTy, p2: &PrimitiveTy) -> bool {
        match (p1, p2) {
            (PrimitiveTy::I8, PrimitiveTy::I8) => true,
            (PrimitiveTy::I16, PrimitiveTy::I16) => true,
            (PrimitiveTy::I32, PrimitiveTy::I32) => true,
            (PrimitiveTy::I64, PrimitiveTy::I64) => true,
            (PrimitiveTy::I128, PrimitiveTy::I128) => true,
            (PrimitiveTy::Isize, PrimitiveTy::Isize) => true,
            (PrimitiveTy::U8, PrimitiveTy::U8) => true,
            (PrimitiveTy::U16, PrimitiveTy::U16) => true,
            (PrimitiveTy::U32, PrimitiveTy::U32) => true,
            (PrimitiveTy::U64, PrimitiveTy::U64) => true,
            (PrimitiveTy::U128, PrimitiveTy::U128) => true,
            (PrimitiveTy::Usize, PrimitiveTy::Usize) => true,
            (PrimitiveTy::F32, PrimitiveTy::F32) => true,
            (PrimitiveTy::F64, PrimitiveTy::F64) => true,
            (PrimitiveTy::Bool, PrimitiveTy::Bool) => true,
            (PrimitiveTy::Char, PrimitiveTy::Char) => true,
            (PrimitiveTy::String, PrimitiveTy::String) => true,
            (PrimitiveTy::Unit, PrimitiveTy::Unit) => true,
            _ => false,
        }
    }

    /// Look up a method on a type.
    fn lookup_method(&self, ty: &Type, method_name: &str, unifier: &Unifier) -> Option<(ImplDef, ImplMethodDef)> {
        // First, check inherent impls
        match self.find_inherent_impl(ty, unifier) {
            Some(impl_def) => {
                match impl_def.methods.get(method_name) {
                    Some(method) => return Some((impl_def.clone(), method.clone())),
                    None => {}
                }
            }
            None => {}
        }

        // Then, check trait impls
        let mut i: usize = 0;
        while i < self.impl_defs.len() {
            let impl_def = &self.impl_defs[i];
            if self.type_matches(&impl_def.self_type, ty, unifier) {
                match impl_def.methods.get(method_name) {
                    Some(method) => return Some((impl_def.clone(), method.clone())),
                    None => {}
                }
            }
            i = i + 1;
        }

        None
    }

    /// Check if a type satisfies a trait bound.
    fn satisfies_bound(&self, ty: &Type, bound: &TraitBound, unifier: &Unifier) -> bool {
        match self.find_impl(bound.trait_id.clone(), ty, unifier) {
            Some(_) => true,
            None => false,
        }
    }

    /// Check all trait bounds on a type.
    fn check_bounds(&self, ty: &Type, bounds: &[TraitBound], unifier: &Unifier) -> [DefId] {
        let mut unsatisfied: [DefId] = vec![];
        let mut i: usize = 0;
        while i < bounds.len() {
            if !self.satisfies_bound(ty, &bounds[i], unifier) {
                unsatisfied.push(bounds[i].trait_id.clone());
            }
            i = i + 1;
        }
        unsatisfied
    }
}

impl TypeContext {
    /// Create a new type context.
    fn new() -> TypeContext {
        TypeContext {
            unifier: Unifier::new(),
            scope: Scope::new(),
            type_defs: HashMap::new(),
            fn_defs: HashMap::new(),
            effect_defs: HashMap::new(),
            trait_resolver: TraitResolver::new(),
            next_def_id: 0,
            errors: vec![],
            current_return_type: None,
            current_loop_type: None,
            current_effect_context: EffectContext::new(),
            handled_effects: vec![],
        }
    }

    /// Allocate a new definition ID.
    fn fresh_def_id(&mut self) -> DefId {
        let id = DefId::new(self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Create a fresh type variable.
    fn fresh_var(&mut self) -> Type {
        self.unifier.fresh_var()
    }

    /// Record an error.
    fn error(&mut self, err: TypeError) {
        self.errors.push(err);
    }

    /// Check if there are any errors.
    fn has_errors(&self) -> bool {
        self.errors.len() > 0
    }

    // ----- Type Collection -----

    /// Collect all declarations from a program.
    fn collect_declarations(&mut self, program: &Program) {
        let mut i: usize = 0;
        while i < program.declarations.len() {
            self.collect_declaration(&program.declarations[i]);
            i = i + 1;
        }
    }

    /// Collect a single declaration.
    fn collect_declaration(&mut self, decl: &Declaration) {
        match decl {
            Declaration::Function(fn_decl) => self.collect_function(fn_decl),
            Declaration::Struct(struct_decl) => self.collect_struct(struct_decl),
            Declaration::Enum(enum_decl) => self.collect_enum(enum_decl),
            Declaration::Effect(effect_decl) => self.collect_effect(effect_decl),
            Declaration::Trait(trait_decl) => self.collect_trait(trait_decl),
            _ => {
                // TODO: handle other declarations
            }
        }
    }

    /// Collect a function declaration.
    fn collect_function(&mut self, fn_decl: &FnDecl) {
        let def_id = self.fresh_def_id();
        let name = fn_decl.name.value.clone();

        // Collect type parameters
        let type_params = self.collect_type_params(&fn_decl.type_params);

        // Collect parameter types
        let mut params: [Type] = vec![];
        let mut i: usize = 0;
        while i < fn_decl.params.len() {
            params.push(self.lower_type(&fn_decl.params[i].ty));
            i = i + 1;
        }

        // Collect return type
        let ret = match &fn_decl.return_type {
            Some(ty) => self.lower_type(ty),
            None => Type::unit(),
        };

        // Collect effect row
        let effect = match &fn_decl.effects {
            Some(row) => Some(self.lower_effect_row(row)),
            None => None,
        };

        // Store the function definition
        self.fn_defs.insert(def_id.id, FnDef {
            name: name.clone(),
            type_params,
            params,
            ret,
            effect,
        });

        // Add to scope
        let fn_type = self.make_fn_type(&self.fn_defs.get(&def_id.id).unwrap());
        self.scope.define_var(name, fn_type);
    }

    /// Collect type parameters from a declaration.
    fn collect_type_params(&mut self, type_params: &Option<TypeParams>) -> [TyVarId] {
        match type_params {
            Some(params) => {
                let mut ids: [TyVarId] = vec![];
                let mut i: usize = 0;
                while i < params.params.len() {
                    let id = self.unifier.fresh_forall_var();
                    ids.push(id);
                    i = i + 1;
                }
                ids
            }
            None => vec![],
        }
    }

    /// Make a function type from a function definition.
    fn make_fn_type(&self, fn_def: &FnDef) -> Type {
        Type::new(TypeKind::Fn {
            params: fn_def.params.clone(),
            ret: fn_def.ret.clone(),
            effect: fn_def.effect.clone(),
        })
    }

    /// Collect a struct declaration.
    fn collect_struct(&mut self, struct_decl: &StructDecl) {
        let def_id = self.fresh_def_id();
        let name = struct_decl.name.value.clone();
        let type_params = self.collect_type_params(&struct_decl.type_params);

        // Collect fields
        let fields = match &struct_decl.body {
            StructBody::Record(field_list) => {
                let mut fields: [StructFieldDef] = vec![];
                let mut i: usize = 0;
                while i < field_list.len() {
                    fields.push(StructFieldDef {
                        name: field_list[i].name.value.clone(),
                        ty: self.lower_type(&field_list[i].ty),
                    });
                    i = i + 1;
                }
                fields
            }
            StructBody::Tuple(types) => {
                let mut fields: [StructFieldDef] = vec![];
                let mut i: usize = 0;
                while i < types.len() {
                    fields.push(StructFieldDef {
                        name: i.to_string(),
                        ty: self.lower_type(&types[i]),
                    });
                    i = i + 1;
                }
                fields
            }
            StructBody::Unit => vec![],
        };

        // Store the type definition
        self.type_defs.insert(def_id.id, TypeDef {
            name: name.clone(),
            type_params,
            kind: TypeDefKind::Struct { fields },
        });

        // Add to scope
        self.scope.define_type(name, def_id);
    }

    /// Collect an enum declaration.
    fn collect_enum(&mut self, enum_decl: &EnumDecl) {
        let def_id = self.fresh_def_id();
        let name = enum_decl.name.value.clone();
        let type_params = self.collect_type_params(&enum_decl.type_params);

        // Collect variants
        let mut variants: [EnumVariantDef] = vec![];
        let mut i: usize = 0;
        while i < enum_decl.variants.len() {
            let variant = &enum_decl.variants[i];
            variants.push(EnumVariantDef {
                name: variant.name.value.clone(),
                payload: match &variant.payload {
                    Some(ty) => Some(self.lower_type(ty)),
                    None => None,
                },
            });
            i = i + 1;
        }

        // Store the type definition
        self.type_defs.insert(def_id.id, TypeDef {
            name: name.clone(),
            type_params,
            kind: TypeDefKind::Enum { variants },
        });

        // Add to scope
        self.scope.define_type(name, def_id);
    }

    /// Collect an effect declaration.
    fn collect_effect(&mut self, effect_decl: &EffectDecl) {
        let def_id = self.fresh_def_id();
        let name = effect_decl.name.value.clone();
        let type_params = self.collect_type_params(&effect_decl.type_params);

        // Collect operations
        let mut operations: [EffectOpDef] = vec![];
        let mut i: usize = 0;
        while i < effect_decl.operations.len() {
            let op = &effect_decl.operations[i];
            let mut params: [Type] = vec![];
            let mut j: usize = 0;
            while j < op.params.len() {
                params.push(self.lower_type(&op.params[j].ty));
                j = j + 1;
            }
            operations.push(EffectOpDef {
                name: op.name.value.clone(),
                params,
                ret: match &op.return_type {
                    Some(ty) => self.lower_type(ty),
                    None => Type::unit(),
                },
            });
            i = i + 1;
        }

        // Store the effect definition
        self.effect_defs.insert(def_id.id, EffectDef {
            name: name.clone(),
            type_params,
            operations,
        });

        // Add to scope
        self.scope.define_type(name, def_id);
    }

    /// Collect a trait declaration.
    fn collect_trait(&mut self, trait_decl: &TraitDecl) {
        // TODO: implement trait collection
    }

    // ----- Type Lowering -----

    /// Lower an AST type to a semantic type.
    fn lower_type(&mut self, ast_ty: &AstType) -> Type {
        match &ast_ty.kind {
            AstTypeKind::Named { path, args } => {
                let name = &path.segments[0].value;

                // Check for primitive types
                if let Some(prim) = self.lookup_primitive(name) {
                    return Type::new(TypeKind::Primitive(prim));
                }

                // Look up user-defined type
                match self.scope.lookup_type(name) {
                    Some(def_id) => {
                        let type_args = match args {
                            Some(arg_list) => {
                                let mut args: [Type] = vec![];
                                let mut i: usize = 0;
                                while i < arg_list.len() {
                                    args.push(self.lower_type(&arg_list[i]));
                                    i = i + 1;
                                }
                                args
                            }
                            None => vec![],
                        };
                        Type::new(TypeKind::Adt { def_id, args: type_args })
                    }
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::UnresolvedType { name: name.clone() },
                            ast_ty.span,
                        ));
                        Type::error()
                    }
                }
            }
            AstTypeKind::Tuple(types) => {
                let mut tys: [Type] = vec![];
                let mut i: usize = 0;
                while i < types.len() {
                    tys.push(self.lower_type(&types[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Tuple(tys))
            }
            AstTypeKind::Array { element, size } => {
                Type::new(TypeKind::Array {
                    element: self.lower_type(element),
                    size: *size,
                })
            }
            AstTypeKind::Slice { element } => {
                Type::new(TypeKind::Slice {
                    element: self.lower_type(element),
                })
            }
            AstTypeKind::Reference { inner, mutable } => {
                Type::new(TypeKind::Ref {
                    inner: self.lower_type(inner),
                    mutable: *mutable,
                })
            }
            AstTypeKind::Pointer { inner, mutable } => {
                Type::new(TypeKind::Ptr {
                    inner: self.lower_type(inner),
                    mutable: *mutable,
                })
            }
            AstTypeKind::Function { params, ret, effects } => {
                let mut param_tys: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    param_tys.push(self.lower_type(&params[i]));
                    i = i + 1;
                }
                let ret_ty = match ret {
                    Some(ty) => self.lower_type(ty),
                    None => Type::unit(),
                };
                let effect = match effects {
                    Some(row) => Some(self.lower_effect_row(row)),
                    None => None,
                };
                Type::new(TypeKind::Fn {
                    params: param_tys,
                    ret: ret_ty,
                    effect,
                })
            }
            AstTypeKind::Never => Type::never(),
            AstTypeKind::Infer => self.fresh_var(),
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Unsupported type syntax".to_string() },
                    ast_ty.span,
                ));
                Type::error()
            }
        }
    }

    /// Look up a primitive type by name.
    fn lookup_primitive(&self, name: &str) -> Option<PrimitiveTy> {
        match name {
            "i8" => Some(PrimitiveTy::I8),
            "i16" => Some(PrimitiveTy::I16),
            "i32" => Some(PrimitiveTy::I32),
            "i64" => Some(PrimitiveTy::I64),
            "i128" => Some(PrimitiveTy::I128),
            "isize" => Some(PrimitiveTy::Isize),
            "u8" => Some(PrimitiveTy::U8),
            "u16" => Some(PrimitiveTy::U16),
            "u32" => Some(PrimitiveTy::U32),
            "u64" => Some(PrimitiveTy::U64),
            "u128" => Some(PrimitiveTy::U128),
            "usize" => Some(PrimitiveTy::Usize),
            "f32" => Some(PrimitiveTy::F32),
            "f64" => Some(PrimitiveTy::F64),
            "bool" => Some(PrimitiveTy::Bool),
            "char" => Some(PrimitiveTy::Char),
            "String" => Some(PrimitiveTy::String),
            _ => None,
        }
    }

    /// Lower an effect row from AST.
    fn lower_effect_row(&mut self, row: &AstEffectRow) -> EffectRow {
        let mut effects: [EffectInstance] = vec![];
        let mut i: usize = 0;
        while i < row.effects.len() {
            let effect: &AstEffectRef = &row.effects[i];
            match self.scope.lookup_type(&effect.name.value) {
                Some(def_id) => {
                    let mut args: [Type] = vec![];
                    match &effect.args {
                        Some(arg_list) => {
                            let mut j: usize = 0;
                            while j < arg_list.len() {
                                args.push(self.lower_type(&arg_list[j]));
                                j = j + 1;
                            }
                        }
                        None => {}
                    }
                    effects.push(EffectInstance { def_id, args });
                }
                None => {
                    self.error(TypeError::new(
                        TypeErrorKind::UnresolvedType { name: effect.name.value.clone() },
                        effect.span,
                    ));
                }
            }
            i = i + 1;
        }

        let row_var = match &row.row_var {
            Some(_) => Some(self.unifier.fresh_effect_row_var()),
            None => None,
        };

        EffectRow::new(effects, row_var)
    }

    // ----- Expression Type Checking -----

    /// Infer the type of an expression.
    fn infer_expr(&mut self, expr: &Expr) -> Type {
        match &expr.kind {
            ExprKind::Literal(lit) => self.infer_literal(lit),
            ExprKind::Variable(name) => {
                match self.scope.lookup_var(&name.value) {
                    Some(ty) => ty,
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::UnresolvedName { name: name.value.clone() },
                            expr.span,
                        ));
                        Type::error()
                    }
                }
            }
            ExprKind::Binary { op, left, right } => {
                let left_ty = self.infer_expr(left);
                let right_ty = self.infer_expr(right);
                self.check_binary_op(op, &left_ty, &right_ty, expr.span)
            }
            ExprKind::Unary { op, operand } => {
                let operand_ty = self.infer_expr(operand);
                self.check_unary_op(op, &operand_ty, expr.span)
            }
            ExprKind::Call { callee, args } => {
                let callee_ty = self.infer_expr(callee);
                self.check_call(&callee_ty, args, expr.span)
            }
            ExprKind::If { condition, then_branch, else_branch } => {
                let cond_ty = self.infer_expr(condition);
                self.unifier.unify(&cond_ty, &Type::bool_type(), condition.span);

                let then_ty = self.check_block(then_branch);
                match else_branch {
                    Some(else_block) => {
                        let else_ty = self.check_block(else_block);
                        self.unifier.unify(&then_ty, &else_ty, expr.span);
                        then_ty
                    }
                    None => {
                        self.unifier.unify(&then_ty, &Type::unit(), expr.span);
                        Type::unit()
                    }
                }
            }
            ExprKind::Block(block) => self.check_block(block),

            ExprKind::Match { scrutinee, arms } => {
                let scrutinee_ty = self.infer_expr(scrutinee);

                // All arms must produce the same type
                let result_ty = self.fresh_var();
                let mut i: usize = 0;
                while i < arms.len() {
                    let arm = &arms[i];

                    // Check pattern against scrutinee type
                    self.check_pattern(&arm.pattern, &scrutinee_ty);

                    // Create child scope for pattern bindings
                    let old_scope = self.scope.clone();
                    self.scope = self.scope.child();
                    self.bind_pattern(&arm.pattern, &scrutinee_ty);

                    // Check guard if present
                    match &arm.guard {
                        Some(guard_expr) => {
                            let guard_ty = self.infer_expr(guard_expr);
                            match self.unifier.unify(&guard_ty, &Type::bool_type(), guard_expr.span) {
                                Ok(()) => {}
                                Err(e) => self.error(e),
                            }
                        }
                        None => {}
                    }

                    // Check arm body
                    let arm_ty = self.infer_expr(&arm.body);
                    match self.unifier.unify(&result_ty, &arm_ty, arm.body.span) {
                        Ok(()) => {}
                        Err(e) => self.error(e),
                    }

                    // Restore scope
                    self.scope = old_scope;
                    i = i + 1;
                }

                // Check pattern exhaustiveness
                let mut patterns: [Pattern] = vec![];
                i = 0;
                while i < arms.len() {
                    patterns.push(arms[i].pattern.clone());
                    i = i + 1;
                }
                self.check_match_exhaustiveness(&patterns, &scrutinee_ty, expr.span);

                result_ty
            }

            ExprKind::While { condition, body } => {
                let cond_ty = self.infer_expr(condition);
                match self.unifier.unify(&cond_ty, &Type::bool_type(), condition.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                self.check_block(body);
                Type::unit()
            }

            ExprKind::Loop { body } => {
                // loop { } has type ! unless there's a break with a value
                self.check_block(body);
                // For now, return unit - proper break analysis needed
                Type::unit()
            }

            ExprKind::For { pattern, iterable, body } => {
                let iter_ty = self.infer_expr(iterable);

                // Get the element type from the iterator
                let elem_ty = self.extract_iterator_element(&iter_ty, iterable.span);

                // Create child scope for loop variable
                let old_scope = self.scope.clone();
                self.scope = self.scope.child();
                self.bind_pattern(pattern, &elem_ty);

                self.check_block(body);

                // Restore scope
                self.scope = old_scope;
                Type::unit()
            }

            ExprKind::FieldAccess { object, field } => {
                let obj_ty = self.infer_expr(object);
                self.check_field_access(&obj_ty, &field.value, expr.span)
            }

            ExprKind::MethodCall { object, method, args } => {
                let obj_ty = self.infer_expr(object);
                self.check_method_call(&obj_ty, &method.value, args, expr.span)
            }

            ExprKind::Index { object, index } => {
                let obj_ty = self.infer_expr(object);
                let idx_ty = self.infer_expr(index);
                self.check_index(&obj_ty, &idx_ty, expr.span)
            }

            ExprKind::Range { start, end, inclusive } => {
                let start_ty = match start {
                    Some(s) => self.infer_expr(s),
                    None => self.fresh_var(),
                };
                let end_ty = match end {
                    Some(e) => self.infer_expr(e),
                    None => start_ty.clone(),
                };

                // Start and end must have the same type
                match self.unifier.unify(&start_ty, &end_ty, expr.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }

                Type::new(TypeKind::Range { element: start_ty, inclusive: *inclusive })
            }

            ExprKind::Struct { name, fields } => {
                self.check_struct_construction(name, fields, expr.span)
            }

            ExprKind::Tuple(elements) => {
                let mut tys: [Type] = vec![];
                let mut i: usize = 0;
                while i < elements.len() {
                    tys.push(self.infer_expr(&elements[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Tuple(tys))
            }

            ExprKind::Array(elements) => {
                if elements.len() == 0 {
                    // Empty array - need type annotation
                    let elem_ty = self.fresh_var();
                    Type::new(TypeKind::Array { element: elem_ty, size: 0 })
                } else {
                    let first_ty = self.infer_expr(&elements[0]);
                    let mut i: usize = 1;
                    while i < elements.len() {
                        let elem_ty = self.infer_expr(&elements[i]);
                        match self.unifier.unify(&first_ty, &elem_ty, elements[i].span) {
                            Ok(()) => {}
                            Err(e) => self.error(e),
                        }
                        i = i + 1;
                    }
                    Type::new(TypeKind::Array { element: first_ty, size: elements.len() as u64 })
                }
            }

            ExprKind::Return { value } => {
                // TODO: check against enclosing function's return type
                match value {
                    Some(v) => { self.infer_expr(v); }
                    None => {}
                }
                Type::never()
            }

            ExprKind::Break { value } => {
                // TODO: check against enclosing loop's expected type
                match value {
                    Some(v) => { self.infer_expr(v); }
                    None => {}
                }
                Type::never()
            }

            ExprKind::Continue => Type::never(),

            ExprKind::Assign { target, value } => {
                let target_ty = self.infer_expr(target);
                let value_ty = self.infer_expr(value);
                match self.unifier.unify(&target_ty, &value_ty, expr.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                Type::unit()
            }

            ExprKind::Reference { mutable, operand } => {
                let inner_ty = self.infer_expr(operand);
                Type::new(TypeKind::Ref { inner: inner_ty, mutable: *mutable })
            }

            ExprKind::Dereference(operand) => {
                let operand_ty = self.infer_expr(operand);
                match &self.unifier.resolve(&operand_ty).kind {
                    TypeKind::Ref { inner, mutable: _ } => inner.clone(),
                    TypeKind::Ptr { inner, mutable: _ } => inner.clone(),
                    TypeKind::Infer(_) => {
                        // Create fresh var for inner type
                        let inner = self.fresh_var();
                        let ref_ty = Type::new(TypeKind::Ref { inner: inner.clone(), mutable: false });
                        match self.unifier.unify(&operand_ty, &ref_ty, expr.span) {
                            Ok(()) => {}
                            Err(e) => self.error(e),
                        }
                        inner
                    }
                    _ => {
                        self.error(TypeError::new(
                            TypeErrorKind::Other { message: "Cannot dereference non-reference type".to_string() },
                            expr.span,
                        ));
                        Type::error()
                    }
                }
            }

            ExprKind::Cast { expr: inner, ty } => {
                let _inner_ty = self.infer_expr(inner);
                let target_ty = self.lower_type(ty);
                // TODO: validate cast is legal
                target_ty
            }

            ExprKind::Handle { expr: inner, handlers } => {
                self.check_effect_handle(inner, handlers, expr.span)
            }

            ExprKind::Perform { effect, operation, args } => {
                self.check_effect_perform(&effect.value, &operation.value, args, expr.span)
            }

            ExprKind::Path(path) => {
                // Could be an enum variant or module path
                self.resolve_path(path, expr.span)
            }

            ExprKind::Closure { params, return_type, body, effects } => {
                // Create a child scope for the closure
                let old_scope = self.scope.clone();
                self.scope = self.scope.child();

                // Add parameters to scope
                let mut param_tys: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    let param_ty = self.lower_type(&params[i].ty);
                    self.scope.define_var(params[i].pattern.name.value.clone(), param_ty.clone());
                    param_tys.push(param_ty);
                    i = i + 1;
                }

                // Infer body type
                let body_ty = self.infer_expr(body);

                // Check return type if specified
                match return_type {
                    Some(ret_ty) => {
                        let expected = self.lower_type(ret_ty);
                        self.unifier.unify(&body_ty, &expected, expr.span);
                    }
                    None => {}
                }

                // Restore scope
                self.scope = old_scope;

                // Build closure type
                let effect = match effects {
                    Some(row) => Some(self.lower_effect_row(row)),
                    None => None,
                };

                Type::new(TypeKind::Fn {
                    params: param_tys,
                    ret: body_ty,
                    effect,
                })
            }
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Unsupported expression".to_string() },
                    expr.span,
                ));
                Type::error()
            }
        }
    }

    /// Infer the type of a literal.
    fn infer_literal(&mut self, lit: &Literal) -> Type {
        match lit {
            Literal::Int(_) => Type::i32_type(), // Default to i32
            Literal::Float(_) => Type::new(TypeKind::Primitive(PrimitiveTy::F64)), // Default to f64
            Literal::Bool(_) => Type::bool_type(),
            Literal::Char(_) => Type::new(TypeKind::Primitive(PrimitiveTy::Char)),
            Literal::String(_) => Type::string_type(),
        }
    }

    /// Check a binary operation.
    fn check_binary_op(&mut self, op: &BinOp, left: &Type, right: &Type, span: Span) -> Type {
        // For now, just unify the operands and return the left type
        // A full implementation would check operator overloading
        self.unifier.unify(left, right, span);
        left.clone()
    }

    /// Check a unary operation.
    fn check_unary_op(&mut self, op: &UnOp, operand: &Type, span: Span) -> Type {
        operand.clone()
    }

    /// Check a function call.
    fn check_call(&mut self, callee: &Type, args: &[Expr], span: Span) -> Type {
        match &callee.kind {
            TypeKind::Fn { params, ret, effect: _ } => {
                if params.len() != args.len() {
                    self.error(TypeError::new(
                        TypeErrorKind::WrongArity {
                            expected: params.len() as u32,
                            found: args.len() as u32,
                        },
                        span,
                    ));
                    return Type::error();
                }

                let mut i: usize = 0;
                while i < args.len() {
                    let arg_ty = self.infer_expr(&args[i]);
                    self.unifier.unify(&params[i], &arg_ty, args[i].span);
                    i = i + 1;
                }

                ret.clone()
            }
            TypeKind::Infer(_) => {
                // Create fresh variables for params and return
                let mut param_tys: [Type] = vec![];
                let mut i: usize = 0;
                while i < args.len() {
                    param_tys.push(self.fresh_var());
                    i = i + 1;
                }
                let ret_ty = self.fresh_var();

                // Unify callee with function type
                let fn_ty = Type::new(TypeKind::Fn {
                    params: param_tys.clone(),
                    ret: ret_ty.clone(),
                    effect: None,
                });
                self.unifier.unify(callee, &fn_ty, span);

                // Check arguments
                i = 0;
                while i < args.len() {
                    let arg_ty = self.infer_expr(&args[i]);
                    self.unifier.unify(&param_tys[i], &arg_ty, args[i].span);
                    i = i + 1;
                }

                ret_ty
            }
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Cannot call non-function".to_string() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Check a block and return its type.
    fn check_block(&mut self, block: &Block) -> Type {
        // Create child scope
        let old_scope = self.scope.clone();
        self.scope = self.scope.child();

        // Check statements
        let mut i: usize = 0;
        while i < block.statements.len() {
            self.check_statement(&block.statements[i]);
            i = i + 1;
        }

        // Get type of final expression
        let result_ty = match &block.result {
            Some(expr) => self.infer_expr(expr),
            None => Type::unit(),
        };

        // Restore scope
        self.scope = old_scope;

        result_ty
    }

    /// Check a statement.
    fn check_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Let { pattern, ty, value, span } => {
                let expected_ty = match ty {
                    Some(t) => self.lower_type(t),
                    None => self.fresh_var(),
                };

                match value {
                    Some(expr) => {
                        let value_ty = self.infer_expr(expr);
                        self.unifier.unify(&expected_ty, &value_ty, *span);
                    }
                    None => {}
                }

                // Bind pattern
                self.bind_pattern(pattern, &expected_ty);
            }
            Statement::Expr(expr) => {
                self.infer_expr(expr);
            }
            _ => {
                // TODO: handle other statements
            }
        }
    }

    /// Bind a pattern to a type, adding variables to scope.
    fn bind_pattern(&mut self, pattern: &Pattern, ty: &Type) {
        match &pattern.kind {
            PatternKind::Identifier(name) => {
                self.scope.define_var(name.value.clone(), ty.clone());
            }
            PatternKind::Wildcard => {
                // Nothing to bind
            }
            PatternKind::Tuple(patterns) => {
                match &ty.kind {
                    TypeKind::Tuple(tys) => {
                        if patterns.len() != tys.len() {
                            self.error(TypeError::new(
                                TypeErrorKind::PatternMismatch {
                                    expected: ty.clone(),
                                    found: Type::error(),
                                },
                                pattern.span,
                            ));
                            return;
                        }
                        let mut i: usize = 0;
                        while i < patterns.len() {
                            self.bind_pattern(&patterns[i], &tys[i]);
                            i = i + 1;
                        }
                    }
                    _ => {
                        self.error(TypeError::new(
                            TypeErrorKind::PatternMismatch {
                                expected: ty.clone(),
                                found: Type::error(),
                            },
                            pattern.span,
                        ));
                    }
                }
            }
            PatternKind::Struct { name, fields } => {
                // Check struct pattern against type
                match &ty.kind {
                    TypeKind::Adt { def_id, args: _ } => {
                        match self.type_defs.get(&def_id.id) {
                            Some(type_def) => {
                                match &type_def.kind {
                                    TypeDefKind::Struct { fields: struct_fields } => {
                                        // Bind each field pattern
                                        let mut i: usize = 0;
                                        while i < fields.len() {
                                            let field_pat = &fields[i];
                                            // Find matching struct field
                                            let field_ty = self.find_struct_field(&struct_fields, &field_pat.name.value);
                                            match field_ty {
                                                Some(fty) => {
                                                    self.bind_pattern(&field_pat.pattern, &fty);
                                                }
                                                None => {
                                                    self.error(TypeError::new(
                                                        TypeErrorKind::UnknownField {
                                                            struct_name: type_def.name.clone(),
                                                            field: field_pat.name.value.clone(),
                                                        },
                                                        pattern.span,
                                                    ));
                                                }
                                            }
                                            i = i + 1;
                                        }
                                    }
                                    TypeDefKind::Enum { variants: _ } => {
                                        self.error(TypeError::new(
                                            TypeErrorKind::PatternMismatch {
                                                expected: ty.clone(),
                                                found: Type::error(),
                                            },
                                            pattern.span,
                                        ));
                                    }
                                }
                            }
                            None => {
                                self.error(TypeError::new(
                                    TypeErrorKind::UnresolvedType { name: name.segments[0].value.clone() },
                                    pattern.span,
                                ));
                            }
                        }
                    }
                    _ => {
                        self.error(TypeError::new(
                            TypeErrorKind::PatternMismatch {
                                expected: ty.clone(),
                                found: Type::error(),
                            },
                            pattern.span,
                        ));
                    }
                }
            }

            PatternKind::Enum { name, variant, payload } => {
                // Check enum variant pattern against type
                match &ty.kind {
                    TypeKind::Adt { def_id, args: _ } => {
                        match self.type_defs.get(&def_id.id) {
                            Some(type_def) => {
                                match &type_def.kind {
                                    TypeDefKind::Enum { variants } => {
                                        let variant_def = self.find_enum_variant(&variants, &variant.value);
                                        match variant_def {
                                            Some(vdef) => {
                                                match payload {
                                                    Some(payload_pat) => {
                                                        match &vdef.payload {
                                                            Some(payload_ty) => {
                                                                self.bind_pattern(payload_pat, payload_ty);
                                                            }
                                                            None => {
                                                                self.error(TypeError::new(
                                                                    TypeErrorKind::Other {
                                                                        message: "Variant has no payload".to_string()
                                                                    },
                                                                    pattern.span,
                                                                ));
                                                            }
                                                        }
                                                    }
                                                    None => {}
                                                }
                                            }
                                            None => {
                                                self.error(TypeError::new(
                                                    TypeErrorKind::Other {
                                                        message: format!("Unknown variant: {}", variant.value)
                                                    },
                                                    pattern.span,
                                                ));
                                            }
                                        }
                                    }
                                    TypeDefKind::Struct { fields: _ } => {
                                        self.error(TypeError::new(
                                            TypeErrorKind::PatternMismatch {
                                                expected: ty.clone(),
                                                found: Type::error(),
                                            },
                                            pattern.span,
                                        ));
                                    }
                                }
                            }
                            None => {
                                self.error(TypeError::new(
                                    TypeErrorKind::UnresolvedType { name: name.segments[0].value.clone() },
                                    pattern.span,
                                ));
                            }
                        }
                    }
                    _ => {
                        self.error(TypeError::new(
                            TypeErrorKind::PatternMismatch {
                                expected: ty.clone(),
                                found: Type::error(),
                            },
                            pattern.span,
                        ));
                    }
                }
            }

            PatternKind::Literal(lit) => {
                // Check literal pattern type matches scrutinee
                let lit_ty = self.infer_literal(lit);
                match self.unifier.unify(ty, &lit_ty, pattern.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
            }

            PatternKind::Or(patterns) => {
                // All alternatives must bind the same variables with same types
                let mut i: usize = 0;
                while i < patterns.len() {
                    self.bind_pattern(&patterns[i], ty);
                    i = i + 1;
                }
            }

            PatternKind::Range { start, end, inclusive: _ } => {
                // Range patterns for integer/char matching
                let start_ty = self.infer_literal(start);
                match self.unifier.unify(ty, &start_ty, pattern.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                match end {
                    Some(end_lit) => {
                        let end_ty = self.infer_literal(end_lit);
                        match self.unifier.unify(&start_ty, &end_ty, pattern.span) {
                            Ok(()) => {}
                            Err(e) => self.error(e),
                        }
                    }
                    None => {}
                }
            }

            PatternKind::Rest => {
                // Rest pattern (..) - used in slice/array patterns
                // Nothing to bind
            }
        }
    }

    /// Check a pattern against a type (without binding).
    fn check_pattern(&mut self, pattern: &Pattern, expected: &Type) {
        // For now, use bind_pattern logic but we may want to separate later
        // The key difference is check_pattern validates structure, bind_pattern adds to scope
    }

    /// Find a field in a struct by name.
    fn find_struct_field(&self, fields: &[StructFieldDef], name: &str) -> Option<Type> {
        let mut i: usize = 0;
        while i < fields.len() {
            if fields[i].name == name {
                return Some(fields[i].ty.clone());
            }
            i = i + 1;
        }
        None
    }

    /// Find a variant in an enum by name.
    fn find_enum_variant(&self, variants: &[EnumVariantDef], name: &str) -> Option<EnumVariantDef> {
        let mut i: usize = 0;
        while i < variants.len() {
            if variants[i].name == name {
                return Some(variants[i].clone());
            }
            i = i + 1;
        }
        None
    }

    /// Extract the element type from an iterator type.
    fn extract_iterator_element(&mut self, iter_ty: &Type, span: Span) -> Type {
        let resolved = self.unifier.resolve(iter_ty);
        match &resolved.kind {
            TypeKind::Range { element, inclusive: _ } => element.clone(),
            TypeKind::Array { element, size: _ } => element.clone(),
            TypeKind::Slice { element } => element.clone(),
            TypeKind::Adt { def_id, args } => {
                // Check if this is an Iterator type and get the Item type
                // For now, assume first type arg is the element
                if args.len() > 0 {
                    args[0].clone()
                } else {
                    self.fresh_var()
                }
            }
            TypeKind::Infer(_) => {
                // Can't determine element type yet
                self.fresh_var()
            }
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Type is not iterable".to_string() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Check field access on a type.
    fn check_field_access(&mut self, obj_ty: &Type, field: &str, span: Span) -> Type {
        let resolved = self.unifier.resolve(obj_ty);
        match &resolved.kind {
            TypeKind::Adt { def_id, args } => {
                match self.type_defs.get(&def_id.id) {
                    Some(type_def) => {
                        match &type_def.kind {
                            TypeDefKind::Struct { fields } => {
                                match self.find_struct_field(&fields, field) {
                                    Some(field_ty) => {
                                        // TODO: substitute type args
                                        field_ty
                                    }
                                    None => {
                                        self.error(TypeError::new(
                                            TypeErrorKind::UnknownField {
                                                struct_name: type_def.name.clone(),
                                                field: field.to_string(),
                                            },
                                            span,
                                        ));
                                        Type::error()
                                    }
                                }
                            }
                            TypeDefKind::Enum { variants: _ } => {
                                self.error(TypeError::new(
                                    TypeErrorKind::Other { message: "Cannot access field on enum".to_string() },
                                    span,
                                ));
                                Type::error()
                            }
                        }
                    }
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::Other { message: "Unknown type".to_string() },
                            span,
                        ));
                        Type::error()
                    }
                }
            }
            TypeKind::Tuple(tys) => {
                // Tuple field access by index (e.g., tuple.0)
                match field.parse::<usize>() {
                    Ok(idx) => {
                        if idx < tys.len() {
                            tys[idx].clone()
                        } else {
                            self.error(TypeError::new(
                                TypeErrorKind::Other {
                                    message: format!("Tuple index {} out of bounds", idx)
                                },
                                span,
                            ));
                            Type::error()
                        }
                    }
                    Err(_) => {
                        self.error(TypeError::new(
                            TypeErrorKind::Other { message: "Tuple fields must be numeric".to_string() },
                            span,
                        ));
                        Type::error()
                    }
                }
            }
            TypeKind::Ref { inner, mutable: _ } => {
                // Auto-deref
                self.check_field_access(inner, field, span)
            }
            TypeKind::Infer(_) => {
                // Can't resolve field access on inference variable yet
                self.fresh_var()
            }
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Cannot access field on this type".to_string() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Check method call on a type.
    fn check_method_call(&mut self, obj_ty: &Type, method: &str, args: &[Expr], span: Span) -> Type {
        let resolved = self.unifier.resolve(obj_ty);

        // Auto-deref through references
        let base_ty = match &resolved.kind {
            TypeKind::Ref { inner, mutable: _ } => inner.clone(),
            _ => resolved.clone(),
        };

        // Look up method using trait resolver
        match self.trait_resolver.lookup_method(&base_ty, method, &self.unifier) {
            Some((impl_def, method_def)) => {
                // Check argument count (method_def.params includes self)
                let expected_args = if method_def.params.len() > 0 {
                    method_def.params.len() - 1  // Exclude self
                } else {
                    0
                };

                if args.len() != expected_args {
                    self.error(TypeError::new(
                        TypeErrorKind::WrongArity {
                            expected: expected_args as u32,
                            found: args.len() as u32,
                        },
                        span,
                    ));
                    return Type::error();
                }

                // Check argument types
                let mut i: usize = 0;
                while i < args.len() {
                    let arg_ty = self.infer_expr(&args[i]);
                    // method_def.params[0] is self, so args map to params[1..]
                    if i + 1 < method_def.params.len() {
                        match self.unifier.unify(&method_def.params[i + 1], &arg_ty, args[i].span) {
                            Ok(()) => {}
                            Err(e) => self.error(e),
                        }
                    }
                    i = i + 1;
                }

                method_def.ret.clone()
            }
            None => {
                // Method not found - report error
                self.error(TypeError::new(
                    TypeErrorKind::Other {
                        message: format!("Method '{}' not found on type", method)
                    },
                    span,
                ));

                // Still check arguments for type errors
                let mut i: usize = 0;
                while i < args.len() {
                    self.infer_expr(&args[i]);
                    i = i + 1;
                }

                Type::error()
            }
        }
    }

    /// Check index operation.
    fn check_index(&mut self, obj_ty: &Type, idx_ty: &Type, span: Span) -> Type {
        let resolved = self.unifier.resolve(obj_ty);
        match &resolved.kind {
            TypeKind::Array { element, size: _ } => {
                // Index must be usize
                match self.unifier.unify(idx_ty, &Type::new(TypeKind::Primitive(PrimitiveTy::Usize)), span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                element.clone()
            }
            TypeKind::Slice { element } => {
                match self.unifier.unify(idx_ty, &Type::new(TypeKind::Primitive(PrimitiveTy::Usize)), span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                element.clone()
            }
            TypeKind::Ref { inner, mutable: _ } => {
                // Auto-deref
                self.check_index(inner, idx_ty, span)
            }
            TypeKind::Infer(_) => self.fresh_var(),
            _ => {
                self.error(TypeError::new(
                    TypeErrorKind::Other { message: "Type does not support indexing".to_string() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Check struct construction.
    fn check_struct_construction(&mut self, name: &Path, fields: &[FieldInit], span: Span) -> Type {
        let struct_name = &name.segments[0].value;

        match self.scope.lookup_type(struct_name) {
            Some(def_id) => {
                match self.type_defs.get(&def_id.id) {
                    Some(type_def) => {
                        match &type_def.kind {
                            TypeDefKind::Struct { fields: struct_fields } => {
                                // Check each field
                                let mut i: usize = 0;
                                while i < fields.len() {
                                    let field_init = &fields[i];
                                    match self.find_struct_field(&struct_fields, &field_init.name.value) {
                                        Some(expected_ty) => {
                                            let actual_ty = self.infer_expr(&field_init.value);
                                            match self.unifier.unify(&expected_ty, &actual_ty, field_init.value.span) {
                                                Ok(()) => {}
                                                Err(e) => self.error(e),
                                            }
                                        }
                                        None => {
                                            self.error(TypeError::new(
                                                TypeErrorKind::UnknownField {
                                                    struct_name: type_def.name.clone(),
                                                    field: field_init.name.value.clone(),
                                                },
                                                span,
                                            ));
                                        }
                                    }
                                    i = i + 1;
                                }

                                // TODO: check all required fields are provided

                                // Return the struct type
                                Type::new(TypeKind::Adt { def_id: def_id.clone(), args: vec![] })
                            }
                            TypeDefKind::Enum { variants: _ } => {
                                self.error(TypeError::new(
                                    TypeErrorKind::Other { message: "Cannot construct enum with struct syntax".to_string() },
                                    span,
                                ));
                                Type::error()
                            }
                        }
                    }
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::UnresolvedType { name: struct_name.clone() },
                            span,
                        ));
                        Type::error()
                    }
                }
            }
            None => {
                self.error(TypeError::new(
                    TypeErrorKind::UnresolvedType { name: struct_name.clone() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Check effect handle expression.
    fn check_effect_handle(&mut self, inner: &Expr, handlers: &[Handler], span: Span) -> Type {
        // Collect all handled effects
        let mut handled_row = EffectRow::pure();
        let mut i: usize = 0;
        while i < handlers.len() {
            let handler = &handlers[i];
            match self.scope.lookup_type(&handler.effect.value) {
                Some(def_id) => {
                    handled_row.effects.push(EffectInstance {
                        def_id,
                        args: vec![], // TODO: track type args
                    });
                }
                None => {
                    self.error(TypeError::new(
                        TypeErrorKind::UnresolvedType { name: handler.effect.value.clone() },
                        handler.span,
                    ));
                }
            }
            i = i + 1;
        }

        // Push handled effects onto stack
        self.handled_effects.push(handled_row);

        // Infer the type of the inner expression (with handlers in scope)
        let inner_ty = self.infer_expr(inner);

        // Pop handled effects
        self.handled_effects.pop();

        // Check each handler
        i = 0;
        while i < handlers.len() {
            let handler = &handlers[i];
            self.check_handler(handler);
            i = i + 1;
        }

        // The result type is the inner expression type with effects removed
        inner_ty
    }

    /// Check a single effect handler.
    fn check_handler(&mut self, handler: &Handler) {
        // Look up the effect
        match self.scope.lookup_type(&handler.effect.value) {
            Some(def_id) => {
                match self.effect_defs.get(&def_id.id) {
                    Some(effect_def) => {
                        // Check each operation handler
                        let mut i: usize = 0;
                        while i < handler.operations.len() {
                            let op_handler = &handler.operations[i];
                            self.check_op_handler(effect_def, op_handler);
                            i = i + 1;
                        }
                    }
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::UnresolvedType { name: handler.effect.value.clone() },
                            handler.span,
                        ));
                    }
                }
            }
            None => {
                self.error(TypeError::new(
                    TypeErrorKind::UnresolvedType { name: handler.effect.value.clone() },
                    handler.span,
                ));
            }
        }
    }

    /// Check a single operation handler.
    fn check_op_handler(&mut self, effect_def: &EffectDef, op_handler: &OpHandler) {
        // Find the operation in the effect
        let op_def = self.find_effect_op(effect_def, &op_handler.operation.value);
        match op_def {
            Some(opdef) => {
                // Create child scope for handler
                let old_scope = self.scope.clone();
                self.scope = self.scope.child();

                // Bind parameters
                let mut i: usize = 0;
                while i < op_handler.params.len() {
                    if i < opdef.params.len() {
                        self.scope.define_var(
                            op_handler.params[i].name.value.clone(),
                            opdef.params[i].clone(),
                        );
                    }
                    i = i + 1;
                }

                // Bind resume continuation if present
                match &op_handler.resume {
                    Some(resume_name) => {
                        // resume has type: (ReturnType) -> ResultType
                        let resume_ty = Type::new(TypeKind::Fn {
                            params: vec![opdef.ret.clone()],
                            ret: self.fresh_var(), // Will be unified with handler result
                            effect: None,
                        });
                        self.scope.define_var(resume_name.value.clone(), resume_ty);
                    }
                    None => {}
                }

                // Check handler body
                self.infer_expr(&op_handler.body);

                // Restore scope
                self.scope = old_scope;
            }
            None => {
                self.error(TypeError::new(
                    TypeErrorKind::InvalidEffectOp {
                        effect: effect_def.name.clone(),
                        op: op_handler.operation.value.clone(),
                    },
                    op_handler.span,
                ));
            }
        }
    }

    /// Find an operation in an effect definition.
    fn find_effect_op(&self, effect_def: &EffectDef, name: &str) -> Option<EffectOpDef> {
        let mut i: usize = 0;
        while i < effect_def.operations.len() {
            if effect_def.operations[i].name == name {
                return Some(effect_def.operations[i].clone());
            }
            i = i + 1;
        }
        None
    }

    /// Check effect perform expression.
    fn check_effect_perform(&mut self, effect: &str, operation: &str, args: &[Expr], span: Span) -> Type {
        // Look up the effect
        match self.scope.lookup_type(effect) {
            Some(def_id) => {
                match self.effect_defs.get(&def_id.id) {
                    Some(effect_def) => {
                        match self.find_effect_op(effect_def, operation) {
                            Some(op_def) => {
                                // Track that this effect is being used
                                self.current_effect_context.use_effect(EffectInstance {
                                    def_id: def_id.clone(),
                                    args: vec![], // TODO: track type args
                                });

                                // Check argument count
                                if args.len() != op_def.params.len() {
                                    self.error(TypeError::new(
                                        TypeErrorKind::WrongArity {
                                            expected: op_def.params.len() as u32,
                                            found: args.len() as u32,
                                        },
                                        span,
                                    ));
                                    return Type::error();
                                }

                                // Check argument types
                                let mut i: usize = 0;
                                while i < args.len() {
                                    let arg_ty = self.infer_expr(&args[i]);
                                    match self.unifier.unify(&op_def.params[i], &arg_ty, args[i].span) {
                                        Ok(()) => {}
                                        Err(e) => self.error(e),
                                    }
                                    i = i + 1;
                                }

                                op_def.ret.clone()
                            }
                            None => {
                                self.error(TypeError::new(
                                    TypeErrorKind::InvalidEffectOp {
                                        effect: effect.to_string(),
                                        op: operation.to_string(),
                                    },
                                    span,
                                ));
                                Type::error()
                            }
                        }
                    }
                    None => {
                        self.error(TypeError::new(
                            TypeErrorKind::UnresolvedType { name: effect.to_string() },
                            span,
                        ));
                        Type::error()
                    }
                }
            }
            None => {
                self.error(TypeError::new(
                    TypeErrorKind::UnresolvedType { name: effect.to_string() },
                    span,
                ));
                Type::error()
            }
        }
    }

    /// Resolve a path expression (e.g., Foo::Bar or module::item).
    fn resolve_path(&mut self, path: &Path, span: Span) -> Type {
        if path.segments.len() == 1 {
            // Simple name - look up in scope
            let name = &path.segments[0].value;
            match self.scope.lookup_var(name) {
                Some(ty) => ty,
                None => {
                    // Could be a type name used as a value (e.g., enum variant)
                    match self.scope.lookup_type(name) {
                        Some(def_id) => {
                            match self.type_defs.get(&def_id.id) {
                                Some(type_def) => {
                                    match &type_def.kind {
                                        TypeDefKind::Struct { fields: _ } => {
                                            // Unit struct used as value
                                            Type::new(TypeKind::Adt { def_id, args: vec![] })
                                        }
                                        TypeDefKind::Enum { variants: _ } => {
                                            self.error(TypeError::new(
                                                TypeErrorKind::Other { message: "Enum type cannot be used as value".to_string() },
                                                span,
                                            ));
                                            Type::error()
                                        }
                                    }
                                }
                                None => {
                                    self.error(TypeError::new(
                                        TypeErrorKind::UnresolvedName { name: name.clone() },
                                        span,
                                    ));
                                    Type::error()
                                }
                            }
                        }
                        None => {
                            self.error(TypeError::new(
                                TypeErrorKind::UnresolvedName { name: name.clone() },
                                span,
                            ));
                            Type::error()
                        }
                    }
                }
            }
        } else if path.segments.len() == 2 {
            // Could be EnumType::Variant
            let type_name = &path.segments[0].value;
            let variant_name = &path.segments[1].value;

            match self.scope.lookup_type(type_name) {
                Some(def_id) => {
                    match self.type_defs.get(&def_id.id) {
                        Some(type_def) => {
                            match &type_def.kind {
                                TypeDefKind::Enum { variants } => {
                                    match self.find_enum_variant(&variants, variant_name) {
                                        Some(variant) => {
                                            // Return enum type - variant carries the payload info
                                            Type::new(TypeKind::Adt { def_id, args: vec![] })
                                        }
                                        None => {
                                            self.error(TypeError::new(
                                                TypeErrorKind::Other {
                                                    message: format!("Unknown variant: {}", variant_name)
                                                },
                                                span,
                                            ));
                                            Type::error()
                                        }
                                    }
                                }
                                TypeDefKind::Struct { fields: _ } => {
                                    self.error(TypeError::new(
                                        TypeErrorKind::Other {
                                            message: "Cannot use path syntax on struct".to_string()
                                        },
                                        span,
                                    ));
                                    Type::error()
                                }
                            }
                        }
                        None => {
                            self.error(TypeError::new(
                                TypeErrorKind::UnresolvedType { name: type_name.clone() },
                                span,
                            ));
                            Type::error()
                        }
                    }
                }
                None => {
                    // Could be module::item - not yet implemented
                    self.error(TypeError::new(
                        TypeErrorKind::UnresolvedName { name: format!("{}::{}", type_name, variant_name) },
                        span,
                    ));
                    Type::error()
                }
            }
        } else {
            // Longer paths - module resolution
            self.error(TypeError::new(
                TypeErrorKind::Other { message: "Module paths not yet implemented".to_string() },
                span,
            ));
            Type::error()
        }
    }

    // ----- Function Body Checking -----

    /// Check all function bodies in a program.
    fn check_function_bodies(&mut self, program: &Program) {
        let mut i: usize = 0;
        while i < program.declarations.len() {
            match &program.declarations[i] {
                Declaration::Function(fn_decl) => {
                    self.check_function_body(fn_decl);
                }
                Declaration::Impl(impl_block) => {
                    self.check_impl_block(impl_block);
                }
                _ => {}
            }
            i = i + 1;
        }
    }

    /// Check a single function body.
    fn check_function_body(&mut self, fn_decl: &FnDecl) {
        // Create child scope for function body
        let old_scope = self.scope.clone();
        self.scope = self.scope.child();

        // Add parameters to scope
        let mut i: usize = 0;
        while i < fn_decl.params.len() {
            let param = &fn_decl.params[i];
            let param_ty = self.lower_type(&param.ty);
            self.bind_pattern(&param.pattern, &param_ty);
            i = i + 1;
        }

        // Get expected return type
        let expected_ret = match &fn_decl.return_type {
            Some(ty) => self.lower_type(ty),
            None => Type::unit(),
        };

        // Get declared effect row
        let declared_effects = match &fn_decl.effects {
            Some(row) => Some(self.lower_effect_row(row)),
            None => None,
        };

        // Store return type and effect context
        let old_expected_ret = self.current_return_type.clone();
        let old_effect_context = self.current_effect_context.clone();
        self.current_return_type = Some(expected_ret.clone());
        self.current_effect_context = EffectContext::with_declared(declared_effects.clone());

        // Check function body
        match &fn_decl.body {
            Some(body) => {
                let body_ty = self.check_block(body);
                // Unify body type with return type
                match self.unifier.unify(&expected_ret, &body_ty, fn_decl.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }

                // Verify all used effects are declared
                self.verify_effects_declared(fn_decl.span);
            }
            None => {
                // External function - no body to check
            }
        }

        // Restore state
        self.current_return_type = old_expected_ret;
        self.current_effect_context = old_effect_context;
        self.scope = old_scope;
    }

    /// Verify that all effects used in the function body are declared in the signature.
    fn verify_effects_declared(&mut self, span: Span) {
        let used = self.current_effect_context.used.clone();
        let mut i: usize = 0;
        while i < used.len() {
            let effect = &used[i];
            if !self.current_effect_context.is_effect_available(effect.def_id.clone(), &self.handled_effects) {
                // Look up effect name for error message
                let effect_name = match self.effect_defs.get(&effect.def_id.id) {
                    Some(def) => def.name.clone(),
                    None => format!("effect#{}", effect.def_id.id),
                };
                self.error(TypeError::new(
                    TypeErrorKind::UnhandledEffect { effect: effect.clone() },
                    span,
                ));
            }
            i = i + 1;
        }
    }

    /// Check an impl block.
    fn check_impl_block(&mut self, impl_block: &ImplBlock) {
        // Create child scope for impl block
        let old_scope = self.scope.clone();
        self.scope = self.scope.child();

        // Add Self type to scope
        let self_ty = self.lower_type(&impl_block.self_type);
        self.scope.define_var("Self".to_string(), self_ty.clone());

        // Check each method
        let mut i: usize = 0;
        while i < impl_block.items.len() {
            match &impl_block.items[i] {
                ImplItem::Method(method) => {
                    self.check_method(method, &self_ty);
                }
                ImplItem::AssocType(assoc_type) => {
                    // Associated types - register but don't check
                }
                ImplItem::AssocConst(assoc_const) => {
                    // Associated constants - check value
                    let expected_ty = self.lower_type(&assoc_const.ty);
                    let value_ty = self.infer_expr(&assoc_const.value);
                    match self.unifier.unify(&expected_ty, &value_ty, assoc_const.span) {
                        Ok(()) => {}
                        Err(e) => self.error(e),
                    }
                }
            }
            i = i + 1;
        }

        // Restore scope
        self.scope = old_scope;
    }

    /// Check a method in an impl block.
    fn check_method(&mut self, method: &FnDecl, self_ty: &Type) {
        // Create child scope for method body
        let old_scope = self.scope.clone();
        self.scope = self.scope.child();

        // Add parameters to scope (including self)
        let mut i: usize = 0;
        while i < method.params.len() {
            let param = &method.params[i];
            if i == 0 && self.is_self_param(&param.pattern) {
                // First param is self - bind as receiver type
                self.scope.define_var("self".to_string(), self_ty.clone());
            } else {
                let param_ty = self.lower_type(&param.ty);
                self.bind_pattern(&param.pattern, &param_ty);
            }
            i = i + 1;
        }

        // Get expected return type
        let expected_ret = match &method.return_type {
            Some(ty) => self.lower_type(ty),
            None => Type::unit(),
        };

        // Store return type for checking return statements
        let old_expected_ret = self.current_return_type.clone();
        self.current_return_type = Some(expected_ret.clone());

        // Check method body
        match &method.body {
            Some(body) => {
                let body_ty = self.check_block(body);
                match self.unifier.unify(&expected_ret, &body_ty, method.span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
            }
            None => {}
        }

        // Restore state
        self.current_return_type = old_expected_ret;
        self.scope = old_scope;
    }

    /// Check if a pattern is a self parameter.
    fn is_self_param(&self, pattern: &Pattern) -> bool {
        match &pattern.kind {
            PatternKind::Identifier(name) => name.value == "self",
            _ => false,
        }
    }

    // ----- Binary/Unary Operator Checking -----

    /// Check a binary operation and return the result type.
    fn check_binary_op_full(&mut self, op: &BinOp, left: &Type, right: &Type, span: Span) -> Type {
        match op {
            // Arithmetic operators: require numeric types, return same type
            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem => {
                match self.unifier.unify(left, right, span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                // TODO: verify left is numeric
                left.clone()
            }

            // Comparison operators: require same type, return bool
            BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge => {
                match self.unifier.unify(left, right, span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                Type::bool_type()
            }

            // Logical operators: require bool, return bool
            BinOp::And | BinOp::Or => {
                match self.unifier.unify(left, &Type::bool_type(), span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                match self.unifier.unify(right, &Type::bool_type(), span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                Type::bool_type()
            }

            // Bitwise operators: require integer types, return same type
            BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor | BinOp::Shl | BinOp::Shr => {
                match self.unifier.unify(left, right, span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                // TODO: verify left is integer
                left.clone()
            }

            // Compound assignment operators
            BinOp::AddAssign | BinOp::SubAssign | BinOp::MulAssign | BinOp::DivAssign |
            BinOp::RemAssign | BinOp::BitAndAssign | BinOp::BitOrAssign | BinOp::BitXorAssign |
            BinOp::ShlAssign | BinOp::ShrAssign => {
                match self.unifier.unify(left, right, span) {
                    Ok(()) => {}
                    Err(e) => self.error(e),
                }
                Type::unit()
            }
        }
    }

    /// Check a unary operation and return the result type.
    fn check_unary_op_full(&mut self, op: &UnOp, operand: &Type, span: Span) -> Type {
        match op {
            UnOp::Neg => {
                // Negation requires signed numeric type
                // TODO: verify operand is signed numeric
                operand.clone()
            }
            UnOp::Not => {
                // Logical not requires bool, bitwise not requires integer
                // For now, return the same type
                operand.clone()
            }
            UnOp::Deref => {
                // Already handled in ExprKind::Dereference
                match &operand.kind {
                    TypeKind::Ref { inner, mutable: _ } => inner.clone(),
                    TypeKind::Ptr { inner, mutable: _ } => inner.clone(),
                    _ => {
                        self.error(TypeError::new(
                            TypeErrorKind::Other { message: "Cannot dereference non-pointer type".to_string() },
                            span,
                        ));
                        Type::error()
                    }
                }
            }
            UnOp::Ref => {
                Type::new(TypeKind::Ref { inner: operand.clone(), mutable: false })
            }
            UnOp::RefMut => {
                Type::new(TypeKind::Ref { inner: operand.clone(), mutable: true })
            }
        }
    }

    // ----- Main Entry Point -----

    /// Type check a program.
    fn check_program(&mut self, program: &Program) -> Result<(), [TypeError]> {
        // Phase 1: Collect all declarations
        self.collect_declarations(program);

        // Phase 2: Type check all function bodies
        self.check_function_bodies(program);

        if self.has_errors() {
            Err(self.errors.clone())
        } else {
            Ok(())
        }
    }
}

// ============================================================
// Pattern Exhaustiveness Checking
// ============================================================

/// Represents a pattern for exhaustiveness checking.
/// Simplified representation that abstracts away syntax details.
enum PatternMatrix {
    /// Wildcard - matches anything
    Wild,
    /// Constructor with subpatterns (e.g., Some(x), Foo { a, b })
    Constructor { name: String, args: [PatternMatrix] },
    /// Literal value
    Literal(LiteralPattern),
    /// Or-pattern (multiple alternatives)
    Or([PatternMatrix]),
    /// Missing pattern (represents what's not yet covered)
    Missing,
}

/// Literal patterns for exhaustiveness checking.
enum LiteralPattern {
    Int(i64),
    Bool(bool),
    Char(char),
    String(String),
    Range { start: i64, end: i64, inclusive: bool },
}

/// The exhaustiveness checker.
struct ExhaustivenessChecker {
    /// Type definitions for looking up constructors
    type_defs: HashMap<u32, TypeDef>,
}

impl ExhaustivenessChecker {
    fn new(type_defs: &HashMap<u32, TypeDef>) -> ExhaustivenessChecker {
        ExhaustivenessChecker {
            type_defs: type_defs.clone(),
        }
    }

    /// Check if a set of patterns is exhaustive for a given type.
    /// Returns a list of missing patterns if not exhaustive.
    fn check_exhaustiveness(&self, patterns: &[PatternMatrix], ty: &Type) -> [String] {
        let missing = self.find_missing_patterns(patterns, ty);
        missing
    }

    /// Find patterns that are not covered.
    fn find_missing_patterns(&self, patterns: &[PatternMatrix], ty: &Type) -> [String] {
        // If any pattern is a wildcard, the match is exhaustive
        let mut i: usize = 0;
        while i < patterns.len() {
            match &patterns[i] {
                PatternMatrix::Wild => return vec![],
                _ => {}
            }
            i = i + 1;
        }

        // Check based on type
        match &ty.kind {
            TypeKind::Primitive(PrimitiveTy::Bool) => {
                self.check_bool_exhaustiveness(patterns)
            }
            TypeKind::Primitive(PrimitiveTy::Unit) => {
                // Unit has exactly one value
                if patterns.len() == 0 {
                    vec!["()".to_string()]
                } else {
                    vec![]
                }
            }
            TypeKind::Adt { def_id, args: _ } => {
                self.check_adt_exhaustiveness(patterns, def_id)
            }
            TypeKind::Tuple(tys) => {
                self.check_tuple_exhaustiveness(patterns, tys)
            }
            _ => {
                // For types like integers, strings, etc., require a wildcard
                if patterns.len() == 0 {
                    vec!["_".to_string()]
                } else {
                    // Check if there's any wildcard or catch-all
                    vec![]
                }
            }
        }
    }

    /// Check exhaustiveness for bool type.
    fn check_bool_exhaustiveness(&self, patterns: &[PatternMatrix]) -> [String] {
        let mut has_true = false;
        let mut has_false = false;

        let mut i: usize = 0;
        while i < patterns.len() {
            match &patterns[i] {
                PatternMatrix::Wild => {
                    has_true = true;
                    has_false = true;
                }
                PatternMatrix::Literal(LiteralPattern::Bool(true)) => has_true = true,
                PatternMatrix::Literal(LiteralPattern::Bool(false)) => has_false = true,
                PatternMatrix::Or(alts) => {
                    // Check each alternative
                    let mut j: usize = 0;
                    while j < alts.len() {
                        match &alts[j] {
                            PatternMatrix::Literal(LiteralPattern::Bool(true)) => has_true = true,
                            PatternMatrix::Literal(LiteralPattern::Bool(false)) => has_false = true,
                            PatternMatrix::Wild => {
                                has_true = true;
                                has_false = true;
                            }
                            _ => {}
                        }
                        j = j + 1;
                    }
                }
                _ => {}
            }
            i = i + 1;
        }

        let mut missing: [String] = vec![];
        if !has_true { missing.push("true".to_string()); }
        if !has_false { missing.push("false".to_string()); }
        missing
    }

    /// Check exhaustiveness for ADT (struct/enum) type.
    fn check_adt_exhaustiveness(&self, patterns: &[PatternMatrix], def_id: &DefId) -> [String] {
        match self.type_defs.get(&def_id.id) {
            Some(type_def) => {
                match &type_def.kind {
                    TypeDefKind::Struct { fields: _ } => {
                        // Structs have exactly one constructor
                        if patterns.len() == 0 {
                            vec![format!("{} {{ .. }}", type_def.name)]
                        } else {
                            vec![]
                        }
                    }
                    TypeDefKind::Enum { variants } => {
                        self.check_enum_exhaustiveness(patterns, &type_def.name, variants)
                    }
                }
            }
            None => vec![]
        }
    }

    /// Check exhaustiveness for enum variants.
    fn check_enum_exhaustiveness(&self, patterns: &[PatternMatrix], enum_name: &str, variants: &[EnumVariantDef]) -> [String] {
        // Track which variants are covered
        let mut covered: HashSet<String> = HashSet::new();

        let mut i: usize = 0;
        while i < patterns.len() {
            match &patterns[i] {
                PatternMatrix::Wild => {
                    // Wildcard covers all variants
                    return vec![];
                }
                PatternMatrix::Constructor { name, args: _ } => {
                    covered.insert(name.clone());
                }
                PatternMatrix::Or(alts) => {
                    let mut j: usize = 0;
                    while j < alts.len() {
                        match &alts[j] {
                            PatternMatrix::Wild => return vec![],
                            PatternMatrix::Constructor { name, args: _ } => {
                                covered.insert(name.clone());
                            }
                            _ => {}
                        }
                        j = j + 1;
                    }
                }
                _ => {}
            }
            i = i + 1;
        }

        // Find missing variants
        let mut missing: [String] = vec![];
        i = 0;
        while i < variants.len() {
            if !covered.contains(&variants[i].name) {
                let pattern_str = match &variants[i].payload {
                    Some(_) => format!("{}::{}(_)", enum_name, variants[i].name),
                    None => format!("{}::{}", enum_name, variants[i].name),
                };
                missing.push(pattern_str);
            }
            i = i + 1;
        }

        missing
    }

    /// Check exhaustiveness for tuple type.
    fn check_tuple_exhaustiveness(&self, patterns: &[PatternMatrix], element_tys: &[Type]) -> [String] {
        // For tuples, we need to check each position
        // This is a simplified version - full algorithm would use pattern matrices
        if patterns.len() == 0 {
            if element_tys.len() == 0 {
                vec!["()".to_string()]
            } else {
                vec!["(_, ...)".to_string()]
            }
        } else {
            vec![]
        }
    }

    /// Convert an AST pattern to our internal pattern representation.
    fn pattern_to_matrix(&self, pattern: &Pattern, ctx: &TypeContext) -> PatternMatrix {
        match &pattern.kind {
            PatternKind::Wildcard => PatternMatrix::Wild,
            PatternKind::Identifier(_) => PatternMatrix::Wild, // Binding is like wildcard for exhaustiveness
            PatternKind::Literal(lit) => {
                match lit {
                    Literal::Bool(b) => PatternMatrix::Literal(LiteralPattern::Bool(*b)),
                    Literal::Int(i) => PatternMatrix::Literal(LiteralPattern::Int(*i)),
                    Literal::Char(c) => PatternMatrix::Literal(LiteralPattern::Char(*c)),
                    Literal::String(s) => PatternMatrix::Literal(LiteralPattern::String(s.clone())),
                    Literal::Float(_) => PatternMatrix::Wild, // Floats treated as wildcard
                }
            }
            PatternKind::Tuple(pats) => {
                let mut args: [PatternMatrix] = vec![];
                let mut i: usize = 0;
                while i < pats.len() {
                    args.push(self.pattern_to_matrix(&pats[i], ctx));
                    i = i + 1;
                }
                PatternMatrix::Constructor { name: "tuple".to_string(), args }
            }
            PatternKind::Struct { name, fields } => {
                let mut args: [PatternMatrix] = vec![];
                let mut i: usize = 0;
                while i < fields.len() {
                    args.push(self.pattern_to_matrix(&fields[i].pattern, ctx));
                    i = i + 1;
                }
                PatternMatrix::Constructor {
                    name: name.segments[0].value.clone(),
                    args,
                }
            }
            PatternKind::Enum { name, variant, payload } => {
                let args = match payload {
                    Some(p) => vec![self.pattern_to_matrix(p, ctx)],
                    None => vec![],
                };
                PatternMatrix::Constructor {
                    name: variant.value.clone(),
                    args,
                }
            }
            PatternKind::Or(pats) => {
                let mut alts: [PatternMatrix] = vec![];
                let mut i: usize = 0;
                while i < pats.len() {
                    alts.push(self.pattern_to_matrix(&pats[i], ctx));
                    i = i + 1;
                }
                PatternMatrix::Or(alts)
            }
            PatternKind::Range { start, end, inclusive } => {
                match (start, end) {
                    (Literal::Int(s), Some(Literal::Int(e))) => {
                        PatternMatrix::Literal(LiteralPattern::Range {
                            start: *s,
                            end: *e,
                            inclusive: *inclusive,
                        })
                    }
                    _ => PatternMatrix::Wild,
                }
            }
            PatternKind::Rest => PatternMatrix::Wild,
        }
    }
}

impl TypeContext {
    /// Check pattern exhaustiveness for a match expression.
    fn check_match_exhaustiveness(&mut self, patterns: &[Pattern], scrutinee_ty: &Type, span: Span) {
        let checker = ExhaustivenessChecker::new(&self.type_defs);

        // Convert patterns to matrix form
        let mut matrix: [PatternMatrix] = vec![];
        let mut i: usize = 0;
        while i < patterns.len() {
            matrix.push(checker.pattern_to_matrix(&patterns[i], self));
            i = i + 1;
        }

        // Check exhaustiveness
        let missing = checker.check_exhaustiveness(&matrix, scrutinee_ty);

        if missing.len() > 0 {
            self.error(TypeError::new(
                TypeErrorKind::NonExhaustive { missing },
                span,
            ));
        }
    }
}

// ============================================================
// Public API
// ============================================================

/// Type check a program and return errors if any.
pub fn check_program(program: &Program) -> Result<(), [TypeError]> {
    let mut ctx = TypeContext::new();
    ctx.check_program(program)
}
