// Blood Self-Hosted Compiler - Type Checking
//
// This module implements type checking and inference for the HIR.
// Type checking validates that expressions have compatible types and
// infers types where they are not explicitly annotated.
//
// Note: Due to blood-rust limitations with Vec<T> type inference on
// struct field operations, the full type checking implementation is
// deferred. This module defines the types and structures needed.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir;
mod unify;

// ============================================================
// Type Error
// ============================================================

/// A type checking error.
pub struct TypeError {
    /// The kind of type error.
    pub kind: TypeErrorKind,
    /// The span where the error occurred.
    pub span: common::Span,
    /// Additional notes for the error.
    pub notes: Vec<TypeNote>,
}

impl TypeError {
    /// Creates a new type error.
    pub fn new(kind: TypeErrorKind, span: common::Span) -> TypeError {
        TypeError {
            kind: kind,
            span: span,
            notes: Vec::new(),
        }
    }

    /// Creates a type mismatch error.
    pub fn mismatch(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::TypeMismatch, span)
    }

    /// Creates an undefined variable error.
    pub fn undefined(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::UndefinedVariable, span)
    }

    /// Creates an invalid call error.
    pub fn not_callable(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::NotCallable, span)
    }
}

/// The kind of type error.
pub enum TypeErrorKind {
    /// Types don't match.
    TypeMismatch,
    /// Cannot infer type.
    CannotInfer,
    /// Undefined variable.
    UndefinedVariable,
    /// Undefined function.
    UndefinedFunction,
    /// Wrong number of arguments.
    ArityMismatch,
    /// Expression is not callable.
    NotCallable,
    /// Expression is not indexable.
    NotIndexable,
    /// Field does not exist.
    NoSuchField,
    /// Method does not exist.
    NoSuchMethod,
    /// Cannot mutate immutable.
    CannotMutate,
    /// Invalid assignment target.
    InvalidLValue,
    /// Missing return value.
    MissingReturn,
    /// Type does not implement trait.
    TraitNotImplemented,
    /// Effect not handled.
    UnhandledEffect,
    /// Invalid break/continue.
    InvalidControl,
    /// Pattern type mismatch.
    PatternMismatch,
    /// Non-exhaustive patterns.
    NonExhaustive,
    /// Recursive type without indirection.
    InfiniteType,
    /// Invalid cast.
    InvalidCast,
}

/// A note attached to a type error.
pub struct TypeNote {
    /// The note message.
    pub message: String,
    /// Optional span for the note.
    pub span: Option<common::Span>,
}

impl TypeNote {
    /// Creates a new type note.
    pub fn new(message: String) -> TypeNote {
        TypeNote {
            message: message,
            span: None,
        }
    }

    /// Creates a type note with a span.
    pub fn with_span(message: String, span: common::Span) -> TypeNote {
        TypeNote {
            message: message,
            span: Some(span),
        }
    }
}

// ============================================================
// Type Information
// ============================================================

/// Information about a struct for type checking.
pub struct StructInfo {
    /// The DefId of the struct.
    pub def_id: hir_def::DefId,
    /// The name of the struct.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Field names (in order).
    pub field_names: Vec<common::Symbol>,
    /// Field info with types (for type checking).
    pub fields: Vec<FieldInfo>,
}

impl StructInfo {
    /// Creates new struct info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        field_names: Vec<common::Symbol>,
        fields: Vec<FieldInfo>,
    ) -> StructInfo {
        StructInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            field_names: field_names,
            fields: fields,
        }
    }
}

/// Information about an enum for type checking.
pub struct EnumInfo {
    /// The DefId of the enum.
    pub def_id: hir_def::DefId,
    /// The name of the enum.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Variant names (in order).
    pub variant_names: Vec<common::Symbol>,
    /// Variant info with types (for type checking).
    pub variants: Vec<VariantInfo>,
}

impl EnumInfo {
    /// Creates new enum info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        variant_names: Vec<common::Symbol>,
        variants: Vec<VariantInfo>,
    ) -> EnumInfo {
        EnumInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            variant_names: variant_names,
            variants: variants,
        }
    }
}

/// Information about a function for type checking.
pub struct FnInfo {
    /// The DefId of the function.
    pub def_id: hir_def::DefId,
    /// The name of the function.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Number of parameters.
    pub num_params: u32,
    /// Whether the function is const.
    pub is_const: bool,
    /// Whether the function is unsafe.
    pub is_unsafe: bool,
}

impl FnInfo {
    /// Creates new function info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        num_params: u32,
        is_const: bool,
        is_unsafe: bool,
    ) -> FnInfo {
        FnInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            num_params: num_params,
            is_const: is_const,
            is_unsafe: is_unsafe,
        }
    }
}

/// Information about an effect for type checking.
pub struct EffectInfo {
    /// The DefId of the effect.
    pub def_id: hir_def::DefId,
    /// The name of the effect.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Operation names.
    pub op_names: Vec<common::Symbol>,
}

impl EffectInfo {
    /// Creates new effect info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        op_names: Vec<common::Symbol>,
    ) -> EffectInfo {
        EffectInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            op_names: op_names,
        }
    }
}

// ============================================================
// Type Checking Mode
// ============================================================

/// The mode for type checking an expression.
pub enum CheckMode {
    /// Infer the type (no expectation).
    Infer,
    /// Check against an expected type.
    Check(hir_ty::Type),
    /// Coerce to an expected type (allows implicit conversions).
    Coerce(hir_ty::Type),
}

impl CheckMode {
    /// Creates an inference mode.
    pub fn infer() -> CheckMode {
        CheckMode::Infer
    }

    /// Creates a checking mode with the given expected type.
    pub fn check(ty: hir_ty::Type) -> CheckMode {
        CheckMode::Check(ty)
    }

    /// Creates a coercion mode with the given target type.
    pub fn coerce(ty: hir_ty::Type) -> CheckMode {
        CheckMode::Coerce(ty)
    }
}

// ============================================================
// Coercion
// ============================================================

/// A type coercion.
pub enum Coercion {
    /// No coercion needed.
    None,
    /// Dereference coercion: &T -> &U where T: Deref<Target=U>
    Deref,
    /// Reference coercion: &T -> &U where T <: U
    RefCoerce,
    /// Unsizing coercion: [T; N] -> [T], Sized -> ?Sized
    Unsize,
    /// Function pointer coercion: fn item -> fn pointer
    FnPointer,
    /// Closure coercion: closure -> fn pointer (when captures empty)
    ClosureToFnPtr,
    /// Never coercion: ! -> T
    NeverToAny,
}

/// Result of attempting a coercion.
pub enum CoercionResult {
    /// Coercion succeeded.
    Ok(Coercion),
    /// Coercion failed.
    Err,
}

// ============================================================
// Exhaustiveness Checking
// ============================================================

/// A witness for non-exhaustiveness (a pattern not covered).
pub struct Witness {
    /// The pattern that isn't covered.
    pub description: String,
}

impl Witness {
    /// Creates a new witness.
    pub fn new(description: String) -> Witness {
        Witness {
            description: description,
        }
    }
}

/// Result of exhaustiveness checking.
pub enum ExhaustivenessResult {
    /// Patterns are exhaustive.
    Exhaustive,
    /// Patterns are not exhaustive, with witnesses.
    NonExhaustive(Vec<Witness>),
}

impl ExhaustivenessResult {
    /// Returns true if the result is exhaustive.
    pub fn is_exhaustive(self: &ExhaustivenessResult) -> bool {
        match self {
            &ExhaustivenessResult::Exhaustive => true,
            &ExhaustivenessResult::NonExhaustive(_) => false,
        }
    }
}

/// A deconstructed pattern for exhaustiveness checking.
pub enum DeconstructedPattern {
    /// A wildcard pattern that matches anything.
    Wildcard,
    /// A literal pattern (integer, bool, char).
    Literal { value: i128 },
    /// A struct variant pattern.
    Variant {
        def_id: hir_def::DefId,
        variant_idx: u32,
        fields: Vec<DeconstructedPattern>,
    },
    /// A struct pattern (non-enum).
    Struct {
        def_id: hir_def::DefId,
        fields: Vec<DeconstructedPattern>,
    },
    /// A tuple pattern.
    Tuple { fields: Vec<DeconstructedPattern> },
    /// An or-pattern (alternative patterns).
    Or { pats: Vec<DeconstructedPattern> },
    /// Missing pattern (for non-exhaustiveness witnesses).
    Missing,
}

impl DeconstructedPattern {
    /// Creates a wildcard pattern.
    pub fn wildcard() -> DeconstructedPattern {
        DeconstructedPattern::Wildcard
    }

    /// Creates a literal pattern.
    pub fn literal(value: i128) -> DeconstructedPattern {
        DeconstructedPattern::Literal { value: value }
    }

    /// Creates a variant pattern.
    pub fn variant(def_id: hir_def::DefId, variant_idx: u32, fields: Vec<DeconstructedPattern>) -> DeconstructedPattern {
        DeconstructedPattern::Variant { def_id: def_id, variant_idx: variant_idx, fields: fields }
    }

    /// Creates a struct pattern.
    pub fn struct_pat(def_id: hir_def::DefId, fields: Vec<DeconstructedPattern>) -> DeconstructedPattern {
        DeconstructedPattern::Struct { def_id: def_id, fields: fields }
    }

    /// Creates a tuple pattern.
    pub fn tuple(fields: Vec<DeconstructedPattern>) -> DeconstructedPattern {
        DeconstructedPattern::Tuple { fields: fields }
    }

    /// Returns true if this pattern is a wildcard.
    pub fn is_wildcard(self: &DeconstructedPattern) -> bool {
        match self {
            &DeconstructedPattern::Wildcard => true,
            _ => false,
        }
    }
}

/// A row in the pattern matrix.
pub struct PatternRow {
    /// The patterns in this row (one per column).
    pub patterns: Vec<DeconstructedPattern>,
}

impl PatternRow {
    /// Creates a new pattern row.
    pub fn new(patterns: Vec<DeconstructedPattern>) -> PatternRow {
        PatternRow { patterns: patterns }
    }
}

/// A pattern matrix for exhaustiveness checking.
pub struct PatternMatrix {
    /// The rows of the matrix.
    pub rows: Vec<PatternRow>,
    /// Number of columns (patterns per row).
    pub width: usize,
}

impl PatternMatrix {
    /// Creates a new empty pattern matrix.
    pub fn new(width: usize) -> PatternMatrix {
        PatternMatrix {
            rows: Vec::new(),
            width: width,
        }
    }

    /// Adds a row to the matrix.
    pub fn push_row(self: &mut PatternMatrix, row: PatternRow) {
        self.rows.push(row);
    }

    /// Returns the number of rows.
    pub fn row_count(self: &PatternMatrix) -> usize {
        self.rows.len()
    }

    /// Returns true if the matrix is empty.
    pub fn is_empty(self: &PatternMatrix) -> bool {
        self.rows.len() == 0
    }
}

// ============================================================
// Type Checking Results
// ============================================================

/// Result of type checking a single item.
pub enum ItemCheckResult {
    /// Type checking succeeded.
    Ok,
    /// Type checking failed with errors.
    Err,
}

/// Result of type checking a crate.
pub struct CrateCheckResult {
    /// Whether type checking succeeded overall.
    pub success: bool,
    /// Number of errors.
    pub error_count: u32,
    /// Number of warnings.
    pub warning_count: u32,
}

impl CrateCheckResult {
    /// Creates a successful result.
    pub fn ok() -> CrateCheckResult {
        CrateCheckResult {
            success: true,
            error_count: 0,
            warning_count: 0,
        }
    }

    /// Creates a failed result.
    pub fn failed(error_count: u32) -> CrateCheckResult {
        CrateCheckResult {
            success: false,
            error_count: error_count,
            warning_count: 0,
        }
    }
}

// ============================================================
// Obligation
// ============================================================

/// A trait obligation that needs to be resolved.
pub struct Obligation {
    /// The predicate (trait bound) that must hold.
    pub predicate: Predicate,
    /// The span where this obligation was created.
    pub span: common::Span,
    /// The cause of this obligation.
    pub cause: ObligationCause,
}

impl Obligation {
    /// Creates a new obligation.
    pub fn new(predicate: Predicate, span: common::Span, cause: ObligationCause) -> Obligation {
        Obligation {
            predicate: predicate,
            span: span,
            cause: cause,
        }
    }
}

/// A predicate that must be satisfied.
pub enum Predicate {
    /// A trait bound: T: Trait
    Trait(hir_ty::TraitRef),
    /// A type equality: T == U
    TypeEqual {
        left: hir_ty::Type,
        right: hir_ty::Type,
    },
    /// A well-formed type: WF(T)
    WellFormed(hir_ty::Type),
}

/// The cause of an obligation.
pub enum ObligationCause {
    /// From an explicit where clause.
    WhereClause,
    /// From a function argument type.
    FnArgument,
    /// From a function return type.
    FnReturn,
    /// From a struct field.
    FieldType,
    /// From a method call.
    MethodCall,
    /// From an operator.
    Operator,
    /// From a cast.
    Cast,
    /// From type coercion.
    Coercion,
    /// From pattern matching.
    Pattern,
}

// ============================================================
// Local Variable Info
// ============================================================

/// Information about a local variable for type checking.
pub struct LocalInfo {
    /// The local variable's type.
    pub ty: hir_ty::Type,
    /// Whether the local is mutable.
    pub mutable: bool,
    /// The span where the local was declared.
    pub span: common::Span,
}

impl LocalInfo {
    /// Creates new local info.
    pub fn new(ty: hir_ty::Type, mutable: bool, span: common::Span) -> LocalInfo {
        LocalInfo {
            ty: ty,
            mutable: mutable,
            span: span,
        }
    }
}

// ============================================================
// Stored Signature Info
// ============================================================

/// Stored info about a function signature for type checking.
pub struct FnSigInfo {
    /// Parameter types.
    pub param_tys: Vec<hir_ty::Type>,
    /// Return type.
    pub return_ty: hir_ty::Type,
    /// Number of generic type parameters.
    pub num_generics: u32,
}

impl FnSigInfo {
    /// Creates a new function signature info.
    pub fn new(param_tys: Vec<hir_ty::Type>, return_ty: hir_ty::Type, num_generics: u32) -> FnSigInfo {
        FnSigInfo { param_tys, return_ty, num_generics }
    }
}

/// Stored info about a struct field.
pub struct FieldInfo {
    /// Field name symbol.
    pub name: common::Symbol,
    /// Field type.
    pub ty: hir_ty::Type,
}

impl FieldInfo {
    /// Creates a new field info.
    pub fn new(name: common::Symbol, ty: hir_ty::Type) -> FieldInfo {
        FieldInfo { name, ty }
    }
}

/// Stored info about an enum variant.
pub struct VariantInfo {
    /// Variant name symbol.
    pub name: common::Symbol,
    /// Field types for tuple variants.
    pub field_tys: Vec<hir_ty::Type>,
    /// Variant index within the enum (for pattern matching).
    pub variant_index: u32,
}

impl VariantInfo {
    /// Creates a new variant info.
    pub fn new(name: common::Symbol, field_tys: Vec<hir_ty::Type>, variant_index: u32) -> VariantInfo {
        VariantInfo { name, field_tys, variant_index }
    }
}

/// Stored info about a constant.
pub struct ConstInfo {
    /// The DefId of the constant.
    pub def_id: hir_def::DefId,
    /// The name of the constant.
    pub name: common::Symbol,
    /// The type of the constant.
    pub ty: hir_ty::Type,
}

impl ConstInfo {
    /// Creates a new const info.
    pub fn new(def_id: hir_def::DefId, name: common::Symbol, ty: hir_ty::Type) -> ConstInfo {
        ConstInfo { def_id, name, ty }
    }
}

/// Stored info about a static.
pub struct StaticInfo {
    /// The DefId of the static.
    pub def_id: hir_def::DefId,
    /// The name of the static.
    pub name: common::Symbol,
    /// The type of the static.
    pub ty: hir_ty::Type,
    /// Whether the static is mutable.
    pub mutable: bool,
}

impl StaticInfo {
    /// Creates a new static info.
    pub fn new(def_id: hir_def::DefId, name: common::Symbol, ty: hir_ty::Type, mutable: bool) -> StaticInfo {
        StaticInfo { def_id, name, ty, mutable }
    }
}

/// Stored info about a method in an impl block.
pub struct MethodInfo {
    /// The DefId of the method.
    pub def_id: hir_def::DefId,
    /// The name of the method.
    pub name: common::Symbol,
    /// Parameter types (excluding self).
    pub param_tys: Vec<hir_ty::Type>,
    /// Return type.
    pub return_ty: hir_ty::Type,
    /// Whether the method takes self by reference.
    pub takes_self_ref: bool,
    /// Whether the method takes self by mutable reference.
    pub takes_self_mut: bool,
}

impl MethodInfo {
    /// Creates a new method info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        param_tys: Vec<hir_ty::Type>,
        return_ty: hir_ty::Type,
        takes_self_ref: bool,
        takes_self_mut: bool,
    ) -> MethodInfo {
        MethodInfo { def_id, name, param_tys, return_ty, takes_self_ref, takes_self_mut }
    }
}

/// Stored info about an impl block.
pub struct ImplInfo {
    /// The DefId of the impl block.
    pub def_id: hir_def::DefId,
    /// The self type this impl is for.
    pub self_ty: hir_ty::Type,
    /// Number of generic parameters on the impl.
    pub num_generics: u32,
    /// Methods in this impl block.
    pub methods: Vec<MethodInfo>,
}

impl ImplInfo {
    /// Creates a new impl info.
    pub fn new(
        def_id: hir_def::DefId,
        self_ty: hir_ty::Type,
        num_generics: u32,
        methods: Vec<MethodInfo>,
    ) -> ImplInfo {
        ImplInfo { def_id, self_ty, num_generics, methods }
    }
}

// ============================================================
// Trait Information
// ============================================================

/// Information about a trait for type checking.
pub struct TraitInfo {
    /// The DefId of the trait.
    pub def_id: hir_def::DefId,
    /// The name of the trait.
    pub name: common::Symbol,
    /// Number of generic type parameters.
    pub num_generics: u32,
    /// Methods required by this trait.
    pub methods: Vec<TraitMethodInfo>,
    /// Associated types in this trait.
    pub assoc_types: Vec<common::Symbol>,
}

impl TraitInfo {
    /// Creates new trait info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        methods: Vec<TraitMethodInfo>,
        assoc_types: Vec<common::Symbol>,
    ) -> TraitInfo {
        TraitInfo { def_id, name, num_generics, methods, assoc_types }
    }
}

/// Information about a trait method.
pub struct TraitMethodInfo {
    /// The name of the method.
    pub name: common::Symbol,
    /// Parameter types (excluding self).
    pub param_tys: Vec<hir_ty::Type>,
    /// Return type.
    pub return_ty: hir_ty::Type,
    /// Whether the method takes &self.
    pub takes_self_ref: bool,
    /// Whether the method takes &mut self.
    pub takes_self_mut: bool,
    /// Whether this method has a default implementation.
    pub has_default: bool,
}

impl TraitMethodInfo {
    /// Creates new trait method info.
    pub fn new(
        name: common::Symbol,
        param_tys: Vec<hir_ty::Type>,
        return_ty: hir_ty::Type,
        takes_self_ref: bool,
        takes_self_mut: bool,
        has_default: bool,
    ) -> TraitMethodInfo {
        TraitMethodInfo {
            name, param_tys, return_ty,
            takes_self_ref, takes_self_mut, has_default,
        }
    }
}

/// Information about a trait implementation.
pub struct TraitImplInfo {
    /// The DefId of this impl block.
    pub impl_def_id: hir_def::DefId,
    /// The DefId of the trait being implemented.
    pub trait_def_id: hir_def::DefId,
    /// The type implementing the trait.
    pub self_ty: hir_ty::Type,
    /// Type arguments for the trait (if generic).
    pub trait_args: Vec<hir_ty::Type>,
    /// Number of generic parameters on the impl.
    pub num_generics: u32,
    /// Where clause predicates for this impl.
    pub where_predicates: Vec<Predicate>,
}

impl TraitImplInfo {
    /// Creates new trait impl info.
    pub fn new(
        impl_def_id: hir_def::DefId,
        trait_def_id: hir_def::DefId,
        self_ty: hir_ty::Type,
        trait_args: Vec<hir_ty::Type>,
        num_generics: u32,
        where_predicates: Vec<Predicate>,
    ) -> TraitImplInfo {
        TraitImplInfo {
            impl_def_id, trait_def_id, self_ty,
            trait_args, num_generics, where_predicates,
        }
    }
}

// ============================================================
// Type Checker
// ============================================================

/// The main type checker.
///
/// This struct coordinates type checking for an entire HIR crate.
/// It maintains:
/// - Substitution table for type unification
/// - Type variable generator
/// - Current function context
/// - Errors collected during type checking
/// - Registered item signatures for lookup
pub struct TypeChecker {
    /// Substitution table for type unification.
    pub subst_table: unify::SubstTable,
    /// Unifier for generating fresh type variables.
    pub unifier: unify::Unifier,
    /// Current function's return type.
    pub return_ty: Option<hir_ty::Type>,
    /// Whether we're currently in a loop.
    pub in_loop: bool,
    /// Type of the current loop (for break values).
    pub loop_ty: Option<hir_ty::Type>,
    /// Local variable types by LocalId index.
    pub locals: Vec<LocalInfo>,
    /// Type errors collected during checking.
    pub errors: Vec<TypeError>,
    /// Function signature info by DefId.index for O(1) lookup.
    pub fn_sigs: Vec<Option<FnSigInfo>>,
    /// Struct info by DefId.index for O(1) lookup.
    pub structs: Vec<Option<StructInfo>>,
    /// Enum info by DefId.index for O(1) lookup.
    pub enums: Vec<Option<EnumInfo>>,
    /// Const info by DefId.index for O(1) lookup.
    pub consts: Vec<Option<ConstInfo>>,
    /// Static info by DefId.index for O(1) lookup.
    pub statics: Vec<Option<StaticInfo>>,
    /// Impl blocks for method resolution.
    pub impls: Vec<ImplInfo>,
    /// Trait definitions by DefId.index for O(1) lookup.
    pub traits: Vec<Option<TraitInfo>>,
    /// Trait implementations for trait resolution.
    pub trait_impls: Vec<TraitImplInfo>,
}

impl TypeChecker {
    /// Creates a new type checker.
    pub fn new() -> TypeChecker {
        TypeChecker {
            subst_table: unify::SubstTable::new(),
            unifier: unify::Unifier::new(),
            return_ty: Option::None,
            in_loop: false,
            loop_ty: Option::None,
            locals: Vec::new(),
            errors: Vec::new(),
            fn_sigs: Vec::new(),
            structs: Vec::new(),
            enums: Vec::new(),
            consts: Vec::new(),
            statics: Vec::new(),
            impls: Vec::new(),
            traits: Vec::new(),
            trait_impls: Vec::new(),
        }
    }

    /// Generates a fresh inference type variable.
    pub fn fresh_infer(self: &mut Self) -> hir_ty::Type {
        self.unifier.fresh_infer()
    }

    /// Adds a local variable to the context.
    pub fn add_local(self: &mut Self, ty: hir_ty::Type, mutable: bool, span: common::Span) -> hir_def::LocalId {
        let id = hir_def::LocalId::new(self.locals.len() as u32);
        let info = LocalInfo::new(ty, mutable, span);
        self.locals.push(info);
        id
    }

    /// Gets the type of a local variable.
    pub fn get_local_ty(self: &Self, id: hir_def::LocalId) -> Option<hir_ty::Type> {
        let idx = id.index as usize;
        if idx < self.locals.len() {
            Some(hir_ty::copy_type(&self.locals[idx].ty))
        } else {
            Option::None
        }
    }

    /// Checks if a local variable is mutable.
    pub fn is_local_mutable(self: &Self, id: hir_def::LocalId) -> bool {
        let idx = id.index as usize;
        if idx < self.locals.len() {
            self.locals[idx].mutable
        } else {
            false
        }
    }

    /// Sets the return type for the current function.
    pub fn set_return_ty(self: &mut Self, ty: hir_ty::Type) {
        self.return_ty = Some(ty);
    }

    /// Clears the return type when exiting a function.
    pub fn clear_return_ty(self: &mut Self) {
        self.return_ty = Option::None;
    }

    /// Enters a loop context.
    pub fn enter_loop(self: &mut Self, ty: hir_ty::Type) {
        self.in_loop = true;
        self.loop_ty = Some(ty);
    }

    /// Exits a loop context.
    pub fn exit_loop(self: &mut Self) {
        self.in_loop = false;
        self.loop_ty = Option::None;
    }

    /// Reports a type error.
    pub fn error(self: &mut Self, kind: TypeErrorKind, span: common::Span) {
        let err = TypeError::new(kind, span);
        self.errors.push(err);
    }

    /// Returns whether any errors have been reported.
    pub fn has_errors(self: &Self) -> bool {
        self.errors.len() > 0
    }

    /// Unifies two types.
    pub fn unify(self: &mut Self, a: &hir_ty::Type, b: &hir_ty::Type, span: common::Span) -> bool {
        match unify::unify(&mut self.subst_table, &mut self.unifier, a, b, span) {
            unify::UnifyResult::Ok => true,
            unify::UnifyResult::Err(e) => {
                // Convert unify error to type error
                let kind = match e.kind {
                    unify::UnifyErrorKind::TypeMismatch => TypeErrorKind::TypeMismatch,
                    unify::UnifyErrorKind::OccursCheck => TypeErrorKind::InfiniteType,
                    unify::UnifyErrorKind::ArityMismatch => TypeErrorKind::ArityMismatch,
                    unify::UnifyErrorKind::EffectMismatch => TypeErrorKind::TypeMismatch,
                    unify::UnifyErrorKind::RecordMismatch => TypeErrorKind::TypeMismatch,
                };
                self.error(kind, e.span);
                false
            }
        }
    }

    /// Resolves a type by applying current substitutions.
    pub fn resolve(self: &Self, ty: &hir_ty::Type) -> hir_ty::Type {
        let table_ref: &unify::SubstTable = &self.subst_table;
        unify::apply_substs(table_ref, ty)
    }

    /// Clears local variables (for entering a new function body).
    pub fn clear_locals(self: &mut Self) {
        self.locals = Vec::new();
    }

    // ========================================================
    // Item Registration (for type checking support)
    // ========================================================

    /// Registers a function signature for later lookup.
    pub fn register_fn_sig(self: &mut Self, def_id: hir_def::DefId, sig: &hir_item::FnSig) {
        // Extract parameter types
        let mut param_tys: Vec<hir_ty::Type> = Vec::new();
        let mut i: usize = 0;
        while i < sig.params.len() {
            param_tys.push(hir_ty::copy_type(&sig.params[i].ty));
            i = i + 1;
        }

        // Get the number of generic parameters
        let num_generics = sig.generics.params.len() as u32;

        // Create the info
        let info = FnSigInfo::new(param_tys, hir_ty::copy_type(&sig.return_ty), num_generics);

        // Store at def_id.index
        let def_idx = def_id.index as usize;
        while self.fn_sigs.len() <= def_idx {
            self.fn_sigs.push(Option::None);
        }
        self.fn_sigs[def_idx] = Some(info);
    }

    /// Registers a struct definition for later lookup.
    pub fn register_struct(self: &mut Self, def_id: hir_def::DefId, name: common::Symbol, struct_def: &hir_item::StructDef) {
        // Extract field names and field info based on struct body
        let mut field_names: Vec<common::Symbol> = Vec::new();
        let mut fields: Vec<FieldInfo> = Vec::new();
        match &struct_def.body {
            &hir_item::StructBody::Record(ref struct_fields) => {
                let mut i: usize = 0;
                while i < struct_fields.len() {
                    let f = &struct_fields[i];
                    field_names.push(f.name.symbol);
                    let info = FieldInfo::new(f.name.symbol, hir_ty::copy_type(&f.ty));
                    fields.push(info);
                    i = i + 1;
                }
            }
            &hir_item::StructBody::Tuple(ref types) => {
                // Tuple structs don't have named fields
            }
            &hir_item::StructBody::Unit => {
                // Unit structs have no fields
            }
        }

        // Count generic parameters
        let num_generics = struct_def.generics.params.len() as u32;

        // Create the info
        let info = StructInfo::new(def_id, name, num_generics, field_names, fields);

        // Store at def_id.index
        let def_idx = def_id.index as usize;
        while self.structs.len() <= def_idx {
            self.structs.push(Option::None);
        }
        self.structs[def_idx] = Some(info);
    }

    /// Registers an enum definition for later lookup.
    pub fn register_enum(self: &mut Self, def_id: hir_def::DefId, name: common::Symbol, enum_def: &hir_item::EnumDef) {
        // Extract variant names and variant info
        let mut variant_names: Vec<common::Symbol> = Vec::new();
        let mut variants: Vec<VariantInfo> = Vec::new();
        let mut i: usize = 0;
        while i < enum_def.variants.len() {
            let v = &enum_def.variants[i];
            variant_names.push(v.name.symbol);

            // Extract field types based on variant kind
            let mut field_tys: Vec<hir_ty::Type> = Vec::new();
            match &v.kind {
                &hir_item::VariantKind::Unit => {
                    // No fields
                }
                &hir_item::VariantKind::Tuple(ref types) => {
                    let mut j: usize = 0;
                    while j < types.len() {
                        field_tys.push(hir_ty::copy_type(&types[j]));
                        j = j + 1;
                    }
                }
                &hir_item::VariantKind::Record(ref struct_fields) => {
                    // For record variants, store field types in order
                    let mut j: usize = 0;
                    while j < struct_fields.len() {
                        field_tys.push(hir_ty::copy_type(&struct_fields[j].ty));
                        j = j + 1;
                    }
                }
            }

            let info = VariantInfo::new(v.name.symbol, field_tys, i as u32);
            variants.push(info);
            i = i + 1;
        }

        // Count generic parameters
        let num_generics = enum_def.generics.params.len() as u32;

        // Create the info
        let info = EnumInfo::new(def_id, name, num_generics, variant_names, variants);

        // Store at def_id.index
        let def_idx = def_id.index as usize;
        while self.enums.len() <= def_idx {
            self.enums.push(Option::None);
        }
        self.enums[def_idx] = Some(info);
    }

    // ========================================================
    // Item Lookup
    // ========================================================

    /// Gets a function signature by DefId in O(1) time.
    pub fn get_fn_sig(self: &Self, def_id: hir_def::DefId) -> Option<&FnSigInfo> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.fn_sigs.len() {
            return Option::None;
        }
        match &self.fn_sigs[def_idx] {
            &Some(ref info) => Some(info),
            &None => Option::None,
        }
    }

    /// Gets a struct info by DefId in O(1) time.
    pub fn get_struct(self: &Self, def_id: hir_def::DefId) -> Option<&StructInfo> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.structs.len() {
            return Option::None;
        }
        match &self.structs[def_idx] {
            &Some(ref info) => Some(info),
            &None => Option::None,
        }
    }

    /// Gets an enum info by DefId in O(1) time.
    pub fn get_enum(self: &Self, def_id: hir_def::DefId) -> Option<&EnumInfo> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.enums.len() {
            return Option::None;
        }
        match &self.enums[def_idx] {
            &Some(ref info) => Some(info),
            &None => Option::None,
        }
    }

    /// Gets the field type for a struct field by name.
    pub fn get_struct_field_ty(self: &Self, def_id: hir_def::DefId, field_name: common::Symbol) -> Option<hir_ty::Type> {
        let struct_info = self.get_struct(def_id);
        match struct_info {
            Some(info) => {
                let mut i: usize = 0;
                while i < info.fields.len() {
                    if info.fields[i].name.index == field_name.index {
                        return Some(hir_ty::copy_type(&info.fields[i].ty));
                    }
                    i = i + 1;
                }
                Option::None
            }
            None => Option::None,
        }
    }

    /// Gets a const info by DefId in O(1) time.
    pub fn get_const(self: &Self, def_id: hir_def::DefId) -> Option<&ConstInfo> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.consts.len() {
            return Option::None;
        }
        match &self.consts[def_idx] {
            &Some(ref info) => Some(info),
            &None => Option::None,
        }
    }

    /// Gets a static info by DefId in O(1) time.
    pub fn get_static(self: &Self, def_id: hir_def::DefId) -> Option<&StaticInfo> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.statics.len() {
            return Option::None;
        }
        match &self.statics[def_idx] {
            &Some(ref info) => Some(info),
            &None => Option::None,
        }
    }

    /// Registers a constant definition for later lookup.
    pub fn register_const(self: &mut Self, def_id: hir_def::DefId, name: common::Symbol, ty: hir_ty::Type) {
        let info = ConstInfo::new(def_id, name, ty);
        let def_idx = def_id.index as usize;
        while self.consts.len() <= def_idx {
            self.consts.push(Option::None);
        }
        self.consts[def_idx] = Some(info);
    }

    /// Registers a static definition for later lookup.
    pub fn register_static(self: &mut Self, def_id: hir_def::DefId, name: common::Symbol, ty: hir_ty::Type, mutable: bool) {
        let info = StaticInfo::new(def_id, name, ty, mutable);
        let def_idx = def_id.index as usize;
        while self.statics.len() <= def_idx {
            self.statics.push(Option::None);
        }
        self.statics[def_idx] = Some(info);
    }

    /// Registers an impl block for method resolution.
    pub fn register_impl(self: &mut Self, impl_info: ImplInfo) {
        self.impls.push(impl_info);
    }

    /// Looks up a method on a type by name.
    /// Returns the method info and the impl it belongs to, or None if not found.
    pub fn lookup_method(self: &Self, ty: &hir_ty::Type, method_name: common::Symbol) -> Option<MethodLookupResult> {
        let mut impl_idx: usize = 0;
        while impl_idx < self.impls.len() {
            let impl_info = &self.impls[impl_idx];

            // Check if this impl's self_ty matches the target type
            if types_match_for_impl(&impl_info.self_ty, ty) {
                // Search methods in this impl
                let mut method_idx: usize = 0;
                while method_idx < impl_info.methods.len() {
                    let method = &impl_info.methods[method_idx];
                    if method.name.index == method_name.index {
                        return Some(MethodLookupResult {
                            impl_index: impl_idx,
                            method_index: method_idx,
                        });
                    }
                    method_idx = method_idx + 1;
                }
            }
            impl_idx = impl_idx + 1;
        }
        Option::None
    }

    /// Gets method info from a lookup result.
    pub fn get_method_from_lookup(self: &Self, result: &MethodLookupResult) -> &MethodInfo {
        &self.impls[result.impl_index].methods[result.method_index]
    }

    /// Gets the impl info from a lookup result.
    pub fn get_impl_from_lookup(self: &Self, result: &MethodLookupResult) -> &ImplInfo {
        &self.impls[result.impl_index]
    }

    /// Gets a variant's index by name within an enum.
    pub fn get_variant_index(self: &Self, enum_def_id: hir_def::DefId, variant_name: common::Symbol) -> Option<u32> {
        let enum_info = self.get_enum(enum_def_id);
        match enum_info {
            Some(info) => {
                let mut i: usize = 0;
                while i < info.variants.len() {
                    if info.variants[i].name.index == variant_name.index {
                        return Some(info.variants[i].variant_index);
                    }
                    i = i + 1;
                }
                Option::None
            }
            None => Option::None,
        }
    }

    // ========================================================
    // Trait Registration and Resolution
    // ========================================================

    /// Registers a trait definition for later lookup.
    pub fn register_trait(self: &mut Self, def_id: hir_def::DefId, info: TraitInfo) {
        let def_idx = def_id.index as usize;
        while self.traits.len() <= def_idx {
            self.traits.push(Option::None);
        }
        self.traits[def_idx] = Some(info);
    }

    /// Gets a trait definition by DefId.
    pub fn get_trait(self: &Self, def_id: hir_def::DefId) -> Option<&TraitInfo> {
        let def_idx = def_id.index as usize;
        if def_idx < self.traits.len() {
            match &self.traits[def_idx] {
                &Option::Some(ref info) => Some(info),
                &Option::None => Option::None,
            }
        } else {
            Option::None
        }
    }

    /// Registers a trait implementation.
    pub fn register_trait_impl(self: &mut Self, impl_info: TraitImplInfo) {
        self.trait_impls.push(impl_info);
    }

    /// Checks if a type implements a trait.
    /// Returns true if an implementation exists.
    pub fn type_implements_trait(self: &Self, ty: &hir_ty::Type, trait_ref: &hir_ty::TraitRef) -> bool {
        // Search for an impl that matches
        let mut i: usize = 0;
        while i < self.trait_impls.len() {
            let impl_info = &self.trait_impls[i];

            // Check if this impl is for the right trait
            if impl_info.trait_def_id.index == trait_ref.def_id.index {
                // Check if the self type matches
                if types_match_for_impl(&impl_info.self_ty, ty) {
                    // For now, we don't check where clause predicates
                    // A full implementation would recursively check them
                    return true;
                }
            }
            i = i + 1;
        }
        false
    }

    /// Resolves an obligation (checks if a predicate is satisfied).
    /// Returns true if the obligation is satisfied.
    pub fn resolve_obligation(self: &Self, obligation: &Obligation) -> bool {
        match &obligation.predicate {
            &Predicate::Trait(ref trait_ref) => {
                // For trait bounds, we need to find an impl
                // The trait ref contains the type parameter that must implement the trait
                // For now, we check if any impl exists for the trait
                self.has_impl_for_trait(trait_ref.def_id)
            }
            &Predicate::TypeEqual { ref left, ref right } => {
                // For type equality, types must unify
                // We can't mutate here, so do a simple structural check
                types_structurally_equal(left, right)
            }
            &Predicate::WellFormed(_) => {
                // WF predicates are assumed satisfied for now
                true
            }
        }
    }

    /// Checks if any implementation exists for a trait.
    fn has_impl_for_trait(self: &Self, trait_def_id: hir_def::DefId) -> bool {
        let mut i: usize = 0;
        while i < self.trait_impls.len() {
            if self.trait_impls[i].trait_def_id.index == trait_def_id.index {
                return true;
            }
            i = i + 1;
        }
        false
    }

    /// Collects obligations from a function call based on where clauses.
    /// Returns obligations that must be satisfied.
    pub fn collect_call_obligations(
        self: &Self,
        fn_sig: &FnSigInfo,
        type_args: &Vec<hir_ty::Type>,
        span: common::Span,
    ) -> Vec<Obligation> {
        let mut obligations: Vec<Obligation> = Vec::new();

        // Check where predicates (would be stored in FnSigInfo if we extended it)
        // For now, create obligations for each type argument implementing basic traits
        // This is a simplified implementation

        let _ = fn_sig;
        let _ = type_args;
        let _ = span;

        obligations
    }

    /// Checks all collected obligations and reports errors for unsatisfied ones.
    pub fn check_obligations(self: &mut Self, obligations: &Vec<Obligation>) {
        let mut i: usize = 0;
        while i < obligations.len() {
            if !self.resolve_obligation(&obligations[i]) {
                // Report error for unsatisfied obligation
                self.error(TypeErrorKind::TraitNotImplemented, obligations[i].span);
            }
            i = i + 1;
        }
    }
}

/// Result of a method lookup.
pub struct MethodLookupResult {
    /// Index into the impls vector.
    pub impl_index: usize,
    /// Index into the impl's methods vector.
    pub method_index: usize,
}

/// Checks if a type matches an impl's self type for method lookup.
/// This handles basic cases; generic matching requires instantiation.
fn types_match_for_impl(impl_ty: &hir_ty::Type, target_ty: &hir_ty::Type) -> bool {
    match (&impl_ty.kind, &target_ty.kind) {
        // ADT types match if same def_id (generic args checked during instantiation)
        (&hir_ty::TypeKind::Adt { def_id: impl_def, args: _ }, &hir_ty::TypeKind::Adt { def_id: target_def, args: _ }) => {
            impl_def.index == target_def.index
        }
        // Primitive types must match exactly
        (&hir_ty::TypeKind::Primitive(impl_prim), &hir_ty::TypeKind::Primitive(target_prim)) => {
            unify::primitives_equal(impl_prim, target_prim)
        }
        // Reference types - check inner type
        (&hir_ty::TypeKind::Ref { ref inner, mutable: impl_mut }, &hir_ty::TypeKind::Ref { inner: ref target_inner, mutable: target_mut }) => {
            impl_mut == target_mut && types_match_for_impl(inner.as_ref(), target_inner.as_ref())
        }
        // Slice types
        (&hir_ty::TypeKind::Slice { ref element }, &hir_ty::TypeKind::Slice { element: ref target_elem }) => {
            types_match_for_impl(element.as_ref(), target_elem.as_ref())
        }
        // Array types
        (&hir_ty::TypeKind::Array { ref element, size }, &hir_ty::TypeKind::Array { element: ref target_elem, size: target_size }) => {
            size == target_size && types_match_for_impl(element.as_ref(), target_elem.as_ref())
        }
        // Inference variables match anything (will be constrained during checking)
        (&hir_ty::TypeKind::Infer(_), _) => true,
        (_, &hir_ty::TypeKind::Infer(_)) => true,
        // Other combinations don't match
        _ => false,
    }
}

/// Checks if two types are structurally equal (for obligation resolution).
/// This is a simplified check that doesn't handle inference variables.
fn types_structurally_equal(a: &hir_ty::Type, b: &hir_ty::Type) -> bool {
    match (&a.kind, &b.kind) {
        (&hir_ty::TypeKind::Never, &hir_ty::TypeKind::Never) => true,
        (&hir_ty::TypeKind::Error, &hir_ty::TypeKind::Error) => true,
        (&hir_ty::TypeKind::Primitive(ref pa), &hir_ty::TypeKind::Primitive(ref pb)) => {
            unify::primitives_equal(*pa, *pb)
        }
        (&hir_ty::TypeKind::Tuple(ref elems_a), &hir_ty::TypeKind::Tuple(ref elems_b)) => {
            if elems_a.len() != elems_b.len() {
                return false;
            }
            let mut i: usize = 0;
            while i < elems_a.len() {
                if !types_structurally_equal(&elems_a[i], &elems_b[i]) {
                    return false;
                }
                i = i + 1;
            }
            true
        }
        (&hir_ty::TypeKind::Ref { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ref { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_structurally_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Ptr { ref inner, mutable: ma },
         &hir_ty::TypeKind::Ptr { inner: ref inner_b, mutable: mb }) => {
            ma == mb && types_structurally_equal(inner.as_ref(), inner_b.as_ref())
        }
        (&hir_ty::TypeKind::Array { ref element, size: sa },
         &hir_ty::TypeKind::Array { element: ref elem_b, size: sb }) => {
            sa == sb && types_structurally_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Slice { ref element },
         &hir_ty::TypeKind::Slice { element: ref elem_b }) => {
            types_structurally_equal(element.as_ref(), elem_b.as_ref())
        }
        (&hir_ty::TypeKind::Adt { def_id: da, ref args },
         &hir_ty::TypeKind::Adt { def_id: db, args: ref args_b }) => {
            if da.index != db.index {
                return false;
            }
            if args.len() != args_b.len() {
                return false;
            }
            let mut i: usize = 0;
            while i < args.len() {
                if !types_structurally_equal(&args[i], &args_b[i]) {
                    return false;
                }
                i = i + 1;
            }
            true
        }
        _ => false,
    }
}

// ============================================================
// Pattern Exhaustiveness Checking Implementation
// ============================================================

/// Checks if a set of match arms is exhaustive for a given type.
/// Returns ExhaustivenessResult indicating whether patterns cover all cases.
pub fn check_exhaustiveness_arms(
    checker: &mut TypeChecker,
    scrutinee_ty: &hir_ty::Type,
    arms: &Vec<hir_expr::MatchArm>,
    _span: common::Span,
) -> ExhaustivenessResult {
    // Convert HIR patterns to deconstructed patterns
    let mut matrix = PatternMatrix::new(1);

    let mut i: usize = 0;
    while i < arms.len() {
        let decon = deconstruct_pattern(checker, &arms[i].pattern);
        let row = PatternRow::new(vec_of_one(decon));
        matrix.push_row(row);
        i = i + 1;
    }

    // Check if the matrix is exhaustive
    let witnesses = compute_witnesses(checker, scrutinee_ty, &matrix);

    if witnesses.len() == 0 {
        ExhaustivenessResult::Exhaustive
    } else {
        ExhaustivenessResult::NonExhaustive(witnesses)
    }
}

/// Converts an HIR pattern to a deconstructed pattern.
fn deconstruct_pattern(checker: &mut TypeChecker, pattern: &hir_expr::Pattern) -> DeconstructedPattern {
    match &pattern.kind {
        &hir_expr::PatternKind::Wildcard => DeconstructedPattern::Wildcard,
        &hir_expr::PatternKind::Binding { local_id: _, ref name, mode: _, ref subpattern } => {
            // Binding acts as wildcard unless it has a sub-pattern
            let _ = name;
            match subpattern {
                &Option::Some(ref sub) => deconstruct_pattern(checker, sub.as_ref()),
                &Option::None => DeconstructedPattern::Wildcard,
            }
        }
        &hir_expr::PatternKind::Literal(ref lit) => {
            deconstruct_literal(lit)
        }
        &hir_expr::PatternKind::Tuple(ref pats) => {
            let mut fields: Vec<DeconstructedPattern> = Vec::new();
            let mut i: usize = 0;
            while i < pats.len() {
                fields.push(deconstruct_pattern(checker, &pats[i]));
                i = i + 1;
            }
            DeconstructedPattern::Tuple { fields: fields }
        }
        &hir_expr::PatternKind::Struct { ref path, ref fields, has_rest } => {
            // Extract the DefId directly from ResolvedPath
            let def_id = path.def_id;
            let mut field_pats: Vec<DeconstructedPattern> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                field_pats.push(deconstruct_pattern(checker, &fields[i].pattern));
                i = i + 1;
            }
            // If there's a rest pattern (..), patterns not listed are wildcards
            let _ = has_rest;
            DeconstructedPattern::Struct { def_id: def_id, fields: field_pats }
        }
        &hir_expr::PatternKind::TupleStruct { ref path, ref fields } => {
            // Tuple struct pattern - could be enum variant with fields
            let def_id = path.def_id;
            let variant_idx = match path.variant_index {
                Option::Some(idx) => idx,
                Option::None => 0,
            };
            let mut field_pats: Vec<DeconstructedPattern> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                field_pats.push(deconstruct_pattern(checker, &fields[i]));
                i = i + 1;
            }
            DeconstructedPattern::Variant { def_id: def_id, variant_idx: variant_idx, fields: field_pats }
        }
        &hir_expr::PatternKind::Or(ref pats) => {
            let mut alts: Vec<DeconstructedPattern> = Vec::new();
            let mut i: usize = 0;
            while i < pats.len() {
                alts.push(deconstruct_pattern(checker, &pats[i]));
                i = i + 1;
            }
            DeconstructedPattern::Or { pats: alts }
        }
        &hir_expr::PatternKind::Ref { ref inner, mutable: _ } => {
            // Reference pattern - unwrap and deconstruct the inner pattern
            deconstruct_pattern(checker, inner.as_ref())
        }
        &hir_expr::PatternKind::Range { ref start, ref end_val, inclusive: _ } => {
            // Range patterns are complex - treat as partial coverage for now
            let _ = start;
            let _ = end_val;
            DeconstructedPattern::Missing
        }
        &hir_expr::PatternKind::Slice { ref prefix, ref rest, ref suffix } => {
            // Slice patterns - simplified handling
            let _ = prefix;
            let _ = rest;
            let _ = suffix;
            DeconstructedPattern::Wildcard
        }
        &hir_expr::PatternKind::Path(ref path) => {
            // Path patterns (could be enum variant or const)
            let def_id = path.def_id;
            let variant_idx = match path.variant_index {
                Option::Some(idx) => idx,
                Option::None => 0,
            };
            DeconstructedPattern::Variant { def_id: def_id, variant_idx: variant_idx, fields: Vec::new() }
        }
        &hir_expr::PatternKind::Rest => {
            // Rest pattern (..) - matches any number of elements
            DeconstructedPattern::Wildcard
        }
        &hir_expr::PatternKind::Error => {
            // Error pattern - treat as wildcard for recovery
            DeconstructedPattern::Wildcard
        }
    }
}

/// Converts a literal to a deconstructed pattern.
fn deconstruct_literal(lit: &hir_expr::Literal) -> DeconstructedPattern {
    match &lit.kind {
        &hir_expr::LiteralKind::Int { val, ty: _ } => {
            DeconstructedPattern::Literal { value: val as i128 }
        }
        &hir_expr::LiteralKind::Bool(b) => {
            let value = if b { 1i128 } else { 0i128 };
            DeconstructedPattern::Literal { value: value }
        }
        &hir_expr::LiteralKind::Char(c) => {
            DeconstructedPattern::Literal { value: c as i128 }
        }
        &hir_expr::LiteralKind::Float { bits: _, ty: _ } => {
            // Float patterns - treat as partial
            DeconstructedPattern::Missing
        }
        &hir_expr::LiteralKind::Str(_) => {
            // String patterns - treat as partial
            DeconstructedPattern::Missing
        }
        &hir_expr::LiteralKind::ByteStr(_) => {
            DeconstructedPattern::Missing
        }
    }
}

/// Computes witnesses for non-exhaustiveness.
/// Returns empty vector if patterns are exhaustive.
fn compute_witnesses(
    checker: &mut TypeChecker,
    scrutinee_ty: &hir_ty::Type,
    matrix: &PatternMatrix,
) -> Vec<Witness> {
    // For exhaustiveness, we need to check if every possible constructor of
    // the scrutinee type is covered by the pattern matrix.

    // Get all constructors for the type
    let constructors = get_type_constructors(checker, scrutinee_ty);

    // If no constructors, the type is uninhabited (like Never)
    if constructors.len() == 0 {
        return Vec::new(); // Exhaustive by vacuity
    }

    let mut witnesses: Vec<Witness> = Vec::new();

    // For each constructor, check if it's covered
    let mut i: usize = 0;
    while i < constructors.len() {
        let ctor = &constructors[i];

        // Check if this constructor is matched by any row in the matrix
        if !constructor_is_covered(matrix, ctor) {
            // This constructor is not covered - it's a witness
            witnesses.push(Witness::new(clone_string_helper(&ctor.description)));
        }
        i = i + 1;
    }

    witnesses
}

/// A constructor for a type (represents one way to create a value).
struct Constructor {
    /// Description of this constructor for error messages.
    description: String,
    /// For enum variants, the variant index.
    variant_idx: Option<u32>,
    /// For literals, the specific value (if finite).
    literal_value: Option<i128>,
}

impl Constructor {
    fn new(description: String) -> Constructor {
        Constructor {
            description: description,
            variant_idx: Option::None,
            literal_value: Option::None,
        }
    }

    fn variant(name: String, idx: u32) -> Constructor {
        Constructor {
            description: name,
            variant_idx: Option::Some(idx),
            literal_value: Option::None,
        }
    }
}

/// Gets all constructors for a type.
fn get_type_constructors(checker: &mut TypeChecker, ty: &hir_ty::Type) -> Vec<Constructor> {
    let mut ctors: Vec<Constructor> = Vec::new();

    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => {
            match prim {
                &hir_ty::PrimitiveTy::Bool => {
                    // Bool has two constructors: true and false
                    ctors.push(Constructor::new(common::make_string("true")));
                    ctors.push(Constructor::new(common::make_string("false")));
                }
                _ => {
                    // Other primitives (integers, etc.) have infinite constructors
                    // Treat as single wildcard constructor for simplicity
                    ctors.push(Constructor::new(common::make_string("_")));
                }
            }
        }
        &hir_ty::TypeKind::Adt { def_id, args: _ } => {
            // Check if it's an enum
            match checker.get_enum(def_id) {
                Option::Some(enum_info) => {
                    // Add one constructor per variant
                    let mut i: usize = 0;
                    while i < enum_info.variants.len() {
                        let variant = &enum_info.variants[i];
                        let mut name = common::make_string("");
                        // Note: We'd need to convert Symbol to String here
                        // For now, use a placeholder
                        name.push_str("Variant");
                        let idx_str = usize_to_string(i);
                        name.push_str(idx_str.as_str());
                        ctors.push(Constructor::variant(name, variant.variant_index));
                        i = i + 1;
                    }
                }
                Option::None => {
                    // It's a struct - single constructor
                    ctors.push(Constructor::new(common::make_string("_")));
                }
            }
        }
        &hir_ty::TypeKind::Tuple(_) => {
            // Tuple has single constructor
            ctors.push(Constructor::new(common::make_string("(..)")));
        }
        &hir_ty::TypeKind::Never => {
            // Never type has no constructors (uninhabited)
        }
        _ => {
            // Other types - treat as single wildcard
            ctors.push(Constructor::new(common::make_string("_")));
        }
    }

    ctors
}

/// Checks if a constructor is covered by the pattern matrix.
fn constructor_is_covered(matrix: &PatternMatrix, ctor: &Constructor) -> bool {
    // A constructor is covered if some row in the matrix matches it
    let mut i: usize = 0;
    while i < matrix.rows.len() {
        if matrix.width > 0 {
            let first_pat = &matrix.rows[i].patterns[0];
            if pattern_matches_constructor(first_pat, ctor) {
                return true;
            }
        }
        i = i + 1;
    }
    false
}

/// Checks if a pattern matches a constructor.
fn pattern_matches_constructor(pat: &DeconstructedPattern, ctor: &Constructor) -> bool {
    match pat {
        &DeconstructedPattern::Wildcard => true,
        &DeconstructedPattern::Variant { def_id: _, variant_idx, fields: _ } => {
            match ctor.variant_idx {
                Option::Some(ctor_idx) => variant_idx == ctor_idx,
                Option::None => false,
            }
        }
        &DeconstructedPattern::Literal { value } => {
            match ctor.literal_value {
                Option::Some(ctor_val) => value == ctor_val,
                Option::None => true, // Literal matches wildcard constructor
            }
        }
        &DeconstructedPattern::Struct { def_id: _, fields: _ } => {
            // Struct pattern matches single struct constructor
            ctor.variant_idx.is_none()
        }
        &DeconstructedPattern::Tuple { fields: _ } => {
            // Tuple pattern matches tuple constructor
            true
        }
        &DeconstructedPattern::Or { ref pats } => {
            // Or pattern matches if any alternative matches
            let mut i: usize = 0;
            while i < pats.len() {
                if pattern_matches_constructor(&pats[i], ctor) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &DeconstructedPattern::Missing => false,
    }
}

/// Creates a Vec with a single element.
fn vec_of_one(p: DeconstructedPattern) -> Vec<DeconstructedPattern> {
    let mut v: Vec<DeconstructedPattern> = Vec::new();
    v.push(p);
    v
}

/// Clones a String (helper function).
fn clone_string_helper(s: &String) -> String {
    let mut result = String::new();
    let bytes = s.as_bytes();
    let mut i: usize = 0;
    while i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Converts a usize to a String.
fn usize_to_string(n: usize) -> String {
    if n == 0 {
        return common::make_string("0");
    }

    let mut result = String::new();
    let mut num = n;
    let mut digits: Vec<char> = Vec::new();

    while num > 0 {
        let digit = (num % 10) as u8;
        digits.push((digit + 48) as char); // 48 is ASCII '0'
        num = num / 10;
    }

    // Reverse the digits
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        result.push(digits[i]);
    }

    result
}
