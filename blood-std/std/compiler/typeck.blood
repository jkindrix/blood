// Blood Self-Hosted Compiler - Type Checking
//
// This module implements type checking and inference for the HIR.
// Type checking validates that expressions have compatible types and
// infers types where they are not explicitly annotated.
//
// Note: Due to blood-rust limitations with Vec<T> type inference on
// struct field operations, the full type checking implementation is
// deferred. This module defines the types and structures needed.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir;
mod unify;

// ============================================================
// Type Context
// ============================================================

/// The context for type checking a function or closure.
///
/// Note: Methods that modify Vec fields are omitted due to blood-rust
/// limitations. The actual type checking implementation will be added
/// when the compiler supports this pattern.
pub struct TypeContext {
    /// Counter for generating fresh type variables.
    pub next_ty_var: u32,
    /// The expected return type of the current function.
    pub return_ty: Option<hir_ty::Type>,
    /// The current function's DefId.
    pub current_fn: Option<hir_def::DefId>,
    /// Whether we're in a loop (for break/continue checking).
    pub in_loop: bool,
    /// The type of the current loop (for break value checking).
    pub loop_ty: Option<hir_ty::Type>,
}

impl TypeContext {
    /// Creates a new type context.
    pub fn new() -> TypeContext {
        TypeContext {
            next_ty_var: 0,
            return_ty: None,
            current_fn: None,
            in_loop: false,
            loop_ty: None,
        }
    }

    /// Generates a fresh type variable.
    pub fn fresh_ty_var(self: &mut Self) -> hir_def::TyVarId {
        let id = hir_def::TyVarId::new(self.next_ty_var);
        self.next_ty_var = self.next_ty_var + 1;
        id
    }

    /// Creates a fresh inference type.
    pub fn fresh_infer(self: &mut Self) -> hir_ty::Type {
        hir_ty::Type::infer(self.fresh_ty_var())
    }

    /// Sets the return type for the current function.
    pub fn set_return_ty(self: &mut Self, ty: hir_ty::Type) {
        self.return_ty = Some(ty);
    }

    /// Enters a loop context.
    pub fn enter_loop(self: &mut Self, ty: hir_ty::Type) {
        self.in_loop = true;
        self.loop_ty = Some(ty);
    }

    /// Exits a loop context.
    pub fn exit_loop(self: &mut Self) {
        self.in_loop = false;
        self.loop_ty = None;
    }
}

// ============================================================
// Type Error
// ============================================================

/// A type checking error.
pub struct TypeError {
    /// The kind of type error.
    pub kind: TypeErrorKind,
    /// The span where the error occurred.
    pub span: common::Span,
    /// Additional notes for the error.
    pub notes: Vec<TypeNote>,
}

impl TypeError {
    /// Creates a new type error.
    pub fn new(kind: TypeErrorKind, span: common::Span) -> TypeError {
        TypeError {
            kind: kind,
            span: span,
            notes: Vec::new(),
        }
    }

    /// Creates a type mismatch error.
    pub fn mismatch(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::TypeMismatch, span)
    }

    /// Creates an undefined variable error.
    pub fn undefined(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::UndefinedVariable, span)
    }

    /// Creates an invalid call error.
    pub fn not_callable(span: common::Span) -> TypeError {
        TypeError::new(TypeErrorKind::NotCallable, span)
    }
}

/// The kind of type error.
pub enum TypeErrorKind {
    /// Types don't match.
    TypeMismatch,
    /// Cannot infer type.
    CannotInfer,
    /// Undefined variable.
    UndefinedVariable,
    /// Undefined function.
    UndefinedFunction,
    /// Wrong number of arguments.
    ArityMismatch,
    /// Expression is not callable.
    NotCallable,
    /// Expression is not indexable.
    NotIndexable,
    /// Field does not exist.
    NoSuchField,
    /// Method does not exist.
    NoSuchMethod,
    /// Cannot mutate immutable.
    CannotMutate,
    /// Invalid assignment target.
    InvalidLValue,
    /// Missing return value.
    MissingReturn,
    /// Type does not implement trait.
    TraitNotImplemented,
    /// Effect not handled.
    UnhandledEffect,
    /// Invalid break/continue.
    InvalidControl,
    /// Pattern type mismatch.
    PatternMismatch,
    /// Non-exhaustive patterns.
    NonExhaustive,
    /// Recursive type without indirection.
    InfiniteType,
    /// Invalid cast.
    InvalidCast,
}

/// A note attached to a type error.
pub struct TypeNote {
    /// The note message.
    pub message: String,
    /// Optional span for the note.
    pub span: Option<common::Span>,
}

impl TypeNote {
    /// Creates a new type note.
    pub fn new(message: String) -> TypeNote {
        TypeNote {
            message: message,
            span: None,
        }
    }

    /// Creates a type note with a span.
    pub fn with_span(message: String, span: common::Span) -> TypeNote {
        TypeNote {
            message: message,
            span: Some(span),
        }
    }
}

// ============================================================
// Type Information
// ============================================================

/// Information about a struct for type checking.
pub struct StructInfo {
    /// The DefId of the struct.
    pub def_id: hir_def::DefId,
    /// The name of the struct.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Field names (in order).
    pub field_names: Vec<common::Symbol>,
}

impl StructInfo {
    /// Creates new struct info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        field_names: Vec<common::Symbol>,
    ) -> StructInfo {
        StructInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            field_names: field_names,
        }
    }
}

/// Information about an enum for type checking.
pub struct EnumInfo {
    /// The DefId of the enum.
    pub def_id: hir_def::DefId,
    /// The name of the enum.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Variant names (in order).
    pub variant_names: Vec<common::Symbol>,
}

impl EnumInfo {
    /// Creates new enum info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        variant_names: Vec<common::Symbol>,
    ) -> EnumInfo {
        EnumInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            variant_names: variant_names,
        }
    }
}

/// Information about a function for type checking.
pub struct FnInfo {
    /// The DefId of the function.
    pub def_id: hir_def::DefId,
    /// The name of the function.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Number of parameters.
    pub num_params: u32,
    /// Whether the function is const.
    pub is_const: bool,
    /// Whether the function is unsafe.
    pub is_unsafe: bool,
}

impl FnInfo {
    /// Creates new function info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        num_params: u32,
        is_const: bool,
        is_unsafe: bool,
    ) -> FnInfo {
        FnInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            num_params: num_params,
            is_const: is_const,
            is_unsafe: is_unsafe,
        }
    }
}

/// Information about an effect for type checking.
pub struct EffectInfo {
    /// The DefId of the effect.
    pub def_id: hir_def::DefId,
    /// The name of the effect.
    pub name: common::Symbol,
    /// Number of generic parameters.
    pub num_generics: u32,
    /// Operation names.
    pub op_names: Vec<common::Symbol>,
}

impl EffectInfo {
    /// Creates new effect info.
    pub fn new(
        def_id: hir_def::DefId,
        name: common::Symbol,
        num_generics: u32,
        op_names: Vec<common::Symbol>,
    ) -> EffectInfo {
        EffectInfo {
            def_id: def_id,
            name: name,
            num_generics: num_generics,
            op_names: op_names,
        }
    }
}

// ============================================================
// Type Checking Mode
// ============================================================

/// The mode for type checking an expression.
pub enum CheckMode {
    /// Infer the type (no expectation).
    Infer,
    /// Check against an expected type.
    Check(hir_ty::Type),
    /// Coerce to an expected type (allows implicit conversions).
    Coerce(hir_ty::Type),
}

impl CheckMode {
    /// Creates an inference mode.
    pub fn infer() -> CheckMode {
        CheckMode::Infer
    }

    /// Creates a checking mode with the given expected type.
    pub fn check(ty: hir_ty::Type) -> CheckMode {
        CheckMode::Check(ty)
    }

    /// Creates a coercion mode with the given target type.
    pub fn coerce(ty: hir_ty::Type) -> CheckMode {
        CheckMode::Coerce(ty)
    }
}

// ============================================================
// Coercion
// ============================================================

/// A type coercion.
pub enum Coercion {
    /// No coercion needed.
    None,
    /// Dereference coercion: &T -> &U where T: Deref<Target=U>
    Deref,
    /// Reference coercion: &T -> &U where T <: U
    RefCoerce,
    /// Unsizing coercion: [T; N] -> [T], Sized -> ?Sized
    Unsize,
    /// Function pointer coercion: fn item -> fn pointer
    FnPointer,
    /// Closure coercion: closure -> fn pointer (when captures empty)
    ClosureToFnPtr,
    /// Never coercion: ! -> T
    NeverToAny,
}

/// Result of attempting a coercion.
pub enum CoercionResult {
    /// Coercion succeeded.
    Ok(Coercion),
    /// Coercion failed.
    Err,
}

// ============================================================
// Exhaustiveness Checking
// ============================================================

/// A witness for non-exhaustiveness (a pattern not covered).
pub struct Witness {
    /// The pattern that isn't covered.
    pub description: String,
}

impl Witness {
    /// Creates a new witness.
    pub fn new(description: String) -> Witness {
        Witness {
            description: description,
        }
    }
}

/// Result of exhaustiveness checking.
pub enum ExhaustivenessResult {
    /// Patterns are exhaustive.
    Exhaustive,
    /// Patterns are not exhaustive, with witnesses.
    NonExhaustive(Vec<Witness>),
}

// ============================================================
// Type Checking Results
// ============================================================

/// Result of type checking a single item.
pub enum ItemCheckResult {
    /// Type checking succeeded.
    Ok,
    /// Type checking failed with errors.
    Err,
}

/// Result of type checking a crate.
pub struct CrateCheckResult {
    /// Whether type checking succeeded overall.
    pub success: bool,
    /// Number of errors.
    pub error_count: u32,
    /// Number of warnings.
    pub warning_count: u32,
}

impl CrateCheckResult {
    /// Creates a successful result.
    pub fn ok() -> CrateCheckResult {
        CrateCheckResult {
            success: true,
            error_count: 0,
            warning_count: 0,
        }
    }

    /// Creates a failed result.
    pub fn failed(error_count: u32) -> CrateCheckResult {
        CrateCheckResult {
            success: false,
            error_count: error_count,
            warning_count: 0,
        }
    }
}

// ============================================================
// Obligation
// ============================================================

/// A trait obligation that needs to be resolved.
pub struct Obligation {
    /// The predicate (trait bound) that must hold.
    pub predicate: Predicate,
    /// The span where this obligation was created.
    pub span: common::Span,
    /// The cause of this obligation.
    pub cause: ObligationCause,
}

impl Obligation {
    /// Creates a new obligation.
    pub fn new(predicate: Predicate, span: common::Span, cause: ObligationCause) -> Obligation {
        Obligation {
            predicate: predicate,
            span: span,
            cause: cause,
        }
    }
}

/// A predicate that must be satisfied.
pub enum Predicate {
    /// A trait bound: T: Trait
    Trait(hir_ty::TraitRef),
    /// A type equality: T == U
    TypeEqual {
        left: hir_ty::Type,
        right: hir_ty::Type,
    },
    /// A well-formed type: WF(T)
    WellFormed(hir_ty::Type),
}

/// The cause of an obligation.
pub enum ObligationCause {
    /// From an explicit where clause.
    WhereClause,
    /// From a function argument type.
    FnArgument,
    /// From a function return type.
    FnReturn,
    /// From a struct field.
    FieldType,
    /// From a method call.
    MethodCall,
    /// From an operator.
    Operator,
    /// From a cast.
    Cast,
    /// From type coercion.
    Coercion,
    /// From pattern matching.
    Pattern,
}

// ============================================================
// Local Variable Info
// ============================================================

/// Information about a local variable for type checking.
pub struct LocalInfo {
    /// The local variable's type.
    pub ty: hir_ty::Type,
    /// Whether the local is mutable.
    pub mutable: bool,
    /// The span where the local was declared.
    pub span: common::Span,
}

impl LocalInfo {
    /// Creates new local info.
    pub fn new(ty: hir_ty::Type, mutable: bool, span: common::Span) -> LocalInfo {
        LocalInfo {
            ty: ty,
            mutable: mutable,
            span: span,
        }
    }
}

// ============================================================
// Type Checker
// ============================================================

/// The main type checker.
///
/// This struct coordinates type checking for an entire HIR crate.
/// It maintains:
/// - Substitution table for type unification
/// - Type variable generator
/// - Current function context
/// - Errors collected during type checking
pub struct TypeChecker {
    /// Substitution table for type unification.
    pub subst_table: unify::SubstTable,
    /// Unifier for generating fresh type variables.
    pub unifier: unify::Unifier,
    /// Current function's return type.
    pub return_ty: Option<hir_ty::Type>,
    /// Whether we're currently in a loop.
    pub in_loop: bool,
    /// Type of the current loop (for break values).
    pub loop_ty: Option<hir_ty::Type>,
    /// Local variable types by LocalId index.
    pub locals: Vec<LocalInfo>,
    /// Type errors collected during checking.
    pub errors: Vec<TypeError>,
}

impl TypeChecker {
    /// Creates a new type checker.
    pub fn new() -> TypeChecker {
        TypeChecker {
            subst_table: unify::SubstTable::new(),
            unifier: unify::Unifier::new(),
            return_ty: Option::None,
            in_loop: false,
            loop_ty: Option::None,
            locals: Vec::new(),
            errors: Vec::new(),
        }
    }

    /// Generates a fresh inference type variable.
    pub fn fresh_infer(self: &mut Self) -> hir_ty::Type {
        self.unifier.fresh_infer()
    }

    /// Adds a local variable to the context.
    pub fn add_local(self: &mut Self, ty: hir_ty::Type, mutable: bool, span: common::Span) -> hir_def::LocalId {
        let id = hir_def::LocalId::new(self.locals.len() as u32);
        let info = LocalInfo::new(ty, mutable, span);
        self.locals.push(info);
        id
    }

    /// Gets the type of a local variable.
    pub fn get_local_ty(self: &Self, id: hir_def::LocalId) -> Option<hir_ty::Type> {
        let idx = id.index as usize;
        if idx < self.locals.len() {
            Some(copy_type(&self.locals[idx].ty))
        } else {
            Option::None
        }
    }

    /// Checks if a local variable is mutable.
    pub fn is_local_mutable(self: &Self, id: hir_def::LocalId) -> bool {
        let idx = id.index as usize;
        if idx < self.locals.len() {
            self.locals[idx].mutable
        } else {
            false
        }
    }

    /// Sets the return type for the current function.
    pub fn set_return_ty(self: &mut Self, ty: hir_ty::Type) {
        self.return_ty = Some(ty);
    }

    /// Clears the return type when exiting a function.
    pub fn clear_return_ty(self: &mut Self) {
        self.return_ty = Option::None;
    }

    /// Enters a loop context.
    pub fn enter_loop(self: &mut Self, ty: hir_ty::Type) {
        self.in_loop = true;
        self.loop_ty = Some(ty);
    }

    /// Exits a loop context.
    pub fn exit_loop(self: &mut Self) {
        self.in_loop = false;
        self.loop_ty = Option::None;
    }

    /// Reports a type error.
    pub fn error(self: &mut Self, kind: TypeErrorKind, span: common::Span) {
        let err = TypeError::new(kind, span);
        self.errors.push(err);
    }

    /// Returns whether any errors have been reported.
    pub fn has_errors(self: &Self) -> bool {
        self.errors.len() > 0
    }

    /// Unifies two types.
    pub fn unify(self: &mut Self, a: &hir_ty::Type, b: &hir_ty::Type, span: common::Span) -> bool {
        match unify::unify(&mut self.subst_table, &mut self.unifier, a, b, span) {
            unify::UnifyResult::Ok => true,
            unify::UnifyResult::Err(e) => {
                // Convert unify error to type error
                let kind = match e.kind {
                    unify::UnifyErrorKind::TypeMismatch => TypeErrorKind::TypeMismatch,
                    unify::UnifyErrorKind::OccursCheck => TypeErrorKind::InfiniteType,
                    unify::UnifyErrorKind::ArityMismatch => TypeErrorKind::ArityMismatch,
                    unify::UnifyErrorKind::EffectMismatch => TypeErrorKind::TypeMismatch,
                    unify::UnifyErrorKind::RecordMismatch => TypeErrorKind::TypeMismatch,
                };
                self.error(kind, e.span);
                false
            }
        }
    }

    /// Resolves a type by applying current substitutions.
    pub fn resolve(self: &Self, ty: &hir_ty::Type) -> hir_ty::Type {
        let table_ref: &unify::SubstTable = &self.subst_table;
        unify::apply_substs(table_ref, ty)
    }

    /// Clears local variables (for entering a new function body).
    pub fn clear_locals(self: &mut Self) {
        self.locals = Vec::new();
    }
}

// ============================================================
// Type Copying (for internal use)
// ============================================================

/// Creates a shallow copy of a type (Blood lacks Clone).
fn copy_type(ty: &hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type { kind: copy_type_kind(&ty.kind) }
}

/// Creates a copy of a TypeKind.
fn copy_type_kind(kind: &hir_ty::TypeKind) -> hir_ty::TypeKind {
    match kind {
        &hir_ty::TypeKind::Primitive(prim) => hir_ty::TypeKind::Primitive(prim),
        &hir_ty::TypeKind::Never => hir_ty::TypeKind::Never,
        &hir_ty::TypeKind::Error => hir_ty::TypeKind::Error,
        &hir_ty::TypeKind::Infer(var_id) => hir_ty::TypeKind::Infer(var_id),
        &hir_ty::TypeKind::Param(var_id) => hir_ty::TypeKind::Param(var_id),
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut copied: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                copied.push(copy_type(&types[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Tuple(copied)
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::TypeKind::Array {
                element: Box::new(copy_type(element.as_ref())),
                size: size,
            }
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::TypeKind::Slice {
                element: Box::new(copy_type(element.as_ref())),
            }
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::TypeKind::Ref {
                inner: Box::new(copy_type(inner.as_ref())),
                mutable: mutable,
            }
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::TypeKind::Ptr {
                inner: Box::new(copy_type(inner.as_ref())),
                mutable: mutable,
            }
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut copied_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                copied_args.push(copy_type(&args[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: copied_args,
            }
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut copied_params: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                copied_params.push(copy_type(&params[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Fn {
                params: copied_params,
                ret: Box::new(copy_type(ret.as_ref())),
                effects: copy_effect_row(effects),
            }
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut copied_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                copied_fields.push(hir_ty::RecordField::new(
                    fields[i].name,
                    copy_type(&fields[i].ty),
                ));
                i = i + 1;
            }
            hir_ty::TypeKind::Record {
                fields: copied_fields,
                row_var: *row_var,
            }
        }
    }
}

/// Creates a copy of an EffectRow.
fn copy_effect_row(row: &hir_ty::EffectRow) -> hir_ty::EffectRow {
    let mut copied_effects: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        let eff = &row.effects[i];
        let mut copied_args: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < eff.args.len() {
            copied_args.push(copy_type(&eff.args[j]));
            j = j + 1;
        }
        copied_effects.push(hir_ty::EffectRef {
            def_id: eff.def_id,
            args: copied_args,
        });
        i = i + 1;
    }
    hir_ty::EffectRow {
        effects: copied_effects,
        row_var: row.row_var,
    }
}
