// Blood Self-Hosted Compiler - Type Unification
//
// This module implements type unification using a union-find algorithm.
// Unification is the core operation of type inference - it makes two
// types equal by finding a substitution for type variables.
//
// Note: Due to blood-rust limitations with Vec<T> type inference on
// struct field operations, some methods are omitted. The types and
// core logic are defined for use by the type checker.

mod common;
mod hir_def;
mod hir_ty;

// ============================================================
// Unification Result
// ============================================================

/// Result of a unification operation.
pub enum UnifyResult {
    /// Unification succeeded.
    Ok,
    /// Unification failed with an error.
    Err(UnifyError),
}

/// An error during unification.
pub struct UnifyError {
    /// The kind of unification error.
    pub kind: UnifyErrorKind,
    /// The span where the error occurred.
    pub span: common::Span,
}

impl UnifyError {
    /// Creates a new unification error.
    pub fn new(kind: UnifyErrorKind, span: common::Span) -> UnifyError {
        UnifyError {
            kind: kind,
            span: span,
        }
    }

    /// Creates a type mismatch error.
    pub fn mismatch(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::TypeMismatch, span)
    }

    /// Creates an occurs check error.
    pub fn occurs(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::OccursCheck, span)
    }

    /// Creates an arity mismatch error.
    pub fn arity(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::ArityMismatch, span)
    }
}

/// The kind of unification error.
pub enum UnifyErrorKind {
    /// Types are incompatible.
    TypeMismatch,
    /// Occurs check failed (infinite type).
    OccursCheck,
    /// Different number of elements (tuple, function params).
    ArityMismatch,
    /// Effect sets are incompatible.
    EffectMismatch,
    /// Record fields don't match.
    RecordMismatch,
}

// ============================================================
// Type Variable Substitution
// ============================================================

/// A substitution entry mapping a type variable to its value.
pub struct TySubst {
    /// The type variable being substituted.
    pub var_id: hir_def::TyVarId,
    /// The type it maps to.
    pub ty: hir_ty::Type,
}

impl TySubst {
    /// Creates a new type substitution.
    pub fn new(var_id: hir_def::TyVarId, ty: hir_ty::Type) -> TySubst {
        TySubst {
            var_id: var_id,
            ty: ty,
        }
    }
}

/// A substitution entry for effect row variables.
pub struct EffectRowSubst {
    /// The effect row variable being substituted.
    pub var_id: hir_def::EffectRowVarId,
    /// The effect row it maps to.
    pub row: hir_ty::EffectRow,
}

impl EffectRowSubst {
    /// Creates a new effect row substitution.
    pub fn new(var_id: hir_def::EffectRowVarId, row: hir_ty::EffectRow) -> EffectRowSubst {
        EffectRowSubst {
            var_id: var_id,
            row: row,
        }
    }
}

/// A substitution entry for record row variables.
pub struct RecordRowSubst {
    /// The record row variable being substituted.
    pub var_id: hir_def::RecordRowVarId,
    /// The record fields it maps to.
    pub fields: Vec<hir_ty::RecordField>,
    /// Optional remaining row variable.
    pub rest: Option<hir_def::RecordRowVarId>,
}

impl RecordRowSubst {
    /// Creates a new record row substitution.
    pub fn new(
        var_id: hir_def::RecordRowVarId,
        fields: Vec<hir_ty::RecordField>,
        rest: Option<hir_def::RecordRowVarId>,
    ) -> RecordRowSubst {
        RecordRowSubst {
            var_id: var_id,
            fields: fields,
            rest: rest,
        }
    }
}

// ============================================================
// Unifier State
// ============================================================

/// The unifier maintains substitutions and generates fresh variables.
///
/// Note: Methods that push to Vec fields are omitted due to blood-rust
/// limitations. The actual unification algorithm will be implemented
/// when the compiler supports this pattern.
pub struct Unifier {
    /// Counter for generating fresh type variables.
    pub next_ty_var: u32,
    /// Counter for generating fresh effect row variables.
    pub next_effect_var: u32,
    /// Counter for generating fresh record row variables.
    pub next_record_var: u32,
}

impl Unifier {
    /// Creates a new unifier.
    pub fn new() -> Unifier {
        Unifier {
            next_ty_var: 0,
            next_effect_var: 0,
            next_record_var: 0,
        }
    }

    /// Generates a fresh type variable.
    pub fn fresh_ty_var(self: &mut Self) -> hir_def::TyVarId {
        let id = hir_def::TyVarId::new(self.next_ty_var);
        self.next_ty_var = self.next_ty_var + 1;
        id
    }

    /// Generates a fresh effect row variable.
    pub fn fresh_effect_var(self: &mut Self) -> hir_def::EffectRowVarId {
        let id = hir_def::EffectRowVarId::new(self.next_effect_var);
        self.next_effect_var = self.next_effect_var + 1;
        id
    }

    /// Generates a fresh record row variable.
    pub fn fresh_record_var(self: &mut Self) -> hir_def::RecordRowVarId {
        let id = hir_def::RecordRowVarId::new(self.next_record_var);
        self.next_record_var = self.next_record_var + 1;
        id
    }

    /// Creates a fresh inference type.
    pub fn fresh_infer(self: &mut Self) -> hir_ty::Type {
        hir_ty::Type::infer(self.fresh_ty_var())
    }
}

// ============================================================
// Substitution Table
// ============================================================

/// A table of type substitutions.
///
/// This is kept separate from Unifier to allow for more flexible
/// usage patterns.
pub struct SubstTable {
    /// Type variable substitutions.
    pub ty_substs: Vec<TySubst>,
    /// Effect row variable substitutions.
    pub effect_substs: Vec<EffectRowSubst>,
    /// Record row variable substitutions.
    pub record_substs: Vec<RecordRowSubst>,
}

impl SubstTable {
    /// Creates an empty substitution table.
    pub fn new() -> SubstTable {
        SubstTable {
            ty_substs: Vec::new(),
            effect_substs: Vec::new(),
            record_substs: Vec::new(),
        }
    }
}

// ============================================================
// Type Matching
// ============================================================

/// Result of checking if two type kinds are structurally compatible.
pub enum MatchResult {
    /// Types are structurally identical.
    Equal,
    /// First type is a subtype of second (for covariance).
    Subtype,
    /// Types need unification.
    NeedUnify,
    /// Types are incompatible.
    Incompatible,
}

/// Checks if two primitive types are the same.
pub fn primitives_equal(a: hir_ty::PrimitiveTy, b: hir_ty::PrimitiveTy) -> bool {
    match a {
        hir_ty::PrimitiveTy::Bool => {
            match b {
                hir_ty::PrimitiveTy::Bool => true,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I8 => {
            match b {
                hir_ty::PrimitiveTy::I8 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I16 => {
            match b {
                hir_ty::PrimitiveTy::I16 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I32 => {
            match b {
                hir_ty::PrimitiveTy::I32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I64 => {
            match b {
                hir_ty::PrimitiveTy::I64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I128 => {
            match b {
                hir_ty::PrimitiveTy::I128 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Isize => {
            match b {
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U8 => {
            match b {
                hir_ty::PrimitiveTy::U8 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U16 => {
            match b {
                hir_ty::PrimitiveTy::U16 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U32 => {
            match b {
                hir_ty::PrimitiveTy::U32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U64 => {
            match b {
                hir_ty::PrimitiveTy::U64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U128 => {
            match b {
                hir_ty::PrimitiveTy::U128 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Usize => {
            match b {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::F32 => {
            match b {
                hir_ty::PrimitiveTy::F32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::F64 => {
            match b {
                hir_ty::PrimitiveTy::F64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Char => {
            match b {
                hir_ty::PrimitiveTy::Char => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Str => {
            match b {
                hir_ty::PrimitiveTy::Str => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
            }
        }
    }
}

// ============================================================
// Constraint Types
// ============================================================

/// A type constraint generated during inference.
pub enum Constraint {
    /// Two types must be equal.
    TypeEqual {
        expected: hir_ty::Type,
        actual: hir_ty::Type,
        span: common::Span,
    },
    /// A type must implement a trait.
    TraitBound {
        ty: hir_ty::Type,
        trait_ref: hir_ty::TraitRef,
        span: common::Span,
    },
    /// An effect row must be a subset of another.
    EffectSubset {
        subset: hir_ty::EffectRow,
        superset: hir_ty::EffectRow,
        span: common::Span,
    },
}

/// A deferred constraint for later resolution.
pub struct DeferredConstraint {
    /// The constraint.
    pub constraint: Constraint,
    /// Priority (lower is higher priority).
    pub priority: u32,
}

impl DeferredConstraint {
    /// Creates a new deferred constraint.
    pub fn new(constraint: Constraint, priority: u32) -> DeferredConstraint {
        DeferredConstraint {
            constraint: constraint,
            priority: priority,
        }
    }
}

// ============================================================
// Substitution Table Operations
// ============================================================

impl SubstTable {
    /// Adds a type variable substitution.
    pub fn add_ty_subst(self: &mut Self, var_id: hir_def::TyVarId, ty: hir_ty::Type) {
        let subst = TySubst::new(var_id, ty);
        self.ty_substs.push(subst);
    }

    /// Looks up a type variable in the substitution table.
    /// Returns Some(ty) if the variable is bound, None otherwise.
    pub fn lookup_ty(self: &Self, var_id: hir_def::TyVarId) -> Option<hir_ty::Type> {
        let mut i: usize = 0;
        while i < self.ty_substs.len() {
            if self.ty_substs[i].var_id.index == var_id.index {
                return Some(copy_type(&self.ty_substs[i].ty));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Adds an effect row variable substitution.
    pub fn add_effect_subst(self: &mut Self, var_id: hir_def::EffectRowVarId, row: hir_ty::EffectRow) {
        let subst = EffectRowSubst::new(var_id, row);
        self.effect_substs.push(subst);
    }

    /// Looks up an effect row variable.
    pub fn lookup_effect(self: &Self, var_id: hir_def::EffectRowVarId) -> Option<hir_ty::EffectRow> {
        let mut i: usize = 0;
        while i < self.effect_substs.len() {
            if self.effect_substs[i].var_id.index == var_id.index {
                return Some(copy_effect_row(&self.effect_substs[i].row));
            }
            i = i + 1;
        }
        Option::None
    }
}

// ============================================================
// Type Copying (Blood lacks Clone)
// ============================================================

/// Creates a shallow copy of a type.
fn copy_type(ty: &hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type { kind: copy_type_kind(&ty.kind) }
}

/// Creates a copy of a TypeKind.
fn copy_type_kind(kind: &hir_ty::TypeKind) -> hir_ty::TypeKind {
    match kind {
        &hir_ty::TypeKind::Primitive(prim) => hir_ty::TypeKind::Primitive(prim),
        &hir_ty::TypeKind::Never => hir_ty::TypeKind::Never,
        &hir_ty::TypeKind::Error => hir_ty::TypeKind::Error,
        &hir_ty::TypeKind::Infer(var_id) => hir_ty::TypeKind::Infer(var_id),
        &hir_ty::TypeKind::Param(var_id) => hir_ty::TypeKind::Param(var_id),
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut copied: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                copied.push(copy_type(&types[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Tuple(copied)
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::TypeKind::Array {
                element: Box::new(copy_type(element.as_ref())),
                size: size,
            }
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::TypeKind::Slice {
                element: Box::new(copy_type(element.as_ref())),
            }
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::TypeKind::Ref {
                inner: Box::new(copy_type(inner.as_ref())),
                mutable: mutable,
            }
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::TypeKind::Ptr {
                inner: Box::new(copy_type(inner.as_ref())),
                mutable: mutable,
            }
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut copied_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                copied_args.push(copy_type(&args[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: copied_args,
            }
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut copied_params: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                copied_params.push(copy_type(&params[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Fn {
                params: copied_params,
                ret: Box::new(copy_type(ret.as_ref())),
                effects: copy_effect_row(effects),
            }
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut copied_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                copied_fields.push(hir_ty::RecordField::new(
                    fields[i].name,
                    copy_type(&fields[i].ty),
                ));
                i = i + 1;
            }
            hir_ty::TypeKind::Record {
                fields: copied_fields,
                row_var: *row_var,
            }
        }
    }
}

/// Creates a copy of an EffectRow.
fn copy_effect_row(row: &hir_ty::EffectRow) -> hir_ty::EffectRow {
    let mut copied_effects: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        let eff = &row.effects[i];
        let mut copied_args: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < eff.args.len() {
            copied_args.push(copy_type(&eff.args[j]));
            j = j + 1;
        }
        copied_effects.push(hir_ty::EffectRef {
            def_id: eff.def_id,
            args: copied_args,
        });
        i = i + 1;
    }
    hir_ty::EffectRow {
        effects: copied_effects,
        row_var: row.row_var,
    }
}

// ============================================================
// Type Resolution (Apply Substitutions)
// ============================================================

/// Applies substitutions to resolve type variables in a type.
/// This is also called "zonking" - replacing inference variables with their solutions.
pub fn apply_substs(table: &SubstTable, ty: &hir_ty::Type) -> hir_ty::Type {
    match &ty.kind {
        &hir_ty::TypeKind::Infer(var_id) => {
            // Look up the type variable
            match table.lookup_ty(var_id) {
                Some(resolved) => {
                    // Recursively apply substitutions to the resolved type
                    apply_substs(table, &resolved)
                }
                Option::None => {
                    // Variable not yet resolved
                    copy_type(ty)
                }
            }
        }
        &hir_ty::TypeKind::Primitive(_) => copy_type(ty),
        &hir_ty::TypeKind::Never => copy_type(ty),
        &hir_ty::TypeKind::Error => copy_type(ty),
        &hir_ty::TypeKind::Param(_) => copy_type(ty),
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut resolved: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                resolved.push(apply_substs(table, &types[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(resolved))
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(apply_substs(table, element.as_ref())),
                size: size,
            })
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(apply_substs(table, element.as_ref())),
            })
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(apply_substs(table, inner.as_ref())),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(apply_substs(table, inner.as_ref())),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut resolved_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                resolved_args.push(apply_substs(table, &args[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: resolved_args,
            })
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut resolved_params: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                resolved_params.push(apply_substs(table, &params[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: resolved_params,
                ret: Box::new(apply_substs(table, ret.as_ref())),
                effects: apply_substs_to_effect_row(table, effects),
            })
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut resolved_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                resolved_fields.push(hir_ty::RecordField::new(
                    fields[i].name,
                    apply_substs(table, &fields[i].ty),
                ));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: resolved_fields,
                row_var: *row_var,
            })
        }
    }
}

/// Applies substitutions to an effect row.
fn apply_substs_to_effect_row(table: &SubstTable, row: &hir_ty::EffectRow) -> hir_ty::EffectRow {
    let mut resolved_effects: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        let eff = &row.effects[i];
        let mut resolved_args: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < eff.args.len() {
            resolved_args.push(apply_substs(table, &eff.args[j]));
            j = j + 1;
        }
        resolved_effects.push(hir_ty::EffectRef {
            def_id: eff.def_id,
            args: resolved_args,
        });
        i = i + 1;
    }
    hir_ty::EffectRow {
        effects: resolved_effects,
        row_var: row.row_var,
    }
}

// ============================================================
// Occurs Check
// ============================================================

/// Checks if a type variable occurs in a type.
/// Used to prevent infinite types like `T = Option<T>`.
pub fn occurs_in(var_id: hir_def::TyVarId, ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Infer(id) => id.index == var_id.index,
        &hir_ty::TypeKind::Primitive(_) => false,
        &hir_ty::TypeKind::Never => false,
        &hir_ty::TypeKind::Error => false,
        &hir_ty::TypeKind::Param(_) => false,
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if occurs_in(var_id, &types[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Array { ref element, size: _ } => {
            occurs_in(var_id, element.as_ref())
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            occurs_in(var_id, element.as_ref())
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            occurs_in(var_id, inner.as_ref())
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable: _ } => {
            occurs_in(var_id, inner.as_ref())
        }
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            let mut i: usize = 0;
            while i < args.len() {
                if occurs_in(var_id, &args[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                if occurs_in(var_id, &params[i]) {
                    return true;
                }
                i = i + 1;
            }
            occurs_in(var_id, ret.as_ref())
        }
        &hir_ty::TypeKind::Record { ref fields, row_var: _ } => {
            let mut i: usize = 0;
            while i < fields.len() {
                if occurs_in(var_id, &fields[i].ty) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
    }
}

// ============================================================
// Core Unification Algorithm
// ============================================================

/// Unifies two types, adding substitutions to the table.
/// Returns Ok if unification succeeds, Err with details if it fails.
pub fn unify(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    a: &hir_ty::Type,
    b: &hir_ty::Type,
    span: common::Span,
) -> UnifyResult {
    // First, apply any existing substitutions (reborrow as shared ref)
    let table_ref: &SubstTable = &*table;
    let a_resolved = apply_substs(table_ref, a);
    let b_resolved = apply_substs(table_ref, b);

    // Now unify the resolved types
    unify_resolved(table, unifier, &a_resolved, &b_resolved, span)
}

/// Unifies two types that have already had substitutions applied.
fn unify_resolved(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    a: &hir_ty::Type,
    b: &hir_ty::Type,
    span: common::Span,
) -> UnifyResult {
    match (&a.kind, &b.kind) {
        // Inference variables
        (&hir_ty::TypeKind::Infer(var_a), &hir_ty::TypeKind::Infer(var_b)) => {
            if var_a.index == var_b.index {
                // Same variable, already unified
                UnifyResult::Ok
            } else {
                // Bind one to the other
                table.add_ty_subst(var_a, copy_type(b));
                UnifyResult::Ok
            }
        }
        (&hir_ty::TypeKind::Infer(var_id), _) => {
            // Occurs check
            if occurs_in(var_id, b) {
                return UnifyResult::Err(UnifyError::occurs(span));
            }
            table.add_ty_subst(var_id, copy_type(b));
            UnifyResult::Ok
        }
        (_, &hir_ty::TypeKind::Infer(var_id)) => {
            // Occurs check
            if occurs_in(var_id, a) {
                return UnifyResult::Err(UnifyError::occurs(span));
            }
            table.add_ty_subst(var_id, copy_type(a));
            UnifyResult::Ok
        }

        // Error types unify with anything (error recovery)
        (&hir_ty::TypeKind::Error, _) => UnifyResult::Ok,
        (_, &hir_ty::TypeKind::Error) => UnifyResult::Ok,

        // Never type unifies with anything (divergence)
        (&hir_ty::TypeKind::Never, _) => UnifyResult::Ok,
        (_, &hir_ty::TypeKind::Never) => UnifyResult::Ok,

        // Primitives must be equal
        (&hir_ty::TypeKind::Primitive(prim_a), &hir_ty::TypeKind::Primitive(prim_b)) => {
            if primitives_equal(prim_a, prim_b) {
                UnifyResult::Ok
            } else {
                UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Type parameters must match exactly
        (&hir_ty::TypeKind::Param(id_a), &hir_ty::TypeKind::Param(id_b)) => {
            if id_a.index == id_b.index {
                UnifyResult::Ok
            } else {
                UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Tuples: same length, unify element-wise
        (&hir_ty::TypeKind::Tuple(ref types_a), &hir_ty::TypeKind::Tuple(ref types_b)) => {
            if types_a.len() != types_b.len() {
                return UnifyResult::Err(UnifyError::arity(span));
            }
            let mut i: usize = 0;
            while i < types_a.len() {
                match unify(table, unifier, &types_a[i], &types_b[i], span) {
                    UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                    UnifyResult::Ok => {}
                }
                i = i + 1;
            }
            UnifyResult::Ok
        }

        // Arrays: same size, unify element types
        (&hir_ty::TypeKind::Array { ref element, size }, other_kind) => {
            let elem_a = element;
            let size_a = size;
            match other_kind {
                &hir_ty::TypeKind::Array { ref element, size } => {
                    if size_a != size {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, elem_a.as_ref(), element.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Slices: unify element types
        (&hir_ty::TypeKind::Slice { ref element }, other_kind) => {
            let elem_a = element;
            match other_kind {
                &hir_ty::TypeKind::Slice { ref element } => {
                    unify(table, unifier, elem_a.as_ref(), element.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // References: same mutability, unify inner types
        (&hir_ty::TypeKind::Ref { ref inner, mutable }, other_kind) => {
            let inner_a = inner;
            let mut_a = mutable;
            match other_kind {
                &hir_ty::TypeKind::Ref { ref inner, mutable } => {
                    if mut_a != mutable {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, inner_a.as_ref(), inner.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Pointers: same mutability, unify inner types
        (&hir_ty::TypeKind::Ptr { ref inner, mutable }, other_kind) => {
            let inner_a = inner;
            let mut_a = mutable;
            match other_kind {
                &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
                    if mut_a != mutable {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, inner_a.as_ref(), inner.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // ADTs: same def_id, unify type arguments
        (&hir_ty::TypeKind::Adt { def_id, ref args }, other_kind) => {
            let def_a = def_id;
            let args_a = args;
            match other_kind {
                &hir_ty::TypeKind::Adt { def_id, ref args } => {
                    if def_a.index != def_id.index {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    if args_a.len() != args.len() {
                        return UnifyResult::Err(UnifyError::arity(span));
                    }
                    let mut i: usize = 0;
                    while i < args_a.len() {
                        match unify(table, unifier, &args_a[i], &args[i], span) {
                            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                            UnifyResult::Ok => {}
                        }
                        i = i + 1;
                    }
                    UnifyResult::Ok
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Function types: unify params, return, and effects
        (&hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ }, other_kind) => {
            let params_a = params;
            let ret_a = ret;
            match other_kind {
                &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
                    if params_a.len() != params.len() {
                        return UnifyResult::Err(UnifyError::arity(span));
                    }
                    let mut i: usize = 0;
                    while i < params_a.len() {
                        match unify(table, unifier, &params_a[i], &params[i], span) {
                            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                            UnifyResult::Ok => {}
                        }
                        i = i + 1;
                    }
                    // Unify return types
                    unify(table, unifier, ret_a.as_ref(), ret.as_ref(), span)
                    // TODO: Unify effect rows
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Record types: unify fields
        (&hir_ty::TypeKind::Record { ref fields, row_var: _ }, other_kind) => {
            let fields_a = fields;
            match other_kind {
                &hir_ty::TypeKind::Record { ref fields, row_var: _ } => {
                    // For now, require exact field match
                    if fields_a.len() != fields.len() {
                        return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
                    }
                    // TODO: Proper structural record unification with row polymorphism
                    let mut i: usize = 0;
                    while i < fields_a.len() {
                        // Fields should be in same order for now
                        if fields_a[i].name.index != fields[i].name.index {
                            return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
                        }
                        match unify(table, unifier, &fields_a[i].ty, &fields[i].ty, span) {
                            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                            UnifyResult::Ok => {}
                        }
                        i = i + 1;
                    }
                    UnifyResult::Ok
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }
    }
}
