// Blood Self-Hosted Compiler - Type Unification
//
// This module implements type unification using a union-find algorithm.
// Unification is the core operation of type inference - it makes two
// types equal by finding a substitution for type variables.
//
// Note: Due to blood-rust limitations with Vec<T> type inference on
// struct field operations, some methods are omitted. The types and
// core logic are defined for use by the type checker.

mod common;
mod hir_def;
mod hir_ty;

// ============================================================
// Unification Result
// ============================================================

/// Result of a unification operation.
pub enum UnifyResult {
    /// Unification succeeded.
    Ok,
    /// Unification failed with an error.
    Err(UnifyError),
}

/// An error during unification.
pub struct UnifyError {
    /// The kind of unification error.
    pub kind: UnifyErrorKind,
    /// The span where the error occurred.
    pub span: common::Span,
}

impl UnifyError {
    /// Creates a new unification error.
    pub fn new(kind: UnifyErrorKind, span: common::Span) -> UnifyError {
        UnifyError {
            kind: kind,
            span: span,
        }
    }

    /// Creates a type mismatch error.
    pub fn mismatch(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::TypeMismatch, span)
    }

    /// Creates an occurs check error.
    pub fn occurs(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::OccursCheck, span)
    }

    /// Creates an arity mismatch error.
    pub fn arity(span: common::Span) -> UnifyError {
        UnifyError::new(UnifyErrorKind::ArityMismatch, span)
    }
}

/// The kind of unification error.
pub enum UnifyErrorKind {
    /// Types are incompatible.
    TypeMismatch,
    /// Occurs check failed (infinite type).
    OccursCheck,
    /// Different number of elements (tuple, function params).
    ArityMismatch,
    /// Effect sets are incompatible.
    EffectMismatch,
    /// Record fields don't match.
    RecordMismatch,
}

// ============================================================
// Type Variable Substitution
// ============================================================

/// A substitution entry mapping a type variable to its value.
pub struct TySubst {
    /// The type variable being substituted.
    pub var_id: hir_def::TyVarId,
    /// The type it maps to.
    pub ty: hir_ty::Type,
}

impl TySubst {
    /// Creates a new type substitution.
    pub fn new(var_id: hir_def::TyVarId, ty: hir_ty::Type) -> TySubst {
        TySubst {
            var_id: var_id,
            ty: ty,
        }
    }
}

/// A substitution entry for effect row variables.
pub struct EffectRowSubst {
    /// The effect row variable being substituted.
    pub var_id: hir_def::EffectRowVarId,
    /// The effect row it maps to.
    pub row: hir_ty::EffectRow,
}

impl EffectRowSubst {
    /// Creates a new effect row substitution.
    pub fn new(var_id: hir_def::EffectRowVarId, row: hir_ty::EffectRow) -> EffectRowSubst {
        EffectRowSubst {
            var_id: var_id,
            row: row,
        }
    }
}

/// A substitution entry for record row variables.
pub struct RecordRowSubst {
    /// The record row variable being substituted.
    pub var_id: hir_def::RecordRowVarId,
    /// The record fields it maps to.
    pub fields: Vec<hir_ty::RecordField>,
    /// Optional remaining row variable.
    pub rest: Option<hir_def::RecordRowVarId>,
}

impl RecordRowSubst {
    /// Creates a new record row substitution.
    pub fn new(
        var_id: hir_def::RecordRowVarId,
        fields: Vec<hir_ty::RecordField>,
        rest: Option<hir_def::RecordRowVarId>,
    ) -> RecordRowSubst {
        RecordRowSubst {
            var_id: var_id,
            fields: fields,
            rest: rest,
        }
    }
}

// ============================================================
// Type Parameter Substitution (for generics)
// ============================================================

/// A substitution entry mapping a type parameter index to a concrete type.
/// This is used during generic instantiation (e.g., calling Vec::new::<i32>()).
pub struct TypeParamEntry {
    /// The index of the type parameter (0 for T, 1 for U, etc.)
    pub param_index: u32,
    /// The concrete type to substitute.
    pub ty: hir_ty::Type,
}

impl TypeParamEntry {
    /// Creates a new type parameter entry.
    pub fn new(param_index: u32, ty: hir_ty::Type) -> TypeParamEntry {
        TypeParamEntry { param_index, ty }
    }
}

/// A substitution map for generic type parameters.
/// Maps type parameter indices to their concrete types during instantiation.
pub struct TypeParamSubst {
    /// The substitution entries.
    pub entries: Vec<TypeParamEntry>,
}

impl TypeParamSubst {
    /// Creates an empty type parameter substitution.
    pub fn new() -> TypeParamSubst {
        TypeParamSubst { entries: Vec::new() }
    }

    /// Creates a substitution from a list of types (indexed 0, 1, 2, ...).
    pub fn from_types(types: &Vec<hir_ty::Type>) -> TypeParamSubst {
        let mut subst = TypeParamSubst::new();
        let mut i: usize = 0;
        while i < types.len() {
            subst.entries.push(TypeParamEntry::new(i as u32, hir_ty::copy_type(&types[i])));
            i = i + 1;
        }
        subst
    }

    /// Adds a substitution entry.
    pub fn add(self: &mut Self, param_index: u32, ty: hir_ty::Type) {
        self.entries.push(TypeParamEntry::new(param_index, ty));
    }

    /// Looks up a type parameter by index.
    pub fn lookup(self: &Self, param_index: u32) -> Option<hir_ty::Type> {
        let mut i: usize = 0;
        while i < self.entries.len() {
            if self.entries[i].param_index == param_index {
                return Some(hir_ty::copy_type(&self.entries[i].ty));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Returns true if this substitution is empty.
    pub fn is_empty(self: &Self) -> bool {
        self.entries.len() == 0
    }
}

/// Substitutes type parameters in a type according to the given substitution.
/// This is used to instantiate generic types with concrete type arguments.
pub fn substitute_type_params(ty: &hir_ty::Type, subst: &TypeParamSubst) -> hir_ty::Type {
    if subst.is_empty() {
        return hir_ty::copy_type(ty);
    }

    match &ty.kind {
        &hir_ty::TypeKind::Param(param_id) => {
            // Look up the type parameter in the substitution
            match subst.lookup(param_id.index) {
                Some(concrete_ty) => concrete_ty,
                Option::None => hir_ty::copy_type(ty), // Parameter not in substitution, keep as-is
            }
        }
        &hir_ty::TypeKind::Primitive(_) => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Never => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Error => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Infer(_) => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut result: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                result.push(substitute_type_params(&types[i], subst));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(result))
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(substitute_type_params(element.as_ref(), subst)),
                size: size,
            })
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(substitute_type_params(element.as_ref(), subst)),
            })
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(substitute_type_params(inner.as_ref(), subst)),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(substitute_type_params(inner.as_ref(), subst)),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut result_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                result_args.push(substitute_type_params(&args[i], subst));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: result_args,
            })
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut result_params: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                result_params.push(substitute_type_params(&params[i], subst));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: result_params,
                ret: Box::new(substitute_type_params(ret.as_ref(), subst)),
                effects: substitute_effect_row_params(effects, subst),
            })
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut result_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                result_fields.push(hir_ty::RecordField::new(
                    fields[i].name,
                    substitute_type_params(&fields[i].ty, subst),
                ));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: result_fields,
                row_var: *row_var,
            })
        }
        &hir_ty::TypeKind::Forall { ref params, ref body } => {
            // Substitute in the body, but don't touch the quantified params
            // (they shadow any outer params with the same var_id)
            let mut copied_params: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                copied_params.push(params[i]);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Forall {
                params: copied_params,
                body: Box::new(substitute_type_params(body.as_ref(), subst)),
            })
        }
        &hir_ty::TypeKind::Ownership { qualifier, ref inner } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ownership {
                qualifier: qualifier,
                inner: Box::new(substitute_type_params(inner.as_ref(), subst)),
            })
        }
    }
}

/// Substitutes type parameters in an effect row.
fn substitute_effect_row_params(row: &hir_ty::EffectRow, subst: &TypeParamSubst) -> hir_ty::EffectRow {
    let mut result_effects: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        let eff = &row.effects[i];
        let mut result_args: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < eff.args.len() {
            result_args.push(substitute_type_params(&eff.args[j], subst));
            j = j + 1;
        }
        result_effects.push(hir_ty::EffectRef {
            def_id: eff.def_id,
            args: result_args,
        });
        i = i + 1;
    }
    hir_ty::EffectRow {
        effects: result_effects,
        row_var: row.row_var,
    }
}

// ============================================================
// Unifier State
// ============================================================

/// The unifier maintains substitutions and generates fresh variables.
///
/// Note: Methods that push to Vec fields are omitted due to blood-rust
/// limitations. The actual unification algorithm will be implemented
/// when the compiler supports this pattern.
pub struct Unifier {
    /// Counter for generating fresh type variables.
    pub next_ty_var: u32,
    /// Counter for generating fresh effect row variables.
    pub next_effect_var: u32,
    /// Counter for generating fresh record row variables.
    pub next_record_var: u32,
}

impl Unifier {
    /// Creates a new unifier.
    pub fn new() -> Unifier {
        Unifier {
            next_ty_var: 0,
            next_effect_var: 0,
            next_record_var: 0,
        }
    }

    /// Creates a new Unifier with the type variable counter starting at the given value.
    /// This avoids TyVarId collisions with HIR-allocated inference variables.
    pub fn new_from(start_ty_var: u32) -> Unifier {
        Unifier {
            next_ty_var: start_ty_var,
            next_effect_var: 0,
            next_record_var: 0,
        }
    }

    /// Generates a fresh type variable.
    pub fn fresh_ty_var(self: &mut Self) -> hir_def::TyVarId {
        let id = hir_def::TyVarId::new(self.next_ty_var);
        self.next_ty_var = self.next_ty_var + 1;
        id
    }

    /// Generates a fresh effect row variable.
    pub fn fresh_effect_var(self: &mut Self) -> hir_def::EffectRowVarId {
        let id = hir_def::EffectRowVarId::new(self.next_effect_var);
        self.next_effect_var = self.next_effect_var + 1;
        id
    }

    /// Generates a fresh record row variable.
    pub fn fresh_record_var(self: &mut Self) -> hir_def::RecordRowVarId {
        let id = hir_def::RecordRowVarId::new(self.next_record_var);
        self.next_record_var = self.next_record_var + 1;
        id
    }

    /// Creates a fresh inference type.
    pub fn fresh_infer(self: &mut Self) -> hir_ty::Type {
        hir_ty::Type::infer(self.fresh_ty_var())
    }
}

/// Creates a copy of a Unifier.
/// Needed to work around blood-rust BUG-003 (&mut field_of_ref mutations are lost).
pub fn clone_unifier(u: &Unifier) -> Unifier {
    Unifier {
        next_ty_var: u.next_ty_var,
        next_effect_var: u.next_effect_var,
        next_record_var: u.next_record_var,
    }
}

// ============================================================
// Substitution Table
// ============================================================

/// A table of type substitutions.
///
/// This is kept separate from Unifier to allow for more flexible
/// usage patterns.
pub struct SubstTable {
    /// Type variable substitutions.
    pub ty_substs: Vec<TySubst>,
    /// Effect row variable substitutions.
    pub effect_substs: Vec<EffectRowSubst>,
    /// Record row variable substitutions.
    pub record_substs: Vec<RecordRowSubst>,
}

impl SubstTable {
    /// Creates an empty substitution table.
    pub fn new() -> SubstTable {
        SubstTable {
            ty_substs: Vec::new(),
            effect_substs: Vec::new(),
            record_substs: Vec::new(),
        }
    }
}

/// Creates a deep clone of a SubstTable.
///
/// This is needed to pass a copy of the substitution table from type checking
/// to each MIR lowering context, so that inference variables can be resolved
/// to concrete types during MIR construction.
pub fn clone_subst_table(table: &SubstTable) -> SubstTable {
    let mut new_table = SubstTable::new();

    // Clone type substitutions
    let mut i: usize = 0;
    while i < table.ty_substs.len() {
        new_table.ty_substs.push(TySubst::new(
            table.ty_substs[i].var_id,
            hir_ty::copy_type(&table.ty_substs[i].ty),
        ));
        i = i + 1;
    }

    // Clone effect row substitutions
    let mut i: usize = 0;
    while i < table.effect_substs.len() {
        new_table.effect_substs.push(EffectRowSubst::new(
            table.effect_substs[i].var_id,
            hir_ty::copy_effect_row(&table.effect_substs[i].row),
        ));
        i = i + 1;
    }

    // Clone record row substitutions
    let mut i: usize = 0;
    while i < table.record_substs.len() {
        let mut fields: Vec<hir_ty::RecordField> = Vec::new();
        let mut j: usize = 0;
        while j < table.record_substs[i].fields.len() {
            fields.push(hir_ty::RecordField::new(
                table.record_substs[i].fields[j].name,
                hir_ty::copy_type(&table.record_substs[i].fields[j].ty),
            ));
            j = j + 1;
        }
        new_table.record_substs.push(RecordRowSubst::new(
            table.record_substs[i].var_id,
            fields,
            table.record_substs[i].rest,
        ));
        i = i + 1;
    }

    new_table
}

// ============================================================
// Type Matching
// ============================================================

/// Result of checking if two type kinds are structurally compatible.
pub enum MatchResult {
    /// Types are structurally identical.
    Equal,
    /// First type is a subtype of second (for covariance).
    Subtype,
    /// Types need unification.
    NeedUnify,
    /// Types are incompatible.
    Incompatible,
}

/// Checks if two primitive types are the same.
pub fn primitives_equal(a: hir_ty::PrimitiveTy, b: hir_ty::PrimitiveTy) -> bool {
    match a {
        hir_ty::PrimitiveTy::Bool => {
            match b {
                hir_ty::PrimitiveTy::Bool => true,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I8 => {
            match b {
                hir_ty::PrimitiveTy::I8 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I16 => {
            match b {
                hir_ty::PrimitiveTy::I16 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I32 => {
            match b {
                hir_ty::PrimitiveTy::I32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I64 => {
            match b {
                hir_ty::PrimitiveTy::I64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::I128 => {
            match b {
                hir_ty::PrimitiveTy::I128 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Isize => {
            match b {
                hir_ty::PrimitiveTy::Isize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U8 => {
            match b {
                hir_ty::PrimitiveTy::U8 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U16 => {
            match b {
                hir_ty::PrimitiveTy::U16 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U32 => {
            match b {
                hir_ty::PrimitiveTy::U32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U64 => {
            match b {
                hir_ty::PrimitiveTy::U64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::U128 => {
            match b {
                hir_ty::PrimitiveTy::U128 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Usize => {
            match b {
                hir_ty::PrimitiveTy::Usize => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::F32 => {
            match b {
                hir_ty::PrimitiveTy::F32 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::F64 => {
            match b {
                hir_ty::PrimitiveTy::F64 => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::Char => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Char => {
            match b {
                hir_ty::PrimitiveTy::Char => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Str => false,
            }
        }
        hir_ty::PrimitiveTy::Str => {
            match b {
                hir_ty::PrimitiveTy::Str => true,
                hir_ty::PrimitiveTy::Bool => false,
                hir_ty::PrimitiveTy::I8 => false,
                hir_ty::PrimitiveTy::I16 => false,
                hir_ty::PrimitiveTy::I32 => false,
                hir_ty::PrimitiveTy::I64 => false,
                hir_ty::PrimitiveTy::I128 => false,
                hir_ty::PrimitiveTy::Isize => false,
                hir_ty::PrimitiveTy::U8 => false,
                hir_ty::PrimitiveTy::U16 => false,
                hir_ty::PrimitiveTy::U32 => false,
                hir_ty::PrimitiveTy::U64 => false,
                hir_ty::PrimitiveTy::U128 => false,
                hir_ty::PrimitiveTy::Usize => false,
                hir_ty::PrimitiveTy::F32 => false,
                hir_ty::PrimitiveTy::F64 => false,
                hir_ty::PrimitiveTy::Char => false,
            }
        }
    }
}

// ============================================================
// Constraint Types
// ============================================================

/// A type constraint generated during inference.
pub enum Constraint {
    /// Two types must be equal.
    TypeEqual {
        expected: hir_ty::Type,
        actual: hir_ty::Type,
        span: common::Span,
    },
    /// A type must implement a trait.
    TraitBound {
        ty: hir_ty::Type,
        trait_ref: hir_ty::TraitRef,
        span: common::Span,
    },
    /// An effect row must be a subset of another.
    EffectSubset {
        subset: hir_ty::EffectRow,
        superset: hir_ty::EffectRow,
        span: common::Span,
    },
}

/// A deferred constraint for later resolution.
pub struct DeferredConstraint {
    /// The constraint.
    pub constraint: Constraint,
    /// Priority (lower is higher priority).
    pub priority: u32,
}

impl DeferredConstraint {
    /// Creates a new deferred constraint.
    pub fn new(constraint: Constraint, priority: u32) -> DeferredConstraint {
        DeferredConstraint {
            constraint: constraint,
            priority: priority,
        }
    }
}

// ============================================================
// Substitution Table Operations
// ============================================================

impl SubstTable {
    /// Adds a type variable substitution.
    pub fn add_ty_subst(self: &mut Self, var_id: hir_def::TyVarId, ty: hir_ty::Type) {
        let subst = TySubst::new(var_id, ty);
        self.ty_substs.push(subst);
    }

    /// Looks up a type variable in the substitution table.
    /// Returns Some(ty) if the variable is bound, None otherwise.
    pub fn lookup_ty(self: &Self, var_id: hir_def::TyVarId) -> Option<hir_ty::Type> {
        let mut i: usize = 0;
        while i < self.ty_substs.len() {
            if self.ty_substs[i].var_id.index == var_id.index {
                return Some(hir_ty::copy_type(&self.ty_substs[i].ty));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Adds an effect row variable substitution.
    pub fn add_effect_subst(self: &mut Self, var_id: hir_def::EffectRowVarId, row: hir_ty::EffectRow) {
        let subst = EffectRowSubst::new(var_id, row);
        self.effect_substs.push(subst);
    }

    /// Looks up an effect row variable.
    pub fn lookup_effect(self: &Self, var_id: hir_def::EffectRowVarId) -> Option<hir_ty::EffectRow> {
        let mut i: usize = 0;
        while i < self.effect_substs.len() {
            if self.effect_substs[i].var_id.index == var_id.index {
                return Some(hir_ty::copy_effect_row(&self.effect_substs[i].row));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Adds a record row variable substitution.
    ///
    /// This binds a record row variable to a set of fields and an optional
    /// rest row variable (for open record types).
    pub fn add_record_subst(
        self: &mut Self,
        var_id: hir_def::RecordRowVarId,
        fields: Vec<hir_ty::RecordField>,
        rest: Option<hir_def::RecordRowVarId>,
    ) {
        let subst = RecordRowSubst::new(var_id, fields, rest);
        self.record_substs.push(subst);
    }

    /// Looks up a record row variable.
    ///
    /// Returns the fields and optional rest row variable that the given
    /// row variable is bound to.
    pub fn lookup_record(self: &Self, var_id: hir_def::RecordRowVarId) -> Option<RecordRowSubst> {
        let mut i: usize = 0;
        while i < self.record_substs.len() {
            if self.record_substs[i].var_id.index == var_id.index {
                // Return a copy of the substitution
                let mut copied_fields: Vec<hir_ty::RecordField> = Vec::new();
                let mut j: usize = 0;
                while j < self.record_substs[i].fields.len() {
                    copied_fields.push(hir_ty::RecordField {
                        name: self.record_substs[i].fields[j].name,
                        ty: hir_ty::copy_type(&self.record_substs[i].fields[j].ty),
                    });
                    j = j + 1;
                }
                return Option::Some(RecordRowSubst {
                    var_id: self.record_substs[i].var_id,
                    fields: copied_fields,
                    rest: self.record_substs[i].rest,
                });
            }
            i = i + 1;
        }
        Option::None
    }
}

// ============================================================
// Type Resolution (Apply Substitutions)
// ============================================================

/// Applies substitutions to resolve type variables in a type.
/// This is also called "zonking" - replacing inference variables with their solutions.
pub fn apply_substs(table: &SubstTable, ty: &hir_ty::Type) -> hir_ty::Type {
    match &ty.kind {
        &hir_ty::TypeKind::Infer(var_id) => {
            // Look up the type variable
            match table.lookup_ty(var_id) {
                Some(resolved) => {
                    // Recursively apply substitutions to the resolved type
                    apply_substs(table, &resolved)
                }
                Option::None => {
                    // Variable not yet resolved
                    hir_ty::copy_type(ty)
                }
            }
        }
        &hir_ty::TypeKind::Primitive(_) => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Never => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Error => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Param(_) => hir_ty::copy_type(ty),
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut resolved: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                resolved.push(apply_substs(table, &types[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Tuple(resolved))
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::Type::new(hir_ty::TypeKind::Array {
                element: Box::new(apply_substs(table, element.as_ref())),
                size: size,
            })
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::Type::new(hir_ty::TypeKind::Slice {
                element: Box::new(apply_substs(table, element.as_ref())),
            })
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ref {
                inner: Box::new(apply_substs(table, inner.as_ref())),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ptr {
                inner: Box::new(apply_substs(table, inner.as_ref())),
                mutable: mutable,
            })
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut resolved_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                resolved_args.push(apply_substs(table, &args[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Adt {
                def_id: def_id,
                args: resolved_args,
            })
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut resolved_params: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                resolved_params.push(apply_substs(table, &params[i]));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Fn {
                params: resolved_params,
                ret: Box::new(apply_substs(table, ret.as_ref())),
                effects: apply_substs_to_effect_row(table, effects),
            })
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut resolved_fields: Vec<hir_ty::RecordField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                resolved_fields.push(hir_ty::RecordField::new(
                    fields[i].name,
                    apply_substs(table, &fields[i].ty),
                ));
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Record {
                fields: resolved_fields,
                row_var: *row_var,
            })
        }
        &hir_ty::TypeKind::Forall { ref params, ref body } => {
            // Apply substitutions to the body
            let mut copied_params: Vec<hir_def::TyVarId> = Vec::new();
            let mut i: usize = 0;
            while i < params.len() {
                copied_params.push(params[i]);
                i = i + 1;
            }
            hir_ty::Type::new(hir_ty::TypeKind::Forall {
                params: copied_params,
                body: Box::new(apply_substs(table, body.as_ref())),
            })
        }
        &hir_ty::TypeKind::Ownership { qualifier, ref inner } => {
            hir_ty::Type::new(hir_ty::TypeKind::Ownership {
                qualifier: qualifier,
                inner: Box::new(apply_substs(table, inner.as_ref())),
            })
        }
    }
}

/// Applies substitutions to an effect row.
fn apply_substs_to_effect_row(table: &SubstTable, row: &hir_ty::EffectRow) -> hir_ty::EffectRow {
    let mut resolved_effects: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < row.effects.len() {
        let eff = &row.effects[i];
        let mut resolved_args: Vec<hir_ty::Type> = Vec::new();
        let mut j: usize = 0;
        while j < eff.args.len() {
            resolved_args.push(apply_substs(table, &eff.args[j]));
            j = j + 1;
        }
        resolved_effects.push(hir_ty::EffectRef {
            def_id: eff.def_id,
            args: resolved_args,
        });
        i = i + 1;
    }
    hir_ty::EffectRow {
        effects: resolved_effects,
        row_var: row.row_var,
    }
}

// ============================================================
// Occurs Check
// ============================================================

/// Checks if a type variable occurs in a type.
/// Used to prevent infinite types like `T = Option<T>`.
pub fn occurs_in(var_id: hir_def::TyVarId, ty: &hir_ty::Type) -> bool {
    match &ty.kind {
        &hir_ty::TypeKind::Infer(id) => id.index == var_id.index,
        &hir_ty::TypeKind::Primitive(_) => false,
        &hir_ty::TypeKind::Never => false,
        &hir_ty::TypeKind::Error => false,
        &hir_ty::TypeKind::Param(_) => false,
        &hir_ty::TypeKind::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if occurs_in(var_id, &types[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Array { ref element, size: _ } => {
            occurs_in(var_id, element.as_ref())
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            occurs_in(var_id, element.as_ref())
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            occurs_in(var_id, inner.as_ref())
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable: _ } => {
            occurs_in(var_id, inner.as_ref())
        }
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            let mut i: usize = 0;
            while i < args.len() {
                if occurs_in(var_id, &args[i]) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, effects: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                if occurs_in(var_id, &params[i]) {
                    return true;
                }
                i = i + 1;
            }
            occurs_in(var_id, ret.as_ref())
        }
        &hir_ty::TypeKind::Record { ref fields, row_var: _ } => {
            let mut i: usize = 0;
            while i < fields.len() {
                if occurs_in(var_id, &fields[i].ty) {
                    return true;
                }
                i = i + 1;
            }
            false
        }
        &hir_ty::TypeKind::Forall { params: _, ref body } => {
            occurs_in(var_id, body.as_ref())
        }
        &hir_ty::TypeKind::Ownership { qualifier: _, ref inner } => {
            occurs_in(var_id, inner.as_ref())
        }
    }
}

// ============================================================
// Core Unification Algorithm
// ============================================================

/// Unifies two types, adding substitutions to the table.
/// Returns Ok if unification succeeds, Err with details if it fails.
pub fn unify(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    a: &hir_ty::Type,
    b: &hir_ty::Type,
    span: common::Span,
) -> UnifyResult {
    // First, apply any existing substitutions (reborrow as shared ref)
    let table_ref: &SubstTable = &*table;
    let a_resolved = apply_substs(table_ref, a);
    let b_resolved = apply_substs(table_ref, b);

    // Now unify the resolved types
    unify_resolved(table, unifier, &a_resolved, &b_resolved, span)
}

/// Unifies two types that have already had substitutions applied.
fn unify_resolved(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    a: &hir_ty::Type,
    b: &hir_ty::Type,
    span: common::Span,
) -> UnifyResult {
    match (&a.kind, &b.kind) {
        // Inference variables
        (&hir_ty::TypeKind::Infer(var_a), &hir_ty::TypeKind::Infer(var_b)) => {
            if var_a.index == var_b.index {
                // Same variable, already unified
                UnifyResult::Ok
            } else {
                // Bind one to the other
                table.add_ty_subst(var_a, hir_ty::copy_type(b));
                UnifyResult::Ok
            }
        }
        (&hir_ty::TypeKind::Infer(var_id), _) => {
            // Occurs check
            if occurs_in(var_id, b) {
                return UnifyResult::Err(UnifyError::occurs(span));
            }
            table.add_ty_subst(var_id, hir_ty::copy_type(b));
            UnifyResult::Ok
        }
        (_, &hir_ty::TypeKind::Infer(var_id)) => {
            // Occurs check
            if occurs_in(var_id, a) {
                return UnifyResult::Err(UnifyError::occurs(span));
            }
            table.add_ty_subst(var_id, hir_ty::copy_type(a));
            UnifyResult::Ok
        }

        // Error types unify with anything (error recovery)
        (&hir_ty::TypeKind::Error, _) => UnifyResult::Ok,
        (_, &hir_ty::TypeKind::Error) => UnifyResult::Ok,

        // Never type unifies with anything (divergence)
        (&hir_ty::TypeKind::Never, _) => UnifyResult::Ok,
        (_, &hir_ty::TypeKind::Never) => UnifyResult::Ok,

        // Primitives must be equal
        (&hir_ty::TypeKind::Primitive(prim_a), &hir_ty::TypeKind::Primitive(prim_b)) => {
            if primitives_equal(prim_a, prim_b) {
                UnifyResult::Ok
            } else {
                UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Type parameters must match exactly
        (&hir_ty::TypeKind::Param(id_a), &hir_ty::TypeKind::Param(id_b)) => {
            if id_a.index == id_b.index {
                UnifyResult::Ok
            } else {
                UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Tuples: same length, unify element-wise
        (&hir_ty::TypeKind::Tuple(ref types_a), &hir_ty::TypeKind::Tuple(ref types_b)) => {
            if types_a.len() != types_b.len() {
                return UnifyResult::Err(UnifyError::arity(span));
            }
            let mut i: usize = 0;
            while i < types_a.len() {
                match unify(table, unifier, &types_a[i], &types_b[i], span) {
                    UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                    UnifyResult::Ok => {}
                }
                i = i + 1;
            }
            UnifyResult::Ok
        }

        // Arrays: same size, unify element types
        (&hir_ty::TypeKind::Array { ref element, size }, other_kind) => {
            let elem_a = element;
            let size_a = size;
            match other_kind {
                &hir_ty::TypeKind::Array { ref element, size } => {
                    if size_a != size {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, elem_a.as_ref(), element.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Slices: unify element types
        (&hir_ty::TypeKind::Slice { ref element }, other_kind) => {
            let elem_a = element;
            match other_kind {
                &hir_ty::TypeKind::Slice { ref element } => {
                    unify(table, unifier, elem_a.as_ref(), element.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // References: same mutability, unify inner types
        (&hir_ty::TypeKind::Ref { ref inner, mutable }, other_kind) => {
            let inner_a = inner;
            let mut_a = mutable;
            match other_kind {
                &hir_ty::TypeKind::Ref { ref inner, mutable } => {
                    if mut_a != mutable {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, inner_a.as_ref(), inner.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Pointers: same mutability, unify inner types
        (&hir_ty::TypeKind::Ptr { ref inner, mutable }, other_kind) => {
            let inner_a = inner;
            let mut_a = mutable;
            match other_kind {
                &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
                    if mut_a != mutable {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, inner_a.as_ref(), inner.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // ADTs: same def_id, unify type arguments
        (&hir_ty::TypeKind::Adt { def_id, ref args }, other_kind) => {
            let def_a = def_id;
            let args_a = args;
            match other_kind {
                &hir_ty::TypeKind::Adt { def_id, ref args } => {
                    if def_a.index != def_id.index {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    if args_a.len() != args.len() {
                        return UnifyResult::Err(UnifyError::arity(span));
                    }
                    let mut i: usize = 0;
                    while i < args_a.len() {
                        match unify(table, unifier, &args_a[i], &args[i], span) {
                            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                            UnifyResult::Ok => {}
                        }
                        i = i + 1;
                    }
                    UnifyResult::Ok
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Function types: unify params, return, and effects
        (&hir_ty::TypeKind::Fn { ref params, ref ret, ref effects }, other_kind) => {
            let params_a = params;
            let ret_a = ret;
            let effects_a = effects;
            match other_kind {
                &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
                    if params_a.len() != params.len() {
                        return UnifyResult::Err(UnifyError::arity(span));
                    }
                    let mut i: usize = 0;
                    while i < params_a.len() {
                        match unify(table, unifier, &params_a[i], &params[i], span) {
                            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                            UnifyResult::Ok => {}
                        }
                        i = i + 1;
                    }
                    // Unify return types
                    match unify(table, unifier, ret_a.as_ref(), ret.as_ref(), span) {
                        UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                        UnifyResult::Ok => {}
                    }
                    // Unify effect rows
                    unify_effect_rows(table, unifier, effects_a, effects, span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Record types: unify with row polymorphism
        (&hir_ty::TypeKind::Record { ref fields, ref row_var }, other_kind) => {
            let fields_a = fields;
            let row_var_a = row_var;
            match other_kind {
                &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
                    let fields_b = fields;
                    let row_var_b = row_var;
                    unify_record_rows(table, unifier, fields_a, row_var_a, fields_b, row_var_b, span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Forall types: unify quantified types
        // Full support would require instantiation and subsumption checking
        (&hir_ty::TypeKind::Forall { ref params, ref body }, other_kind) => {
            let params_a = params;
            let body_a = body;
            match other_kind {
                &hir_ty::TypeKind::Forall { ref params, ref body } => {
                    // For now, require same number of quantified params
                    if params_a.len() != params.len() {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    // Unify the body types
                    // NOTE: This is a simplified implementation. Full forall unification
                    // would require skolemization (replacing quantified vars with fresh
                    // rigid vars) to properly check impredicative polymorphism.
                    unify(table, unifier, body_a.as_ref(), body.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }

        // Ownership types: same qualifier, unify inner types
        (&hir_ty::TypeKind::Ownership { qualifier, ref inner }, other_kind) => {
            let qualifier_a = qualifier;
            let inner_a = inner;
            match other_kind {
                &hir_ty::TypeKind::Ownership { qualifier, ref inner } => {
                    if !ownership_qualifiers_equal(qualifier_a, qualifier) {
                        return UnifyResult::Err(UnifyError::mismatch(span));
                    }
                    unify(table, unifier, inner_a.as_ref(), inner.as_ref(), span)
                }
                _ => UnifyResult::Err(UnifyError::mismatch(span))
            }
        }
    }
}

/// Checks if two ownership qualifiers are equal.
fn ownership_qualifiers_equal(a: hir_ty::OwnershipQualifier, b: hir_ty::OwnershipQualifier) -> bool {
    match (a, b) {
        (hir_ty::OwnershipQualifier::Linear, hir_ty::OwnershipQualifier::Linear) => true,
        (hir_ty::OwnershipQualifier::Affine, hir_ty::OwnershipQualifier::Affine) => true,
        _ => false,
    }
}

// ============================================================
// Effect Row Unification
// ============================================================

/// Unifies two effect rows.
///
/// Effect row unification rules:
/// 1. If both rows are closed (no row_var): check effect sets are equal
/// 2. If one has a row_var (open row): bind the var to the difference
/// 3. If both have row_vars: create fresh var for intersection
pub fn unify_effect_rows(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    a: &hir_ty::EffectRow,
    b: &hir_ty::EffectRow,
    span: common::Span,
) -> UnifyResult {
    // Check if both rows are closed (no row variables)
    let a_closed = a.row_var.is_none();
    let b_closed = b.row_var.is_none();

    if a_closed && b_closed {
        // Both closed: effects must match exactly
        if !effect_sets_equal(&a.effects, &b.effects) {
            return UnifyResult::Err(UnifyError::new(UnifyErrorKind::EffectMismatch, span));
        }
        return UnifyResult::Ok;
    }

    // At least one row is open (has a row variable)
    // We need to:
    // 1. Check that known effects are compatible
    // 2. Bind row variables to capture the difference

    // First, check that all effects in a are in b (or can be added via b's row var)
    // and all effects in b are in a (or can be added via a's row var)
    let a_has_all_b = contains_all_effects(&a.effects, &b.effects);
    let b_has_all_a = contains_all_effects(&b.effects, &a.effects);

    // If a is closed but doesn't have all of b's effects, fail
    if a_closed && !a_has_all_b {
        return UnifyResult::Err(UnifyError::new(UnifyErrorKind::EffectMismatch, span));
    }

    // If b is closed but doesn't have all of a's effects, fail
    if b_closed && !b_has_all_a {
        return UnifyResult::Err(UnifyError::new(UnifyErrorKind::EffectMismatch, span));
    }

    // Now bind row variables to capture the differences
    match (a.row_var, b.row_var) {
        (Option::Some(a_var), Option::None) => {
            // a is open, b is closed
            // Bind a_var to the effects in b that aren't in a
            let diff = compute_effect_difference(&b.effects, &a.effects);
            let bound_row = hir_ty::EffectRow {
                effects: diff,
                row_var: Option::None, // The difference has no row var (closed)
            };
            table.add_effect_subst(a_var, bound_row);
        }
        (Option::None, Option::Some(b_var)) => {
            // b is open, a is closed
            // Bind b_var to the effects in a that aren't in b
            let diff = compute_effect_difference(&a.effects, &b.effects);
            let bound_row = hir_ty::EffectRow {
                effects: diff,
                row_var: Option::None,
            };
            table.add_effect_subst(b_var, bound_row);
        }
        (Option::Some(a_var), Option::Some(b_var)) => {
            // Both are open - create a fresh row variable for the unified row
            // This is the most complex case
            let fresh_var = unifier.fresh_effect_var();

            // Merge all known effects
            let merged = merge_effect_lists(&a.effects, &b.effects);

            // Bind both row vars to the merged effects + fresh var
            let merged_row = hir_ty::EffectRow {
                effects: merged,
                row_var: Option::Some(fresh_var),
            };

            // For the original vars, bind them to what they need to add
            // a_var should provide: (b.effects - a.effects) + fresh_var
            let a_needs = compute_effect_difference(&b.effects, &a.effects);
            let a_bound = hir_ty::EffectRow {
                effects: a_needs,
                row_var: Option::Some(fresh_var),
            };
            table.add_effect_subst(a_var, a_bound);

            // b_var should provide: (a.effects - b.effects) + fresh_var
            let b_needs = compute_effect_difference(&a.effects, &b.effects);
            let b_bound = hir_ty::EffectRow {
                effects: b_needs,
                row_var: Option::Some(fresh_var),
            };
            table.add_effect_subst(b_var, b_bound);

            let _ = merged_row; // Document that this represents the unified row
        }
        (Option::None, Option::None) => {
            // Both closed - already handled above
        }
    }

    UnifyResult::Ok
}

/// Checks if all effects in `subset` are present in `superset`.
fn contains_all_effects(superset: &Vec<hir_ty::EffectRef>, subset: &Vec<hir_ty::EffectRef>) -> bool {
    let mut i: usize = 0;
    while i < subset.len() {
        if !effect_list_contains(superset, &subset[i]) {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Computes effects in `from` that are not in `subtract`.
fn compute_effect_difference(from: &Vec<hir_ty::EffectRef>, subtract: &Vec<hir_ty::EffectRef>) -> Vec<hir_ty::EffectRef> {
    let mut result: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < from.len() {
        if !effect_list_contains(subtract, &from[i]) {
            result.push(copy_effect_ref(&from[i]));
        }
        i = i + 1;
    }
    result
}

/// Merges two effect lists, eliminating duplicates.
fn merge_effect_lists(a: &Vec<hir_ty::EffectRef>, b: &Vec<hir_ty::EffectRef>) -> Vec<hir_ty::EffectRef> {
    let mut result: Vec<hir_ty::EffectRef> = Vec::new();

    // Add all from a
    let mut i: usize = 0;
    while i < a.len() {
        result.push(copy_effect_ref(&a[i]));
        i = i + 1;
    }

    // Add from b if not already present
    let mut j: usize = 0;
    while j < b.len() {
        if !effect_list_contains(&result, &b[j]) {
            result.push(copy_effect_ref(&b[j]));
        }
        j = j + 1;
    }

    result
}

/// Creates a copy of an EffectRef.
fn copy_effect_ref(eff: &hir_ty::EffectRef) -> hir_ty::EffectRef {
    let mut args: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < eff.args.len() {
        args.push(hir_ty::copy_type(&eff.args[i]));
        i = i + 1;
    }
    hir_ty::EffectRef {
        def_id: eff.def_id,
        args: args,
    }
}

/// Checks if two effect sets are equal (ignoring order).
fn effect_sets_equal(a: &Vec<hir_ty::EffectRef>, b: &Vec<hir_ty::EffectRef>) -> bool {
    if a.len() != b.len() {
        return false;
    }

    // Check that every effect in a is in b
    let mut i: usize = 0;
    while i < a.len() {
        if !effect_list_contains(b, &a[i]) {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Checks if an effect list contains a specific effect.
fn effect_list_contains(list: &Vec<hir_ty::EffectRef>, eff_ref: &hir_ty::EffectRef) -> bool {
    let mut i: usize = 0;
    while i < list.len() {
        if effects_equal(&list[i], eff_ref) {
            return true;
        }
        i = i + 1;
    }
    false
}

/// Checks if two effect references are equal.
fn effects_equal(a: &hir_ty::EffectRef, b: &hir_ty::EffectRef) -> bool {
    // Check DefIds match
    if a.def_id.index != b.def_id.index {
        return false;
    }

    // Check type arguments match
    if a.args.len() != b.args.len() {
        return false;
    }

    let mut i: usize = 0;
    while i < a.args.len() {
        if !types_equal(&a.args[i], &b.args[i]) {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Simple structural type equality check.
fn types_equal(a: &hir_ty::Type, b: &hir_ty::Type) -> bool {
    match (&a.kind, &b.kind) {
        (&hir_ty::TypeKind::Primitive(pa), &hir_ty::TypeKind::Primitive(pb)) => {
            primitives_equal(pa, pb)
        }
        (&hir_ty::TypeKind::Never, &hir_ty::TypeKind::Never) => true,
        (&hir_ty::TypeKind::Error, &hir_ty::TypeKind::Error) => true,
        (&hir_ty::TypeKind::Infer(va), &hir_ty::TypeKind::Infer(vb)) => {
            va.index == vb.index
        }
        (&hir_ty::TypeKind::Ownership { qualifier: qa, ref inner },
         &hir_ty::TypeKind::Ownership { qualifier: qb, inner: ref inner_b }) => {
            ownership_qualifiers_equal(qa, qb) && types_equal(inner.as_ref(), inner_b.as_ref())
        }
        _ => false // Conservative: non-primitive types need unification
    }
}

// ============================================================
// Record Row Unification
// ============================================================

/// Unifies two record types with row polymorphism support.
///
/// Record row unification rules:
/// 1. If both rows are closed (no row_var): fields must match exactly
/// 2. If one has a row_var (open row): bind the var to extra fields
/// 3. If both have row_vars: unify common fields, bind difference
///
/// Row polymorphism allows functions to work with records that have
/// at least certain fields, enabling structural subtyping.
pub fn unify_record_rows(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    fields_a: &Vec<hir_ty::RecordField>,
    row_var_a: &Option<hir_def::RecordRowVarId>,
    fields_b: &Vec<hir_ty::RecordField>,
    row_var_b: &Option<hir_def::RecordRowVarId>,
    span: common::Span,
) -> UnifyResult {
    // Check if rows are closed (no row variables)
    let a_closed = row_var_a.is_none();
    let b_closed = row_var_b.is_none();

    // Case 1: Both closed - require exact field match
    if a_closed && b_closed {
        if fields_a.len() != fields_b.len() {
            return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
        }
        return unify_record_fields_exact(table, unifier, fields_a, fields_b, span);
    }

    // Case 2: Find common and different fields
    // Common fields must unify; different fields go into row variables

    // Collect field names from both records
    let mut common: Vec<(usize, usize)> = Vec::new(); // (a_idx, b_idx)
    let mut only_in_a: Vec<usize> = Vec::new();
    let mut only_in_b: Vec<usize> = Vec::new();

    // Find common fields and fields only in a
    let mut i: usize = 0;
    while i < fields_a.len() {
        let found = find_field_by_name(fields_b, fields_a[i].name);
        match found {
            Option::Some(b_idx) => {
                common.push((i, b_idx));
            }
            Option::None => {
                only_in_a.push(i);
            }
        }
        i = i + 1;
    }

    // Find fields only in b
    let mut j: usize = 0;
    while j < fields_b.len() {
        let found = find_field_by_name(fields_a, fields_b[j].name);
        if found.is_none() {
            only_in_b.push(j);
        }
        j = j + 1;
    }

    // Unify common fields
    let mut k: usize = 0;
    while k < common.len() {
        let (a_idx, b_idx) = common[k];
        match unify(table, unifier, &fields_a[a_idx].ty, &fields_b[b_idx].ty, span) {
            UnifyResult::Err(e) => { return UnifyResult::Err(e); }
            UnifyResult::Ok => {}
        }
        k = k + 1;
    }

    // Handle different fields based on row variable availability
    match (row_var_a, row_var_b) {
        (&Option::Some(var_a), &Option::None) => {
            // A is open, B is closed
            // A must not have any extra fields, and A's row var binds to B's extras
            if only_in_a.len() > 0 {
                return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
            }
            // Bind var_a to fields only in B
            let extra_fields = collect_fields_by_indices(fields_b, &only_in_b);
            table.add_record_subst(var_a, extra_fields, Option::None);
        }
        (&Option::None, &Option::Some(var_b)) => {
            // B is open, A is closed
            // B must not have any extra fields, and B's row var binds to A's extras
            if only_in_b.len() > 0 {
                return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
            }
            // Bind var_b to fields only in A
            let extra_fields = collect_fields_by_indices(fields_a, &only_in_a);
            table.add_record_subst(var_b, extra_fields, Option::None);
        }
        (&Option::Some(var_a), &Option::Some(var_b)) => {
            // Both open - create fresh row variable for unified extension
            let fresh_var = unifier.fresh_record_var();

            // A's row var binds to B's extra fields + fresh
            let a_extra = collect_fields_by_indices(fields_b, &only_in_b);
            table.add_record_subst(var_a, a_extra, Option::Some(fresh_var));

            // B's row var binds to A's extra fields + fresh
            let b_extra = collect_fields_by_indices(fields_a, &only_in_a);
            table.add_record_subst(var_b, b_extra, Option::Some(fresh_var));
        }
        (&Option::None, &Option::None) => {
            // Both closed - already handled above
        }
    }

    UnifyResult::Ok
}

/// Unifies record fields exactly (for closed records).
fn unify_record_fields_exact(
    table: &mut SubstTable,
    unifier: &mut Unifier,
    fields_a: &Vec<hir_ty::RecordField>,
    fields_b: &Vec<hir_ty::RecordField>,
    span: common::Span,
) -> UnifyResult {
    // Check that field sets match (order-independent)
    let mut i: usize = 0;
    while i < fields_a.len() {
        let found = find_field_by_name(fields_b, fields_a[i].name);
        match found {
            Option::Some(b_idx) => {
                match unify(table, unifier, &fields_a[i].ty, &fields_b[b_idx].ty, span) {
                    UnifyResult::Err(e) => { return UnifyResult::Err(e); }
                    UnifyResult::Ok => {}
                }
            }
            Option::None => {
                return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
            }
        }
        i = i + 1;
    }

    // Verify b doesn't have extra fields not in a
    let mut j: usize = 0;
    while j < fields_b.len() {
        if find_field_by_name(fields_a, fields_b[j].name).is_none() {
            return UnifyResult::Err(UnifyError::new(UnifyErrorKind::RecordMismatch, span));
        }
        j = j + 1;
    }

    UnifyResult::Ok
}

/// Finds a field by name and returns its index.
fn find_field_by_name(fields: &Vec<hir_ty::RecordField>, name: common::Symbol) -> Option<usize> {
    let mut i: usize = 0;
    while i < fields.len() {
        if fields[i].name.index == name.index {
            return Option::Some(i);
        }
        i = i + 1;
    }
    Option::None
}

/// Collects fields at the given indices.
fn collect_fields_by_indices(
    fields: &Vec<hir_ty::RecordField>,
    indices: &Vec<usize>,
) -> Vec<hir_ty::RecordField> {
    let mut result: Vec<hir_ty::RecordField> = Vec::new();
    let mut i: usize = 0;
    while i < indices.len() {
        let idx = indices[i];
        if idx < fields.len() {
            result.push(hir_ty::RecordField {
                name: fields[idx].name,
                ty: hir_ty::copy_type(&fields[idx].ty),
            });
        }
        i = i + 1;
    }
    result
}
