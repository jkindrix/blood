// Blood Self-Hosted Compiler - HIR Function Body Lowering
//
// This module handles lowering function bodies to HIR.
// Separated from hir_lower_expr.blood for better organization.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_expr;
mod resolve;

// ============================================================
// Body Lowering
// ============================================================

/// Lower a function body.
/// ast_params is used to generate destructuring let statements for complex parameter patterns.
pub fn lower_fn_body(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    body_id: hir_def::BodyId,
    params: &Vec<hir_item::FnParam>,
    ast_params: &Vec<ast::Param>,
    body_expr: &Option<ast::Expr>,
    body_block: &Option<ast::Block>,
) -> hir_expr::Body {
    // Push a function scope for parameter bindings
    ctx.resolver.push_scope(resolve::ScopeKind::Function);

    // Create locals for parameters and register them in scope
    let mut locals: Vec<hir_expr::Local> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() && i < ast_params.len() {
        let p = &params[i];
        let ast_p = &ast_params[i];
        let local_id = hir_def::LocalId::new(i as u32);

        // Extract the correct symbol from the AST pattern's span
        // (The FnParam's symbol may have garbage due to struct layout issues)
        let param_symbol = extract_param_symbol_from_ast(ctx, &ast_p.pattern);

        // Create a properly corrected SpannedSymbol for the local
        let corrected_name = common::SpannedSymbol {
            symbol: param_symbol,
            span: p.name.span,
        };

        let local = hir_expr::Local::new(
            local_id,
            corrected_name,
            hir_ty::copy_type(&p.ty),
            p.mutable,
            p.span,
        );
        locals.push(local);

        // Register parameter in scope so it can be looked up in the body
        ctx.resolver.define_local(param_symbol, local_id, p.mutable, p.span);

        i = i + 1;
    }

    let param_count = params.len() as u32;

    // Ensure body let-bindings get LocalIds that don't collide with parameter IDs.
    // Parameters use hardcoded LocalId(0..n-1), so body locals must start at n.
    if ctx.next_local_id < param_count {
        ctx.next_local_id = param_count;
    }

    // Clear the body_locals accumulator before lowering the body.
    // During body lowering, lower_pattern will push binding locals here.
    ctx.body_locals = Vec::new();

    // Lower the body expression
    let mut body_lowered = match body_expr {
        &Some(ref e) => hir_lower_expr::lower_expr(ctx, e),
        &None => {
            match body_block {
                &Some(ref block) => hir_lower_expr::lower_block_to_expr(ctx, block),
                &None => {
                    // No body - create unit expression
                    hir_expr::Expr::new(
                        hir_expr::ExprKind::Tuple(Vec::new()),
                        hir_ty::Type::unit(),
                        common::Span::dummy(),
                    )
                }
            }
        }
    };

    // Generate destructuring let statements for complex parameter patterns
    let destructure_stmts = generate_param_destructures(ctx, params, ast_params, &mut locals);

    // If we have destructuring statements, wrap the body in a block with those statements
    if destructure_stmts.len() > 0 {
        body_lowered = wrap_with_destructures(body_lowered, destructure_stmts);
    }

    // Merge accumulated body locals (from let-binding patterns) into the locals Vec.
    // These were collected by lower_pattern during body expression lowering.
    let mut bl_idx: usize = 0;
    while bl_idx < ctx.body_locals.len() {
        let bl = &ctx.body_locals[bl_idx];
        locals.push(hir_expr::Local::new(
            bl.id,
            bl.name,
            hir_ty::copy_type(&bl.ty),
            bl.mutable,
            bl.span,
        ));
        bl_idx = bl_idx + 1;
    }
    ctx.body_locals = Vec::new();

    // Pop the function scope
    ctx.resolver.pop_scope();

    hir_expr::Body::new(body_id, locals, param_count, body_lowered)
}

/// Check if a pattern needs destructuring (is not a simple identifier or wildcard).
fn needs_destructuring(pattern: &ast::Pattern) -> bool {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut: _, name: _, ref subpattern } => {
            // Simple ident with no subpattern doesn't need destructuring
            subpattern.is_some()
        }
        &ast::PatternKind::Wildcard => false,
        &ast::PatternKind::Ref { is_mut: _, ref inner } => {
            needs_destructuring(inner.as_ref())
        }
        _ => true
    }
}

/// Generate destructuring let statements for complex parameter patterns.
fn generate_param_destructures(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    params: &Vec<hir_item::FnParam>,
    ast_params: &Vec<ast::Param>,
    locals: &mut Vec<hir_expr::Local>,
) -> Vec<hir_expr::Stmt> {
    let mut stmts: Vec<hir_expr::Stmt> = Vec::new();

    let mut i: usize = 0;
    while i < ast_params.len() && i < params.len() {
        let ast_param = &ast_params[i];

        if needs_destructuring(&ast_param.pattern) {
            // Get the synthetic parameter's local_id
            let param_local_id = hir_def::LocalId::new(i as u32);

            // Lower the pattern
            let pattern_hir = hir_lower_expr::lower_pattern(ctx, &ast_param.pattern);

            // Collect local IDs from the pattern and add them to locals
            collect_pattern_locals(&pattern_hir, locals);

            // Create a reference to the synthetic parameter
            let param_ty = hir_ty::copy_type(&params[i].ty);
            let param_ref = hir_expr::Expr::new(
                hir_expr::ExprKind::Local(param_local_id),
                param_ty,
                ast_param.span,
            );

            // Create the let statement: let <pattern> = <param>;
            let let_stmt = hir_expr::Stmt::Let {
                pattern: pattern_hir,
                ty: Option::None,
                init: Some(param_ref),
                span: ast_param.span,
            };

            stmts.push(let_stmt);
        }

        i = i + 1;
    }

    stmts
}

/// Collect local IDs from a pattern and add them to the locals vector.
fn collect_pattern_locals(pattern: &hir_expr::Pattern, locals: &mut Vec<hir_expr::Local>) {
    match &pattern.kind {
        &hir_expr::PatternKind::Binding { local_id, ref name, mode: _, ref subpattern } => {
            // Add this binding to locals
            let local = hir_expr::Local::new(
                local_id,
                *name,
                hir_ty::copy_type(&pattern.ty),
                false,  // Mutability determined by binding mode
                pattern.span,
            );
            locals.push(local);

            // Recurse into subpattern if present
            if subpattern.is_some() {
                collect_pattern_locals(subpattern.as_ref().unwrap().as_ref(), locals);
            }
        }
        &hir_expr::PatternKind::Tuple(ref fields) => {
            let mut i: usize = 0;
            while i < fields.len() {
                collect_pattern_locals(&fields[i], locals);
                i = i + 1;
            }
        }
        &hir_expr::PatternKind::TupleStruct { path: _, ref fields } => {
            let mut i: usize = 0;
            while i < fields.len() {
                collect_pattern_locals(&fields[i], locals);
                i = i + 1;
            }
        }
        &hir_expr::PatternKind::Struct { path: _, ref fields, has_rest: _ } => {
            let mut i: usize = 0;
            while i < fields.len() {
                collect_pattern_locals(&fields[i].pattern, locals);
                i = i + 1;
            }
        }
        &hir_expr::PatternKind::Ref { mutable: _, ref inner } => {
            collect_pattern_locals(inner.as_ref(), locals);
        }
        &hir_expr::PatternKind::Or(ref patterns) => {
            // For Or patterns, all arms bind the same variables
            // Just collect from the first arm
            if patterns.len() > 0 {
                collect_pattern_locals(&patterns[0], locals);
            }
        }
        &hir_expr::PatternKind::Slice { ref prefix, ref rest, ref suffix } => {
            let mut i: usize = 0;
            while i < prefix.len() {
                collect_pattern_locals(&prefix[i], locals);
                i = i + 1;
            }
            if rest.is_some() {
                collect_pattern_locals(rest.as_ref().unwrap().as_ref(), locals);
            }
            let mut i: usize = 0;
            while i < suffix.len() {
                collect_pattern_locals(&suffix[i], locals);
                i = i + 1;
            }
        }
        // These pattern kinds don't introduce bindings
        &hir_expr::PatternKind::Wildcard => {}
        &hir_expr::PatternKind::Rest => {}
        &hir_expr::PatternKind::Literal(_) => {}
        &hir_expr::PatternKind::Path(_) => {}
        &hir_expr::PatternKind::Range { start: _, end_val: _, inclusive: _ } => {}
        &hir_expr::PatternKind::Error => {}
    }
}

/// Wrap an expression with destructuring let statements.
fn wrap_with_destructures(body: hir_expr::Expr, stmts: Vec<hir_expr::Stmt>) -> hir_expr::Expr {
    // Create a block with the destructuring statements followed by the body expression
    let span = body.span;
    let block = hir_expr::Block::new(stmts, Some(Box::new(body)), span);
    hir_expr::Expr::new(
        hir_expr::ExprKind::Block(block),
        hir_ty::Type::infer(hir_def::TyVarId::new(0)),  // Type will be inferred
        span,
    )
}

/// Extract the parameter symbol from an AST pattern using span-based lookup.
/// This works around struct layout issues where reading the symbol directly
/// from the AST enum variant gives garbage values.
fn extract_param_symbol_from_ast(ctx: &mut hir_lower_ctx::LoweringCtx, pattern: &ast::Pattern) -> common::Symbol {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut: _, name: _, subpattern: _ } => {
            // Use the pattern's span to extract the actual name string
            // (name.span might be garbage due to struct layout issues)
            let name_str = ctx.span_to_string(pattern.span);
            // Intern the string to get a symbol that matches what expression lowering uses
            ctx.intern(name_str.as_str())
        }
        &ast::PatternKind::Ref { is_mut: _, ref inner } => {
            // Look through reference patterns
            extract_param_symbol_from_ast(ctx, inner.as_ref())
        }
        _ => {
            // For wildcards and complex patterns, return a dummy symbol
            // Complex patterns are handled by destructuring
            common::Symbol::new(0)
        }
    }
}
