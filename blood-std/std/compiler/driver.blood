// Blood Self-Hosted Compiler - Driver
//
// This module provides the main compiler driver that orchestrates all
// compilation phases: parsing, HIR lowering, type checking, MIR lowering,
// and code generation.

mod common;
mod error;
mod ast;
mod hir;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir_lower;
mod hir_lower_ctx;
mod parser;
mod parser_base;
mod resolve;
mod mir_def;
mod mir_body;
mod mir_lower;
mod codegen;
mod interner;
mod unify;
mod typeck;
mod typeck_driver;
mod source;
mod type_intern;

// ============================================================
// Compilation Result
// ============================================================

/// The result of a complete compilation.
pub struct CompileResult {
    /// Whether compilation succeeded.
    pub success: bool,
    /// Generated LLVM IR (if successful).
    pub llvm_ir: Option<String>,
    /// All errors collected during compilation.
    pub errors: Vec<error::CompileError>,
    /// All warnings collected during compilation.
    pub warnings: Vec<error::CompileWarning>,
}

impl CompileResult {
    /// Creates a successful result.
    pub fn ok(llvm_ir: String) -> CompileResult {
        CompileResult {
            success: true,
            llvm_ir: Option::Some(llvm_ir),
            errors: Vec::new(),
            warnings: Vec::new(),
        }
    }

    /// Creates a failed result.
    pub fn err(errors: Vec<error::CompileError>) -> CompileResult {
        CompileResult {
            success: false,
            llvm_ir: Option::None,
            errors: errors,
            warnings: Vec::new(),
        }
    }

    /// Returns true if there are errors.
    pub fn has_errors(self: &CompileResult) -> bool {
        self.errors.len() > 0
    }
}

// ============================================================
// Compiler
// ============================================================

/// The main compiler driver.
pub struct Compiler {
    /// String interner for symbols.
    interner: interner::StringInterner,
}

impl Compiler {
    /// Creates a new compiler.
    pub fn new() -> Compiler {
        Compiler {
            interner: interner::StringInterner::new(),
        }
    }

    /// Compiles source code to LLVM IR.
    ///
    /// This runs the full compilation pipeline:
    /// 1. Parse source to AST
    /// 2. Lower AST to HIR
    /// 3. Type check HIR
    /// 4. Lower HIR to MIR
    /// 5. Generate LLVM IR from MIR
    pub fn compile(self: &mut Compiler, source: &str) -> CompileResult {
        // Delegate to compile_with_base_dir with empty base dir
        self.compile_with_base_dir(source, common::make_string(""))
    }

    /// Parses source code and returns the AST.
    pub fn parse(self: &mut Compiler, source: &str) -> ParseOnlyResult {
        let parse_result = parser::parse_file(source);

        if parse_result.errors.len() > 0 {
            let errors = convert_parse_errors(&parse_result.errors);
            return ParseOnlyResult {
                success: false,
                program: Option::None,
                errors: errors,
            };
        }

        ParseOnlyResult {
            success: true,
            program: parse_result.program,
            errors: Vec::new(),
        }
    }

    /// Checks source code without generating code.
    ///
    /// Runs parsing and HIR lowering to check for errors.
    pub fn check(self: &mut Compiler, source: &str) -> CheckResult {
        // Parse
        let parse_result = parser::parse_file(source);
        if parse_result.errors.len() > 0 {
            let errors = convert_parse_errors(&parse_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                let mut errors = Vec::new();
                errors.push(error::CompileError::new(
                    error::CompilePhase::Parse,
                    common::make_string("No program produced by parser"),
                ));
                return CheckResult {
                    success: false,
                    errors: errors,
                };
            }
        };

        // Lower to HIR
        let lower_result = hir_lower::lower_program(program, source);
        if has_error_diagnostics(&lower_result.diagnostics) {
            let errors = convert_hir_diagnostics(&lower_result.diagnostics);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Type check
        let typeck_result = typeck_driver::check_lower_result(&lower_result);
        if !typeck_result.success {
            let errors = convert_type_errors(&typeck_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Check succeeded
        CheckResult {
            success: true,
            errors: Vec::new(),
        }
    }

    /// Compiles source code with a specified base directory for module resolution.
    pub fn compile_with_base_dir(self: &mut Compiler, source: &str, base_dir: String) -> CompileResult {
        // Phase 1: Parse
        let parse_result = parser::parse_file(source);
        if parse_result.errors.len() > 0 {
            let errors = convert_parse_errors(&parse_result.errors);
            return CompileResult::err(errors);
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                let mut errors = Vec::new();
                errors.push(error::CompileError::new(
                    error::CompilePhase::Parse,
                    common::make_string("No program produced by parser"),
                ));
                return CompileResult::err(errors);
            }
        };

        // Phase 2: Lower to HIR with base_dir
        let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, source);
        if has_error_diagnostics(&lower_result.diagnostics) {
            let errors = convert_hir_diagnostics(&lower_result.diagnostics);
            return CompileResult::err(errors);
        }

        let crate_data = match &lower_result.crate_data {
            &Option::Some(ref c) => c,
            &Option::None => {
                let mut errors = Vec::new();
                errors.push(error::CompileError::new(
                    error::CompilePhase::Lower,
                    common::make_string("No HIR crate produced"),
                ));
                return CompileResult::err(errors);
            }
        };

        // Phase 3: Type checking
        let typeck_result = typeck_driver::check_lower_result(&lower_result);
        if !typeck_result.success {
            let errors = convert_type_errors(&typeck_result.errors);
            return CompileResult::err(errors);
        }

        // Phase 4: Lower HIR bodies to MIR
        let mut mir_functions: Vec<(String, mir_body::MirBody)> = Vec::new();
        let mut mir_errors: Vec<error::CompileError> = Vec::new();
        let mut body_idx: usize = 0;
        while body_idx < lower_result.bodies.len() {
            let body_entry = &lower_result.bodies[body_idx];
            let hir_body = &body_entry.body;
            let body_id = body_entry.body_id;

            // Find the Item for this body to get name and return type
            let fn_info = find_fn_for_body(&lower_result.items, body_id);

            // Get return type from function signature, or default to unit
            let return_ty = match &fn_info {
                &Option::Some(ref info) => type_intern::TyId::new(info.return_ty.index),
                &Option::None => type_intern::CommonTypes::unit(),
            };

            // Get span from function item, or use dummy span
            let span = match &fn_info {
                &Option::Some(ref info) => info.span,
                &Option::None => common::Span::new(0, 0, 1, 1),
            };

            // Get function name or generate one
            let fn_name = match &fn_info {
                &Option::Some(ref info) => resolve_fn_name(source, info),
                &Option::None => make_fn_name(body_idx),
            };

            // Get DefId from function info or use body_id's index as fallback.
            // This fallback must match typeck_driver's find_def_id_for_body fallback
            // to ensure method resolution lookups use consistent keys.
            let def_id = match &fn_info {
                &Option::Some(ref info) => info.def_id,
                &Option::None => hir_def::DefId::new(body_id.index),
            };

            // Lower the body to MIR with substitution table for type resolution
            let mir_result = mir_lower::lower_body(
                def_id,
                hir_body,
                return_ty,
                span,
                &typeck_result.subst_table,
                &typeck_result.method_resolutions,
                &typeck_result.field_resolutions,
            );

            // Collect any MIR lowering errors
            let mut ei: usize = 0;
            while ei < mir_result.errors.len() {
                mir_errors.push(convert_mir_error(&mir_result.errors[ei]));
                ei = ei + 1;
            }

            mir_functions.push((fn_name, mir_result.body));

            body_idx = body_idx + 1;
        }

        // Halt before codegen if MIR lowering produced errors
        if mir_errors.len() > 0 {
            return CompileResult::err(mir_errors);
        }

        // Phase 5: Generate LLVM IR from MIR
        let codegen_result = codegen::generate_module_with_items("main", &mir_functions, &lower_result.items, &typeck_result.default_method_remaps);
        if !codegen_result.success {
            let errors = convert_codegen_errors(&codegen_result.errors);
            return CompileResult::err(errors);
        }

        // Propagate codegen warnings and non-fatal errors
        let mut result = CompileResult::ok(codegen_result.llvm_ir);
        if codegen_result.errors.len() > 0 {
            result.warnings = convert_codegen_errors_to_warnings(&codegen_result.errors);
        }
        let mut wi: usize = 0;
        while wi < codegen_result.warnings.len() {
            result.warnings.push(error::CompileWarning::new(
                error::CompilePhase::Codegen,
                clone_string(&codegen_result.warnings[wi]),
            ));
            wi = wi + 1;
        }
        result
    }

    /// Checks source code with a specified base directory for module resolution.
    pub fn check_with_base_dir(self: &mut Compiler, source: &str, base_dir: String) -> CheckResult {
        // Parse
        let parse_result = parser::parse_file(source);
        if parse_result.errors.len() > 0 {
            let errors = convert_parse_errors(&parse_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                let mut errors = Vec::new();
                errors.push(error::CompileError::new(
                    error::CompilePhase::Parse,
                    common::make_string("No program produced by parser"),
                ));
                return CheckResult {
                    success: false,
                    errors: errors,
                };
            }
        };

        // Lower to HIR with base_dir
        let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, source);
        if has_error_diagnostics(&lower_result.diagnostics) {
            let errors = convert_hir_diagnostics(&lower_result.diagnostics);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Type check
        let typeck_result = typeck_driver::check_lower_result(&lower_result);
        if !typeck_result.success {
            let errors = convert_type_errors(&typeck_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Post-typeck validation: check that a main function exists
        let has_main = has_main_function(&lower_result);
        if !has_main {
            let mut errors: Vec<error::CompileError> = Vec::new();
            errors.push(error::CompileError::new(
                error::CompilePhase::TypeCheck,
                common::make_string("main function not found"),
            ));
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Check succeeded
        CheckResult {
            success: true,
            errors: Vec::new(),
        }
    }

    /// Instrumented version of check_with_base_dir that traces region memory usage.
    /// Pass region_id from region_create() to enable tracing, or 0 to disable.
    pub fn check_with_base_dir_traced(self: &mut Compiler, source: &str, base_dir: String, region_id: u64) -> CheckResult {
        let trace = region_id != 0;

        if trace {
            let used0 = region_used(region_id);
            print_str("[TRACE] Before parse: ");
            println_u64(used0);
        }

        // Parse
        let parse_result = parser::parse_file(source);

        if trace {
            let used1 = region_used(region_id);
            print_str("[TRACE] After parse: ");
            println_u64(used1);
        }

        if parse_result.errors.len() > 0 {
            let errors = convert_parse_errors(&parse_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                let mut errors = Vec::new();
                errors.push(error::CompileError::new(
                    error::CompilePhase::Parse,
                    common::make_string("No program produced by parser"),
                ));
                return CheckResult {
                    success: false,
                    errors: errors,
                };
            }
        };

        // Lower to HIR with base_dir
        let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, source);

        if trace {
            let used2 = region_used(region_id);
            print_str("[TRACE] After HIR lower: ");
            println_u64(used2);
        }

        if has_error_diagnostics(&lower_result.diagnostics) {
            let errors = convert_hir_diagnostics(&lower_result.diagnostics);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Type check
        let typeck_result = typeck_driver::check_lower_result(&lower_result);

        if trace {
            let used3 = region_used(region_id);
            print_str("[TRACE] After typeck: ");
            println_u64(used3);
        }

        if !typeck_result.success {
            let errors = convert_type_errors(&typeck_result.errors);
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Post-typeck validation: check that a main function exists
        let has_main = has_main_function(&lower_result);
        if !has_main {
            let mut errors: Vec<error::CompileError> = Vec::new();
            errors.push(error::CompileError::new(
                error::CompilePhase::TypeCheck,
                common::make_string("main function not found"),
            ));
            return CheckResult {
                success: false,
                errors: errors,
            };
        }

        // Check succeeded
        CheckResult {
            success: true,
            errors: Vec::new(),
        }
    }

    /// Gets a reference to the string interner.
    pub fn interner(self: &Self) -> &interner::StringInterner {
        &self.interner
    }

    /// Gets a mutable reference to the string interner.
    pub fn interner_mut(self: &mut Self) -> &mut interner::StringInterner {
        &mut self.interner
    }
}

// ============================================================
// Additional Result Types
// ============================================================

/// Result of parse-only operation.
pub struct ParseOnlyResult {
    pub success: bool,
    pub program: Option<ast::Program>,
    pub errors: Vec<error::CompileError>,
}

/// Result of check-only operation.
pub struct CheckResult {
    pub success: bool,
    pub errors: Vec<error::CompileError>,
}

// ============================================================
// Error Conversion Functions
// ============================================================

/// Converts parser diagnostics to compile errors.
fn convert_parse_errors(diagnostics: &Vec<parser_base::Diagnostic>) -> Vec<error::CompileError> {
    let mut errors = Vec::new();
    let mut i: usize = 0;
    while i < diagnostics.len() {
        let diag = &diagnostics[i];
        // Build message with notes appended
        let mut msg = clone_string(&diag.message);
        let mut ni: usize = 0;
        while ni < diag.notes.len() {
            msg.push_str("\n  note: ");
            msg.push_str(diag.notes[ni].as_str());
            ni = ni + 1;
        }
        errors.push(error::CompileError::with_code(
            error::CompilePhase::Parse,
            msg,
            diag.span,
            common::make_string(parser_error_code(&diag.code)),
        ));
        i = i + 1;
    }
    errors
}

/// Converts HIR diagnostics to compile errors.
fn convert_hir_diagnostics(diagnostics: &Vec<hir::Diagnostic>) -> Vec<error::CompileError> {
    let mut errors = Vec::new();
    let mut i: usize = 0;
    while i < diagnostics.len() {
        let diag = &diagnostics[i];
        errors.push(error::CompileError::with_code(
            error::CompilePhase::Lower,
            clone_string(&diag.message),
            diag.span,
            common::make_string(hir_diagnostic_code(&diag.code)),
        ));
        i = i + 1;
    }
    errors
}

/// Checks if any diagnostic is an error (not just a warning).
fn has_error_diagnostics(diagnostics: &Vec<hir::Diagnostic>) -> bool {
    let mut i: usize = 0;
    while i < diagnostics.len() {
        let diag = &diagnostics[i];
        match &diag.level {
            &hir::DiagnosticLevel::Error => return true,
            &hir::DiagnosticLevel::Warning => {}
            &hir::DiagnosticLevel::Note => {}
            &hir::DiagnosticLevel::Help => {}
        }
        i = i + 1;
    }
    false
}

/// Converts type errors to compile errors.
fn convert_type_errors(type_errors: &Vec<typeck::TypeError>) -> Vec<error::CompileError> {
    let mut errors = Vec::new();
    let mut i: usize = 0;
    while i < type_errors.len() {
        let te = &type_errors[i];
        let mut message = type_error_message(&te.kind);
        // Append any context notes to the error message
        let mut ni: usize = 0;
        while ni < te.notes.len() {
            message.push_str("\n  note: ");
            message.push_str(te.notes[ni].message.as_str());
            ni = ni + 1;
        }
        errors.push(error::CompileError::with_code(
            error::CompilePhase::TypeCheck,
            message,
            te.span,
            common::make_string(type_error_code(&te.kind)),
        ));
        i = i + 1;
    }
    errors
}

/// Converts a single MIR lowering error to a compile error.
fn convert_mir_error(err: &mir_lower::mir_lower_ctx::MirLowerError) -> error::CompileError {
    let mut message = common::make_string(mir_lower::mir_lower_ctx::mir_error_kind_label(&err.kind));
    message.push_str(": ");
    message.push_str(err.message.as_str());
    // Append contextual notes
    let mut ni: usize = 0;
    while ni < err.notes.len() {
        message.push_str("\n  note: ");
        message.push_str(err.notes[ni].message.as_str());
        ni = ni + 1;
    }
    error::CompileError::with_code(
        error::CompilePhase::MirLower,
        message,
        err.span,
        common::make_string(mir_lower::mir_lower_ctx::mir_error_code(&err.kind)),
    )
}

/// Converts codegen errors to compile errors.
fn convert_codegen_errors(codegen_errors: &Vec<codegen::codegen_ctx::CodegenError>) -> Vec<error::CompileError> {
    let mut errors = Vec::new();
    let mut i: usize = 0;
    while i < codegen_errors.len() {
        let ce = &codegen_errors[i];
        let code_str = codegen::codegen_ctx::error_kind_code(&ce.kind);
        let mut message = common::make_string(codegen::codegen_ctx::error_kind_label(&ce.kind));
        message.push_str(": ");
        message.push_str(ce.message.as_str());
        match &ce.fn_name {
            &Option::Some(ref name) => {
                message.push_str(" (in function ");
                message.push_str(name.as_str());
                message.push(')');
            }
            &Option::None => {}
        }
        // Append contextual notes
        let mut ni: usize = 0;
        while ni < ce.notes.len() {
            message.push_str("\n  note: ");
            message.push_str(ce.notes[ni].message.as_str());
            ni = ni + 1;
        }
        // Use with_code when span is available, embed code in message otherwise
        match &ce.span {
            &Option::Some(ref span) => {
                errors.push(error::CompileError::with_code(
                    error::CompilePhase::Codegen,
                    message,
                    *span,
                    common::make_string(code_str),
                ));
            }
            &Option::None => {
                let mut coded_msg = common::make_string("[");
                coded_msg.push_str(code_str);
                coded_msg.push_str("] ");
                coded_msg.push_str(message.as_str());
                errors.push(error::CompileError::new(
                    error::CompilePhase::Codegen,
                    coded_msg,
                ));
            }
        }
        i = i + 1;
    }
    errors
}

/// Converts codegen errors to compile warnings (for non-fatal errors that didn't prevent codegen).
fn convert_codegen_errors_to_warnings(codegen_errors: &Vec<codegen::codegen_ctx::CodegenError>) -> Vec<error::CompileWarning> {
    let mut warnings = Vec::new();
    let mut i: usize = 0;
    while i < codegen_errors.len() {
        let ce = &codegen_errors[i];
        let code_str = codegen::codegen_ctx::error_kind_code(&ce.kind);
        // Embed code in warning message since CompileWarning has no code field
        let mut message = common::make_string("[");
        message.push_str(code_str);
        message.push_str("] ");
        message.push_str(codegen::codegen_ctx::error_kind_label(&ce.kind));
        message.push_str(": ");
        message.push_str(ce.message.as_str());
        match &ce.fn_name {
            &Option::Some(ref name) => {
                message.push_str(" (in function ");
                message.push_str(name.as_str());
                message.push(')');
            }
            &Option::None => {}
        }
        // Append contextual notes
        let mut ni: usize = 0;
        while ni < ce.notes.len() {
            message.push_str("\n  note: ");
            message.push_str(ce.notes[ni].message.as_str());
            ni = ni + 1;
        }
        // Use span-aware constructor when span is available
        match &ce.span {
            &Option::Some(ref span) => {
                warnings.push(error::CompileWarning::with_span(
                    error::CompilePhase::Codegen,
                    message,
                    *span,
                ));
            }
            &Option::None => {
                warnings.push(error::CompileWarning::new(
                    error::CompilePhase::Codegen,
                    message,
                ));
            }
        }
        i = i + 1;
    }
    warnings
}

/// Converts a TypeErrorKind to a human-readable message.
fn type_error_message(kind: &typeck::TypeErrorKind) -> String {
    match kind {
        &typeck::TypeErrorKind::TypeMismatch => common::make_string("type mismatch"),
        &typeck::TypeErrorKind::CannotInfer => common::make_string("cannot infer type"),
        &typeck::TypeErrorKind::UndefinedVariable => common::make_string("undefined variable"),
        &typeck::TypeErrorKind::UndefinedFunction => common::make_string("undefined function"),
        &typeck::TypeErrorKind::ArityMismatch => common::make_string("wrong number of arguments"),
        &typeck::TypeErrorKind::NotCallable => common::make_string("expression is not callable"),
        &typeck::TypeErrorKind::NotIndexable => common::make_string("expression is not indexable"),
        &typeck::TypeErrorKind::NoSuchField => common::make_string("field does not exist"),
        &typeck::TypeErrorKind::NoSuchMethod => common::make_string("method does not exist"),
        &typeck::TypeErrorKind::CannotMutate => common::make_string("cannot mutate immutable value"),
        &typeck::TypeErrorKind::InvalidLValue => common::make_string("invalid assignment target"),
        &typeck::TypeErrorKind::MissingReturn => common::make_string("missing return value"),
        &typeck::TypeErrorKind::TraitNotImplemented => common::make_string("type does not implement trait"),
        &typeck::TypeErrorKind::UnhandledEffect => common::make_string("unhandled effect"),
        &typeck::TypeErrorKind::InvalidControl => common::make_string("invalid break/continue"),
        &typeck::TypeErrorKind::PatternMismatch => common::make_string("pattern type mismatch"),
        &typeck::TypeErrorKind::NonExhaustive => common::make_string("non-exhaustive patterns"),
        &typeck::TypeErrorKind::InfiniteType => common::make_string("infinite type (recursive without indirection)"),
        &typeck::TypeErrorKind::InvalidCast => common::make_string("invalid cast"),
        &typeck::TypeErrorKind::UnreachablePattern => common::make_string("unreachable pattern"),
        &typeck::TypeErrorKind::LinearNotUsed => common::make_string("linear value not consumed"),
        &typeck::TypeErrorKind::LinearUsedMultipleTimes => common::make_string("linear value used more than once"),
        &typeck::TypeErrorKind::AffineUsedMultipleTimes => common::make_string("affine value used more than once"),
        &typeck::TypeErrorKind::UndeclaredEffect => common::make_string("undeclared effect"),
    }
}

// ============================================================
// Error Code Functions
// ============================================================

/// Returns the error code string for a parser ErrorCode.
fn parser_error_code(code: &parser_base::ErrorCode) -> &str {
    match code {
        &parser_base::ErrorCode::UnexpectedToken => "E0001",
        &parser_base::ErrorCode::UnexpectedEof => "E0002",
        &parser_base::ErrorCode::UnexpectedCharacter => "E0003",
        &parser_base::ErrorCode::InvalidInteger => "E0004",
        &parser_base::ErrorCode::InvalidFloat => "E0005",
        &parser_base::ErrorCode::ExpectedExpression => "E0006",
        &parser_base::ErrorCode::ExpectedType => "E0007",
        &parser_base::ErrorCode::ExpectedPattern => "E0008",
        &parser_base::ErrorCode::ExpectedIdentifier => "E0009",
        &parser_base::ErrorCode::ExpectedDeclaration => "E0010",
    }
}

/// Returns the error code string for an HIR DiagnosticCode.
fn hir_diagnostic_code(code: &hir::DiagnosticCode) -> &str {
    match code {
        &hir::DiagnosticCode::E0100 => "E0100",
        &hir::DiagnosticCode::E0101 => "E0101",
        &hir::DiagnosticCode::E0102 => "E0102",
        &hir::DiagnosticCode::E0103 => "E0103",
        &hir::DiagnosticCode::E0104 => "E0104",
        &hir::DiagnosticCode::E0200 => "E0200",
        &hir::DiagnosticCode::E0201 => "E0201",
        &hir::DiagnosticCode::E0202 => "E0202",
        &hir::DiagnosticCode::E0203 => "E0203",
        &hir::DiagnosticCode::E0204 => "E0204",
        &hir::DiagnosticCode::E0205 => "E0205",
        &hir::DiagnosticCode::E0206 => "E0206",
        &hir::DiagnosticCode::E0300 => "E0300",
        &hir::DiagnosticCode::E0301 => "E0301",
        &hir::DiagnosticCode::E0302 => "E0302",
        &hir::DiagnosticCode::E0303 => "E0303",
        &hir::DiagnosticCode::E0304 => "E0304",
        &hir::DiagnosticCode::E0305 => "E0305",
        &hir::DiagnosticCode::E0400 => "E0400",
        &hir::DiagnosticCode::E0401 => "E0401",
        &hir::DiagnosticCode::E0402 => "E0402",
        &hir::DiagnosticCode::E0403 => "E0403",
        &hir::DiagnosticCode::E0500 => "E0500",
        &hir::DiagnosticCode::E0501 => "E0501",
        &hir::DiagnosticCode::E0502 => "E0502",
        &hir::DiagnosticCode::E0503 => "E0503",
        &hir::DiagnosticCode::E0600 => "E0600",
        &hir::DiagnosticCode::E0601 => "E0601",
        &hir::DiagnosticCode::E0602 => "E0602",
        &hir::DiagnosticCode::E0603 => "E0603",
        &hir::DiagnosticCode::E0604 => "E0604",
        &hir::DiagnosticCode::E0900 => "E0900",
    }
}

/// Returns the error code string for a TypeErrorKind.
fn type_error_code(kind: &typeck::TypeErrorKind) -> &str {
    match kind {
        &typeck::TypeErrorKind::TypeMismatch => "E0201",
        &typeck::TypeErrorKind::CannotInfer => "E0202",
        &typeck::TypeErrorKind::UndefinedVariable => "E0203",
        &typeck::TypeErrorKind::UndefinedFunction => "E0204",
        &typeck::TypeErrorKind::ArityMismatch => "E0205",
        &typeck::TypeErrorKind::NotCallable => "E0206",
        &typeck::TypeErrorKind::NotIndexable => "E0207",
        &typeck::TypeErrorKind::NoSuchField => "E0208",
        &typeck::TypeErrorKind::NoSuchMethod => "E0209",
        &typeck::TypeErrorKind::CannotMutate => "E0210",
        &typeck::TypeErrorKind::InvalidLValue => "E0211",
        &typeck::TypeErrorKind::MissingReturn => "E0212",
        &typeck::TypeErrorKind::TraitNotImplemented => "E0213",
        &typeck::TypeErrorKind::UnhandledEffect => "E0214",
        &typeck::TypeErrorKind::InvalidControl => "E0215",
        &typeck::TypeErrorKind::PatternMismatch => "E0216",
        &typeck::TypeErrorKind::NonExhaustive => "E0217",
        &typeck::TypeErrorKind::InfiniteType => "E0218",
        &typeck::TypeErrorKind::InvalidCast => "E0219",
        &typeck::TypeErrorKind::UnreachablePattern => "E0220",
        &typeck::TypeErrorKind::LinearNotUsed => "E0221",
        &typeck::TypeErrorKind::LinearUsedMultipleTimes => "E0222",
        &typeck::TypeErrorKind::AffineUsedMultipleTimes => "E0223",
        &typeck::TypeErrorKind::UndeclaredEffect => "E0224",
    }
}

// ============================================================
// Function Info Extraction
// ============================================================

/// Information extracted from a function item.
pub struct FnInfo {
    /// The DefId of the function.
    pub def_id: hir_def::DefId,
    /// The function name (as Symbol).
    pub name: common::Symbol,
    /// The span of the function name (for extracting name from source).
    pub name_span: common::Span,
    /// The return type.
    pub return_ty: type_intern::TyId,
    /// The span of the function.
    pub span: common::Span,
}

/// Finds the function Item that corresponds to a given BodyId.
pub fn find_fn_for_body(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    target_body_id: hir_def::BodyId,
) -> Option<FnInfo> {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                match &fn_def.body_id {
                    &Option::Some(ref bid) => {
                        if bid.index == target_body_id.index {
                            return Option::Some(FnInfo {
                                def_id: entry.item.def_id,
                                name: entry.item.name.symbol,
                                name_span: entry.item.name.span,
                                return_ty: fn_def.sig.return_ty,
                                span: entry.item.span,
                            });
                        }
                    }
                    &Option::None => {}
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                // Check associated functions in impl blocks
                let mut j: usize = 0;
                while j < impl_def.items.len() {
                    match &impl_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return Option::Some(FnInfo {
                                            def_id: assoc_fn.def_id,
                                            name: assoc_fn.name.symbol,
                                            name_span: assoc_fn.name.span,
                                            return_ty: assoc_fn.sig.return_ty,
                                            span: assoc_fn.name.span,
                                        });
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return Option::Some(FnInfo {
                                            def_id: assoc_const.def_id,
                                            name: assoc_const.name.symbol,
                                            name_span: assoc_const.name.span,
                                            return_ty: assoc_const.ty,
                                            span: assoc_const.name.span,
                                        });
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            // Other item kinds don't have function bodies
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(ref const_def) => {
                if const_def.body_id.index == target_body_id.index {
                    return Option::Some(FnInfo {
                        def_id: entry.item.def_id,
                        name: entry.item.name.symbol,
                        name_span: entry.item.name.span,
                        return_ty: const_def.ty,
                        span: entry.item.span,
                    });
                }
            }
            &hir_item::ItemKind::Static(ref static_def) => {
                if static_def.body_id.index == target_body_id.index {
                    return Option::Some(FnInfo {
                        def_id: entry.item.def_id,
                        name: entry.item.name.symbol,
                        name_span: entry.item.name.span,
                        return_ty: static_def.ty,
                        span: entry.item.span,
                    });
                }
            }
            &hir_item::ItemKind::Trait(ref trait_def) => {
                // Check associated functions in trait definitions (default method bodies)
                let mut j: usize = 0;
                while j < trait_def.items.len() {
                    match &trait_def.items[j] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            match &assoc_fn.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return Option::Some(FnInfo {
                                            def_id: assoc_fn.def_id,
                                            name: assoc_fn.name.symbol,
                                            name_span: assoc_fn.name.span,
                                            return_ty: assoc_fn.sig.return_ty,
                                            span: assoc_fn.name.span,
                                        });
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                        &hir_item::AssocItem::Type(_) => {}
                        &hir_item::AssocItem::Const(ref assoc_const) => {
                            match &assoc_const.body_id {
                                &Option::Some(ref bid) => {
                                    if bid.index == target_body_id.index {
                                        return Option::Some(FnInfo {
                                            def_id: assoc_const.def_id,
                                            name: assoc_const.name.symbol,
                                            name_span: assoc_const.name.span,
                                            return_ty: assoc_const.ty,
                                            span: assoc_const.name.span,
                                        });
                                    }
                                }
                                &Option::None => {}
                            }
                        }
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Effect(_) => {}
            &hir_item::ItemKind::Handler(ref handler_def) => {
                // Check return clause body
                match &handler_def.return_clause {
                    &Option::Some(ref ret_clause) => {
                        if ret_clause.body_id.index == target_body_id.index {
                            // Return clause: return type is the computation result type
                            // We don't have the exact type here, use a placeholder
                            return Option::Some(FnInfo {
                                def_id: hir_def::DefId::new(target_body_id.index),
                                name: ret_clause.param_name.symbol,
                                name_span: ret_clause.param_name.span,
                                return_ty: type_intern::CommonTypes::unit(),
                                span: ret_clause.param_name.span,
                            });
                        }
                    }
                    &Option::None => {}
                }
                // Check operation implementation bodies
                let mut j: usize = 0;
                while j < handler_def.op_impls.len() {
                    let impl_entry = &handler_def.op_impls[j];
                    if impl_entry.body_id.index == target_body_id.index {
                        // Find the effect operation return type by searching Effect items
                        let ret_ty = find_effect_op_return_ty(items, impl_entry.op_def_id);
                        return Option::Some(FnInfo {
                            def_id: impl_entry.op_def_id,
                            name: impl_entry.name.symbol,
                            name_span: impl_entry.name.span,
                            return_ty: ret_ty,
                            span: impl_entry.span,
                        });
                    }
                    j = j + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }
    Option::None
}

/// Finds the return type of an effect operation by its DefId.
fn find_effect_op_return_ty(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    op_def_id: hir_def::DefId,
) -> type_intern::TyId {
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Effect(ref effect_def) => {
                let mut j: usize = 0;
                while j < effect_def.operations.len() {
                    let effect_op = &effect_def.operations[j];
                    if effect_op.def_id.index == op_def_id.index {
                        return effect_op.return_ty;
                    }
                    j = j + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    // Fallback: couldn't find the op definition
    type_intern::CommonTypes::unit()
}

/// Resolves a Symbol to a String using the interner.
pub fn resolve_symbol(interner: &interner::StringInterner, symbol: common::Symbol) -> String {
    match interner.resolve(symbol) {
        Option::Some(s) => clone_string(s),
        Option::None => make_fn_name(symbol.index as usize),
    }
}

/// Extracts a string from source text given a span.
pub fn span_to_string(source: &str, span: common::Span) -> String {
    let src_bytes = source.as_bytes();
    let mut result = String::new();
    let mut i = span.start;
    while i < span.end && i < src_bytes.len() {
        result.push(src_bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Resolves a function name from FnInfo, using source text for span-based extraction.
pub fn resolve_fn_name(source: &str, info: &FnInfo) -> String {
    let name = span_to_string(source, info.name_span);
    if name.len() > 0 {
        name
    } else {
        make_fn_name(info.name.index as usize)
    }
}

// ============================================================
// Helper Functions
// ============================================================

/// Checks if the lowered program contains a main function.
fn has_main_function(lower_result: &hir_lower_ctx::LowerResult) -> bool {
    let mut i: usize = 0;
    while i < lower_result.items.len() {
        let entry = &lower_result.items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(_) => {
                let name = resolve_symbol(&lower_result.interner, entry.item.name.symbol);
                if str_equals(&name, "main") {
                    return true;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    false
}

/// Compares a String to a string literal for equality.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();
    if bytes.len() != other_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    common::make_string(s.as_str())
}

/// Generates a function name from an index.
pub fn make_fn_name(index: usize) -> String {
    let mut name = common::make_string("fn_");
    append_usize(&mut name, index);
    name
}

/// Appends a usize as decimal digits to a string.
fn append_usize(s: &mut String, n: usize) {
    if n == 0 {
        s.push('0');
        return;
    }

    let mut digits: Vec<char> = Vec::new();
    let mut val = n;
    while val > 0 {
        let digit = (val % 10) as u8;
        digits.push((48u8 + digit) as char);
        val = val / 10;
    }

    // Reverse digits
    let len = digits.len();
    let mut i: usize = 0;
    while i < len {
        s.push(digits[len - 1 - i]);
        i = i + 1;
    }
}

// ============================================================
// Convenience Functions
// ============================================================

/// Compiles source code to LLVM IR using a fresh compiler.
pub fn compile(source: &str) -> CompileResult {
    let mut compiler = Compiler::new();
    compiler.compile(source)
}

/// Checks source code without generating code.
pub fn check(source: &str) -> CheckResult {
    let mut compiler = Compiler::new();
    compiler.check(source)
}

/// Parses source code and returns the AST.
pub fn parse(source: &str) -> ParseOnlyResult {
    let mut compiler = Compiler::new();
    compiler.parse(source)
}

// ============================================================
// File-Based Compilation
// ============================================================

/// Compiles a file to LLVM IR using its directory as the base for module resolution.
pub fn compile_file(path: &str) -> CompileResult {
    // Read the file
    let read_result = source::read_file(path);
    if !read_result.success {
        let mut errors: Vec<error::CompileError> = Vec::new();
        let msg = match &read_result.error {
            &Option::Some(ref e) => clone_string_from_ref(e),
            &Option::None => common::make_string("Unknown file read error"),
        };
        errors.push(error::CompileError::new(error::CompilePhase::Parse, msg));
        return CompileResult::err(errors);
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            let mut errors: Vec<error::CompileError> = Vec::new();
            errors.push(error::CompileError::new(
                error::CompilePhase::Parse,
                common::make_string("No content in file"),
            ));
            return CompileResult::err(errors);
        }
    };

    // Get the base directory for module resolution
    let base_dir = source::parent_dir(path);

    // Create compiler and compile with base_dir
    let mut compiler = Compiler::new();
    compiler.compile_with_base_dir(content.as_str(), base_dir)
}

/// Checks a file for errors without generating code.
pub fn check_file(path: &str) -> CheckResult {
    // Read the file
    let read_result = source::read_file(path);
    if !read_result.success {
        let mut errors: Vec<error::CompileError> = Vec::new();
        let msg = match &read_result.error {
            &Option::Some(ref e) => clone_string_from_ref(e),
            &Option::None => common::make_string("Unknown file read error"),
        };
        errors.push(error::CompileError::new(error::CompilePhase::Parse, msg));
        return CheckResult {
            success: false,
            errors: errors,
        };
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            let mut errors: Vec<error::CompileError> = Vec::new();
            errors.push(error::CompileError::new(
                error::CompilePhase::Parse,
                common::make_string("No content in file"),
            ));
            return CheckResult {
                success: false,
                errors: errors,
            };
        }
    };

    let source_str = content.as_str();

    // Get the base directory for module resolution
    let base_dir = source::parent_dir(path);

    // Create compiler and check with base_dir
    let mut compiler = Compiler::new();
    compiler.check_with_base_dir(source_str, base_dir)
}

/// Instrumented version of check_file that traces region memory usage.
pub fn check_file_traced(path: &str, region_id: u64) -> CheckResult {
    // Read the file
    let read_result = source::read_file(path);
    if !read_result.success {
        let mut errors: Vec<error::CompileError> = Vec::new();
        let msg = match &read_result.error {
            &Option::Some(ref e) => clone_string_from_ref(e),
            &Option::None => common::make_string("Unknown file read error"),
        };
        errors.push(error::CompileError::new(error::CompilePhase::Parse, msg));
        return CheckResult {
            success: false,
            errors: errors,
        };
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            let mut errors: Vec<error::CompileError> = Vec::new();
            errors.push(error::CompileError::new(
                error::CompilePhase::Parse,
                common::make_string("No content in file"),
            ));
            return CheckResult {
                success: false,
                errors: errors,
            };
        }
    };

    // Get the base directory for module resolution
    let base_dir = source::parent_dir(path);

    // Create compiler and check with base_dir (traced)
    let mut compiler = Compiler::new();
    compiler.check_with_base_dir_traced(content.as_str(), base_dir, region_id)
}

/// Clones a String from a reference.
fn clone_string_from_ref(s: &String) -> String {
    common::make_string(s.as_str())
}
