// Blood Self-Hosted Compiler - HIR Lowering Context
//
// This module defines the core types for AST-to-HIR lowering:
// - LoweringCtx: The main context holding state during lowering
// - LowerResult: The result of lowering (success or failure)
// - ItemEntry, BodyEntry: Storage entries for items and bodies
//
// Other hir_lower_* modules import this for access to LoweringCtx.

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod resolve;
mod interner;

// ============================================================
// Builtin Function Definition Mapping
// ============================================================

/// Maps a builtin function's DefId to its runtime function name.
/// Used for constructors like Vec::new(), String::new(), Box::new()
/// and variant constructors like Option::Some, Option::None.
pub struct BuiltinFnDef {
    pub def_id_index: u32,
    pub runtime_name: String,
}

impl BuiltinFnDef {
    pub fn new(def_id_index: u32, runtime_name: String) -> BuiltinFnDef {
        BuiltinFnDef { def_id_index: def_id_index, runtime_name: runtime_name }
    }
}

// ============================================================
// Lowering Result
// ============================================================

/// Result of lowering an AST to HIR.
pub struct LowerResult {
    /// The lowered HIR crate, if successful.
    pub crate_data: Option<hir::Crate>,
    /// Any diagnostics (errors, warnings) from lowering.
    pub diagnostics: Vec<hir::Diagnostic>,
    /// Lowered items (available when successful).
    pub items: Vec<ItemEntry>,
    /// Index from DefId.index to items Vec index for O(1) lookup.
    pub item_index: Vec<Option<usize>>,
    /// Lowered bodies (available when successful).
    pub bodies: Vec<BodyEntry>,
    /// Number of bodies from the main file (the first N entries in bodies).
    /// Bodies after this index are from external modules and should be skipped
    /// during type checking to avoid false errors from incomplete scope resolution.
    pub main_body_count: usize,
    /// The next type variable ID after HIR lowering.
    /// The type checker must start its counter at this value to avoid
    /// TyVarId collisions with HIR-allocated inference variables.
    pub next_ty_var: u32,
    /// Next DefId index for allocating new DefIds (avoids collisions with HIR-allocated ones).
    pub next_def_id: u32,
    /// Builtin type DefIds for type checker registration.
    pub builtin_string_def: Option<hir_def::DefId>,
    pub builtin_vec_def: Option<hir_def::DefId>,
    pub builtin_option_def: Option<hir_def::DefId>,
    pub builtin_box_def: Option<hir_def::DefId>,
    pub builtin_hashmap_def: Option<hir_def::DefId>,
    pub builtin_result_def: Option<hir_def::DefId>,
    /// Builtin variant DefIds for type checker variant resolution.
    pub builtin_option_some_def: Option<hir_def::DefId>,
    pub builtin_option_none_def: Option<hir_def::DefId>,
    pub builtin_result_ok_def: Option<hir_def::DefId>,
    pub builtin_result_err_def: Option<hir_def::DefId>,
    /// The string interner from the lowering context.
    /// Contains all symbol-to-string mappings created during lowering.
    /// Codegen uses this to resolve function names from Symbol indices.
    pub interner: interner::StringInterner,
    /// Builtin function DefId-to-runtime-name mappings.
    /// Covers constructors (String::new, Vec::new, Box::new, HashMap::new)
    /// and variant constructors (Option::Some, Option::None, Result::Ok, Result::Err).
    pub builtin_fn_defs: Vec<BuiltinFnDef>,
}

impl LowerResult {
    /// Creates a successful result with items, item_index, and bodies.
    pub fn success_with_data(
        crate_data: hir::Crate,
        items: Vec<ItemEntry>,
        item_index: Vec<Option<usize>>,
        bodies: Vec<BodyEntry>,
        main_body_count: usize,
        next_ty_var: u32,
        next_def_id: u32,
        builtin_string_def: Option<hir_def::DefId>,
        builtin_vec_def: Option<hir_def::DefId>,
        builtin_option_def: Option<hir_def::DefId>,
        builtin_box_def: Option<hir_def::DefId>,
        builtin_hashmap_def: Option<hir_def::DefId>,
        builtin_result_def: Option<hir_def::DefId>,
        builtin_option_some_def: Option<hir_def::DefId>,
        builtin_option_none_def: Option<hir_def::DefId>,
        builtin_result_ok_def: Option<hir_def::DefId>,
        builtin_result_err_def: Option<hir_def::DefId>,
        interner: interner::StringInterner,
        builtin_fn_defs: Vec<BuiltinFnDef>,
    ) -> LowerResult {
        LowerResult {
            crate_data: Option::Some(crate_data),
            diagnostics: Vec::new(),
            items: items,
            item_index: item_index,
            bodies: bodies,
            main_body_count: main_body_count,
            next_ty_var: next_ty_var,
            next_def_id: next_def_id,
            builtin_string_def: builtin_string_def,
            builtin_vec_def: builtin_vec_def,
            builtin_option_def: builtin_option_def,
            builtin_box_def: builtin_box_def,
            builtin_hashmap_def: builtin_hashmap_def,
            builtin_result_def: builtin_result_def,
            builtin_option_some_def: builtin_option_some_def,
            builtin_option_none_def: builtin_option_none_def,
            builtin_result_ok_def: builtin_result_ok_def,
            builtin_result_err_def: builtin_result_err_def,
            interner: interner,
            builtin_fn_defs: builtin_fn_defs,
        }
    }

    /// Creates a successful result (legacy, no items/bodies).
    pub fn success(crate_data: hir::Crate) -> LowerResult {
        LowerResult {
            crate_data: Option::Some(crate_data),
            diagnostics: Vec::new(),
            items: Vec::new(),
            item_index: Vec::new(),
            bodies: Vec::new(),
            main_body_count: 0,
            next_ty_var: 0,
            next_def_id: 0,
            builtin_string_def: Option::None,
            builtin_vec_def: Option::None,
            builtin_option_def: Option::None,
            builtin_box_def: Option::None,
            builtin_hashmap_def: Option::None,
            builtin_result_def: Option::None,
            builtin_option_some_def: Option::None,
            builtin_option_none_def: Option::None,
            builtin_result_ok_def: Option::None,
            builtin_result_err_def: Option::None,
            interner: interner::StringInterner::new(),
            builtin_fn_defs: Vec::new(),
        }
    }

    /// Creates a failure result with diagnostics.
    pub fn failure(diagnostics: Vec<hir::Diagnostic>) -> LowerResult {
        LowerResult {
            crate_data: Option::None,
            diagnostics: diagnostics,
            items: Vec::new(),
            item_index: Vec::new(),
            bodies: Vec::new(),
            main_body_count: 0,
            next_ty_var: 0,
            next_def_id: 0,
            builtin_string_def: Option::None,
            builtin_vec_def: Option::None,
            builtin_option_def: Option::None,
            builtin_box_def: Option::None,
            builtin_hashmap_def: Option::None,
            builtin_result_def: Option::None,
            builtin_option_some_def: Option::None,
            builtin_option_none_def: Option::None,
            builtin_result_ok_def: Option::None,
            builtin_result_err_def: Option::None,
            interner: interner::StringInterner::new(),
            builtin_fn_defs: Vec::new(),
        }
    }

    /// Returns true if lowering was successful.
    pub fn is_ok(self: &Self) -> bool {
        self.crate_data.is_some()
    }

    /// Gets the number of bodies.
    pub fn body_count(self: &Self) -> usize {
        self.bodies.len()
    }

    /// Gets a body by index.
    pub fn get_body(self: &Self, index: usize) -> Option<&BodyEntry> {
        if index < self.bodies.len() {
            Option::Some(&self.bodies[index])
        } else {
            Option::None
        }
    }

    /// Gets an item by DefId in O(1) time.
    /// Returns None if the DefId doesn't correspond to an item.
    pub fn get_item(self: &Self, def_id: hir_def::DefId) -> Option<&ItemEntry> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.item_index.len() {
            return Option::None;
        }
        match &self.item_index[def_idx] {
            &Some(idx) => Some(&self.items[idx]),
            &None => Option::None,
        }
    }
}

// ============================================================
// Lowering Context
// ============================================================

/// Context for lowering AST to HIR.
///
/// Maintains the resolver for name resolution and collects
/// lowered items and bodies.
pub struct LoweringCtx {
    /// The name resolver.
    pub resolver: resolve::Resolver,
    /// The string interner for symbol resolution.
    pub interner: interner::StringInterner,
    /// Counter for allocating DefIds.
    pub next_def_id: u32,
    /// Counter for allocating BodyIds.
    pub next_body_id: u32,
    /// Counter for allocating LocalIds.
    pub next_local_id: u32,
    /// Counter for allocating type variables.
    pub next_ty_var: u32,
    /// Counter for allocating effect row variables.
    pub next_effect_row_var: u32,
    /// Counter for allocating record row variables.
    pub next_record_row_var: u32,
    /// Collected diagnostics.
    pub diagnostics: Vec<hir::Diagnostic>,
    /// Lowered items.
    pub items: Vec<ItemEntry>,
    /// Index from DefId.index to items Vec index for O(1) lookup.
    pub item_index: Vec<Option<usize>>,
    /// Bodies by BodyId index.
    pub bodies: Vec<BodyEntry>,
    /// The entry point DefId (main function), if found.
    pub entry_point: Option<hir_def::DefId>,
    /// Base directory for resolving external modules.
    pub base_dir: String,
    /// Loaded modules for circular import prevention.
    /// Each entry is (module_name_symbol, def_id, file_path).
    pub loaded_modules: Vec<LoadedModule>,
    /// Source text for resolving span-based symbols.
    pub source: String,
    /// Accumulated body locals from let-binding patterns during body lowering.
    /// This is populated by lower_pattern when it creates binding patterns,
    /// and drained by lower_fn_body to add them to the Body's locals Vec.
    pub body_locals: Vec<hir_expr::Local>,
    /// The current Self type when lowering inside an impl block.
    pub current_self_type: Option<hir_ty::Type>,
    /// DefIds for builtin types (set during register_builtin_types).
    pub builtin_string_def: Option<hir_def::DefId>,
    pub builtin_vec_def: Option<hir_def::DefId>,
    pub builtin_option_def: Option<hir_def::DefId>,
    pub builtin_box_def: Option<hir_def::DefId>,
    pub builtin_hashmap_def: Option<hir_def::DefId>,
    pub builtin_result_def: Option<hir_def::DefId>,
    /// DefIds for builtin enum variants (set during register_builtin_children).
    pub builtin_option_some_def: Option<hir_def::DefId>,
    pub builtin_option_none_def: Option<hir_def::DefId>,
    pub builtin_result_ok_def: Option<hir_def::DefId>,
    pub builtin_result_err_def: Option<hir_def::DefId>,
    /// Paths currently being loaded (for circular import detection during recursive loading).
    /// Separates circular-import detection from loaded_modules ordering.
    pub loading_paths: Vec<String>,
    /// Builtin function DefId-to-runtime-name mappings.
    pub builtin_fn_defs: Vec<BuiltinFnDef>,
    /// Seen (trait_def_id, type_def_id) pairs for overlapping impl detection.
    /// Each entry is (trait_idx << 32) | type_idx.
    pub seen_trait_impls: Vec<u64>,
}

/// Tracks a loaded external module to prevent circular imports.
pub struct LoadedModule {
    /// The module name symbol.
    pub name: common::Symbol,
    /// The DefId assigned to this module.
    pub def_id: hir_def::DefId,
    /// The file path that was loaded.
    pub path: String,
}

/// Entry storing a DefId and its corresponding Item.
pub struct ItemEntry {
    pub def_id: hir_def::DefId,
    pub item: hir_item::Item,
}

impl ItemEntry {
    pub fn new(def_id: hir_def::DefId, item: hir_item::Item) -> ItemEntry {
        ItemEntry { def_id, item }
    }
}

/// Entry storing a BodyId and its corresponding Body.
pub struct BodyEntry {
    pub body_id: hir_def::BodyId,
    pub body: hir_expr::Body,
}

impl BodyEntry {
    pub fn new(body_id: hir_def::BodyId, body: hir_expr::Body) -> BodyEntry {
        BodyEntry { body_id, body }
    }
}

impl LoadedModule {
    /// Creates a new LoadedModule.
    pub fn new(name: common::Symbol, def_id: hir_def::DefId, path: String) -> LoadedModule {
        LoadedModule { name, def_id, path }
    }
}

impl LoweringCtx {
    /// Creates a new lowering context with current directory as base.
    pub fn new(source: String) -> LoweringCtx {
        LoweringCtx {
            resolver: resolve::Resolver::new(),
            interner: interner::StringInterner::new(),
            next_def_id: 0,
            next_body_id: 0,
            next_local_id: 0,
            next_ty_var: 0,
            next_effect_row_var: 0,
            next_record_row_var: 0,
            diagnostics: Vec::new(),
            items: Vec::new(),
            item_index: Vec::new(),
            bodies: Vec::new(),
            entry_point: Option::None,
            base_dir: common::make_string("."),
            loaded_modules: Vec::new(),
            source: source,
            body_locals: Vec::new(),
            current_self_type: Option::None,
            builtin_string_def: Option::None,
            builtin_vec_def: Option::None,
            builtin_option_def: Option::None,
            builtin_box_def: Option::None,
            builtin_hashmap_def: Option::None,
            builtin_result_def: Option::None,
            builtin_option_some_def: Option::None,
            builtin_option_none_def: Option::None,
            builtin_result_ok_def: Option::None,
            builtin_result_err_def: Option::None,
            loading_paths: Vec::new(),
            builtin_fn_defs: Vec::new(),
            seen_trait_impls: Vec::new(),
        }
    }

    /// Creates a new lowering context with a specified base directory.
    pub fn with_base_dir(base_dir: String, source: String) -> LoweringCtx {
        LoweringCtx {
            resolver: resolve::Resolver::new(),
            interner: interner::StringInterner::new(),
            next_def_id: 0,
            next_body_id: 0,
            next_local_id: 0,
            next_ty_var: 0,
            next_effect_row_var: 0,
            next_record_row_var: 0,
            diagnostics: Vec::new(),
            items: Vec::new(),
            item_index: Vec::new(),
            bodies: Vec::new(),
            entry_point: Option::None,
            base_dir: base_dir,
            loaded_modules: Vec::new(),
            source: source,
            body_locals: Vec::new(),
            current_self_type: Option::None,
            builtin_string_def: Option::None,
            builtin_vec_def: Option::None,
            builtin_option_def: Option::None,
            builtin_box_def: Option::None,
            builtin_hashmap_def: Option::None,
            builtin_result_def: Option::None,
            builtin_option_some_def: Option::None,
            builtin_option_none_def: Option::None,
            builtin_result_ok_def: Option::None,
            builtin_result_err_def: Option::None,
            loading_paths: Vec::new(),
            builtin_fn_defs: Vec::new(),
            seen_trait_impls: Vec::new(),
        }
    }

    /// Allocates a fresh DefId.
    pub fn alloc_def_id(self: &mut Self) -> hir_def::DefId {
        let id = hir_def::DefId::new(self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Allocates a fresh BodyId.
    pub fn alloc_body_id(self: &mut Self) -> hir_def::BodyId {
        let id = hir_def::BodyId::new(self.next_body_id);
        self.next_body_id = self.next_body_id + 1;
        id
    }

    /// Allocates a fresh LocalId.
    pub fn alloc_local_id(self: &mut Self) -> hir_def::LocalId {
        let id = hir_def::LocalId::new(self.next_local_id);
        self.next_local_id = self.next_local_id + 1;
        id
    }

    /// Allocates a fresh TyVarId.
    pub fn alloc_ty_var(self: &mut Self) -> hir_def::TyVarId {
        let id = hir_def::TyVarId::new(self.next_ty_var);
        self.next_ty_var = self.next_ty_var + 1;
        id
    }

    /// Allocates a fresh EffectRowVarId.
    pub fn alloc_effect_row_var(self: &mut Self) -> hir_def::EffectRowVarId {
        let id = hir_def::EffectRowVarId::new(self.next_effect_row_var);
        self.next_effect_row_var = self.next_effect_row_var + 1;
        id
    }

    /// Allocates a fresh RecordRowVarId.
    pub fn alloc_record_row_var(self: &mut Self) -> hir_def::RecordRowVarId {
        let id = hir_def::RecordRowVarId::new(self.next_record_row_var);
        self.next_record_row_var = self.next_record_row_var + 1;
        id
    }

    /// Reports an error diagnostic.
    pub fn error(self: &mut Self, code: hir::DiagnosticCode, message: String, span: common::Span) {
        let diag = hir::Diagnostic::error(code, message, span);
        self.diagnostics.push(diag);
    }

    /// Reports a warning diagnostic.
    pub fn warning(self: &mut Self, code: hir::DiagnosticCode, message: String, span: common::Span) {
        let diag = hir::Diagnostic::warning(code, message, span);
        self.diagnostics.push(diag);
    }

    /// Returns true if there are any error diagnostics.
    pub fn has_errors(self: &Self) -> bool {
        let mut i: usize = 0;
        while i < self.diagnostics.len() {
            match self.diagnostics[i].level {
                hir::DiagnosticLevel::Error => { return true; }
                hir::DiagnosticLevel::Warning => {}
                hir::DiagnosticLevel::Note => {}
                hir::DiagnosticLevel::Help => {}
            }
            i = i + 1;
        }
        false
    }

    /// Adds an item to the lowered items.
    pub fn add_item(self: &mut Self, def_id: hir_def::DefId, item: hir_item::Item) {
        let idx = self.items.len();
        let entry = ItemEntry::new(def_id, item);
        self.items.push(entry);

        // Ensure item_index is large enough
        let def_idx = def_id.index as usize;
        while self.item_index.len() <= def_idx {
            self.item_index.push(Option::None);
        }
        self.item_index[def_idx] = Some(idx);
    }

    /// Gets an item by DefId in O(1) time.
    /// Returns None if the DefId doesn't correspond to an item.
    pub fn get_item(self: &Self, def_id: hir_def::DefId) -> Option<&ItemEntry> {
        let def_idx = def_id.index as usize;
        if def_idx >= self.item_index.len() {
            return Option::None;
        }
        match &self.item_index[def_idx] {
            &Some(idx) => Some(&self.items[idx]),
            &None => Option::None,
        }
    }

    /// Adds a body to the lowered bodies.
    pub fn add_body(self: &mut Self, body_id: hir_def::BodyId, body: hir_expr::Body) {
        let entry = BodyEntry::new(body_id, body);
        self.bodies.push(entry);
    }

    /// Checks if a module has already been loaded (by file path).
    /// Returns the DefId if found, None otherwise.
    pub fn find_loaded_module(self: &Self, path: &String) -> Option<hir_def::DefId> {
        let mut i: usize = 0;
        while i < self.loaded_modules.len() {
            if string_eq(&self.loaded_modules[i].path, path) {
                return Option::Some(self.loaded_modules[i].def_id);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Adds a loaded module to the tracking list.
    pub fn add_loaded_module(
        self: &mut Self,
        name: common::Symbol,
        def_id: hir_def::DefId,
        path: String,
    ) {
        let entry = LoadedModule::new(name, def_id, path);
        self.loaded_modules.push(entry);
    }

    /// Checks if a file path is currently being loaded (circular import detection).
    /// This is separate from find_loaded_module because loaded_modules uses
    /// post-order insertion (dependencies before dependents) for correct Phase 3a ordering.
    pub fn is_path_loading(self: &Self, path: &String) -> bool {
        let mut i: usize = 0;
        while i < self.loading_paths.len() {
            if string_eq(&self.loading_paths[i], path) {
                return true;
            }
            i = i + 1;
        }
        false
    }

    /// Gets the base directory for resolving external modules.
    pub fn get_base_dir(self: &Self) -> &String {
        &self.base_dir
    }

    /// Resolves a symbol to its string representation.
    /// Returns a copy of the interned string, or a fallback if not found.
    pub fn resolve_symbol(self: &Self, symbol: common::Symbol) -> String {
        match self.interner.resolve(symbol) {
            Option::Some(s) => clone_str(s),
            Option::None => {
                // Fallback: generate a name from the index
                let mut result = String::new();
                result.push_str("sym_");
                append_u32_to_string(&mut result, symbol.index);
                result
            }
        }
    }

    /// Interns a string and returns its symbol.
    pub fn intern(self: &mut Self, s: &str) -> common::Symbol {
        self.interner.intern(s)
    }

    /// Extracts a string from source text given a span.
    pub fn span_to_string(self: &Self, span: common::Span) -> String {
        let start = span.start;
        let end = span.end;
        let src_bytes = self.source.as_bytes();
        let mut result = String::new();
        let mut i = start;
        while i < end && i < src_bytes.len() {
            result.push(src_bytes[i] as char);
            i = i + 1;
        }
        result
    }

}

// ============================================================
// Helper Functions
// ============================================================

/// Compares a String with a &str for equality.
fn str_eq(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();
    if bytes.len() != other_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Compares two Strings for equality.
fn string_eq(a: &String, b: &String) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Clones a &String to a String.
fn clone_str(s: &String) -> String {
    common::make_string(s.as_str())
}

/// Appends a u32 as decimal to a string.
pub fn append_u32_to_string(s: &mut String, n: u32) {
    if n == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<char> = Vec::new();
    let mut val = n;
    while val > 0 {
        let digit = (val % 10) as u8;
        digits.push((48u8 + digit) as char);
        val = val / 10;
    }
    let len = digits.len();
    let mut i: usize = 0;
    while i < len {
        s.push(digits[len - 1 - i]);
        i = i + 1;
    }
}

