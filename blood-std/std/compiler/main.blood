// Blood Self-Hosted Compiler - Main Entry Point
//
// This module provides the command-line interface for the Blood compiler.
// It orchestrates parsing arguments, reading source files, and running
// the compilation pipeline.
//
// CLI and I/O is provided by blood-rust builtins:
// - args_count() -> i32 - get number of CLI arguments
// - args_get(i32) -> &str - get argument at index
// - print_str(&str) - print string without newline
// - println_str(&str) - print string with newline
// - file_write_string(&str, &str) -> bool - write string to file path

mod common;
mod ast;
mod hir;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir_lower;
mod hir_lower_ctx;
mod parser;
mod parser_base;
mod resolve;
mod mir_def;
mod mir_body;
mod mir_lower;
mod codegen;
mod interner;
mod unify;
mod typeck;
mod typeck_driver;
mod driver;
mod reporter;
mod source;

// ============================================================
// Command Line Arguments
// ============================================================

/// Compiler command to execute.
pub enum Command {
    /// Check source code for errors.
    Check,
    /// Build source code to LLVM IR.
    Build,
    /// Run source code (compile and execute).
    Run,
    /// Print help message.
    Help,
    /// Print version information.
    Version,
}

/// Parsed command line arguments.
pub struct Args {
    /// The command to execute.
    pub command: Command,
    /// The source file path (if provided).
    pub source_file: Option<String>,
    /// Output file path (if provided).
    pub output_file: Option<String>,
    /// Whether to enable verbose output.
    pub verbose: bool,
    /// Whether to enable colored output.
    pub colors: bool,
}

impl Args {
    /// Creates default arguments.
    pub fn default() -> Args {
        Args {
            command: Command::Help,
            source_file: Option::None,
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for checking a file.
    pub fn check(file: String) -> Args {
        Args {
            command: Command::Check,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for building a file.
    pub fn build(file: String) -> Args {
        Args {
            command: Command::Build,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Main function - entry point for the compiler.
pub fn main() -> i32 {
    // Initialize the global string interner before any parsing
    // This ensures consistent symbol indices across all compilation phases
    interner::init_global_interner();

    // Parse command line arguments
    // Note: Without FFI for argument access, we use a stub
    let args = parse_args_stub();

    // Execute the command
    match &args.command {
        &Command::Check => run_check(&args),
        &Command::Build => run_build(&args),
        &Command::Run => run_run(&args),
        &Command::Help => run_help(&args),
        &Command::Version => run_version(&args),
    }
}

/// Parses command line arguments using blood-rust builtins.
///
/// Uses args_count() and args_get() builtins to access actual CLI args.
fn parse_args_stub() -> Args {
    let argc = args_count();

    // Build argv vector from CLI args
    let mut argv: Vec<String> = Vec::new();
    let mut i: i32 = 0;
    while i < argc {
        let arg_ref: &str = args_get(i);
        argv.push(common::make_string(arg_ref));
        i = i + 1;
    }

    // Use existing parse_args function
    parse_args(argc, &argv)
}

// ============================================================
// Command Handlers
// ============================================================

/// Runs the check command.
fn run_check(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Use check_file for proper base_dir module resolution
            let result = driver::check_file(path.as_str());
            if result.success {
                print_success("Check passed");
                0
            } else {
                // Read the source content for error reporting
                let read_result = source::read_file(path.as_str());
                let content = match &read_result.content {
                    &Option::Some(ref c) => c.as_str(),
                    &Option::None => "",
                };
                // Format and print errors
                let error_reporter = reporter::ErrorReporter::new(content, path.as_str());
                let formatted = error_reporter.format_errors(&result.errors);
                print_string(&formatted);
                1
            }
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the build command.
fn run_build(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Use compile_file for proper base_dir module resolution
            let result = driver::compile_file(path.as_str());
            if result.success {
                // Output the LLVM IR
                match &result.llvm_ir {
                    &Option::Some(ref ir) => {
                        // Write to output file or stdout
                        match &args.output_file {
                            &Option::Some(ref out_path) => {
                                // Write to output file using blood-rust builtin
                                let write_success = file_write_string(out_path.as_str(), ir.as_str());
                                if write_success {
                                    print_success("Wrote LLVM IR to: ");
                                    print_string(out_path);
                                    print_newline();
                                } else {
                                    print_error("Failed to write file: ");
                                    print_string(out_path);
                                    print_newline();
                                    return 1;
                                }
                            }
                            &Option::None => {
                                // Print to stdout
                                print_string(ir);
                            }
                        }
                        0
                    }
                    &Option::None => {
                        print_error("Compilation succeeded but no IR generated");
                        1
                    }
                }
            } else {
                // Read the source content for error reporting
                let read_result = source::read_file(path.as_str());
                let content = match &read_result.content {
                    &Option::Some(ref c) => c.as_str(),
                    &Option::None => "",
                };
                // Format and print errors
                let error_reporter = reporter::ErrorReporter::new(content, path.as_str());
                let formatted = error_reporter.format_errors(&result.errors);
                print_string(&formatted);
                1
            }
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the run command.
///
/// This command compiles the source to LLVM IR and then attempts to execute it.
///
/// # Current Limitation
///
/// The run command currently only generates LLVM IR. Full execution would require:
/// 1. A shell execution builtin to run external commands
/// 2. Access to LLVM tools (llc) to compile IR to object code
/// 3. Access to a linker (ld, clang, gcc) to create an executable
/// 4. Running the resulting binary and capturing its exit code
///
/// To run a Blood program manually after compilation:
/// 1. Use `blood build file.blood -o output.ll` to generate LLVM IR
/// 2. Run `llc output.ll -filetype=obj -o output.o` to create object file
/// 3. Run `clang output.o -o output` to link into executable
/// 4. Run `./output` to execute
fn run_run(args: &Args) -> i32 {
    // Build first (generates LLVM IR)
    let build_result = run_build(args);
    if build_result != 0 {
        return build_result;
    }

    // Execution requires shell command support which is not available
    print_info("Build complete. See help for manual execution steps.");
    print_info("Run command requires shell execution builtin (not yet available).");
    0
}

/// Prints help message.
fn run_help(_args: &Args) -> i32 {
    let mut help = String::new();
    help.push_str("Blood Compiler\n");
    help.push_str("\n");
    help.push_str("USAGE:\n");
    help.push_str("    blood <command> [options] <file>\n");
    help.push_str("\n");
    help.push_str("COMMANDS:\n");
    help.push_str("    check    Check source for errors without compiling\n");
    help.push_str("    build    Compile source to LLVM IR\n");
    help.push_str("    run      Compile and execute\n");
    help.push_str("    help     Print this help message\n");
    help.push_str("    version  Print version information\n");
    help.push_str("\n");
    help.push_str("OPTIONS:\n");
    help.push_str("    -o <file>    Output file path\n");
    help.push_str("    -v           Verbose output\n");
    help.push_str("    --no-color   Disable colored output\n");
    print_string(&help);
    0
}

/// Prints version information.
fn run_version(_args: &Args) -> i32 {
    let mut version = String::new();
    version.push_str("Blood Compiler 0.1.0\n");
    version.push_str("Self-hosted implementation\n");
    print_string(&version);
    0
}

// ============================================================
// Compile From String (Test API)
// ============================================================

/// Compiles source code from a string (for testing without file I/O).
pub fn compile_source(source: &str, filename: &str) -> CompileOutput {
    let result = driver::compile(source);

    if result.success {
        CompileOutput {
            success: true,
            llvm_ir: result.llvm_ir,
            error_output: Option::None,
        }
    } else {
        let error_reporter = reporter::ErrorReporter::new(source, filename);
        let formatted = error_reporter.format_errors(&result.errors);
        CompileOutput {
            success: false,
            llvm_ir: Option::None,
            error_output: Option::Some(formatted),
        }
    }
}

/// Output from compiling source code.
pub struct CompileOutput {
    /// Whether compilation succeeded.
    pub success: bool,
    /// Generated LLVM IR (if successful).
    pub llvm_ir: Option<String>,
    /// Formatted error output (if failed).
    pub error_output: Option<String>,
}

// ============================================================
// Output Helpers
// ============================================================

/// Prints an error message.
fn print_error(msg: &str) {
    let mut output = String::new();
    output.push_str("error: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a success message.
fn print_success(msg: &str) {
    let mut output = String::new();
    output.push_str("success: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints an info message.
fn print_info(msg: &str) {
    let mut output = String::new();
    output.push_str("info: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a string to stdout using blood-rust println_str builtin.
fn print_string(s: &String) {
    // Convert String to &str for builtin call
    // Note: We iterate and print char by char because
    // println_str expects &str, not &String
    print_str(s.as_str());
}

/// Prints a newline using blood-rust builtin.
fn print_newline() {
    println_str("");
}

// ============================================================
// Argument Parsing (Structure for when FFI is available)
// ============================================================

/// Parses command line arguments into Args structure.
/// This function structure is ready for when argument access is available.
pub fn parse_args(argc: i32, argv: &Vec<String>) -> Args {
    let mut args = Args::default();

    if argc < 2 {
        return args;
    }

    // Parse command
    let cmd = &argv[1];
    args.command = parse_command(cmd);

    // Parse remaining arguments
    let mut i: usize = 2;
    while i < argv.len() {
        let arg = &argv[i];
        let bytes = arg.as_bytes();

        if bytes.len() > 0 && bytes[0] == 45 { // '-'
            // Option flag
            if str_equals(arg, "-o") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.output_file = Option::Some(clone_string(&argv[i]));
                }
            } else if str_equals(arg, "-v") {
                args.verbose = true;
            } else if str_equals(arg, "--no-color") {
                args.colors = false;
            }
        } else {
            // Positional argument (source file)
            if args.source_file.is_none() {
                args.source_file = Option::Some(clone_string(arg));
            }
        }
        i = i + 1;
    }

    args
}

/// Parses a command string into Command enum.
fn parse_command(cmd: &String) -> Command {
    if str_equals(cmd, "check") {
        Command::Check
    } else if str_equals(cmd, "build") {
        Command::Build
    } else if str_equals(cmd, "run") {
        Command::Run
    } else if str_equals(cmd, "help") {
        Command::Help
    } else if str_equals(cmd, "version") {
        Command::Version
    } else {
        Command::Help
    }
}

// ============================================================
// String Helpers
// ============================================================

/// Compares a String with a &str.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();

    if bytes.len() != other_bytes.len() {
        return false;
    }

    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    common::make_string(s.as_str())
}
