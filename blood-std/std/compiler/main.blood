// Blood Self-Hosted Compiler - Main Entry Point
//
// This module provides the command-line interface for the Blood compiler.
// It orchestrates parsing arguments, reading source files, and running
// the compilation pipeline.
//
// CLI and I/O is provided by blood-rust builtins:
// - args_count() -> i32 - get number of CLI arguments
// - args_get(i32) -> &str - get argument at index
// - print_str(&str) - print string without newline
// - println_str(&str) - print string with newline
// - file_write_string(&str, &str) -> bool - write string to file path
// - file_append_string(&str, &str) -> i32 - append string to file path
// - system(&str) -> i32 - run shell command

mod common;
mod ast;
mod hir;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir_lower;
mod hir_lower_ctx;
mod parser;
mod parser_base;
mod resolve;
mod mir_def;
mod mir_body;
mod mir_lower;
mod codegen;
mod codegen_ctx;
mod codegen_streaming;
mod codegen_types;
mod interner;
mod unify;
mod typeck;
mod typeck_driver;
mod driver;
mod reporter;
mod source;

// ============================================================
// Command Line Arguments
// ============================================================

/// Compiler command to execute.
pub enum Command {
    /// Check source code for errors.
    Check,
    /// Build source code to LLVM IR.
    Build,
    /// Run source code (compile and execute).
    Run,
    /// Print help message.
    Help,
    /// Print version information.
    Version,
}

/// Parsed command line arguments.
pub struct Args {
    /// The command to execute.
    pub command: Command,
    /// The source file path (if provided).
    pub source_file: Option<String>,
    /// Output file path (if provided).
    pub output_file: Option<String>,
    /// Whether to enable verbose output.
    pub verbose: bool,
    /// Whether to enable colored output.
    pub colors: bool,
}

impl Args {
    /// Creates default arguments.
    pub fn default() -> Args {
        Args {
            command: Command::Help,
            source_file: Option::None,
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for checking a file.
    pub fn check(file: String) -> Args {
        Args {
            command: Command::Check,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for building a file.
    pub fn build(file: String) -> Args {
        Args {
            command: Command::Build,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Main function - entry point for the compiler.
pub fn main() -> i32 {
    // Initialize the global string interner before any parsing
    // This ensures consistent symbol indices across all compilation phases
    interner::init_global_interner();

    // Parse command line arguments
    // Note: Without FFI for argument access, we use a stub
    let args = parse_args_stub();

    // Execute the command
    match &args.command {
        &Command::Check => run_check(&args),
        &Command::Build => run_build(&args),
        &Command::Run => run_run(&args),
        &Command::Help => run_help(&args),
        &Command::Version => run_version(&args),
    }
}

/// Parses command line arguments using blood-rust builtins.
///
/// Uses args_count() and args_get() builtins to access actual CLI args.
fn parse_args_stub() -> Args {
    let argc = args_count();

    // Build argv vector from CLI args
    let mut argv: Vec<String> = Vec::new();
    let mut i: i32 = 0;
    while i < argc {
        let arg_ref: &str = args_get(i);
        argv.push(common::make_string(arg_ref));
        i = i + 1;
    }

    // Use existing parse_args function
    parse_args(argc, &argv)
}

// ============================================================
// Command Handlers
// ============================================================

/// Runs the check command.
///
/// Wraps the entire check in a region so all front-end allocations (parse, HIR,
/// typeck for all transitive imports) are bulk-freed when check completes.
fn run_check(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Create region for all check allocations.
            // 16 MB initial, 50 GB max — virtual address reservation via mmap,
            // physical pages committed on demand.
            // Self-hosting requires ~21 GB for HIR + additional for typeck.
            let check_region = region_create(16777216, 53687091200);
            region_activate(check_region);

            // Run check (all parse/HIR/typeck allocations go to check_region)
            let result = driver::check_file(path.as_str());

            // Print results while region is still alive (strings are in the region)
            let exit_code = if result.success {
                print_success("Check passed");
                0
            } else {
                // Read the source content for error reporting
                let read_result = source::read_file(path.as_str());
                let content = match &read_result.content {
                    &Option::Some(ref c) => c.as_str(),
                    &Option::None => "",
                };
                // Format and print errors
                let error_reporter = reporter::ErrorReporter::new(content, path.as_str());
                let formatted = error_reporter.format_errors(&result.errors);
                print_string(&formatted);
                1
            };

            // Deactivate and destroy — bulk-frees all front-end data
            region_deactivate();
            region_destroy(check_region);

            exit_code
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the build command.
/// Uses streaming codegen to write IR directly to file, avoiding OOM.
/// Then invokes llc-14 to produce an object file and clang-14 to link an executable.
fn run_build(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Determine output path for LLVM IR
            let ll_path = match &args.output_file {
                &Option::Some(ref out) => clone_string(out),
                &Option::None => default_ll_path(path),
            };

            // Phase 1: Generate LLVM IR via streaming codegen
            let result = compile_file_streaming(path.as_str(), ll_path.as_str());
            if !result {
                return 1;
            }
            print_success("Wrote LLVM IR to: ");
            print_str(ll_path.as_str());
            print_newline();

            // Phase 2: Compile IR to object file with llc-14
            // Derive obj and bin paths from ll_path base (strip .ll extension)
            let base_path = strip_ll_ext(&ll_path);
            let mut obj_path = common::make_string(base_path.as_str());
            obj_path.push_str(".o");
            let mut llc_cmd = String::new();
            llc_cmd.push_str("llc-14 --opaque-pointers ");
            llc_cmd.push_str(ll_path.as_str());
            llc_cmd.push_str(" -filetype=obj -o ");
            llc_cmd.push_str(obj_path.as_str());
            let llc_result = system(llc_cmd.as_str());
            if llc_result != 0 {
                print_error("llc-14 failed to compile IR to object file");
                return 1;
            }
            print_success("Wrote object file to: ");
            print_str(obj_path.as_str());
            print_newline();

            // Phase 3: Link with clang-14, blood runtime, and C runtime stub
            let bin_path = base_path;
            let mut clang_cmd = String::new();
            clang_cmd.push_str("clang-14 ");
            clang_cmd.push_str(obj_path.as_str());
            clang_cmd.push_str(" /home/jkindrix/blood-rust/runtime/runtime.o");
            clang_cmd.push_str(" /home/jkindrix/blood-rust/target/release/libblood_runtime.a");
            clang_cmd.push_str(" -lm -ldl -lpthread -no-pie -o ");
            clang_cmd.push_str(bin_path.as_str());
            let clang_result = system(clang_cmd.as_str());
            if clang_result != 0 {
                print_error("clang-14 linking failed");
                return 1;
            }
            print_success("Wrote executable to: ");
            print_str(bin_path.as_str());
            print_newline();

            0
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the run command.
/// Compiles source to LLVM IR, invokes llc-14 and clang-14, then executes the result.
fn run_run(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Phase 1: Generate LLVM IR
            let ll_path = default_ll_path(path);
            let result = compile_file_streaming(path.as_str(), ll_path.as_str());
            if !result {
                return 1;
            }

            // Phase 2: Compile IR to object file with llc-14
            let obj_path = replace_ext(path, ".o");
            let mut llc_cmd = String::new();
            llc_cmd.push_str("llc-14 --opaque-pointers ");
            llc_cmd.push_str(ll_path.as_str());
            llc_cmd.push_str(" -filetype=obj -o ");
            llc_cmd.push_str(obj_path.as_str());
            let llc_result = system(llc_cmd.as_str());
            if llc_result != 0 {
                print_error("llc-14 failed to compile IR to object file");
                return 1;
            }

            // Phase 3: Link with clang-14, blood runtime, and C runtime stub
            let bin_path = strip_blood_ext(path);
            let mut clang_cmd = String::new();
            clang_cmd.push_str("clang-14 ");
            clang_cmd.push_str(obj_path.as_str());
            clang_cmd.push_str(" /home/jkindrix/blood-rust/runtime/runtime.o");
            clang_cmd.push_str(" /home/jkindrix/blood-rust/target/release/libblood_runtime.a");
            clang_cmd.push_str(" -lm -ldl -lpthread -no-pie -o ");
            clang_cmd.push_str(bin_path.as_str());
            let clang_result = system(clang_cmd.as_str());
            if clang_result != 0 {
                print_error("clang-14 linking failed");
                return 1;
            }

            // Phase 4: Execute the binary
            let mut run_cmd = String::new();
            run_cmd.push_str("./");
            run_cmd.push_str(bin_path.as_str());
            let exit_code = system(run_cmd.as_str());
            exit_code
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Prints help message.
fn run_help(_args: &Args) -> i32 {
    let mut help = String::new();
    help.push_str("Blood Compiler\n");
    help.push_str("\n");
    help.push_str("USAGE:\n");
    help.push_str("    blood <command> [options] <file>\n");
    help.push_str("\n");
    help.push_str("COMMANDS:\n");
    help.push_str("    check    Check source for errors without compiling\n");
    help.push_str("    build    Compile source to LLVM IR\n");
    help.push_str("    run      Compile and execute\n");
    help.push_str("    help     Print this help message\n");
    help.push_str("    version  Print version information\n");
    help.push_str("\n");
    help.push_str("OPTIONS:\n");
    help.push_str("    -o <file>    Output file path\n");
    help.push_str("    -v           Verbose output\n");
    help.push_str("    --no-color   Disable colored output\n");
    print_string(&help);
    0
}

/// Prints version information.
fn run_version(_args: &Args) -> i32 {
    let mut version = String::new();
    version.push_str("Blood Compiler 0.1.0\n");
    version.push_str("Self-hosted implementation\n");
    print_string(&version);
    0
}

// ============================================================
// Compile From String (Test API)
// ============================================================

/// Compiles source code from a string (for testing without file I/O).
pub fn compile_source(source: &str, filename: &str) -> CompileOutput {
    let result = driver::compile(source);

    if result.success {
        CompileOutput {
            success: true,
            llvm_ir: result.llvm_ir,
            error_output: Option::None,
        }
    } else {
        let error_reporter = reporter::ErrorReporter::new(source, filename);
        let formatted = error_reporter.format_errors(&result.errors);
        CompileOutput {
            success: false,
            llvm_ir: Option::None,
            error_output: Option::Some(formatted),
        }
    }
}

/// Output from compiling source code.
pub struct CompileOutput {
    /// Whether compilation succeeded.
    pub success: bool,
    /// Generated LLVM IR (if successful).
    pub llvm_ir: Option<String>,
    /// Formatted error output (if failed).
    pub error_output: Option<String>,
}

// ============================================================
// Output Helpers
// ============================================================

/// Prints an error message.
fn print_error(msg: &str) {
    let mut output = String::new();
    output.push_str("error: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a success message.
fn print_success(msg: &str) {
    let mut output = String::new();
    output.push_str("success: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints an info message.
fn print_info(msg: &str) {
    let mut output = String::new();
    output.push_str("info: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a string to stdout using blood-rust println_str builtin.
fn print_string(s: &String) {
    // Convert String to &str for builtin call
    // Note: We iterate and print char by char because
    // println_str expects &str, not &String
    print_str(s.as_str());
}

// ============================================================
// Argument Parsing (Structure for when FFI is available)
// ============================================================

/// Parses command line arguments into Args structure.
/// This function structure is ready for when argument access is available.
pub fn parse_args(argc: i32, argv: &Vec<String>) -> Args {
    let mut args = Args::default();

    if argc < 2 {
        return args;
    }

    // Parse command
    let cmd = &argv[1];
    args.command = parse_command(cmd);

    // Parse remaining arguments
    let mut i: usize = 2;
    while i < argv.len() {
        let arg = &argv[i];
        let bytes = arg.as_bytes();

        if bytes.len() > 0 && bytes[0] == 45 { // '-'
            // Option flag
            if str_equals(arg, "-o") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.output_file = Option::Some(clone_string(&argv[i]));
                }
            } else if str_equals(arg, "-v") {
                args.verbose = true;
            } else if str_equals(arg, "--no-color") {
                args.colors = false;
            }
        } else {
            // Positional argument (source file)
            if args.source_file.is_none() {
                args.source_file = Option::Some(clone_string(arg));
            }
        }
        i = i + 1;
    }

    args
}

/// Parses a command string into Command enum.
fn parse_command(cmd: &String) -> Command {
    if str_equals(cmd, "check") {
        Command::Check
    } else if str_equals(cmd, "build") {
        Command::Build
    } else if str_equals(cmd, "run") {
        Command::Run
    } else if str_equals(cmd, "help") {
        Command::Help
    } else if str_equals(cmd, "version") {
        Command::Version
    } else {
        Command::Help
    }
}

// ============================================================
// String Helpers
// ============================================================

/// Compares a String with a &str.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();

    if bytes.len() != other_bytes.len() {
        return false;
    }

    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    common::make_string(s.as_str())
}

/// Constructs a unique, mangled function name for LLVM IR.
///
/// Uses the lowering context's interner to resolve the bare name, then
/// qualifies it with the DefId to ensure uniqueness (many types share
/// method names like "new", "len", etc.).
///
/// Format: `def{N}_{name}` for regular functions, `blood_main` for the
/// entry point (matching blood-rust's runtime convention).
fn make_mangled_fn_name(intern: &interner::StringInterner, info: &driver::FnInfo) -> String {
    // Resolve bare name from interner
    let bare_name = match intern.resolve(info.name) {
        Option::Some(s) => common::make_string(s.as_str()),
        Option::None => {
            // Fallback: use DefId-based name
            return driver::make_fn_name(info.def_id.index as usize);
        }
    };

    // Entry point: blood-rust runtime expects "blood_main"
    if str_equals(&bare_name, "main") {
        return common::make_string("blood_main");
    }

    // Regular function: def{N}_{name}
    let mut result = String::new();
    result.push_str("def");
    push_usize(&mut result, info.def_id.index as usize);
    result.push(95 as char); // '_'
    result.push_str(bare_name.as_str());
    result
}

/// Resolves a Symbol to a string using the lowering interner.
/// Returns the bare name or a fallback "sym_{index}".
/// Returns true if the given name is a region_* builtin that is handled
/// by intrinsic_declarations() as a wrapper around blood_region_*.
fn is_region_builtin(name: &str) -> bool {
    if str_eq(name, "region_create") { return true; }
    if str_eq(name, "region_destroy") { return true; }
    if str_eq(name, "region_activate") { return true; }
    if str_eq(name, "region_deactivate") { return true; }
    if str_eq(name, "region_alloc") { return true; }
    if str_eq(name, "region_exit_scope") { return true; }
    if str_eq(name, "region_used") { return true; }
    false
}

/// Returns true if the given name is a format runtime function that is
/// already declared with correct { ptr, i64 } return type in
/// intrinsic_declarations(). These must be skipped in the dynamic
/// foreign function declaration loop to avoid duplicate declarations
/// with conflicting signatures.
fn is_format_runtime_builtin(name: &str) -> bool {
    if str_eq(name, "int_to_string") { return true; }
    if str_eq(name, "bool_to_string") { return true; }
    if str_eq(name, "float_to_string") { return true; }
    if str_eq(name, "char_to_string") { return true; }
    false
}

/// Returns true if the given name is a builtin that has a wrapper/define
/// in intrinsic_declarations(). These must be skipped in generate_foreign_declarations
/// to avoid duplicate declarations or conflicting signatures.
fn is_intrinsic_wrapper_builtin(name: &str) -> bool {
    // print/println/eprint/eprintln wrappers → *_str runtime variants
    // Both the Blood-side wrapper names AND the runtime target names must be skipped,
    // since intrinsic_declarations() declares both (define @print + declare @print_str).
    if str_eq(name, "print") { return true; }
    if str_eq(name, "println") { return true; }
    if str_eq(name, "eprint") { return true; }
    if str_eq(name, "eprintln") { return true; }
    if str_eq(name, "print_str") { return true; }
    if str_eq(name, "println_str") { return true; }
    if str_eq(name, "eprint_str") { return true; }
    if str_eq(name, "eprintln_str") { return true; }
    // assert wrappers → blood_assert* runtime functions
    if str_eq(name, "assert") { return true; }
    if str_eq(name, "assert_eq_int") { return true; }
    if str_eq(name, "assert_eq_bool") { return true; }
    if str_eq(name, "blood_assert") { return true; }
    if str_eq(name, "blood_assert_eq_int") { return true; }
    if str_eq(name, "blood_assert_eq_bool") { return true; }
    // unreachable/todo → inline panic implementations
    if str_eq(name, "unreachable") { return true; }
    if str_eq(name, "todo") { return true; }
    // process_exit → libc exit
    if str_eq(name, "process_exit") { return true; }
    if str_eq(name, "exit") { return true; }
    // Low-level memory → blood_alloc_simple etc.
    if str_eq(name, "alloc") { return true; }
    if str_eq(name, "realloc") { return true; }
    if str_eq(name, "free") { return true; }
    if str_eq(name, "memcpy") { return true; }
    if str_eq(name, "blood_alloc_simple") { return true; }
    if str_eq(name, "blood_realloc") { return true; }
    if str_eq(name, "blood_free_simple") { return true; }
    if str_eq(name, "blood_memcpy") { return true; }
    // str_concat → blood_str_concat
    if str_eq(name, "str_concat") { return true; }
    if str_eq(name, "blood_str_concat") { return true; }
    // Math library name mismatches (Blood name → libm name)
    if str_eq(name, "abs") { return true; }
    if str_eq(name, "abs_f32") { return true; }
    if str_eq(name, "sqrt_f32") { return true; }
    if str_eq(name, "fabs") { return true; }
    if str_eq(name, "fabsf") { return true; }
    if str_eq(name, "sqrtf") { return true; }
    // Builtins whose Blood types don't match runtime ABI:
    // Blood registers these with Option<T>/String return types which codegen
    // converts to ptr, but the runtime uses concrete types (double, i64, i32, {ptr,i64}).
    if str_eq(name, "parse_f64") { return true; }
    if str_eq(name, "parse_i64_radix") { return true; }
    if str_eq(name, "char_from_u32") { return true; }
    if str_eq(name, "read_line") { return true; }
    false
}

fn resolve_symbol(intern: &interner::StringInterner, sym: common::Symbol) -> String {
    match intern.resolve(sym) {
        Option::Some(s) => common::make_string(s.as_str()),
        Option::None => {
            let mut fallback = String::new();
            fallback.push_str("sym");
            push_usize(&mut fallback, sym.index as usize);
            fallback
        }
    }
}

/// Builds a DefId-qualified name: def{N}_{name}.
fn make_def_name(def_id: u32, name: &String) -> String {
    let mut result = String::new();
    result.push_str("def");
    push_usize(&mut result, def_id as usize);
    result.push(95 as char); // '_'
    result.push_str(name.as_str());
    result
}

/// Generates minimal stub declarations for functions that are referenced but not defined.
/// This handles enum variant constructors that are used as discriminant values in match.
/// Buffers output via ctx.buffer_write for batched file I/O.
fn generate_missing_stubs(
    ctx: &mut codegen_ctx::CodegenCtx,
    defined_names: &Vec<String>,
) {
    // Collect all referenced function names from the generated IR
    // that need stub declarations (used as pointer values in match)
    // Track which stubs we've already generated to avoid duplicates
    let mut generated_stubs: Vec<String> = Vec::new();
    let count = ctx.def_names_count();
    let mut stubs = String::new();
    stubs.push_str("\n; Stub functions for enum variant constructors\n");
    let mut stub_idx: usize = 0;
    while stub_idx < count {
        let entry = ctx.def_name_at(stub_idx);
        let def_id = entry.0; // (def_id, name) tuple - get def_id
        let name = entry.1; // (def_id, name) tuple - get name

        // Skip static global variables - they are declared as globals, not functions
        if ctx.is_static(def_id) {
            stub_idx = stub_idx + 1;
            continue;
        }

        // Only generate stubs for user-defined functions (names starting with "def")
        // Skip runtime/intrinsic functions (like box_new, vec_new, etc.) which are
        // already declared in intrinsic_declarations()
        let name_bytes = name.as_bytes();
        let is_user_fn = name_bytes.len() >= 3
            && name_bytes[0] == 100  // 'd'
            && name_bytes[1] == 101  // 'e'
            && name_bytes[2] == 102; // 'f'
        if !is_user_fn {
            stub_idx = stub_idx + 1;
            continue;
        }

        // Check if already defined in Pass 2
        let mut is_defined = false;
        let mut di: usize = 0;
        while di < defined_names.len() {
            if str_equals(&defined_names[di], name.as_str()) {
                is_defined = true;
                di = defined_names.len(); // break
            }
            di = di + 1;
        }
        // Also check if we already generated a stub for this name
        if !is_defined {
            let mut already_stubbed = false;
            let mut si: usize = 0;
            while si < generated_stubs.len() {
                if str_equals(&generated_stubs[si], name.as_str()) {
                    already_stubbed = true;
                    si = generated_stubs.len(); // break
                }
                si = si + 1;
            }
            if !already_stubbed {
                // Generate stub and track it
                stubs.push_str("define void @");
                stubs.push_str(name.as_str());
                stubs.push_str("() { ret void }\n");
                generated_stubs.push(clone_string(&name));
            }
        }
        stub_idx = stub_idx + 1;
    }
    // Buffer stubs for batched file I/O
    ctx.buffer_write(stubs.as_str());
}

/// Registers def_names for all function-like items in the items list.
///
/// This covers functions without bodies (foreign/builtin functions, trait declarations)
/// and associated functions in impl/trait blocks. Foreign functions use their bare
/// names (matching blood-rust runtime symbols); all others use def{N}_{name} format.
fn register_all_item_names(
    ctx: &mut codegen_ctx::CodegenCtx,
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                let name = resolve_symbol(intern, entry.item.name.symbol);
                if str_equals(&name, "main") {
                    ctx.register_def_name(entry.def_id.index, common::make_string("blood_main"));
                } else {
                    let mangled = make_def_name(entry.def_id.index, &name);
                    ctx.register_def_name(entry.def_id.index, mangled);
                }
            }
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                // Foreign functions use bare names (matching runtime symbols)
                let mut fi: usize = 0;
                while fi < foreign_def.items.len() {
                    match &foreign_def.items[fi] {
                        &hir_item::ForeignItem::Fn(ref ff) => {
                            let name = resolve_symbol(intern, ff.name.symbol);
                            ctx.register_def_name(ff.def_id.index, name);
                        }
                        &hir_item::ForeignItem::Static(ref _fs) => {}
                        &hir_item::ForeignItem::OpaqueType(ref _ot) => {}
                    }
                    fi = fi + 1;
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                let mut ai: usize = 0;
                while ai < impl_def.items.len() {
                    match &impl_def.items[ai] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            let name = resolve_symbol(intern, assoc_fn.name.symbol);
                            let mangled = make_def_name(assoc_fn.def_id.index, &name);
                            ctx.register_def_name(assoc_fn.def_id.index, mangled);
                        }
                        &hir_item::AssocItem::Type(ref _at) => {}
                        &hir_item::AssocItem::Const(ref _ac) => {}
                    }
                    ai = ai + 1;
                }
            }
            &hir_item::ItemKind::Trait(ref trait_def) => {
                let mut ti: usize = 0;
                while ti < trait_def.items.len() {
                    match &trait_def.items[ti] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            let name = resolve_symbol(intern, assoc_fn.name.symbol);
                            let mangled = make_def_name(assoc_fn.def_id.index, &name);
                            ctx.register_def_name(assoc_fn.def_id.index, mangled);
                        }
                        &hir_item::AssocItem::Type(ref _at) => {}
                        &hir_item::AssocItem::Const(ref _ac) => {}
                    }
                    ti = ti + 1;
                }
            }
            &hir_item::ItemKind::Struct(ref _s) => {}
            &hir_item::ItemKind::Enum(ref _e) => {}
            &hir_item::ItemKind::TypeAlias(ref _ta) => {}
            &hir_item::ItemKind::Const(ref _c) => {}
            &hir_item::ItemKind::Static(ref _s) => {}
            &hir_item::ItemKind::Effect(ref _ef) => {}
            &hir_item::ItemKind::Handler(ref _h) => {}
            &hir_item::ItemKind::Module(ref _m) => {}
            &hir_item::ItemKind::Macro(ref _m) => {}
        }
        i = i + 1;
    }
}

/// Registers def_names for all enum variant constructors.
/// Each variant gets a name like def{enum_def_id}_{variant_name} so the codegen
/// can emit identifiable references instead of @fn_NNN.
fn register_enum_variant_names(
    ctx: &mut codegen_ctx::CodegenCtx,
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Enum(ref enum_def) => {
                let enum_name = resolve_symbol(intern, entry.item.name.symbol);
                let mut vi: usize = 0;
                while vi < enum_def.variants.len() {
                    let variant = &enum_def.variants[vi];
                    let variant_name = resolve_symbol(intern, variant.name.symbol);
                    let mut mangled = String::new();
                    mangled.push_str("def");
                    push_usize(&mut mangled, entry.def_id.index as usize);
                    mangled.push(95 as char); // '_'
                    mangled.push_str(enum_name.as_str());
                    mangled.push_str("__");
                    mangled.push_str(variant_name.as_str());
                    ctx.register_def_name(variant.def_id.index, mangled);
                    vi = vi + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
}

/// Generates LLVM `declare` statements for all foreign functions in the items list.
/// These are runtime builtins that need extern declarations for linking.
fn generate_foreign_declarations(
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) -> String {
    let mut output = String::new();
    output.push_str("\n; Foreign function declarations (blood-rust runtime)\n");

    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                let mut fi: usize = 0;
                while fi < foreign_def.items.len() {
                    match &foreign_def.items[fi] {
                        &hir_item::ForeignItem::Fn(ref ff) => {
                            let name = resolve_symbol(intern, ff.name.symbol);
                            // Skip region_* functions - they are defined as
                            // wrappers around blood_region_* in intrinsic_declarations()
                            if is_region_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            // Skip format runtime builtins - they are declared with
                            // correct { ptr, i64 } return type in intrinsic_declarations()
                            if is_format_runtime_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            // Skip builtins that have wrapper definitions in
                            // intrinsic_declarations() (print→print_str, assert→blood_assert, etc.)
                            if is_intrinsic_wrapper_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            let ret_ty = codegen_types::return_type_to_llvm(&ff.return_ty);
                            output.push_str("declare ");
                            output.push_str(ret_ty.as_str());
                            output.push_str(" @");
                            output.push_str(name.as_str());
                            output.push_str("(");
                            let mut pi: usize = 0;
                            while pi < ff.param_tys.len() {
                                if pi > 0 {
                                    output.push_str(", ");
                                }
                                let param_ty = codegen_types::type_to_llvm(&ff.param_tys[pi]);
                                output.push_str(param_ty.as_str());
                                pi = pi + 1;
                            }
                            output.push_str(")\n");
                        }
                        &hir_item::ForeignItem::Static(ref _fs) => {}
                        &hir_item::ForeignItem::OpaqueType(ref _ot) => {}
                    }
                    fi = fi + 1;
                }
            }
            &hir_item::ItemKind::Fn(ref _f) => {}
            &hir_item::ItemKind::Struct(ref _s) => {}
            &hir_item::ItemKind::Enum(ref _e) => {}
            &hir_item::ItemKind::TypeAlias(ref _ta) => {}
            &hir_item::ItemKind::Const(ref _c) => {}
            &hir_item::ItemKind::Static(ref _s) => {}
            &hir_item::ItemKind::Trait(ref _t) => {}
            &hir_item::ItemKind::Effect(ref _ef) => {}
            &hir_item::ItemKind::Handler(ref _h) => {}
            &hir_item::ItemKind::Module(ref _m) => {}
            &hir_item::ItemKind::Impl(ref _im) => {}
            &hir_item::ItemKind::Macro(ref _m) => {}
        }
        i = i + 1;
    }

    output
}

// ============================================================
// Path Helpers
// ============================================================

/// Returns the default .ll output path for a source file.
/// Replaces .blood extension with .ll, or appends .ll if no .blood extension.
fn default_ll_path(source_path: &String) -> String {
    replace_ext(source_path, ".ll")
}

/// Replaces the .blood extension with a new extension.
fn replace_ext(source_path: &String, new_ext: &str) -> String {
    let bytes = source_path.as_bytes();
    let blood_ext = ".blood";
    let ext_bytes = blood_ext.as_bytes();

    if bytes.len() >= ext_bytes.len() {
        let start = bytes.len() - ext_bytes.len();
        let mut matches = true;
        let mut k: usize = 0;
        while k < ext_bytes.len() {
            if bytes[start + k] != ext_bytes[k] {
                matches = false;
            }
            k = k + 1;
        }
        if matches {
            // Strip .blood and add new extension
            let mut result = String::new();
            let mut j: usize = 0;
            while j < start {
                result.push(bytes[j] as char);
                j = j + 1;
            }
            result.push_str(new_ext);
            return result;
        }
    }
    // No .blood extension found, just append
    let mut result = common::make_string(source_path.as_str());
    result.push_str(new_ext);
    result
}

/// Strips the .blood extension from a path.
fn strip_blood_ext(source_path: &String) -> String {
    replace_ext(source_path, "")
}

/// Strips the .ll extension from a path.
fn strip_ll_ext(path: &String) -> String {
    let bytes = path.as_bytes();
    let ll_ext = ".ll";
    let ext_bytes = ll_ext.as_bytes();
    if bytes.len() >= ext_bytes.len() {
        let start = bytes.len() - ext_bytes.len();
        let mut matches = true;
        let mut k: usize = 0;
        while k < ext_bytes.len() {
            if bytes[start + k] != ext_bytes[k] {
                matches = false;
            }
            k = k + 1;
        }
        if matches {
            let mut result = String::new();
            let mut j: usize = 0;
            while j < start {
                result.push(bytes[j] as char);
                j = j + 1;
            }
            return result;
        }
    }
    common::make_string(path.as_str())
}

// ============================================================
// Streaming Compilation
// ============================================================

/// Compiles a source file using streaming codegen, writing IR directly to output_path.
/// Returns true on success, false on error (errors are printed directly).
///
/// Uses phase-scoped regions to manage memory:
/// - Parse region: holds AST nodes (destroyed after HIR lowering)
/// - HIR region: holds HIR/typeck data (destroyed after codegen)
/// - Per-function MIR regions: hold MIR bodies (destroyed after each function's IR is written)
fn compile_file_streaming(path: &str, output_path: &str) -> bool {
    // Phase 1: Read source file and compute base_dir (global allocator — small)
    let read_result = source::read_file(path);
    if !read_result.success {
        print_error("Failed to read source file");
        return false;
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            print_error("No content in file");
            return false;
        }
    };

    let base_dir = source::parent_dir(path);

    // === Parse Phase (parse_region) ===
    // 2 MB initial, 10 GB max — holds AST nodes, tokens, spans.
    // Destroyed after HIR lowering to free AST memory early.
    let parse_region = region_create(2097152, 10737418240);
    region_activate(parse_region);

    let parse_result = parser::parse_file(content.as_str());
    if parse_result.errors.len() > 0 {
        print_error("Parse errors:");
        let error_reporter = reporter::ErrorReporter::new(content.as_str(), path);
        let mut i: usize = 0;
        while i < parse_result.errors.len() {
            let diag = &parse_result.errors[i];
            let mut msg = String::new();
            msg.push_str("  ");
            msg.push_str(diag.message.as_str());
            msg.push('\n');
            print_str(msg.as_str());
            i = i + 1;
        }
        region_deactivate();
        region_destroy(parse_region);
        return false;
    }

    let program = match &parse_result.program {
        &Option::Some(ref p) => p,
        &Option::None => {
            print_error("No program produced by parser");
            region_deactivate();
            region_destroy(parse_region);
            return false;
        }
    };

    // Deactivate parse_region — AST remains readable for HIR lowering.
    region_deactivate();

    // === HIR Lower Phase (hir_region) ===
    // 16 MB initial, 50 GB max — holds HIR items, bodies, types, typeck info.
    // Self-hosting requires ~21 GB for HIR + additional for typeck.
    let hir_region = region_create(16777216, 53687091200);
    region_activate(hir_region);

    let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, content.as_str());

    // Check for HIR lowering errors
    let mut has_hir_errors = false;
    let mut di: usize = 0;
    while di < lower_result.diagnostics.len() {
        let diag = &lower_result.diagnostics[di];
        match &diag.level {
            &hir::DiagnosticLevel::Error => {
                has_hir_errors = true;
            }
            &hir::DiagnosticLevel::Warning => {}
            &hir::DiagnosticLevel::Note => {}
            &hir::DiagnosticLevel::Help => {}
        }
        di = di + 1;
    }
    if has_hir_errors {
        print_error("HIR lowering errors");
        region_deactivate();
        region_destroy(hir_region);
        region_destroy(parse_region);
        return false;
    }

    // Deactivate hir_region temporarily to destroy parse_region
    region_deactivate();

    // AST no longer needed — free parse memory early (before type checking)
    region_destroy(parse_region);

    // === Type Check Phase (hir_region) ===
    region_activate(hir_region);

    let typeck_result = typeck_driver::check_lower_result(&lower_result);
    if !typeck_result.success {
        let mut ti: usize = 0;
        while ti < typeck_result.errors.len() {
            let err = &typeck_result.errors[ti];
            let mut msg = String::new();
            msg.push_str("type error at line ");
            push_usize(&mut msg, err.span.line as usize);
            msg.push('\n');
            print_str(msg.as_str());
            ti = ti + 1;
        }
        region_deactivate();
        region_destroy(hir_region);
        return false;
    }

    // Deactivate hir_region — data remains readable for codegen.
    // New allocations (codegen ctx, def_names) go to global allocator.
    region_deactivate();

    // Phase 5: Streaming codegen (global allocator for ctx persistent state)
    let mut ctx = codegen_streaming::begin_streaming_module("main", output_path, &lower_result.items);

    // Register builtin ADT types (Vec, String, HashMap, Box) in the ADT registry.
    // These types are not in the HIR items list but user structs may contain them as fields.
    // Without this, fields like `Vec<Token>` resolve to `ptr` (8 bytes) instead of
    // `{ ptr, i64, i64 }` (24 bytes), causing stack buffer overflows.
    codegen::register_builtin_adts(
        &mut ctx,
        &lower_result.builtin_vec_def,
        &lower_result.builtin_string_def,
        &lower_result.builtin_hashmap_def,
        &lower_result.builtin_box_def,
    );
    // Rebuild all user struct/enum layouts now that builtins are registered.
    codegen::rebuild_adt_layouts(&mut ctx, &lower_result.items);

    // Collect static DefIds first - needed for name registration filtering.
    let mut static_def_ids: Vec<u32> = Vec::new();
    let mut si: usize = 0;
    while si < lower_result.items.len() {
        let item = &lower_result.items[si].item;
        match &item.kind {
            &hir_item::ItemKind::Static(ref _static_def) => {
                static_def_ids.push(item.def_id.index);
            }
            _ => {}
        }
        si = si + 1;
    }

    // Pass 0: Emit static global variable declarations.
    // This must happen before any functions that reference statics.
    // Also registers static names in ctx using the interner.
    codegen_streaming::emit_static_globals_with_names(&mut ctx, &lower_result.interner, &lower_result.items);

    // Pass 1a: Register def_names for all function bodies (global allocator)
    // SKIP static bodies - their names are already registered by emit_static_globals_with_names
    let mut body_idx: usize = 0;
    while body_idx < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx];
        let body_id = body_entry.body_id;
        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id.index,
            &Option::None => body_idx as u32,
        };
        // Skip static bodies
        let mut is_static = false;
        let mut sbi: usize = 0;
        while sbi < static_def_ids.len() {
            if static_def_ids[sbi] == def_id {
                is_static = true;
                sbi = static_def_ids.len();
            }
            sbi = sbi + 1;
        }
        if !is_static {
            let fn_name = match &fn_info {
                &Option::Some(ref info) => make_mangled_fn_name(&lower_result.interner, info),
                &Option::None => driver::make_fn_name(body_idx),
            };
            ctx.register_def_name(def_id, fn_name);
        }
        body_idx = body_idx + 1;
    }

    // Pass 1b: Register def_names for ALL function-like items (including those without bodies).
    // This ensures that calls to foreign/builtin functions resolve to the correct name.
    register_all_item_names(&mut ctx, &lower_result.interner, &lower_result.items);

    // Pass 1c: Register def_names for builtin constructors (String::new, Vec::new, etc.).
    // These DefIds are allocated by the HIR lowering and map to runtime function names.
    let mut bfi: usize = 0;
    while bfi < lower_result.builtin_fn_defs.len() {
        let entry = &lower_result.builtin_fn_defs[bfi];
        ctx.register_def_name(entry.def_id_index, clone_string(&entry.runtime_name));
        bfi = bfi + 1;
    }

    // Pass 1e: Register def_names for enum variant constructors.
    // Enum variants have their own DefIds used when constructing variants (e.g., TokenKind::Ident(...)).
    register_enum_variant_names(&mut ctx, &lower_result.interner, &lower_result.items);

    // Pass 1d: Register def_names for synthetic builtin methods (String::push_str, Vec::push, etc.).
    // These DefIds are allocated by the type checker and map to runtime function names.
    let mut bi: usize = 0;
    while bi < typeck_result.builtin_def_names.len() {
        let entry = &typeck_result.builtin_def_names[bi];
        ctx.register_def_name(entry.def_id_index, clone_string(&entry.runtime_name));
        bi = bi + 1;
    }

    // Track which function names were defined (for stub generation after pass 2)
    // Also track DefIds to skip duplicate function definitions from generic instantiations
    let mut defined_names: Vec<String> = Vec::new();
    let mut defined_def_ids: Vec<u32> = Vec::new();

    // Pass 2: For each body, lower to MIR and stream IR to file.
    // Per-function MIR regions nest inside the (now deactivated) front-end region.
    let mut body_idx2: usize = 0;
    while body_idx2 < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx2];
        let hir_body = &body_entry.body;
        let body_id = body_entry.body_id;

        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);

        let return_ty = match &fn_info {
            &Option::Some(ref info) => hir_ty::copy_type(&info.return_ty),
            &Option::None => hir_ty::Type::unit(),
        };
        let span = match &fn_info {
            &Option::Some(ref info) => info.span,
            &Option::None => common::Span::new(0, 0, 1, 1),
        };
        let fn_name = match &fn_info {
            &Option::Some(ref info) => make_mangled_fn_name(&lower_result.interner, info),
            &Option::None => driver::make_fn_name(body_idx2),
        };
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id,
            &Option::None => hir_def::DefId::new(body_idx2 as u32),
        };

        // Check if this body belongs to a static variable - skip if so.
        // Static initializers are handled separately as global variable declarations,
        // not as regular functions.
        let mut is_static_body = false;
        let mut sbi2: usize = 0;
        while sbi2 < static_def_ids.len() {
            if static_def_ids[sbi2] == def_id.index {
                is_static_body = true;
                sbi2 = static_def_ids.len(); // break
            }
            sbi2 = sbi2 + 1;
        }
        if is_static_body {
            body_idx2 = body_idx2 + 1;
            continue;
        }

        // Check if this DefId was already processed (skip duplicates from generic instantiations)
        let mut is_duplicate = false;
        let mut di: usize = 0;
        while di < defined_def_ids.len() {
            if defined_def_ids[di] == def_id.index {
                is_duplicate = true;
                di = defined_def_ids.len(); // break
            }
            di = di + 1;
        }
        if is_duplicate {
            body_idx2 = body_idx2 + 1;
            continue;
        }
        defined_def_ids.push(def_id.index);
        defined_names.push(clone_string(&fn_name));

        // Per-function MIR region: isolates MIR lowering allocations.
        // Deactivate before codegen so ctx's persistent state uses global allocator.
        // Large functions (e.g., match expressions with many arms) may need significant memory.
        let mir_region = region_create(4194304, 1073741824);  // 4 MB init, 1 GB max
        region_activate(mir_region);

        // Lower to MIR (allocations go to mir_region)
        let mir_body = mir_lower::lower_body(
            def_id,
            hir_body,
            return_ty,
            span,
            &typeck_result.subst_table,
            &typeck_result.method_resolutions,
            &typeck_result.field_resolutions,
        );

        // Deactivate mir_region — MIR body remains readable until destroy.
        // Codegen modifies ctx state (string_table, output buffer) that must persist.
        region_deactivate();

        // Stream this function's IR to file (reads MIR, writes to global allocator)
        codegen_streaming::generate_function_to_file(&mut ctx, &mir_body, fn_name.as_str());

        // Destroy mir_region — frees MIR body and all lowering temporaries
        region_destroy(mir_region);

        body_idx2 = body_idx2 + 1;
    }

    // Pass 3: Generate stub functions for registered names without bodies.
    // These are enum variant constructors and other synthetic functions that are
    // referenced as function pointers but don't have HIR bodies.
    generate_missing_stubs(&mut ctx, &defined_names);

    // Finish: write string constants and intrinsic declarations
    codegen_streaming::finish_streaming_module(&mut ctx);

    // Write foreign function declarations (runtime builtins)
    let foreign_decls = generate_foreign_declarations(&lower_result.interner, &lower_result.items);
    ctx.buffer_write(foreign_decls.as_str());

    // Final flush: write any remaining buffered IR to disk
    ctx.flush_write_buffer();

    // Destroy HIR region — bulk-frees all HIR and typeck data
    // (parse_region was already destroyed after HIR lowering)
    region_destroy(hir_region);

    true
}

/// Pushes a usize as decimal digits into a string.
fn push_usize(s: &mut String, val: usize) {
    if val == 0 {
        s.push('0');
        return;
    }
    // Build digits in reverse
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    // Push in reverse order
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}
