// Blood Self-Hosted Compiler - Main Entry Point
//
// This module provides the command-line interface for the Blood compiler.
// It orchestrates parsing arguments, reading source files, and running
// the compilation pipeline.
//
// CLI and I/O is provided by blood-rust builtins:
// - args_count() -> i32 - get number of CLI arguments
// - args_get(i32) -> &str - get argument at index
// - print_str(&str) - print string without newline
// - println_str(&str) - print string with newline
// - file_write_string(&str, &str) -> bool - write string to file path
// - file_append_string(&str, &str) -> i32 - append string to file path
// - system(&str) -> i32 - run shell command

mod common;
mod ast;
mod hir;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir_lower;
mod hir_lower_ctx;
mod parser;
mod parser_base;
mod resolve;
mod mir_def;
mod mir_body;
mod mir_lower;
mod codegen;
mod codegen_ctx;
mod codegen_streaming;
mod interner;
mod unify;
mod typeck;
mod typeck_driver;
mod driver;
mod reporter;
mod source;

// ============================================================
// Command Line Arguments
// ============================================================

/// Compiler command to execute.
pub enum Command {
    /// Check source code for errors.
    Check,
    /// Build source code to LLVM IR.
    Build,
    /// Run source code (compile and execute).
    Run,
    /// Print help message.
    Help,
    /// Print version information.
    Version,
}

/// Parsed command line arguments.
pub struct Args {
    /// The command to execute.
    pub command: Command,
    /// The source file path (if provided).
    pub source_file: Option<String>,
    /// Output file path (if provided).
    pub output_file: Option<String>,
    /// Whether to enable verbose output.
    pub verbose: bool,
    /// Whether to enable colored output.
    pub colors: bool,
}

impl Args {
    /// Creates default arguments.
    pub fn default() -> Args {
        Args {
            command: Command::Help,
            source_file: Option::None,
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for checking a file.
    pub fn check(file: String) -> Args {
        Args {
            command: Command::Check,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }

    /// Creates arguments for building a file.
    pub fn build(file: String) -> Args {
        Args {
            command: Command::Build,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
        }
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Main function - entry point for the compiler.
pub fn main() -> i32 {
    // Initialize the global string interner before any parsing
    // This ensures consistent symbol indices across all compilation phases
    interner::init_global_interner();

    // Parse command line arguments
    // Note: Without FFI for argument access, we use a stub
    let args = parse_args_stub();

    // Execute the command
    match &args.command {
        &Command::Check => run_check(&args),
        &Command::Build => run_build(&args),
        &Command::Run => run_run(&args),
        &Command::Help => run_help(&args),
        &Command::Version => run_version(&args),
    }
}

/// Parses command line arguments using blood-rust builtins.
///
/// Uses args_count() and args_get() builtins to access actual CLI args.
fn parse_args_stub() -> Args {
    let argc = args_count();

    // Build argv vector from CLI args
    let mut argv: Vec<String> = Vec::new();
    let mut i: i32 = 0;
    while i < argc {
        let arg_ref: &str = args_get(i);
        argv.push(common::make_string(arg_ref));
        i = i + 1;
    }

    // Use existing parse_args function
    parse_args(argc, &argv)
}

// ============================================================
// Command Handlers
// ============================================================

/// Runs the check command.
fn run_check(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Use check_file for proper base_dir module resolution
            let result = driver::check_file(path.as_str());
            if result.success {
                print_success("Check passed");
                0
            } else {
                // Read the source content for error reporting
                let read_result = source::read_file(path.as_str());
                let content = match &read_result.content {
                    &Option::Some(ref c) => c.as_str(),
                    &Option::None => "",
                };
                // Format and print errors
                let error_reporter = reporter::ErrorReporter::new(content, path.as_str());
                let formatted = error_reporter.format_errors(&result.errors);
                print_string(&formatted);
                1
            }
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the build command.
/// Uses streaming codegen to write IR directly to file, avoiding OOM.
fn run_build(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Determine output path
            let output_path = match &args.output_file {
                &Option::Some(ref out) => clone_string(out),
                &Option::None => default_ll_path(path),
            };

            // Use streaming compilation to write IR directly to file
            let result = compile_file_streaming(path.as_str(), output_path.as_str());
            if result {
                print_success("Wrote LLVM IR to: ");
                print_str(output_path.as_str());
                print_newline();
                0
            } else {
                1
            }
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the run command.
///
/// This command compiles the source to LLVM IR and then attempts to execute it.
///
/// # Current Limitation
///
/// The run command currently only generates LLVM IR. Full execution would require:
/// 1. A shell execution builtin to run external commands
/// 2. Access to LLVM tools (llc) to compile IR to object code
/// 3. Access to a linker (ld, clang, gcc) to create an executable
/// 4. Running the resulting binary and capturing its exit code
///
/// To run a Blood program manually after compilation:
/// 1. Use `blood build file.blood -o output.ll` to generate LLVM IR
/// 2. Run `llc output.ll -filetype=obj -o output.o` to create object file
/// 3. Run `clang output.o -o output` to link into executable
/// 4. Run `./output` to execute
fn run_run(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Generate LLVM IR
            let ll_path = default_ll_path(path);
            let result = compile_file_streaming(path.as_str(), ll_path.as_str());
            if !result {
                return 1;
            }

            // Compile IR to object file with llc
            let obj_path = replace_ext(path, ".o");
            let mut llc_cmd = String::new();
            llc_cmd.push_str("llc ");
            llc_cmd.push_str(ll_path.as_str());
            llc_cmd.push_str(" -filetype=obj -o ");
            llc_cmd.push_str(obj_path.as_str());
            let llc_result = system(llc_cmd.as_str());
            if llc_result != 0 {
                print_error("llc failed");
                return 1;
            }

            // Link with clang
            let bin_path = strip_blood_ext(path);
            let mut clang_cmd = String::new();
            clang_cmd.push_str("clang ");
            clang_cmd.push_str(obj_path.as_str());
            clang_cmd.push_str(" -o ");
            clang_cmd.push_str(bin_path.as_str());
            let clang_result = system(clang_cmd.as_str());
            if clang_result != 0 {
                print_error("clang linking failed");
                return 1;
            }

            // Execute the binary
            let mut run_cmd = String::new();
            run_cmd.push_str("./");
            run_cmd.push_str(bin_path.as_str());
            let exit_code = system(run_cmd.as_str());
            exit_code
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Prints help message.
fn run_help(_args: &Args) -> i32 {
    let mut help = String::new();
    help.push_str("Blood Compiler\n");
    help.push_str("\n");
    help.push_str("USAGE:\n");
    help.push_str("    blood <command> [options] <file>\n");
    help.push_str("\n");
    help.push_str("COMMANDS:\n");
    help.push_str("    check    Check source for errors without compiling\n");
    help.push_str("    build    Compile source to LLVM IR\n");
    help.push_str("    run      Compile and execute\n");
    help.push_str("    help     Print this help message\n");
    help.push_str("    version  Print version information\n");
    help.push_str("\n");
    help.push_str("OPTIONS:\n");
    help.push_str("    -o <file>    Output file path\n");
    help.push_str("    -v           Verbose output\n");
    help.push_str("    --no-color   Disable colored output\n");
    print_string(&help);
    0
}

/// Prints version information.
fn run_version(_args: &Args) -> i32 {
    let mut version = String::new();
    version.push_str("Blood Compiler 0.1.0\n");
    version.push_str("Self-hosted implementation\n");
    print_string(&version);
    0
}

// ============================================================
// Compile From String (Test API)
// ============================================================

/// Compiles source code from a string (for testing without file I/O).
pub fn compile_source(source: &str, filename: &str) -> CompileOutput {
    let result = driver::compile(source);

    if result.success {
        CompileOutput {
            success: true,
            llvm_ir: result.llvm_ir,
            error_output: Option::None,
        }
    } else {
        let error_reporter = reporter::ErrorReporter::new(source, filename);
        let formatted = error_reporter.format_errors(&result.errors);
        CompileOutput {
            success: false,
            llvm_ir: Option::None,
            error_output: Option::Some(formatted),
        }
    }
}

/// Output from compiling source code.
pub struct CompileOutput {
    /// Whether compilation succeeded.
    pub success: bool,
    /// Generated LLVM IR (if successful).
    pub llvm_ir: Option<String>,
    /// Formatted error output (if failed).
    pub error_output: Option<String>,
}

// ============================================================
// Output Helpers
// ============================================================

/// Prints an error message.
fn print_error(msg: &str) {
    let mut output = String::new();
    output.push_str("error: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a success message.
fn print_success(msg: &str) {
    let mut output = String::new();
    output.push_str("success: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints an info message.
fn print_info(msg: &str) {
    let mut output = String::new();
    output.push_str("info: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a string to stdout using blood-rust println_str builtin.
fn print_string(s: &String) {
    // Convert String to &str for builtin call
    // Note: We iterate and print char by char because
    // println_str expects &str, not &String
    print_str(s.as_str());
}

/// Prints a newline using blood-rust builtin.
fn print_newline() {
    println_str("");
}

// ============================================================
// Argument Parsing (Structure for when FFI is available)
// ============================================================

/// Parses command line arguments into Args structure.
/// This function structure is ready for when argument access is available.
pub fn parse_args(argc: i32, argv: &Vec<String>) -> Args {
    let mut args = Args::default();

    if argc < 2 {
        return args;
    }

    // Parse command
    let cmd = &argv[1];
    args.command = parse_command(cmd);

    // Parse remaining arguments
    let mut i: usize = 2;
    while i < argv.len() {
        let arg = &argv[i];
        let bytes = arg.as_bytes();

        if bytes.len() > 0 && bytes[0] == 45 { // '-'
            // Option flag
            if str_equals(arg, "-o") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.output_file = Option::Some(clone_string(&argv[i]));
                }
            } else if str_equals(arg, "-v") {
                args.verbose = true;
            } else if str_equals(arg, "--no-color") {
                args.colors = false;
            }
        } else {
            // Positional argument (source file)
            if args.source_file.is_none() {
                args.source_file = Option::Some(clone_string(arg));
            }
        }
        i = i + 1;
    }

    args
}

/// Parses a command string into Command enum.
fn parse_command(cmd: &String) -> Command {
    if str_equals(cmd, "check") {
        Command::Check
    } else if str_equals(cmd, "build") {
        Command::Build
    } else if str_equals(cmd, "run") {
        Command::Run
    } else if str_equals(cmd, "help") {
        Command::Help
    } else if str_equals(cmd, "version") {
        Command::Version
    } else {
        Command::Help
    }
}

// ============================================================
// String Helpers
// ============================================================

/// Compares a String with a &str.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();

    if bytes.len() != other_bytes.len() {
        return false;
    }

    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    common::make_string(s.as_str())
}

// ============================================================
// Path Helpers
// ============================================================

/// Returns the default .ll output path for a source file.
/// Replaces .blood extension with .ll, or appends .ll if no .blood extension.
fn default_ll_path(source_path: &String) -> String {
    replace_ext(source_path, ".ll")
}

/// Replaces the .blood extension with a new extension.
fn replace_ext(source_path: &String, new_ext: &str) -> String {
    let bytes = source_path.as_bytes();
    let blood_ext = ".blood";
    let ext_bytes = blood_ext.as_bytes();

    if bytes.len() >= ext_bytes.len() {
        let start = bytes.len() - ext_bytes.len();
        let mut matches = true;
        let mut k: usize = 0;
        while k < ext_bytes.len() {
            if bytes[start + k] != ext_bytes[k] {
                matches = false;
            }
            k = k + 1;
        }
        if matches {
            // Strip .blood and add new extension
            let mut result = String::new();
            let mut j: usize = 0;
            while j < start {
                result.push(bytes[j] as char);
                j = j + 1;
            }
            result.push_str(new_ext);
            return result;
        }
    }
    // No .blood extension found, just append
    let mut result = common::make_string(source_path.as_str());
    result.push_str(new_ext);
    result
}

/// Strips the .blood extension from a path.
fn strip_blood_ext(source_path: &String) -> String {
    replace_ext(source_path, "")
}

// ============================================================
// Streaming Compilation
// ============================================================

/// Compiles a source file using streaming codegen, writing IR directly to output_path.
/// Returns true on success, false on error (errors are printed directly).
fn compile_file_streaming(path: &str, output_path: &str) -> bool {
    // Phase 1: Read the source file
    let read_result = source::read_file(path);
    if !read_result.success {
        print_error("Failed to read source file");
        return false;
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            print_error("No content in file");
            return false;
        }
    };

    // Phase 2: Parse
    let parse_result = parser::parse_file(content.as_str());
    if parse_result.errors.len() > 0 {
        print_error("Parse errors:");
        let error_reporter = reporter::ErrorReporter::new(content.as_str(), path);
        let mut i: usize = 0;
        while i < parse_result.errors.len() {
            let diag = &parse_result.errors[i];
            let mut msg = String::new();
            msg.push_str("  ");
            msg.push_str(diag.message.as_str());
            msg.push('\n');
            print_str(msg.as_str());
            i = i + 1;
        }
        return false;
    }

    let program = match &parse_result.program {
        &Option::Some(ref p) => p,
        &Option::None => {
            print_error("No program produced by parser");
            return false;
        }
    };

    // Phase 3: Lower to HIR with base_dir for module resolution
    let base_dir = source::parent_dir(path);
    let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, content.as_str());

    // Check for HIR lowering errors
    let mut has_hir_errors = false;
    let mut di: usize = 0;
    while di < lower_result.diagnostics.len() {
        let diag = &lower_result.diagnostics[di];
        match &diag.level {
            &hir::DiagnosticLevel::Error => {
                has_hir_errors = true;
            }
            &hir::DiagnosticLevel::Warning => {}
            &hir::DiagnosticLevel::Note => {}
            &hir::DiagnosticLevel::Help => {}
        }
        di = di + 1;
    }
    if has_hir_errors {
        print_error("HIR lowering errors");
        return false;
    }

    // Phase 4: Type checking
    let typeck_result = typeck_driver::check_lower_result(&lower_result);
    if !typeck_result.success {
        let mut ti: usize = 0;
        while ti < typeck_result.errors.len() {
            let err = &typeck_result.errors[ti];
            let mut msg = String::new();
            msg.push_str("type error at line ");
            push_usize(&mut msg, err.span.line as usize);
            msg.push('\n');
            print_str(msg.as_str());
            ti = ti + 1;
        }
        return false;
    }

    // Phase 5: Streaming codegen
    // Initialize streaming context with module header
    let mut ctx = codegen_streaming::begin_streaming_module("main", output_path, &lower_result.items);

    // Pass 1: Register def_names for all function bodies
    let mut body_idx: usize = 0;
    while body_idx < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx];
        let body_id = body_entry.body_id;
        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);
        let fn_name = match &fn_info {
            &Option::Some(ref info) => driver::resolve_fn_name(content.as_str(), info),
            &Option::None => driver::make_fn_name(body_idx),
        };
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id.index,
            &Option::None => body_idx as u32,
        };
        ctx.register_def_name(def_id, fn_name);
        body_idx = body_idx + 1;
    }

    // Pass 2: For each body, lower to MIR and stream IR to file
    let mut body_idx2: usize = 0;
    while body_idx2 < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx2];
        let hir_body = &body_entry.body;
        let body_id = body_entry.body_id;

        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);

        let return_ty = match &fn_info {
            &Option::Some(ref info) => hir_ty::copy_type(&info.return_ty),
            &Option::None => hir_ty::Type::unit(),
        };
        let span = match &fn_info {
            &Option::Some(ref info) => info.span,
            &Option::None => common::Span::new(0, 0, 1, 1),
        };
        let fn_name = match &fn_info {
            &Option::Some(ref info) => driver::resolve_fn_name(content.as_str(), info),
            &Option::None => driver::make_fn_name(body_idx2),
        };
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id,
            &Option::None => hir_def::DefId::new(body_idx2 as u32),
        };

        // Lower to MIR
        let mir_body = mir_lower::lower_body(
            def_id,
            hir_body,
            return_ty,
            span,
            &typeck_result.subst_table,
        );

        // Stream this function's IR to file
        codegen_streaming::generate_function_to_file(&mut ctx, &mir_body, fn_name.as_str(), output_path);

        body_idx2 = body_idx2 + 1;
    }

    // Finish: write string constants and intrinsic declarations
    codegen_streaming::finish_streaming_module(&mut ctx, output_path);

    true
}

/// Pushes a usize as decimal digits into a string.
fn push_usize(s: &mut String, val: usize) {
    if val == 0 {
        s.push('0');
        return;
    }
    // Build digits in reverse
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    // Push in reverse order
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}
