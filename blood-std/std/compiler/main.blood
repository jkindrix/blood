// Blood Self-Hosted Compiler - Main Entry Point
//
// This module provides the command-line interface for the Blood compiler.
// It orchestrates parsing arguments, reading source files, and running
// the compilation pipeline.
//
// CLI and I/O is provided by blood-rust builtins:
// - args_count() -> i32 - get number of CLI arguments
// - args_get(i32) -> &str - get argument at index
// - print_str(&str) - print string without newline
// - println_str(&str) - print string with newline
// - file_write_string(&str, &str) -> bool - write string to file path
// - file_append_string(&str, &str) -> i32 - append string to file path
// - system(&str) -> i32 - run shell command

mod common;
mod ast;
mod hir;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir_lower;
mod hir_lower_ctx;
mod parser;
mod parser_base;
mod resolve;
mod mir_def;
mod mir_body;
mod mir_lower;
mod codegen;
mod codegen_ctx;
mod codegen_streaming;
mod codegen_types;
mod interner;
mod unify;
mod typeck;
mod typeck_driver;
mod driver;
mod reporter;
mod source;
mod build_cache;
mod dump_mir;
mod validate_mir;
mod codegen_size;
mod type_intern;

// ============================================================
// Command Line Arguments
// ============================================================

/// Compiler command to execute.
pub enum Command {
    /// Check source code for errors.
    Check,
    /// Build source code to LLVM IR.
    Build,
    /// Run source code (compile and execute).
    Run,
    /// Run tests in source file.
    Test,
    /// Remove build artifacts.
    Clean,
    /// Print help message.
    Help,
    /// Print version information.
    Version,
}

/// Controls how far the build pipeline runs.
pub enum EmitMode {
    /// Full pipeline: IR -> object -> executable.
    Full,
    /// Stop after emitting LLVM IR (.ll file).
    LlvmIr,
    /// Stop after emitting object file (.o file).
    Obj,
}

/// Parsed command line arguments.
pub struct Args {
    /// The command to execute.
    pub command: Command,
    /// The source file path (if provided).
    pub source_file: Option<String>,
    /// Output file path (if provided).
    pub output_file: Option<String>,
    /// Whether to enable verbose output.
    pub verbose: bool,
    /// Whether to enable colored output.
    pub colors: bool,
    /// Whether to print per-phase timing information.
    pub timings: bool,
    /// Whether to skip the build cache.
    pub no_cache: bool,
    /// Whether to build in release mode (enables LLVM optimizations and strips symbols).
    pub release: bool,
    /// Whether to dump MIR for each function.
    pub dump_mir: bool,
    /// Optional filter for --dump-mir (only dump functions containing this substring).
    pub dump_mir_filter: Option<String>,
    /// Whether to emit MIR annotations as comments in LLVM IR.
    pub trace_codegen: bool,
    /// Whether to dump type/field resolution tables after type checking.
    pub dump_types: bool,
    /// Whether to dump ADT layouts (sizes, fields, variants).
    pub dump_layouts: bool,
    /// Whether to validate MIR before codegen.
    pub validate_mir: bool,
    /// Whether to print memory profile at each phase boundary.
    pub mem_profile: bool,
    /// Controls how far the build pipeline runs (Full, LlvmIr, or Obj).
    pub emit_mode: EmitMode,
    /// Optimization level for llc (0-3). Default 0; --release sets to 2.
    pub opt_level: u32,
    /// Whether to strip symbols from the linked binary.
    pub strip: bool,
    /// Whether to enable AddressSanitizer instrumentation.
    pub sanitize_address: bool,
    /// Filter string for test names (--filter / -F).
    pub test_filter: Option<String>,
    /// Whether to list tests without running them (--list).
    pub test_list: bool,
    /// Whether to include ignored tests (--include-ignored).
    pub test_include_ignored: bool,
    /// Whether to run only ignored tests (--ignored).
    pub test_only_ignored: bool,
    /// Whether to stop on first failure (--fail-fast).
    pub test_fail_fast: bool,
}

impl Args {
    /// Creates default arguments.
    pub fn new() -> Args {
        Args {
            command: Command::Help,
            source_file: Option::None,
            output_file: Option::None,
            verbose: false,
            colors: true,
            timings: false,
            no_cache: false,
            release: false,
            dump_mir: false,
            dump_mir_filter: Option::None,
            trace_codegen: false,
            dump_types: false,
            dump_layouts: false,
            validate_mir: false,
            mem_profile: false,
            emit_mode: EmitMode::Full,
            opt_level: 0,
            strip: false,
            sanitize_address: false,
            test_filter: Option::None,
            test_list: false,
            test_include_ignored: false,
            test_only_ignored: false,
            test_fail_fast: false,
        }
    }

    /// Creates arguments for checking a file.
    pub fn check(file: String) -> Args {
        Args {
            command: Command::Check,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
            timings: false,
            no_cache: false,
            release: false,
            dump_mir: false,
            dump_mir_filter: Option::None,
            trace_codegen: false,
            dump_types: false,
            dump_layouts: false,
            validate_mir: false,
            mem_profile: false,
            emit_mode: EmitMode::Full,
            opt_level: 0,
            strip: false,
            sanitize_address: false,
            test_filter: Option::None,
            test_list: false,
            test_include_ignored: false,
            test_only_ignored: false,
            test_fail_fast: false,
        }
    }

    /// Creates arguments for building a file.
    pub fn build(file: String) -> Args {
        Args {
            command: Command::Build,
            source_file: Option::Some(file),
            output_file: Option::None,
            verbose: false,
            colors: true,
            timings: false,
            no_cache: false,
            release: false,
            dump_mir: false,
            dump_mir_filter: Option::None,
            trace_codegen: false,
            dump_types: false,
            dump_layouts: false,
            validate_mir: false,
            mem_profile: false,
            emit_mode: EmitMode::Full,
            opt_level: 0,
            strip: false,
            sanitize_address: false,
            test_filter: Option::None,
            test_list: false,
            test_include_ignored: false,
            test_only_ignored: false,
            test_fail_fast: false,
        }
    }
}

// ============================================================
// Main Entry Point
// ============================================================

/// Main function - entry point for the compiler.
pub fn main() -> i32 {
    // Initialize the global string interner before any parsing
    // This ensures consistent symbol indices across all compilation phases
    interner::init_global_interner();
    type_intern::init_type_interner();

    // Parse command line arguments
    // Note: Without FFI for argument access, we use a stub
    let args = parse_args_stub();

    // Execute the command
    match &args.command {
        &Command::Check => run_check(&args),
        &Command::Build => run_build(&args),
        &Command::Run => run_run(&args),
        &Command::Test => run_test(&args),
        &Command::Clean => run_clean(&args),
        &Command::Help => run_help(&args),
        &Command::Version => run_version(&args),
    }
}

/// Parses command line arguments using blood-rust builtins.
///
/// Uses args_count() and args_get() builtins to access actual CLI args.
fn parse_args_stub() -> Args {
    let argc = args_count();

    // Build argv vector from CLI args
    let mut argv: Vec<String> = Vec::new();
    let mut i: i32 = 0;
    while i < argc {
        let arg_ref: &str = args_get(i);
        argv.push(common::make_string(arg_ref));
        i = i + 1;
    }

    // Use existing parse_args function
    parse_args(argc, &argv)
}

// ============================================================
// Command Handlers
// ============================================================

/// Runs the check command.
///
/// Wraps the entire check in a region so all front-end allocations (parse, HIR,
/// typeck for all transitive imports) are bulk-freed when check completes.
fn run_check(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            let check_start = blood_clock_millis();

            // Create region for all check allocations.
            // 16 MB initial, 50 GB max — virtual address reservation via mmap,
            // physical pages committed on demand.
            let check_region = region_create(16777216, 53687091200);
            region_activate(check_region);

            eprint_str("  Checking...");
            let result = driver::check_file(path.as_str());
            let check_elapsed = blood_clock_millis() - check_start;
            eprint_str(" done\n");

            let exit_code = if result.success {
                print_success("Check passed");
                if args.timings {
                    print_str("\nTimings:\n");
                    print_str("  Check total          ");
                    print_timing_ms(check_elapsed);
                }
                0
            } else {
                // Read the source content for error reporting
                let read_result = source::read_file(path.as_str());
                let content = match &read_result.content {
                    &Option::Some(ref c) => c.as_str(),
                    &Option::None => "",
                };
                // Format and print errors
                let error_reporter = reporter::ErrorReporter::new(content, path.as_str());
                let formatted = error_reporter.format_errors(&result.errors);
                print_string(&formatted);
                1
            };

            // Bulk-free all front-end data
            region_deactivate();
            region_destroy(check_region);

            exit_code
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

// ============================================================
// Runtime Discovery
// ============================================================

/// Paths to the Blood runtime libraries needed for linking.
pub struct RuntimePaths {
    /// Path to the C runtime object (runtime.o).
    pub c_runtime: String,
    /// Path to the Rust runtime static library (libblood_runtime.a).
    pub rust_runtime: String,
}

/// Finds the C runtime object (runtime.o).
///
/// Search order:
/// 1. BLOOD_RUNTIME environment variable
/// 2. Relative to executable directory: <exe_dir>/runtime.o
/// 3. Relative to executable directory: <exe_dir>/runtime/runtime.o
fn find_c_runtime() -> Option<String> {
    // 1. Check BLOOD_RUNTIME environment variable
    let env_val: &str = env_get("BLOOD_RUNTIME");
    if env_val.len() > 0 {
        if file_exists(env_val) {
            return Option::Some(common::make_string(env_val));
        }
    }

    // 2. Search relative to executable
    let exe_path: &str = args_get(0);
    let exe_dir = source::parent_dir(exe_path);

    // <exe_dir>/runtime.o
    let sibling = source::join_path(exe_dir.as_str(), "runtime.o");
    if file_exists(sibling.as_str()) {
        return Option::Some(sibling);
    }

    // <exe_dir>/runtime/runtime.o
    let runtime_subdir = source::join_path(exe_dir.as_str(), "runtime");
    let in_subdir = source::join_path(runtime_subdir.as_str(), "runtime.o");
    if file_exists(in_subdir.as_str()) {
        return Option::Some(in_subdir);
    }

    Option::None
}

/// Finds the Rust runtime static library (libblood_runtime.a).
///
/// Search order:
/// 1. BLOOD_RUST_RUNTIME environment variable
/// 2. Relative to executable directory: <exe_dir>/libblood_runtime.a
fn find_rust_runtime() -> Option<String> {
    // 1. Check BLOOD_RUST_RUNTIME environment variable
    let env_val: &str = env_get("BLOOD_RUST_RUNTIME");
    if env_val.len() > 0 {
        if file_exists(env_val) {
            return Option::Some(common::make_string(env_val));
        }
    }

    // 2. Search relative to executable
    let exe_path: &str = args_get(0);
    let exe_dir = source::parent_dir(exe_path);

    // <exe_dir>/libblood_runtime.a
    let sibling = source::join_path(exe_dir.as_str(), "libblood_runtime.a");
    if file_exists(sibling.as_str()) {
        return Option::Some(sibling);
    }

    Option::None
}

/// Finds both runtime libraries, printing a helpful error if either is missing.
fn find_runtime_paths() -> Option<RuntimePaths> {
    let c_rt = find_c_runtime();
    let rust_rt = find_rust_runtime();

    let c_ok = match &c_rt {
        &Option::Some(ref _p) => true,
        &Option::None => false,
    };
    let rust_ok = match &rust_rt {
        &Option::Some(ref _p) => true,
        &Option::None => false,
    };

    if c_ok && rust_ok {
        let c_path = match c_rt {
            Option::Some(p) => p,
            Option::None => { return Option::None; }
        };
        let r_path = match rust_rt {
            Option::Some(p) => p,
            Option::None => { return Option::None; }
        };
        return Option::Some(RuntimePaths {
            c_runtime: c_path,
            rust_runtime: r_path,
        });
    }

    // Print helpful error
    print_error("Could not find Blood runtime libraries for linking.");
    if !c_ok {
        print_str("  missing: runtime.o (C runtime stub)\n");
    }
    if !rust_ok {
        print_str("  missing: libblood_runtime.a (Rust runtime library)\n");
    }
    print_str("  Searched:\n");
    print_str("    1. BLOOD_RUNTIME / BLOOD_RUST_RUNTIME environment variables\n");
    let exe_path: &str = args_get(0);
    let exe_dir = source::parent_dir(exe_path);
    print_str("    2. Next to executable: ");
    print_str(exe_dir.as_str());
    print_str("/\n");
    print_str("  Fix: set BLOOD_RUNTIME and BLOOD_RUST_RUNTIME, or copy runtime\n");
    print_str("       files next to the compiler binary.\n");

    Option::None
}

// ============================================================
// Build & Run Commands
// ============================================================

/// Runs the build command.
/// Uses streaming codegen to write IR directly to file, avoiding OOM.
/// Then invokes llc-18 to produce an object file and clang-18 to link an executable.
fn run_build(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Discover runtime libraries early (fail before expensive IR generation)
            let runtime = match find_runtime_paths() {
                Option::Some(rt) => rt,
                Option::None => { return 1; }
            };

            // Determine output path for LLVM IR
            let ll_path = match &args.output_file {
                &Option::Some(ref out) => clone_string(out),
                &Option::None => default_ll_path(path),
            };

            // Phase 1: Generate LLVM IR via streaming codegen
            let result = compile_file_streaming(path.as_str(), ll_path.as_str(), args);
            if !result {
                return 1;
            }
            print_success("Wrote LLVM IR to: ");
            print_str(ll_path.as_str());
            print_newline();

            // Early return for --emit llvm-ir
            match &args.emit_mode {
                &EmitMode::LlvmIr => { return 0; }
                &EmitMode::Full => {}
                &EmitMode::Obj => {}
            }

            // Phase 2: Compile IR to object file with llc-18
            // Derive obj and bin paths from ll_path base (strip .ll extension)
            let base_path = strip_ll_ext(&ll_path);
            let mut obj_path = common::make_string(base_path.as_str());
            obj_path.push_str(".o");
            let mut llc_cmd = String::new();
            llc_cmd.push_str("llc-18 ");
            llc_cmd.push_str(ll_path.as_str());
            if args.opt_level == 0 {
                llc_cmd.push_str(" -O0");
            } else if args.opt_level == 1 {
                llc_cmd.push_str(" -O1");
            } else if args.opt_level == 2 {
                llc_cmd.push_str(" -O2");
            } else {
                llc_cmd.push_str(" -O3");
            }
            llc_cmd.push_str(" -filetype=obj -relocation-model=pic -o ");
            llc_cmd.push_str(obj_path.as_str());
            let llc_start = blood_clock_millis();
            let llc_result = system(llc_cmd.as_str());
            let llc_elapsed = blood_clock_millis() - llc_start;
            if llc_result != 0 {
                print_error("llc-18 failed to compile IR to object file");
                return 1;
            }
            print_success("Wrote object file to: ");
            print_str(obj_path.as_str());
            print_newline();

            // Early return for --emit obj
            match &args.emit_mode {
                &EmitMode::Obj => { return 0; }
                &EmitMode::Full => {}
                &EmitMode::LlvmIr => {}
            }

            // Phase 3: Link with clang-18, blood runtime, and C runtime stub
            let bin_path = base_path;
            let mut clang_cmd = String::new();
            clang_cmd.push_str("clang-18 ");
            clang_cmd.push_str(obj_path.as_str());
            clang_cmd.push_str(" ");
            clang_cmd.push_str(runtime.c_runtime.as_str());
            clang_cmd.push_str(" ");
            clang_cmd.push_str(runtime.rust_runtime.as_str());
            clang_cmd.push_str(" -Wl,-z,muldefs");
            if args.strip {
                clang_cmd.push_str(" -s");
            }
            clang_cmd.push_str(" -lm -ldl -lpthread");
            if args.sanitize_address {
                clang_cmd.push_str(" -fsanitize=address");
            }
            clang_cmd.push_str(" -pie -o ");
            clang_cmd.push_str(bin_path.as_str());
            let clang_start = blood_clock_millis();
            let clang_result = system(clang_cmd.as_str());
            let clang_elapsed = blood_clock_millis() - clang_start;
            if clang_result != 0 {
                print_error("clang-18 linking failed");
                return 1;
            }
            print_success("Wrote executable to: ");
            print_str(bin_path.as_str());
            print_newline();

            if args.timings {
                print_str("  llc-18               ");
                print_timing_ms(llc_elapsed);
                print_str("  clang-18             ");
                print_timing_ms(clang_elapsed);
            }

            0
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Runs the run command.
/// Compiles source to LLVM IR, invokes llc-18 and clang-18, then executes the result.
fn run_run(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Discover runtime libraries early (fail before expensive IR generation)
            let runtime = match find_runtime_paths() {
                Option::Some(rt) => rt,
                Option::None => { return 1; }
            };

            // Phase 1: Generate LLVM IR
            let ll_path = default_ll_path(path);
            let result = compile_file_streaming(path.as_str(), ll_path.as_str(), args);
            if !result {
                return 1;
            }

            // Early return for --emit llvm-ir
            match &args.emit_mode {
                &EmitMode::LlvmIr => {
                    print_success("Wrote LLVM IR to: ");
                    print_str(ll_path.as_str());
                    print_newline();
                    return 0;
                }
                &EmitMode::Full => {}
                &EmitMode::Obj => {}
            }

            // Phase 2: Compile IR to object file with llc-18
            let obj_path = replace_ext(path, ".o");
            let mut llc_cmd = String::new();
            llc_cmd.push_str("llc-18 ");
            llc_cmd.push_str(ll_path.as_str());
            if args.opt_level == 0 {
                llc_cmd.push_str(" -O0");
            } else if args.opt_level == 1 {
                llc_cmd.push_str(" -O1");
            } else if args.opt_level == 2 {
                llc_cmd.push_str(" -O2");
            } else {
                llc_cmd.push_str(" -O3");
            }
            llc_cmd.push_str(" -filetype=obj -relocation-model=pic -o ");
            llc_cmd.push_str(obj_path.as_str());
            let llc_result = system(llc_cmd.as_str());
            if llc_result != 0 {
                print_error("llc-18 failed to compile IR to object file");
                return 1;
            }

            // Early return for --emit obj
            match &args.emit_mode {
                &EmitMode::Obj => {
                    print_success("Wrote object file to: ");
                    print_str(obj_path.as_str());
                    print_newline();
                    return 0;
                }
                &EmitMode::Full => {}
                &EmitMode::LlvmIr => {}
            }

            // Phase 3: Link with clang-18, blood runtime, and C runtime stub
            let bin_path = strip_blood_ext(path);
            let mut clang_cmd = String::new();
            clang_cmd.push_str("clang-18 ");
            clang_cmd.push_str(obj_path.as_str());
            clang_cmd.push_str(" ");
            clang_cmd.push_str(runtime.c_runtime.as_str());
            clang_cmd.push_str(" ");
            clang_cmd.push_str(runtime.rust_runtime.as_str());
            clang_cmd.push_str(" -Wl,-z,muldefs");
            if args.strip {
                clang_cmd.push_str(" -s");
            }
            clang_cmd.push_str(" -lm -ldl -lpthread");
            if args.sanitize_address {
                clang_cmd.push_str(" -fsanitize=address");
            }
            clang_cmd.push_str(" -pie -o ");
            clang_cmd.push_str(bin_path.as_str());
            let clang_result = system(clang_cmd.as_str());
            if clang_result != 0 {
                print_error("clang-18 linking failed");
                return 1;
            }

            // Phase 4: Execute the binary
            let mut run_cmd = String::new();
            run_cmd.push_str("./");
            run_cmd.push_str(bin_path.as_str());
            let exit_code = system(run_cmd.as_str());
            exit_code
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

/// Prints help message.
fn run_help(_args: &Args) -> i32 {
    let mut help = String::new();
    help.push_str("Blood Compiler\n");
    help.push_str("\n");
    help.push_str("USAGE:\n");
    help.push_str("    blood <command> [options] <file>\n");
    help.push_str("\n");
    help.push_str("COMMANDS:\n");
    help.push_str("    check    Check source for errors without compiling\n");
    help.push_str("    build    Compile source to executable\n");
    help.push_str("    run      Compile and execute\n");
    help.push_str("    test     Discover and run #[test] functions\n");
    help.push_str("    clean    Remove build artifacts (.blood-cache, .ll, .o files)\n");
    help.push_str("    help     Print this help message\n");
    help.push_str("    version  Print version information\n");
    help.push_str("\n");
    help.push_str("OPTIONS:\n");
    help.push_str("    -o <file>          Output file path\n");
    help.push_str("    -v                 Verbose output\n");
    help.push_str("    --no-color         Disable colored output\n");
    help.push_str("    --timings          Print per-phase timing\n");
    help.push_str("    --mem-profile      Print per-phase memory diagnostics\n");
    help.push_str("    --no-cache         Skip the build cache\n");
    help.push_str("    --release          Build with -O2 and strip symbols\n");
    help.push_str("    -O0/-O1/-O2/-O3   Set optimization level (default: -O0)\n");
    help.push_str("    --emit <mode>      Stop early: 'llvm-ir' or 'obj'\n");
    help.push_str("    --sanitize=address Enable AddressSanitizer\n");
    help.push_str("\n");
    help.push_str("DEBUG OPTIONS:\n");
    help.push_str("    --dump-mir          Dump MIR for all functions to stderr\n");
    help.push_str("    --dump-mir=<filter> Dump MIR for functions matching filter\n");
    help.push_str("    --trace-codegen     Emit MIR as comments in LLVM IR output\n");
    help.push_str("    --dump-types        Dump type/field resolutions to stderr\n");
    help.push_str("    --dump-layouts      Dump ADT sizes, fields, variant layouts\n");
    help.push_str("    --validate-mir      Validate MIR before codegen\n");
    help.push_str("\n");
    help.push_str("TEST OPTIONS (for 'test' command):\n");
    help.push_str("    --filter <name>     Only run tests containing <name>\n");
    help.push_str("    -F <name>           Short form of --filter\n");
    help.push_str("    --list              List test names without running\n");
    help.push_str("    --ignored           Run only ignored tests\n");
    help.push_str("    --include-ignored   Include ignored tests in run\n");
    help.push_str("    --fail-fast         Stop on first test failure\n");
    print_string(&help);
    0
}

/// Prints version information.
fn run_version(_args: &Args) -> i32 {
    let mut version = String::new();
    version.push_str("Blood Compiler 0.1.0\n");
    version.push_str("Host: x86_64-unknown-linux-gnu\n");
    version.push_str("LLVM: 18\n");
    print_string(&version);
    0
}

/// Runs the clean command.
/// Removes build cache directory and (if source file given) derived build artifacts.
fn run_clean(args: &Args) -> i32 {
    // Determine base directory
    let base_dir = match &args.source_file {
        &Option::Some(ref path) => source::parent_dir(path.as_str()),
        &Option::None => common::make_string("."),
    };

    // Determine cache directory: BLOOD_CACHE env var or <base_dir>/.blood-cache/
    let cache_env: &str = env_get("BLOOD_CACHE");
    let cache_dir = if cache_env.len() > 0 {
        common::make_string(cache_env)
    } else {
        source::join_path(base_dir.as_str(), ".blood-cache")
    };

    // Remove cache directory
    let mut rm_cache = String::new();
    rm_cache.push_str("rm -rf ");
    rm_cache.push_str(cache_dir.as_str());
    if file_exists(cache_dir.as_str()) {
        system(rm_cache.as_str());
        print_str("info: Removed cache: ");
        print_str(cache_dir.as_str());
        print_newline();
    }

    // If source file given, also remove derived artifacts (.ll, .o, binary)
    match &args.source_file {
        &Option::Some(ref path) => {
            let ll = default_ll_path(path);
            let obj = replace_ext(path, ".o");
            let bin = strip_blood_ext(path);

            if file_exists(ll.as_str()) {
                let mut rm_ll = String::new();
                rm_ll.push_str("rm -f ");
                rm_ll.push_str(ll.as_str());
                system(rm_ll.as_str());
                print_str("info: Removed ");
                print_str(ll.as_str());
                print_newline();
            }
            if file_exists(obj.as_str()) {
                let mut rm_obj = String::new();
                rm_obj.push_str("rm -f ");
                rm_obj.push_str(obj.as_str());
                system(rm_obj.as_str());
                print_str("info: Removed ");
                print_str(obj.as_str());
                print_newline();
            }
            if file_exists(bin.as_str()) {
                let mut rm_bin = String::new();
                rm_bin.push_str("rm -f ");
                rm_bin.push_str(bin.as_str());
                system(rm_bin.as_str());
                print_str("info: Removed ");
                print_str(bin.as_str());
                print_newline();
            }
        }
        &Option::None => {}
    }

    0
}

// ============================================================
// Test Framework
// ============================================================

/// Configuration for a test function derived from its attributes.
struct TestConfig {
    /// Whether the function has #[test].
    is_test: bool,
    /// Whether the function has #[ignore].
    ignore: bool,
    /// Whether the function has #[should_panic].
    should_panic: bool,
}

/// Information about a discovered test function.
struct TestInfo {
    /// The test function name.
    name: String,
    /// Test configuration from attributes.
    config: TestConfig,
}

/// Outcome of running a single test.
enum TestOutcome {
    /// Test passed.
    Passed,
    /// Test failed with a message.
    Failed(String),
    /// Test was ignored.
    Ignored,
}

/// Record of a single test failure.
struct TestFailure {
    /// Name of the failed test.
    name: String,
    /// Failure message.
    message: String,
}

/// Aggregated test results.
struct TestResults {
    /// Number of tests that passed.
    passed: u32,
    /// Number of tests that failed.
    failed: u32,
    /// Number of tests that were ignored.
    ignored: u32,
    /// Details of each failure.
    failures: Vec<TestFailure>,
}

/// Extracts a substring from source bytes given a span.
fn span_to_str(source: &str, span: &common::Span) -> String {
    let bytes = source.as_bytes();
    let start = span.start as usize;
    let end = span.end as usize;
    let mut result = String::new();
    let mut i: usize = start;
    while i < end && i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Extracts test configuration from a function's attribute list.
///
/// Scans for #[test], #[ignore], and #[should_panic] attributes
/// by extracting attribute path names directly from the source text.
fn extract_test_config(attrs: &Vec<ast::Attribute>, source: &str) -> TestConfig {
    let mut is_test = false;
    let mut ignore = false;
    let mut should_panic = false;

    let mut i: usize = 0;
    while i < attrs.len() {
        let attr = &attrs[i];
        // Each attribute path is a Vec<SpannedSymbol>; simple attrs have one element
        if attr.path.len() > 0 {
            let name = span_to_str(source, &attr.path[0].span);
            if str_equals(&name, "test") {
                is_test = true;
            } else if str_equals(&name, "ignore") {
                ignore = true;
            } else if str_equals(&name, "should_panic") {
                should_panic = true;
            }
        }
        i = i + 1;
    }

    TestConfig {
        is_test: is_test,
        ignore: ignore,
        should_panic: should_panic,
    }
}

/// Discovers all #[test] functions in a parsed program.
///
/// Exhaustively matches all 14 Declaration variants. Only Function
/// declarations can carry #[test] attributes. Uses source text for
/// span-based name extraction (parser symbols are not in the global interner).
fn discover_tests(program: &ast::Program, source: &str) -> Vec<TestInfo> {
    let mut tests: Vec<TestInfo> = Vec::new();

    let mut i: usize = 0;
    while i < program.declarations.len() {
        match &program.declarations[i] {
            &ast::Declaration::Function(ref fn_decl) => {
                let config = extract_test_config(&fn_decl.attrs, source);
                if config.is_test {
                    // Extract function name from source text using span
                    let name = span_to_str(source, &fn_decl.name.span);
                    tests.push(TestInfo {
                        name: name,
                        config: config,
                    });
                }
            }
            &ast::Declaration::TypeAlias(ref _ta) => {}
            &ast::Declaration::Struct(ref _s) => {}
            &ast::Declaration::Enum(ref _e) => {}
            &ast::Declaration::Effect(ref _ef) => {}
            &ast::Declaration::Handler(ref _h) => {}
            &ast::Declaration::Const(ref _c) => {}
            &ast::Declaration::Static(ref _s) => {}
            &ast::Declaration::Impl(ref _im) => {}
            &ast::Declaration::Trait(ref _t) => {}
            &ast::Declaration::Bridge(ref _b) => {}
            &ast::Declaration::Module(ref _m) => {}
            &ast::Declaration::Macro(ref _ma) => {}
            &ast::Declaration::Use(ref _u) => {}
        }
        i = i + 1;
    }

    tests
}

/// Generates a test harness by appending a main() that calls the test function.
/// Uses `-> i32` return type and explicit `0` return to ensure clean exit code.
fn generate_test_harness(original_source: &str, test_name: &String) -> String {
    let mut harness = common::make_string(original_source);
    harness.push_str("\nfn main() -> i32 {\n    ");
    harness.push_str(test_name.as_str());
    harness.push_str("();\n    0\n}\n");
    harness
}

/// Runs a single test: generates harness, compiles, links, executes.
///
/// Returns the test outcome (Passed, Failed, or Ignored).
fn run_single_test(
    test: &TestInfo,
    source_path: &String,
    original_source: &str,
    args: &Args,
) -> TestOutcome {
    // Generate harness source
    let harness_source = generate_test_harness(original_source, &test.name);

    // Write harness to temp file
    let mut harness_path = String::new();
    harness_path.push_str("/tmp/blood_test_");
    harness_path.push_str(test.name.as_str());
    harness_path.push_str(".blood");
    file_write_string(harness_path.as_str(), harness_source.as_str());

    // Determine output paths
    let mut ll_path = String::new();
    ll_path.push_str("/tmp/blood_test_");
    ll_path.push_str(test.name.as_str());
    ll_path.push_str(".ll");

    let mut obj_path = String::new();
    obj_path.push_str("/tmp/blood_test_");
    obj_path.push_str(test.name.as_str());
    obj_path.push_str(".o");

    let mut bin_path = String::new();
    bin_path.push_str("/tmp/blood_test_");
    bin_path.push_str(test.name.as_str());

    // Build Args for compilation (no cache, quiet)
    let mut build_args = Args::build(clone_string(&harness_path));
    build_args.no_cache = true;

    // Phase 1: Compile to LLVM IR via streaming codegen
    let compile_ok = compile_file_streaming(harness_path.as_str(), ll_path.as_str(), &build_args);

    // Clean up harness source file
    let mut rm_harness = String::new();
    rm_harness.push_str("rm -f ");
    rm_harness.push_str(harness_path.as_str());
    system(rm_harness.as_str());

    if !compile_ok {
        // Clean up any partial artifacts
        let mut rm_ll = String::new();
        rm_ll.push_str("rm -f ");
        rm_ll.push_str(ll_path.as_str());
        system(rm_ll.as_str());

        if test.config.should_panic {
            return TestOutcome::Passed;
        }
        return TestOutcome::Failed(common::make_string("compilation failed"));
    }

    // Phase 2: Find runtime and compile IR to object
    let runtime = match find_runtime_paths() {
        Option::Some(rt) => rt,
        Option::None => {
            let mut rm_ll = String::new();
            rm_ll.push_str("rm -f ");
            rm_ll.push_str(ll_path.as_str());
            system(rm_ll.as_str());
            return TestOutcome::Failed(common::make_string("runtime not found"));
        }
    };

    // llc-18: IR -> object
    let mut llc_cmd = String::new();
    llc_cmd.push_str("llc-18 ");
    llc_cmd.push_str(ll_path.as_str());
    llc_cmd.push_str(" -O0 -filetype=obj -relocation-model=pic -o ");
    llc_cmd.push_str(obj_path.as_str());
    llc_cmd.push_str(" 2>/dev/null");
    let llc_result = system(llc_cmd.as_str());

    // Clean up .ll
    let mut rm_ll = String::new();
    rm_ll.push_str("rm -f ");
    rm_ll.push_str(ll_path.as_str());
    system(rm_ll.as_str());

    if llc_result != 0 {
        let mut rm_obj = String::new();
        rm_obj.push_str("rm -f ");
        rm_obj.push_str(obj_path.as_str());
        system(rm_obj.as_str());

        if test.config.should_panic {
            return TestOutcome::Passed;
        }
        return TestOutcome::Failed(common::make_string("llc-18 failed"));
    }

    // Phase 3: clang-18 link
    let mut clang_cmd = String::new();
    clang_cmd.push_str("clang-18 ");
    clang_cmd.push_str(obj_path.as_str());
    clang_cmd.push_str(" ");
    clang_cmd.push_str(runtime.c_runtime.as_str());
    clang_cmd.push_str(" ");
    clang_cmd.push_str(runtime.rust_runtime.as_str());
    clang_cmd.push_str(" -Wl,-z,muldefs -lm -ldl -lpthread -pie -o ");
    clang_cmd.push_str(bin_path.as_str());
    clang_cmd.push_str(" 2>/dev/null");
    let clang_result = system(clang_cmd.as_str());

    // Clean up .o
    let mut rm_obj = String::new();
    rm_obj.push_str("rm -f ");
    rm_obj.push_str(obj_path.as_str());
    system(rm_obj.as_str());

    if clang_result != 0 {
        let mut rm_bin = String::new();
        rm_bin.push_str("rm -f ");
        rm_bin.push_str(bin_path.as_str());
        system(rm_bin.as_str());

        if test.config.should_panic {
            return TestOutcome::Passed;
        }
        return TestOutcome::Failed(common::make_string("linking failed"));
    }

    // Phase 4: Execute the test binary
    let mut run_cmd = String::new();
    run_cmd.push_str(bin_path.as_str());
    run_cmd.push_str(" 2>/dev/null");
    let exit_code = system(run_cmd.as_str());

    // Clean up binary
    let mut rm_bin = String::new();
    rm_bin.push_str("rm -f ");
    rm_bin.push_str(bin_path.as_str());
    system(rm_bin.as_str());

    // Interpret result
    if test.config.should_panic {
        if exit_code != 0 {
            TestOutcome::Passed
        } else {
            TestOutcome::Failed(common::make_string("expected panic but test passed"))
        }
    } else {
        if exit_code == 0 {
            TestOutcome::Passed
        } else {
            let mut msg = String::new();
            msg.push_str("exit code ");
            push_usize(&mut msg, exit_code as usize);
            TestOutcome::Failed(msg)
        }
    }
}

/// Prints the test summary (failures + totals).
fn print_test_summary(results: &TestResults) {
    // Print failure details
    if results.failed > 0 {
        print_str("\nfailures:\n\n");
        let mut i: usize = 0;
        while i < results.failures.len() {
            let failure = &results.failures[i];
            print_str("---- ");
            print_str(failure.name.as_str());
            print_str(" ----\n");
            print_str("    ");
            print_str(failure.message.as_str());
            print_str("\n");
            i = i + 1;
        }

        print_str("\nfailures:\n");
        let mut j: usize = 0;
        while j < results.failures.len() {
            print_str("    ");
            print_str(results.failures[j].name.as_str());
            print_str("\n");
            j = j + 1;
        }
    }

    // Print summary line
    print_str("\ntest result: ");
    if results.failed == 0 {
        print_str("ok");
    } else {
        print_str("FAILED");
    }
    print_str(". ");

    let mut passed_str = String::new();
    push_usize(&mut passed_str, results.passed as usize);
    print_str(passed_str.as_str());
    print_str(" passed; ");

    let mut failed_str = String::new();
    push_usize(&mut failed_str, results.failed as usize);
    print_str(failed_str.as_str());
    print_str(" failed; ");

    let mut ignored_str = String::new();
    push_usize(&mut ignored_str, results.ignored as usize);
    print_str(ignored_str.as_str());
    print_str(" ignored\n");
}

/// Runs the test command.
///
/// Discovers #[test] functions via AST-only parsing, generates per-test
/// harnesses, compiles and runs each test independently.
fn run_test(args: &Args) -> i32 {
    match &args.source_file {
        &Option::Some(ref path) => {
            // Phase 1: Read source file
            let read_result = source::read_file(path.as_str());
            if !read_result.success {
                print_error("Failed to read source file");
                return 1;
            }

            let content = match &read_result.content {
                &Option::Some(ref c) => c,
                &Option::None => {
                    print_error("No content in file");
                    return 1;
                }
            };

            // Phase 2: Parse (AST only — no type checking needed for test discovery)
            let parse_region = region_create(2097152, 10737418240);
            region_activate(parse_region);

            let parse_result = parser::parse_file(content.as_str());
            let program = match &parse_result.program {
                &Option::Some(ref p) => p,
                &Option::None => {
                    print_error("Failed to parse source file");
                    region_deactivate();
                    region_destroy(parse_region);
                    return 1;
                }
            };

            // Phase 3: Discover tests
            // Deactivate region first so String allocations go to system heap.
            // AST data in the region remains valid until region_destroy.
            region_deactivate();
            let all_tests = discover_tests(program, content.as_str());

            // Destroy parse region — AST data freed, but extracted strings survive
            region_destroy(parse_region);

            if all_tests.len() == 0 {
                print_str("no tests found\n");
                return 0;
            }

            // Phase 4: Apply filters
            let mut tests: Vec<TestInfo> = Vec::new();
            let mut ti: usize = 0;
            while ti < all_tests.len() {
                let t = &all_tests[ti];
                let mut include = true;

                // Filter by name substring
                match &args.test_filter {
                    &Option::Some(ref filter) => {
                        if !str_contains_ref(t.name.as_str(), filter.as_str()) {
                            include = false;
                        }
                    }
                    &Option::None => {}
                }

                // Filter by ignore status
                if args.test_only_ignored && !t.config.ignore {
                    include = false;
                }

                if include {
                    tests.push(TestInfo {
                        name: clone_string(&t.name),
                        config: TestConfig {
                            is_test: t.config.is_test,
                            ignore: t.config.ignore,
                            should_panic: t.config.should_panic,
                        },
                    });
                }

                ti = ti + 1;
            }

            // --list mode: print test names and return
            if args.test_list {
                let mut li: usize = 0;
                while li < tests.len() {
                    print_str(tests[li].name.as_str());
                    print_str(": test\n");
                    li = li + 1;
                }
                let mut count_str = String::new();
                push_usize(&mut count_str, tests.len());
                print_str("\n");
                print_str(count_str.as_str());
                print_str(" tests\n");
                return 0;
            }

            // Phase 5: Run tests
            let mut count_str = String::new();
            push_usize(&mut count_str, tests.len());
            print_str("\nrunning ");
            print_str(count_str.as_str());
            print_str(" tests\n");

            let mut results = TestResults {
                passed: 0,
                failed: 0,
                ignored: 0,
                failures: Vec::new(),
            };

            let mut ri: usize = 0;
            while ri < tests.len() {
                let t = &tests[ri];

                print_str("test ");
                print_str(t.name.as_str());
                print_str(" ... ");

                // Check if ignored (and not --include-ignored)
                if t.config.ignore && !args.test_include_ignored {
                    print_str("ignored\n");
                    results.ignored = results.ignored + 1;
                    ri = ri + 1;
                    continue;
                }

                let outcome = run_single_test(t, path, content.as_str(), args);
                match &outcome {
                    &TestOutcome::Passed => {
                        print_str("ok\n");
                        results.passed = results.passed + 1;
                    }
                    &TestOutcome::Failed(ref msg) => {
                        print_str("FAILED\n");
                        results.failed = results.failed + 1;
                        results.failures.push(TestFailure {
                            name: clone_string(&t.name),
                            message: clone_string(msg),
                        });
                        if args.test_fail_fast {
                            ri = tests.len(); // break
                        }
                    }
                    &TestOutcome::Ignored => {
                        print_str("ignored\n");
                        results.ignored = results.ignored + 1;
                    }
                }

                ri = ri + 1;
            }

            // Phase 6: Print summary
            print_test_summary(&results);

            if results.failed > 0 { 1 } else { 0 }
        }
        &Option::None => {
            print_error("No source file specified");
            1
        }
    }
}

// ============================================================
// Compile From String (Test API)
// ============================================================

/// Compiles source code from a string (for testing without file I/O).
pub fn compile_source(source: &str, filename: &str) -> CompileOutput {
    let result = driver::compile(source);

    if result.success {
        CompileOutput {
            success: true,
            llvm_ir: result.llvm_ir,
            error_output: Option::None,
        }
    } else {
        let error_reporter = reporter::ErrorReporter::new(source, filename);
        let formatted = error_reporter.format_errors(&result.errors);
        CompileOutput {
            success: false,
            llvm_ir: Option::None,
            error_output: Option::Some(formatted),
        }
    }
}

/// Output from compiling source code.
pub struct CompileOutput {
    /// Whether compilation succeeded.
    pub success: bool,
    /// Generated LLVM IR (if successful).
    pub llvm_ir: Option<String>,
    /// Formatted error output (if failed).
    pub error_output: Option<String>,
}

// ============================================================
// Output Helpers
// ============================================================

/// Prints an error message.
fn print_error(msg: &str) {
    let mut output = String::new();
    output.push_str("error: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a success message.
fn print_success(msg: &str) {
    let mut output = String::new();
    output.push_str("success: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints an info message.
fn print_info(msg: &str) {
    let mut output = String::new();
    output.push_str("info: ");
    output.push_str(msg);
    output.push('\n');
    print_string(&output);
}

/// Prints a string to stdout using blood-rust println_str builtin.
fn print_string(s: &String) {
    // Convert String to &str for builtin call
    // Note: We iterate and print char by char because
    // println_str expects &str, not &String
    print_str(s.as_str());
}

// ============================================================
// Argument Parsing (Structure for when FFI is available)
// ============================================================

/// Parses command line arguments into Args structure.
/// This function structure is ready for when argument access is available.
pub fn parse_args(argc: i32, argv: &Vec<String>) -> Args {
    let mut args = Args::new();

    if argc < 2 {
        return args;
    }

    // Parse command
    let cmd = &argv[1];
    args.command = parse_command(cmd);

    // Parse remaining arguments
    let mut i: usize = 2;
    while i < argv.len() {
        let arg = &argv[i];
        let bytes = arg.as_bytes();

        if bytes.len() > 0 && bytes[0] == 45 { // '-'
            // Option flag
            if str_equals(arg, "-o") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.output_file = Option::Some(clone_string(&argv[i]));
                }
            } else if str_equals(arg, "-v") {
                args.verbose = true;
            } else if str_equals(arg, "--no-color") {
                args.colors = false;
            } else if str_equals(arg, "--timings") {
                args.timings = true;
            } else if str_equals(arg, "--no-cache") {
                args.no_cache = true;
            } else if str_equals(arg, "--release") {
                args.release = true;
                args.opt_level = 2;
                args.strip = true;
            } else if str_equals(arg, "--emit=llvm-ir") {
                args.emit_mode = EmitMode::LlvmIr;
            } else if str_equals(arg, "--emit=obj") {
                args.emit_mode = EmitMode::Obj;
            } else if str_equals(arg, "--emit") {
                // Space-separated: --emit llvm-ir / --emit obj
                if i + 1 < argv.len() {
                    i = i + 1;
                    let emit_val = &argv[i];
                    if str_equals(emit_val, "llvm-ir") {
                        args.emit_mode = EmitMode::LlvmIr;
                    } else if str_equals(emit_val, "obj") {
                        args.emit_mode = EmitMode::Obj;
                    } else {
                        print_error("unknown --emit mode (expected 'llvm-ir' or 'obj')");
                    }
                }
            } else if str_equals(arg, "-O0") {
                args.opt_level = 0;
            } else if str_equals(arg, "-O1") {
                args.opt_level = 1;
            } else if str_equals(arg, "-O2") {
                args.opt_level = 2;
            } else if str_equals(arg, "-O3") {
                args.opt_level = 3;
            } else if str_equals(arg, "--sanitize=address") {
                args.sanitize_address = true;
            } else if str_equals(arg, "--dump-mir") {
                args.dump_mir = true;
            } else if str_starts_with(arg, "--dump-mir=") {
                args.dump_mir = true;
                args.dump_mir_filter = Option::Some(substr_after(arg, 11));
            } else if str_equals(arg, "--trace-codegen") {
                args.trace_codegen = true;
            } else if str_equals(arg, "--dump-types") {
                args.dump_types = true;
            } else if str_equals(arg, "--dump-layouts") {
                args.dump_layouts = true;
            } else if str_equals(arg, "--validate-mir") {
                args.validate_mir = true;
            } else if str_equals(arg, "--mem-profile") {
                args.mem_profile = true;
            } else if str_equals(arg, "--list") {
                args.test_list = true;
            } else if str_equals(arg, "--fail-fast") {
                args.test_fail_fast = true;
            } else if str_equals(arg, "--ignored") {
                args.test_only_ignored = true;
            } else if str_equals(arg, "--include-ignored") {
                args.test_include_ignored = true;
            } else if str_equals(arg, "--filter") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.test_filter = Option::Some(clone_string(&argv[i]));
                }
            } else if str_equals(arg, "-F") {
                if i + 1 < argv.len() {
                    i = i + 1;
                    args.test_filter = Option::Some(clone_string(&argv[i]));
                }
            } else if str_starts_with(arg, "--filter=") {
                args.test_filter = Option::Some(substr_after(arg, 9));
            }
        } else {
            // Positional argument (source file)
            if args.source_file.is_none() {
                args.source_file = Option::Some(clone_string(arg));
            }
        }
        i = i + 1;
    }

    args
}

/// Parses a command string into Command enum.
fn parse_command(cmd: &String) -> Command {
    if str_equals(cmd, "check") {
        Command::Check
    } else if str_equals(cmd, "build") {
        Command::Build
    } else if str_equals(cmd, "run") {
        Command::Run
    } else if str_equals(cmd, "test") {
        Command::Test
    } else if str_equals(cmd, "help") {
        Command::Help
    } else if str_equals(cmd, "version") {
        Command::Version
    } else if str_equals(cmd, "clean") {
        Command::Clean
    } else {
        Command::Help
    }
}

// ============================================================
// String Helpers
// ============================================================

/// Compares a String with a &str.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();

    if bytes.len() != other_bytes.len() {
        return false;
    }

    let mut i: usize = 0;
    while i < bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
        i = i + 1;
    }

    true
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    common::make_string(s.as_str())
}

/// Checks if a String starts with a given &str prefix.
fn str_starts_with(s: &String, prefix: &str) -> bool {
    let bytes = s.as_bytes();
    let prefix_bytes = prefix.as_bytes();
    if bytes.len() < prefix_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < prefix_bytes.len() {
        if bytes[i] != prefix_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Returns the substring of a String starting at the given byte offset.
fn substr_after(s: &String, offset: usize) -> String {
    let bytes = s.as_bytes();
    let mut result = String::new();
    let mut i: usize = offset;
    while i < bytes.len() {
        result.push(bytes[i] as char);
        i = i + 1;
    }
    result
}

/// Checks if &str `haystack` contains &str `needle` as a substring.
fn str_contains_ref(haystack: &str, needle: &str) -> bool {
    let h_bytes = haystack.as_bytes();
    let n_bytes = needle.as_bytes();
    if n_bytes.len() == 0 {
        return true;
    }
    if h_bytes.len() < n_bytes.len() {
        return false;
    }
    let limit = h_bytes.len() - n_bytes.len() + 1;
    let mut i: usize = 0;
    while i < limit {
        let mut matched = true;
        let mut j: usize = 0;
        while j < n_bytes.len() {
            if h_bytes[i + j] != n_bytes[j] {
                matched = false;
                j = n_bytes.len(); // break
            }
            j = j + 1;
        }
        if matched {
            return true;
        }
        i = i + 1;
    }
    false
}

/// Constructs a unique, mangled function name for LLVM IR.
///
/// Uses the lowering context's interner to resolve the bare name, then
/// qualifies it with the DefId to ensure uniqueness (many types share
/// method names like "new", "len", etc.).
///
/// Format: `def{N}_{name}` for regular functions, `blood_main` for the
/// entry point (matching blood-rust's runtime convention).
fn make_mangled_fn_name(intern: &interner::StringInterner, info: &driver::FnInfo) -> String {
    // Resolve bare name from interner
    let bare_name = match intern.resolve(info.name) {
        Option::Some(s) => common::make_string(s.as_str()),
        Option::None => {
            // Fallback: use DefId-based name
            return driver::make_fn_name(info.def_id.index as usize);
        }
    };

    // Entry point: blood-rust runtime expects "blood_main"
    if str_equals(&bare_name, "main") {
        return common::make_string("blood_main");
    }

    // Regular function: def{N}_{name}
    let mut result = String::new();
    result.push_str("def");
    push_usize(&mut result, info.def_id.index as usize);
    result.push(95 as char); // '_'
    result.push_str(bare_name.as_str());
    result
}

/// Resolves a Symbol to a string using the lowering interner.
/// Returns the bare name or a fallback "sym_{index}".
/// Returns true if the given name is a region_* builtin that is handled
/// by intrinsic_declarations() as a wrapper around blood_region_*.
fn is_region_builtin(name: &str) -> bool {
    if str_eq(name, "region_create") { return true; }
    if str_eq(name, "region_destroy") { return true; }
    if str_eq(name, "region_activate") { return true; }
    if str_eq(name, "region_deactivate") { return true; }
    if str_eq(name, "region_alloc") { return true; }
    if str_eq(name, "region_exit_scope") { return true; }
    if str_eq(name, "region_used") { return true; }
    if str_eq(name, "region_trim") { return true; }
    if str_eq(name, "region_committed") { return true; }
    if str_eq(name, "region_alloc_count") { return true; }
    if str_eq(name, "system_alloc_live_bytes") { return true; }
    if str_eq(name, "realloc_diag_count") { return true; }
    if str_eq(name, "realloc_diag_wasted") { return true; }
    if str_eq(name, "realloc_diag_inplace") { return true; }
    if str_eq(name, "realloc_diag_inplace_bytes") { return true; }
    if str_eq(name, "realloc_diag_offset_delta") { return true; }
    if str_eq(name, "realloc_stats_reset") { return true; }
    if str_eq(name, "print_alloc_hist") { return true; }
    if str_eq(name, "alloc_hist_reset") { return true; }
    false
}

/// Returns true if the given name is a format runtime function that is
/// already declared with correct { ptr, i64 } return type in
/// intrinsic_declarations(). These must be skipped in the dynamic
/// foreign function declaration loop to avoid duplicate declarations
/// with conflicting signatures.
fn is_format_runtime_builtin(name: &str) -> bool {
    if str_eq(name, "int_to_string") { return true; }
    if str_eq(name, "bool_to_string") { return true; }
    if str_eq(name, "float_to_string") { return true; }
    if str_eq(name, "char_to_string") { return true; }
    false
}

/// Returns true if the given name is a builtin that has a wrapper/define
/// in intrinsic_declarations(). These must be skipped in generate_foreign_declarations
/// to avoid duplicate declarations or conflicting signatures.
fn is_intrinsic_wrapper_builtin(name: &str) -> bool {
    // print/println/eprint/eprintln wrappers → *_str runtime variants
    // Both the Blood-side wrapper names AND the runtime target names must be skipped,
    // since intrinsic_declarations() declares both (define @print + declare @print_str).
    if str_eq(name, "print") { return true; }
    if str_eq(name, "println") { return true; }
    if str_eq(name, "eprint") { return true; }
    if str_eq(name, "eprintln") { return true; }
    if str_eq(name, "print_str") { return true; }
    if str_eq(name, "println_str") { return true; }
    if str_eq(name, "eprint_str") { return true; }
    if str_eq(name, "eprintln_str") { return true; }
    // assert wrappers → blood_assert* runtime functions
    if str_eq(name, "assert") { return true; }
    if str_eq(name, "assert_eq_int") { return true; }
    if str_eq(name, "assert_eq_bool") { return true; }
    if str_eq(name, "blood_assert") { return true; }
    if str_eq(name, "blood_assert_eq_int") { return true; }
    if str_eq(name, "blood_assert_eq_bool") { return true; }
    // unreachable/todo → inline panic implementations
    if str_eq(name, "unreachable") { return true; }
    if str_eq(name, "todo") { return true; }
    // process_exit → libc exit
    if str_eq(name, "process_exit") { return true; }
    if str_eq(name, "exit") { return true; }
    // Low-level memory → blood_alloc_simple etc.
    if str_eq(name, "alloc") { return true; }
    if str_eq(name, "realloc") { return true; }
    if str_eq(name, "free") { return true; }
    if str_eq(name, "memcpy") { return true; }
    if str_eq(name, "blood_alloc_simple") { return true; }
    if str_eq(name, "blood_realloc") { return true; }
    if str_eq(name, "blood_free_simple") { return true; }
    if str_eq(name, "blood_memcpy") { return true; }
    // str_concat → blood_str_concat
    if str_eq(name, "str_concat") { return true; }
    if str_eq(name, "blood_str_concat") { return true; }
    // Math library name mismatches (Blood name → libm name)
    if str_eq(name, "abs") { return true; }
    if str_eq(name, "abs_f32") { return true; }
    if str_eq(name, "sqrt_f32") { return true; }
    if str_eq(name, "fabs") { return true; }
    if str_eq(name, "fabsf") { return true; }
    if str_eq(name, "sqrtf") { return true; }
    // Builtins whose Blood types don't match runtime ABI:
    // Blood registers these with Option<T>/String return types which codegen
    // converts to ptr, but the runtime uses concrete types (double, i64, i32, {ptr,i64}).
    if str_eq(name, "parse_f64") { return true; }
    if str_eq(name, "parse_i64_radix") { return true; }
    if str_eq(name, "char_from_u32") { return true; }
    if str_eq(name, "read_line") { return true; }
    // Thread builtins → blood_thread_spawn / blood_thread_join runtime functions
    if str_eq(name, "thread_spawn") { return true; }
    if str_eq(name, "thread_join") { return true; }
    if str_eq(name, "blood_thread_spawn") { return true; }
    if str_eq(name, "blood_thread_join") { return true; }
    false
}

fn resolve_symbol(intern: &interner::StringInterner, sym: common::Symbol) -> String {
    match intern.resolve(sym) {
        Option::Some(s) => common::make_string(s.as_str()),
        Option::None => {
            let mut fallback = String::new();
            fallback.push_str("sym");
            push_usize(&mut fallback, sym.index as usize);
            fallback
        }
    }
}

/// Builds a DefId-qualified name: def{N}_{name}.
fn make_def_name(def_id: u32, name: &String) -> String {
    let mut result = String::new();
    result.push_str("def");
    push_usize(&mut result, def_id as usize);
    result.push(95 as char); // '_'
    result.push_str(name.as_str());
    result
}

/// Generates minimal stub declarations for functions that are referenced but not defined.
/// This handles enum variant constructors that are used as discriminant values in match.
/// Buffers output via ctx.buffer_write for batched file I/O.
fn generate_missing_stubs(
    ctx: &mut codegen_ctx::CodegenCtx,
    defined_names: &Vec<String>,
) {
    // Collect all referenced function names from the generated IR
    // that need stub declarations (used as pointer values in match)
    // Track which stubs we've already generated to avoid duplicates
    let mut generated_stubs: Vec<String> = Vec::new();
    let count = ctx.def_names_count();
    let mut stubs = String::new();
    stubs.push_str("\n; Stub functions for enum variant constructors\n");
    let mut stub_idx: usize = 0;
    while stub_idx < count {
        let entry = ctx.def_name_at(stub_idx);
        let def_id = entry.0; // (def_id, name) tuple - get def_id
        let name = entry.1; // (def_id, name) tuple - get name

        // Skip static global variables - they are declared as globals, not functions
        if ctx.is_static(def_id) {
            stub_idx = stub_idx + 1;
            continue;
        }

        // Only generate stubs for user-defined functions (names starting with "def" or "fn_")
        // Skip runtime/intrinsic functions (like box_new, vec_new, etc.) which are
        // already declared in intrinsic_declarations()
        let name_bytes = name.as_bytes();
        let is_user_fn = (name_bytes.len() >= 3
            && name_bytes[0] == 100  // 'd'
            && name_bytes[1] == 101  // 'e'
            && name_bytes[2] == 102) // 'f'
            || (name_bytes.len() >= 3
            && name_bytes[0] == 102  // 'f'
            && name_bytes[1] == 110  // 'n'
            && name_bytes[2] == 95); // '_'
        if !is_user_fn {
            stub_idx = stub_idx + 1;
            continue;
        }

        // Check if already defined in Pass 2
        let mut is_defined = false;
        let mut di: usize = 0;
        while di < defined_names.len() {
            if str_equals(&defined_names[di], name.as_str()) {
                is_defined = true;
                di = defined_names.len(); // break
            }
            di = di + 1;
        }
        // Also check if we already generated a stub for this name
        if !is_defined {
            let mut already_stubbed = false;
            let mut si: usize = 0;
            while si < generated_stubs.len() {
                if str_equals(&generated_stubs[si], name.as_str()) {
                    already_stubbed = true;
                    si = generated_stubs.len(); // break
                }
                si = si + 1;
            }
            if !already_stubbed {
                // Generate stub and track it
                stubs.push_str("define void @");
                stubs.push_str(name.as_str());
                stubs.push_str("() { ret void }\n");
                generated_stubs.push(clone_string(&name));
            }
        }
        stub_idx = stub_idx + 1;
    }
    // Buffer stubs for batched file I/O
    ctx.buffer_write(stubs.as_str());
}

/// Registers def_names for all function-like items in the items list.
///
/// This covers functions without bodies (foreign/builtin functions, trait declarations)
/// and associated functions in impl/trait blocks. Foreign functions use their bare
/// names (matching blood-rust runtime symbols); all others use def{N}_{name} format.
fn register_all_item_names(
    ctx: &mut codegen_ctx::CodegenCtx,
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Fn(ref fn_def) => {
                let name = resolve_symbol(intern, entry.item.name.symbol);
                if str_equals(&name, "main") {
                    ctx.register_def_name(entry.def_id.index, common::make_string("blood_main"));
                } else {
                    let mangled = make_def_name(entry.def_id.index, &name);
                    ctx.register_def_name(entry.def_id.index, mangled);
                }
            }
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                // Foreign functions use bare names (matching runtime symbols)
                let mut fi: usize = 0;
                while fi < foreign_def.items.len() {
                    match &foreign_def.items[fi] {
                        &hir_item::ForeignItem::Fn(ref ff) => {
                            let name = resolve_symbol(intern, ff.name.symbol);
                            ctx.register_def_name(ff.def_id.index, name);
                        }
                        &hir_item::ForeignItem::Static(ref _fs) => {}
                        &hir_item::ForeignItem::OpaqueType(ref _ot) => {}
                    }
                    fi = fi + 1;
                }
            }
            &hir_item::ItemKind::Impl(ref impl_def) => {
                let mut ai: usize = 0;
                while ai < impl_def.items.len() {
                    match &impl_def.items[ai] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            let name = resolve_symbol(intern, assoc_fn.name.symbol);
                            let mangled = make_def_name(assoc_fn.def_id.index, &name);
                            ctx.register_def_name(assoc_fn.def_id.index, mangled);
                        }
                        &hir_item::AssocItem::Type(ref _at) => {}
                        &hir_item::AssocItem::Const(ref _ac) => {}
                    }
                    ai = ai + 1;
                }
            }
            &hir_item::ItemKind::Trait(ref trait_def) => {
                let mut ti: usize = 0;
                while ti < trait_def.items.len() {
                    match &trait_def.items[ti] {
                        &hir_item::AssocItem::Fn(ref assoc_fn) => {
                            let name = resolve_symbol(intern, assoc_fn.name.symbol);
                            let mangled = make_def_name(assoc_fn.def_id.index, &name);
                            ctx.register_def_name(assoc_fn.def_id.index, mangled);
                        }
                        &hir_item::AssocItem::Type(ref _at) => {}
                        &hir_item::AssocItem::Const(ref _ac) => {}
                    }
                    ti = ti + 1;
                }
            }
            &hir_item::ItemKind::Struct(ref _s) => {}
            &hir_item::ItemKind::Enum(ref _e) => {}
            &hir_item::ItemKind::TypeAlias(ref _ta) => {}
            &hir_item::ItemKind::Const(ref _c) => {}
            &hir_item::ItemKind::Static(ref _s) => {}
            &hir_item::ItemKind::Effect(ref _ef) => {}
            &hir_item::ItemKind::Handler(ref _h) => {}
            &hir_item::ItemKind::Module(ref _m) => {}
            &hir_item::ItemKind::Macro(ref _m) => {}
        }
        i = i + 1;
    }
}

/// Registers def_names for all enum variant constructors.
/// Each variant gets a name like def{enum_def_id}_{variant_name} so the codegen
/// can emit identifiable references instead of @fn_NNN.
fn register_enum_variant_names(
    ctx: &mut codegen_ctx::CodegenCtx,
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Enum(ref enum_def) => {
                let enum_name = resolve_symbol(intern, entry.item.name.symbol);
                let mut vi: usize = 0;
                while vi < enum_def.variants.len() {
                    let variant = &enum_def.variants[vi];
                    let variant_name = resolve_symbol(intern, variant.name.symbol);
                    let mut mangled = String::new();
                    mangled.push_str("def");
                    push_usize(&mut mangled, entry.def_id.index as usize);
                    mangled.push(95 as char); // '_'
                    mangled.push_str(enum_name.as_str());
                    mangled.push_str("__");
                    mangled.push_str(variant_name.as_str());
                    ctx.register_def_name(variant.def_id.index, mangled);
                    vi = vi + 1;
                }
            }
            _ => {}
        }
        i = i + 1;
    }
}

/// Generates LLVM `declare` statements for all foreign functions in the items list.
/// These are runtime builtins that need extern declarations for linking.
fn generate_foreign_declarations(
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) -> String {
    let mut output = String::new();
    output.push_str("\n; Foreign function declarations (blood-rust runtime)\n");

    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Foreign(ref foreign_def) => {
                let mut fi: usize = 0;
                while fi < foreign_def.items.len() {
                    match &foreign_def.items[fi] {
                        &hir_item::ForeignItem::Fn(ref ff) => {
                            let name = resolve_symbol(intern, ff.name.symbol);
                            // Skip region_* functions - they are defined as
                            // wrappers around blood_region_* in intrinsic_declarations()
                            if is_region_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            // Skip format runtime builtins - they are declared with
                            // correct { ptr, i64 } return type in intrinsic_declarations()
                            if is_format_runtime_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            // Skip builtins that have wrapper definitions in
                            // intrinsic_declarations() (print→print_str, assert→blood_assert, etc.)
                            if is_intrinsic_wrapper_builtin(name.as_str()) {
                                fi = fi + 1;
                                continue;
                            }
                            let ret_hir_ty = type_intern::ty_id_to_type(ff.return_ty);
                            let ret_ty = codegen_types::return_type_to_llvm(&ret_hir_ty);
                            output.push_str("declare ");
                            output.push_str(ret_ty.as_str());
                            output.push_str(" @");
                            output.push_str(name.as_str());
                            output.push_str("(");
                            let mut pi: usize = 0;
                            while pi < ff.param_tys.len() {
                                if pi > 0 {
                                    output.push_str(", ");
                                }
                                let param_hir_ty = type_intern::ty_id_to_type(ff.param_tys[pi]);
                                let param_ty = codegen_types::type_to_llvm(&param_hir_ty);
                                output.push_str(param_ty.as_str());
                                pi = pi + 1;
                            }
                            output.push_str(")\n");
                        }
                        &hir_item::ForeignItem::Static(ref _fs) => {}
                        &hir_item::ForeignItem::OpaqueType(ref _ot) => {}
                    }
                    fi = fi + 1;
                }
            }
            &hir_item::ItemKind::Fn(ref _f) => {}
            &hir_item::ItemKind::Struct(ref _s) => {}
            &hir_item::ItemKind::Enum(ref _e) => {}
            &hir_item::ItemKind::TypeAlias(ref _ta) => {}
            &hir_item::ItemKind::Const(ref _c) => {}
            &hir_item::ItemKind::Static(ref _s) => {}
            &hir_item::ItemKind::Trait(ref _t) => {}
            &hir_item::ItemKind::Effect(ref _ef) => {}
            &hir_item::ItemKind::Handler(ref _h) => {}
            &hir_item::ItemKind::Module(ref _m) => {}
            &hir_item::ItemKind::Impl(ref _im) => {}
            &hir_item::ItemKind::Macro(ref _m) => {}
        }
        i = i + 1;
    }

    output
}

// ============================================================
// Path Helpers
// ============================================================

/// Returns the default .ll output path for a source file.
/// Replaces .blood extension with .ll, or appends .ll if no .blood extension.
fn default_ll_path(source_path: &String) -> String {
    replace_ext(source_path, ".ll")
}

/// Replaces the .blood extension with a new extension.
fn replace_ext(source_path: &String, new_ext: &str) -> String {
    let bytes = source_path.as_bytes();
    let blood_ext = ".blood";
    let ext_bytes = blood_ext.as_bytes();

    if bytes.len() >= ext_bytes.len() {
        let start = bytes.len() - ext_bytes.len();
        let mut matches = true;
        let mut k: usize = 0;
        while k < ext_bytes.len() {
            if bytes[start + k] != ext_bytes[k] {
                matches = false;
            }
            k = k + 1;
        }
        if matches {
            // Strip .blood and add new extension
            let mut result = String::new();
            let mut j: usize = 0;
            while j < start {
                result.push(bytes[j] as char);
                j = j + 1;
            }
            result.push_str(new_ext);
            return result;
        }
    }
    // No .blood extension found, just append
    let mut result = common::make_string(source_path.as_str());
    result.push_str(new_ext);
    result
}

/// Strips the .blood extension from a path.
fn strip_blood_ext(source_path: &String) -> String {
    replace_ext(source_path, "")
}

/// Strips the .ll extension from a path.
fn strip_ll_ext(path: &String) -> String {
    let bytes = path.as_bytes();
    let ll_ext = ".ll";
    let ext_bytes = ll_ext.as_bytes();
    if bytes.len() >= ext_bytes.len() {
        let start = bytes.len() - ext_bytes.len();
        let mut matches = true;
        let mut k: usize = 0;
        while k < ext_bytes.len() {
            if bytes[start + k] != ext_bytes[k] {
                matches = false;
            }
            k = k + 1;
        }
        if matches {
            let mut result = String::new();
            let mut j: usize = 0;
            while j < start {
                result.push(bytes[j] as char);
                j = j + 1;
            }
            return result;
        }
    }
    common::make_string(path.as_str())
}

// ============================================================
// Effect Handler Info Collection
// ============================================================

/// Information about a handler operation needed for wrapper generation.
struct HandlerOpInfo {
    /// The handler's user-visible name (e.g., "SilentLog").
    handler_name: String,
    /// The operation's user-visible name (e.g., "log").
    op_name: String,
    /// The operation's index within the effect.
    op_index: u32,
    /// The handler's DefId.
    handler_def_id: u32,
    /// The effect's DefId.
    effect_def_id: u32,
    /// The body DefId of the handler op implementation.
    body_def_id: u32,
    /// The number of parameters the operation takes (excluding self/state).
    param_count: u32,
}

/// Information about a handler's return clause.
struct HandlerReturnInfo {
    /// The handler's user-visible name (e.g., "SilentLog").
    handler_name: String,
    /// The handler's DefId.
    handler_def_id: u32,
    /// The effect's DefId.
    effect_def_id: u32,
    /// The body DefId of the return clause (BodyId.index used as DefId).
    body_def_id: u32,
    /// Whether this handler has an explicit return clause body.
    has_body: bool,
    /// Return clause kind:
    /// 0 = identity (return(x) { x })
    /// 1 = state field reference (return(x) { total })
    /// 2 = general expression (call compiled body)
    return_kind: u32,
    /// For return_kind=1: index of the state field in the handler state struct.
    state_field_index: u32,
    /// Number of state fields in the handler.
    state_field_count: u32,
}

/// Collected information about all handlers in the program.
struct HandlerInfo {
    /// Handler operation infos for wrapper generation.
    ops: Vec<HandlerOpInfo>,
    /// Handler return clause infos.
    returns: Vec<HandlerReturnInfo>,
}

/// Return clause classification result.
struct ReturnClauseKind {
    /// 0=identity, 1=state field, 2=general
    kind: u32,
    /// For kind=1: index of the referenced state field
    field_index: u32,
}

/// Classifies a return clause body expression.
/// Looks up the body by body_id and inspects the expression:
/// - If the body expression is a VarRef to the last param (result), return kind=0 (identity).
/// - If the body expression is a VarRef to a state field (local index < state_count), return kind=1.
/// - Otherwise return kind=2 (general).
fn classify_return_clause(
    bodies: &Vec<hir_lower_ctx::BodyEntry>,
    body_id_index: u32,
    state_count: u32,
) -> ReturnClauseKind {
    // Find the body by body_id
    let mut bi: usize = 0;
    while bi < bodies.len() {
        if bodies[bi].body_id.index == body_id_index {
            let body = &bodies[bi].body;
            // Classify the body expression.
            // The body expression is typically a Block with a tail expression.
            // We need to dig through Block wrappers to find the actual leaf expression.
            return classify_leaf_expr(&body.expr, state_count);
        }
        bi = bi + 1;
    }
    // Body not found — treat as identity
    ReturnClauseKind { kind: 0, field_index: 0 }
}

/// Classifies a local reference expression for return clause analysis.
/// Returns: 0=identity (references result param), 1=state field, 2=unknown
fn classify_local_ref(local_index: u32, state_count: u32) -> ReturnClauseKind {
    if local_index == state_count {
        return ReturnClauseKind { kind: 0, field_index: 0 };
    }
    if local_index < state_count {
        return ReturnClauseKind { kind: 1, field_index: local_index };
    }
    ReturnClauseKind { kind: 2, field_index: 0 }
}

/// Extracts the local variable index from a block tail expression.
/// Returns -1 if the block doesn't have a simple Local tail expression.
fn extract_block_tail_local(block: &hir_expr::Block) -> i32 {
    if block.stmts.len() != 0 {
        return -1;
    }
    match &block.expr {
        &Some(ref e) => extract_expr_local_index(e.as_ref()),
        &None => -1,
    }
}

/// Extracts the local variable index from a simple Local expression.
/// Returns -1 if the expression is not a simple Local reference.
fn extract_expr_local_index(expr: &hir_expr::Expr) -> i32 {
    match &expr.kind {
        &hir_expr::ExprKind::Local(local_id) => local_id.index as i32,
        _ => -1,
    }
}

/// Classifies the leaf expression of a return clause.
fn classify_leaf_expr(expr: &hir_expr::Expr, state_count: u32) -> ReturnClauseKind {
    // Check if this is a Local reference directly
    let direct_idx = extract_expr_local_index(expr);
    if direct_idx >= 0 {
        return classify_local_ref(direct_idx as u32, state_count);
    }
    // Check if this is a Block wrapper with a simple tail Local expression.
    match &expr.kind {
        &hir_expr::ExprKind::Block(ref block) => {
            let block_idx = extract_block_tail_local(block);
            if block_idx >= 0 {
                return classify_local_ref(block_idx as u32, state_count);
            }
            ReturnClauseKind { kind: 2, field_index: 0 }
        }
        _ => ReturnClauseKind { kind: 2, field_index: 0 },
    }
}

/// Collects handler information from HIR items.
/// Populates handler→effect mappings in the codegen context and returns
/// HandlerInfo for wrapper/registration generation.
fn collect_handler_info(
    ctx: &mut codegen_ctx::CodegenCtx,
    intern: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
    bodies: &Vec<hir_lower_ctx::BodyEntry>,
) -> HandlerInfo {
    let mut ops: Vec<HandlerOpInfo> = Vec::new();
    let mut returns: Vec<HandlerReturnInfo> = Vec::new();

    let mut i: usize = 0;
    while i < items.len() {
        let entry = &items[i];
        match &entry.item.kind {
            &hir_item::ItemKind::Handler(ref handler_def) => {
                let handler_def_id = entry.def_id.index;
                let effect_def_id = handler_def.handled_effect.def_id.index;

                // Use DefId-based handler name to avoid interner mismatch.
                // The wrapper functions use handler{N} prefix (e.g., handler19_log).
                let mut handler_name = common::make_string("handler");
                push_usize(&mut handler_name, handler_def_id as usize);

                // Register handler→effect mapping
                ctx.register_handler_effect(handler_def_id, effect_def_id);

                // Collect return clause info
                // Handlers without an explicit return clause get body_def_id=0
                // which signals "identity return" (return body result unchanged)
                let state_count = handler_def.state.len() as u32;

                match &handler_def.return_clause {
                    &Option::Some(ref ret_clause) => {
                        // Classify the return clause by inspecting the HIR body expression.
                        let ret_kind = classify_return_clause(bodies, ret_clause.body_id.index, state_count);

                        returns.push(HandlerReturnInfo {
                            handler_name: clone_string(&handler_name),
                            handler_def_id,
                            effect_def_id,
                            body_def_id: ret_clause.body_id.index,
                            has_body: true,
                            return_kind: ret_kind.kind,
                            state_field_index: ret_kind.field_index,
                            state_field_count: state_count,
                        });
                    }
                    &Option::None => {
                        // Generate identity return wrapper (ret i64 %result)
                        let mut id_name = common::make_string("handler");
                        push_usize(&mut id_name, handler_def_id as usize);
                        returns.push(HandlerReturnInfo {
                            handler_name: id_name,
                            handler_def_id,
                            effect_def_id,
                            body_def_id: 0,
                            has_body: false,
                            return_kind: 0,
                            state_field_index: 0,
                            state_field_count: state_count,
                        });
                    }
                }

                // Collect operation infos
                let mut oi: usize = 0;
                while oi < handler_def.op_impls.len() {
                    let op_impl = &handler_def.op_impls[oi];

                    // Use DefId-based op name for reliability
                    let mut op_name = common::make_string("op");
                    push_usize(&mut op_name, op_impl.op_def_id.index as usize);

                    // Find op_index by searching the effect's operations
                    let op_index = find_op_index(items, effect_def_id, op_impl.op_def_id.index);

                    ops.push(HandlerOpInfo {
                        handler_name: clone_string(&handler_name),
                        op_name,
                        op_index,
                        handler_def_id,
                        effect_def_id,
                        // Use op_def_id (not body_id) — this matches what find_fn_for_body
                        // returns as the DefId for handler op bodies.
                        body_def_id: op_impl.op_def_id.index,
                        param_count: op_impl.param_names.len() as u32,
                    });
                    oi = oi + 1;
                }
            }
            &hir_item::ItemKind::Fn(_) => {}
            &hir_item::ItemKind::Struct(_) => {}
            &hir_item::ItemKind::Enum(_) => {}
            &hir_item::ItemKind::TypeAlias(_) => {}
            &hir_item::ItemKind::Const(_) => {}
            &hir_item::ItemKind::Static(_) => {}
            &hir_item::ItemKind::Trait(_) => {}
            &hir_item::ItemKind::Effect(ref effect_def) => {
                // Register (effect_def_id, op_name_symbol) → positional index for Perform resolution.
                let effect_item_def_id = entry.item.def_id.index;
                let mut opi: usize = 0;
                while opi < effect_def.operations.len() {
                    ctx.register_op_def_index(
                        effect_item_def_id,
                        effect_def.operations[opi].name.symbol.index,
                        opi as u32,
                    );
                    opi = opi + 1;
                }
            }
            &hir_item::ItemKind::Module(_) => {}
            &hir_item::ItemKind::Macro(_) => {}
            &hir_item::ItemKind::Impl(_) => {}
            &hir_item::ItemKind::Foreign(_) => {}
        }
        i = i + 1;
    }

    HandlerInfo { ops, returns }
}

/// Finds the operation index within an effect definition by op DefId.
fn find_op_index(
    items: &Vec<hir_lower_ctx::ItemEntry>,
    effect_def_id: u32,
    op_def_id: u32,
) -> u32 {
    let mut i: usize = 0;
    while i < items.len() {
        match &items[i].item.kind {
            &hir_item::ItemKind::Effect(ref effect_def) => {
                if items[i].def_id.index == effect_def_id {
                    let mut j: usize = 0;
                    while j < effect_def.operations.len() {
                        if effect_def.operations[j].def_id.index == op_def_id {
                            return j as u32;
                        }
                        j = j + 1;
                    }
                }
            }
            _ => {}
        }
        i = i + 1;
    }
    0 // fallback
}

/// Generates handler op wrapper functions and the __blood_register_handlers function.
/// Returns the LLVM IR string to append to the module.
fn generate_handler_wrappers(
    handler_info: &HandlerInfo,
    ctx: &codegen_ctx::CodegenCtx,
) -> String {
    let mut ir = String::new();

    if handler_info.ops.len() == 0 && handler_info.returns.len() == 0 {
        return ir;
    }

    ir.push_str("\n; Effect handler wrapper functions\n");

    // Generate wrapper for each handler operation.
    // Wrapper signature: i64 (ptr %state, ptr %args, i64 %arg_count, i64 %cont)
    // The wrapper unpacks args, calls the inner body, and handles continuation resume.
    let mut oi: usize = 0;
    while oi < handler_info.ops.len() {
        let opinfo = &handler_info.ops[oi];

        // Wrapper function name: {HandlerName}_{OpName}
        let mut wrapper_name = clone_string(&opinfo.handler_name);
        wrapper_name.push(95 as char); // '_'
        wrapper_name.push_str(opinfo.op_name.as_str());

        // Find the inner body function name
        let inner_name = match ctx.lookup_def_name(opinfo.body_def_id) {
            Option::Some(name) => name,
            Option::None => {
                let mut fallback = common::make_string("fn_");
                push_usize(&mut fallback, opinfo.body_def_id as usize);
                fallback
            }
        };

        // Determine inner function return type (from fn_signatures)
        let inner_ret_ty = match ctx.lookup_fn_ret_type(opinfo.body_def_id) {
            Option::Some(ty) => ty,
            Option::None => common::make_string("void"),
        };

        // Generate wrapper
        ir.push_str("define weak_odr i64 @");
        ir.push_str(wrapper_name.as_str());
        ir.push_str("(ptr %state, ptr %args, i64 %arg_count, i64 %cont) {\n");
        ir.push_str("entry:\n");

        // Unpack args and call inner body
        // Inner body params: the natural parameters of the handler op
        let param_count = opinfo.param_count as usize;

        // Build call to inner function
        // First arg is always ptr %state (handler op state pointer)
        if param_count == 0 {
            // State-only — call inner with just the state pointer
            if str_eq(inner_ret_ty.as_str(), "void") {
                ir.push_str("  call void @");
                ir.push_str(inner_name.as_str());
                ir.push_str("(ptr %state)\n");
                ir.push_str("  br label %do_resume\n");
                ir.push_str("do_resume:\n");
                emit_resume_logic(&mut ir, "0");
            } else {
                ir.push_str("  %inner_result = call ");
                ir.push_str(inner_ret_ty.as_str());
                ir.push_str(" @");
                ir.push_str(inner_name.as_str());
                ir.push_str("(ptr %state)\n");
                let widened = widen_to_i64(&mut ir, "inner_result", inner_ret_ty.as_str());
                ir.push_str("  br label %do_resume\n");
                ir.push_str("do_resume:\n");
                emit_resume_logic(&mut ir, widened.as_str());
            }
        } else {
            // Load args from args array
            let mut pi: usize = 0;
            while pi < param_count {
                // Get the expected param type from inner function signature
                // Offset by 1 to skip the state pointer parameter
                let param_ty = match ctx.lookup_fn_param_type(opinfo.body_def_id, pi + 1) {
                    Option::Some(ty) => ty,
                    Option::None => common::make_string("i64"),
                };

                if pi == 0 {
                    // First arg: load directly from args ptr
                    ir.push_str("  %arg_i64_0 = load i64, ptr %args\n");
                } else {
                    // Subsequent args: GEP into args array
                    ir.push_str("  %arg_ptr_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = getelementptr i64, ptr %args, i64 ");
                    push_usize(&mut ir, pi);
                    ir.push_str("\n");
                    ir.push_str("  %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = load i64, ptr %arg_ptr_");
                    push_usize(&mut ir, pi);
                    ir.push_str("\n");
                }

                // Narrow i64 to param type if needed
                if str_eq(param_ty.as_str(), "i64") {
                    // Already correct
                } else if str_eq(param_ty.as_str(), "i32") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = trunc i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to i32\n");
                } else if str_eq(param_ty.as_str(), "i16") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = trunc i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to i16\n");
                } else if str_eq(param_ty.as_str(), "i8") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = trunc i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to i8\n");
                } else if str_eq(param_ty.as_str(), "i1") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = trunc i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to i1\n");
                } else if str_eq(param_ty.as_str(), "ptr") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = inttoptr i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to ptr\n");
                } else if str_eq(param_ty.as_str(), "double") {
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = bitcast i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to double\n");
                } else if str_eq(param_ty.as_str(), "float") {
                    ir.push_str("  %arg_f64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = bitcast i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to double\n");
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = fptrunc double %arg_f64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to float\n");
                } else {
                    // For struct/aggregate types, use inttoptr then load
                    ir.push_str("  %arg_ptr_cast_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = inttoptr i64 %arg_i64_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" to ptr\n");
                    ir.push_str("  %arg_");
                    push_usize(&mut ir, pi);
                    ir.push_str(" = load ");
                    ir.push_str(param_ty.as_str());
                    ir.push_str(", ptr %arg_ptr_cast_");
                    push_usize(&mut ir, pi);
                    ir.push_str("\n");
                }

                pi = pi + 1;
            }

            // Build call to inner function
            if str_eq(inner_ret_ty.as_str(), "void") {
                ir.push_str("  call void @");
                ir.push_str(inner_name.as_str());
                ir.push_str("(ptr %state, ");
                emit_call_args(&mut ir, ctx, opinfo.body_def_id, param_count, 1);
                ir.push_str(")\n");
                ir.push_str("  br label %do_resume\n");
                ir.push_str("do_resume:\n");
                emit_resume_logic(&mut ir, "0");
            } else {
                ir.push_str("  %inner_result = call ");
                ir.push_str(inner_ret_ty.as_str());
                ir.push_str(" @");
                ir.push_str(inner_name.as_str());
                ir.push_str("(ptr %state, ");
                emit_call_args(&mut ir, ctx, opinfo.body_def_id, param_count, 1);
                ir.push_str(")\n");
                let widened = widen_to_i64(&mut ir, "inner_result", inner_ret_ty.as_str());
                ir.push_str("  br label %do_resume\n");
                ir.push_str("do_resume:\n");
                emit_resume_logic(&mut ir, widened.as_str());
            }
        }

        ir.push_str("}\n\n");

        oi = oi + 1;
    }

    // Generate return clause wrappers
    // Signature: i64 (i64 %result, ptr %state)
    let mut ri: usize = 0;
    while ri < handler_info.returns.len() {
        let ret_info = &handler_info.returns[ri];

        let mut wrapper_name = clone_string(&ret_info.handler_name);
        wrapper_name.push_str("_return");

        ir.push_str("define weak_odr i64 @");
        ir.push_str(wrapper_name.as_str());
        ir.push_str("(i64 %result, ptr %state) {\n");
        ir.push_str("entry:\n");

        if ret_info.return_kind == 0 {
            // Identity: return(x) { x } — just return the result unchanged
            ir.push_str("  ret i64 %result\n");
        } else if ret_info.return_kind == 1 {
            // State field: return(x) { total } — load state field from %state pointer
            // State is a struct with fields laid out sequentially.
            // For single-field state, load directly from %state.
            // For multi-field state, GEP to the correct field offset.
            if ret_info.state_field_count == 1 {
                // Single field: load directly from state pointer
                ir.push_str("  %state_val = load i32, ptr %state\n");
                ir.push_str("  %ret_ext = sext i32 %state_val to i64\n");
                ir.push_str("  ret i64 %ret_ext\n");
            } else {
                // Multi-field: GEP to field offset, then load
                // State is a packed struct of i64 fields (one per state field).
                ir.push_str("  %field_ptr = getelementptr i64, ptr %state, i64 ");
                push_usize(&mut ir, ret_info.state_field_index as usize);
                ir.push_str("\n");
                ir.push_str("  %state_val = load i64, ptr %field_ptr\n");
                ir.push_str("  ret i64 %state_val\n");
            }
        } else {
            // General case (return_kind == 2): fall back to identity
            // TODO: implement general return clause expression evaluation
            ir.push_str("  ret i64 %result\n");
        }

        ir.push_str("}\n\n");

        ri = ri + 1;
    }

    // Generate __blood_register_handlers
    ir.push_str("; Handler registration\n");
    ir.push_str("define linkonce_odr void @__blood_register_handlers() {\n");
    ir.push_str("entry:\n");

    // Group ops by handler (effect_def_id)
    // For each unique effect, build an ops array and call blood_evidence_register
    let mut registered_effects: Vec<u32> = Vec::new();
    let mut ei: usize = 0;
    while ei < handler_info.ops.len() {
        let opentry = &handler_info.ops[ei];
        let eid = opentry.effect_def_id;

        // Check if we already registered this effect
        let mut already = false;
        let mut ri2: usize = 0;
        while ri2 < registered_effects.len() {
            if registered_effects[ri2] == eid {
                already = true;
                ri2 = registered_effects.len(); // break
            }
            ri2 = ri2 + 1;
        }

        if !already {
            registered_effects.push(eid);

            // Count ops for this effect
            let mut op_count: usize = 0;
            let mut ci: usize = 0;
            while ci < handler_info.ops.len() {
                if handler_info.ops[ci].effect_def_id == eid {
                    op_count = op_count + 1;
                }
                ci = ci + 1;
            }

            // Alloca for ops array
            let eid_str = codegen_types::format_u64(eid as u64);
            ir.push_str("  %handler_ops_");
            ir.push_str(eid_str.as_str());
            ir.push_str(" = alloca [");
            push_usize(&mut ir, op_count);
            ir.push_str(" x ptr]\n");

            // Store each op's wrapper function pointer
            let mut store_idx: usize = 0;
            let mut si: usize = 0;
            while si < handler_info.ops.len() {
                if handler_info.ops[si].effect_def_id == eid {
                    let sop = &handler_info.ops[si];
                    let mut wrapper_name = clone_string(&sop.handler_name);
                    wrapper_name.push(95 as char); // '_'
                    wrapper_name.push_str(sop.op_name.as_str());

                    if store_idx == 0 {
                        ir.push_str("  store ptr @");
                        ir.push_str(wrapper_name.as_str());
                        ir.push_str(", ptr %handler_ops_");
                        ir.push_str(eid_str.as_str());
                        ir.push_str("\n");
                    } else {
                        ir.push_str("  %op_ptr_");
                        ir.push_str(eid_str.as_str());
                        ir.push_str("_");
                        push_usize(&mut ir, store_idx);
                        ir.push_str(" = getelementptr [");
                        push_usize(&mut ir, op_count);
                        ir.push_str(" x ptr], ptr %handler_ops_");
                        ir.push_str(eid_str.as_str());
                        ir.push_str(", i64 0, i64 ");
                        push_usize(&mut ir, store_idx);
                        ir.push_str("\n");
                        ir.push_str("  store ptr @");
                        ir.push_str(wrapper_name.as_str());
                        ir.push_str(", ptr %op_ptr_");
                        ir.push_str(eid_str.as_str());
                        ir.push_str("_");
                        push_usize(&mut ir, store_idx);
                        ir.push_str("\n");
                    }
                    store_idx = store_idx + 1;
                }
                si = si + 1;
            }

            // Call blood_evidence_register
            ir.push_str("  call void @blood_evidence_register(ptr null, i64 ");
            ir.push_str(eid_str.as_str());
            ir.push_str(", ptr %handler_ops_");
            ir.push_str(eid_str.as_str());
            ir.push_str(", i64 ");
            push_usize(&mut ir, op_count);
            ir.push_str(")\n");
        }

        ei = ei + 1;
    }

    ir.push_str("  ret void\n");
    ir.push_str("}\n\n");

    // Emit llvm.global_ctors
    ir.push_str("@llvm.global_ctors = appending global [1 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @__blood_register_handlers, ptr null }]\n");

    ir
}

/// Emits resume logic for a handler op wrapper.
/// If cont == 0, returns resume_val directly (tail-resumptive).
/// Otherwise, calls blood_continuation_resume and returns its result.
fn emit_resume_logic(ir: &mut String, resume_val: &str) {
    ir.push_str("  %is_tail = icmp eq i64 %cont, 0\n");
    ir.push_str("  br i1 %is_tail, label %tail_resume, label %cont_resume\n");
    ir.push_str("tail_resume:\n");
    ir.push_str("  ret i64 ");
    ir.push_str(resume_val);
    ir.push_str("\n");
    ir.push_str("cont_resume:\n");
    ir.push_str("  %cont_result = call i64 @blood_continuation_resume(i64 %cont, i64 ");
    ir.push_str(resume_val);
    ir.push_str(")\n");
    ir.push_str("  ret i64 %cont_result\n");
}

/// Widens a value to i64, returning the name of the widened value.
fn widen_to_i64(ir: &mut String, val_name: &str, ty: &str) -> String {
    if str_eq(ty, "i64") {
        let mut s = common::make_string("%");
        s.push_str(val_name);
        return s;
    }
    if str_eq(ty, "i32") || str_eq(ty, "i16") || str_eq(ty, "i8") || str_eq(ty, "i1") {
        ir.push_str("  %");
        ir.push_str(val_name);
        ir.push_str("_wide = zext ");
        ir.push_str(ty);
        ir.push_str(" %");
        ir.push_str(val_name);
        ir.push_str(" to i64\n");
        let mut s = common::make_string("%");
        s.push_str(val_name);
        s.push_str("_wide");
        return s;
    }
    if str_eq(ty, "ptr") {
        ir.push_str("  %");
        ir.push_str(val_name);
        ir.push_str("_wide = ptrtoint ptr %");
        ir.push_str(val_name);
        ir.push_str(" to i64\n");
        let mut s = common::make_string("%");
        s.push_str(val_name);
        s.push_str("_wide");
        return s;
    }
    if str_eq(ty, "double") {
        ir.push_str("  %");
        ir.push_str(val_name);
        ir.push_str("_wide = bitcast double %");
        ir.push_str(val_name);
        ir.push_str(" to i64\n");
        let mut s = common::make_string("%");
        s.push_str(val_name);
        s.push_str("_wide");
        return s;
    }
    // For other types (void, struct, etc.), return 0
    common::make_string("0")
}

/// Emits call arguments for the inner handler op body function.
/// For i64 params, uses %arg_i64_{N} directly (no narrowing was done).
/// For other types, uses %arg_{N} (narrowing creates this name).
/// sig_offset: offset into fn_signatures params (1 to skip state ptr, 0 for no offset).
fn emit_call_args(ir: &mut String, ctx: &codegen_ctx::CodegenCtx, body_def_id: u32, param_count: usize, sig_offset: usize) {
    let mut pi: usize = 0;
    while pi < param_count {
        if pi > 0 {
            ir.push_str(", ");
        }
        let param_ty = match ctx.lookup_fn_param_type(body_def_id, pi + sig_offset) {
            Option::Some(ty) => ty,
            Option::None => common::make_string("i64"),
        };
        ir.push_str(param_ty.as_str());
        if str_eq(param_ty.as_str(), "i64") {
            // For i64 params, the loaded value is directly %arg_i64_{N}
            ir.push_str(" %arg_i64_");
        } else {
            // For narrowed types, the narrowed value is %arg_{N}
            ir.push_str(" %arg_");
        }
        push_usize(ir, pi);
        pi = pi + 1;
    }
}

// ============================================================
// Codegen Work List
// ============================================================

/// A single unit of codegen work: one function body to lower and emit.
struct CodegenWorkItem {
    /// Index into lower_result.bodies.
    body_idx: usize,
    /// The mangled function name for LLVM IR.
    fn_name: String,
    /// The DefId of this function.
    def_id: hir_def::DefId,
    /// The function's return type.
    return_ty: type_intern::TyId,
    /// The function's source span.
    span: common::Span,
}

/// Result of scanning bodies to build the work list.
struct CodegenWorkList {
    /// The work items to process.
    items: Vec<CodegenWorkItem>,
    /// Function names that were defined (for stub generation).
    defined_names: Vec<String>,
    /// DefIds that were defined (for duplicate detection — already embedded in items).
    defined_def_ids: Vec<u32>,
}

/// Scans all HIR bodies and builds a work list of functions to codegen.
/// Filters out static bodies and duplicates from generic instantiations.
/// This separates work identification from work execution, enabling batching.
fn build_codegen_worklist(
    lower_result: &hir_lower_ctx::LowerResult,
    static_def_ids: &Vec<u32>,
) -> CodegenWorkList {
    let mut items: Vec<CodegenWorkItem> = Vec::new();
    let mut defined_names: Vec<String> = Vec::new();
    let mut defined_def_ids: Vec<u32> = Vec::new();

    let mut body_idx: usize = 0;
    while body_idx < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx];
        let body_id = body_entry.body_id;

        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);

        let return_ty = match &fn_info {
            &Option::Some(ref info) => type_intern::TyId::new(info.return_ty.index),
            &Option::None => type_intern::CommonTypes::unit(),
        };
        let span = match &fn_info {
            &Option::Some(ref info) => info.span,
            &Option::None => common::Span::new(0, 0, 1, 1),
        };
        let fn_name = match &fn_info {
            &Option::Some(ref info) => make_mangled_fn_name(&lower_result.interner, info),
            &Option::None => driver::make_fn_name(body_idx),
        };
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id,
            &Option::None => hir_def::DefId::new(body_idx as u32),
        };

        // Check if this body belongs to a static variable - skip if so.
        let mut is_static_body = false;
        let mut sbi: usize = 0;
        while sbi < static_def_ids.len() {
            if static_def_ids[sbi] == def_id.index {
                is_static_body = true;
                sbi = static_def_ids.len(); // break
            }
            sbi = sbi + 1;
        }
        if is_static_body {
            body_idx = body_idx + 1;
            continue;
        }

        // Check if this DefId was already processed (skip duplicates)
        let mut is_duplicate = false;
        let mut di: usize = 0;
        while di < defined_def_ids.len() {
            if defined_def_ids[di] == def_id.index {
                is_duplicate = true;
                di = defined_def_ids.len(); // break
            }
            di = di + 1;
        }
        if is_duplicate {
            body_idx = body_idx + 1;
            continue;
        }

        defined_def_ids.push(def_id.index);
        defined_names.push(clone_string(&fn_name));

        items.push(CodegenWorkItem {
            body_idx,
            fn_name,
            def_id,
            return_ty,
            span,
        });

        body_idx = body_idx + 1;
    }

    CodegenWorkList {
        items,
        defined_names,
        defined_def_ids,
    }
}

// ============================================================
// Parallel Codegen Infrastructure
// ============================================================

/// Arguments passed to each codegen worker thread via u64 address.
/// All pointer-like fields are u64 addresses obtained via `&T as u64`.
struct ThreadCodegenArg {
    /// Address of the worker's CodegenCtx (&mut CodegenCtx as u64).
    worker_ctx_addr: u64,
    /// Address of the shared LowerResult (&LowerResult as u64).
    lower_result_addr: u64,
    /// Address of the shared TypeCheckResult (&TypeCheckResult as u64).
    typeck_result_addr: u64,
    /// Address of the shared CodegenWorkList (&CodegenWorkList as u64).
    worklist_addr: u64,
    /// Start index in worklist.items (inclusive).
    chunk_start: usize,
    /// End index in worklist.items (exclusive).
    chunk_end: usize,
    /// Address of the worker's output String (&mut String as u64).
    output_ir_addr: u64,
}

/// Worker function for parallel codegen threads.
/// Receives a ThreadCodegenArg via u64 address, processes its chunk of the
/// worklist (MIR lowering + codegen), and writes IR to its output String.
fn codegen_thread_worker(arg: u64) -> u64 {
    let targ: &ThreadCodegenArg = arg as &ThreadCodegenArg;
    let ctx: &mut codegen_ctx::CodegenCtx = targ.worker_ctx_addr as &mut codegen_ctx::CodegenCtx;
    let lower: &hir_lower_ctx::LowerResult = targ.lower_result_addr as &hir_lower_ctx::LowerResult;
    let typeck: &typeck_driver::TypeCheckResult = targ.typeck_result_addr as &typeck_driver::TypeCheckResult;
    let wl: &CodegenWorkList = targ.worklist_addr as &CodegenWorkList;
    let output: &mut String = targ.output_ir_addr as &mut String;

    // Per-thread codegen region: holds codegen temporaries + ctx growth.
    // Thread-local since regions use thread-local stacks.
    let thread_codegen_region = region_create(33554432, 8589934592);
    region_activate(thread_codegen_region);

    let mut i: usize = targ.chunk_start;
    while i < targ.chunk_end {
        let work = &wl.items[i];
        let body_entry = &lower.bodies[work.body_idx];
        let hir_body = &body_entry.body;

        // Per-function MIR region sits on top of thread_codegen_region.
        let mir_region = region_create(4194304, 8589934592);
        region_activate(mir_region);

        let body = mir_lower::lower_body(
            work.def_id,
            hir_body,
            type_intern::TyId::new(work.return_ty.index),
            work.span,
            &typeck.subst_table,
            &typeck.method_resolutions,
            &typeck.field_resolutions,
        );

        // Pop mir_region — thread_codegen_region becomes active.
        region_deactivate();

        // Set up call remaps for trait default methods
        ctx.call_remaps = find_call_remaps_for_def(
            &typeck.default_method_remaps,
            work.def_id.index,
        );

        // Set handler op state flags if needed
        let is_hop = ctx.is_handler_op_body(work.def_id.index);
        if is_hop {
            ctx.handler_op_state_local = 1;
            ctx.is_handler_op = true;
        }

        // Codegen (thread_codegen_region active — all allocations scoped)
        let fn_ir = codegen::generate_function_with_ctx(ctx, &body, work.fn_name.as_str());
        output.push_str(fn_ir.as_str());

        // Destroy MIR region — frees MIR body data
        region_destroy(mir_region);

        // Clear handler op state flags
        if is_hop {
            ctx.handler_op_state_local = -1;
            ctx.is_handler_op = false;
        }

        // Clear call remaps
        ctx.call_remaps = Vec::new();

        i = i + 1;
    }

    region_deactivate();
    region_destroy(thread_codegen_region);
    0
}

// ============================================================
// Pass 2: MIR Lowering + Codegen
// ============================================================

/// Runs Pass 2 codegen, writing each function's IR directly to output_path.
/// Processes functions sequentially with per-function MIR regions for memory efficiency.
fn codegen_pass2(
    ctx: &mut codegen_ctx::CodegenCtx,
    worklist: &CodegenWorkList,
    lower_result: &hir_lower_ctx::LowerResult,
    typeck_result: &typeck_driver::TypeCheckResult,
    output_path: &str,
    args: &Args,
) -> bool {
    let total_items: usize = worklist.items.len();
    if total_items == 0 {
        return true;
    }

    let mut i: usize = 0;
    while i < total_items {
        let work = &worklist.items[i];

        if i % 100 == 0 {
            eprint_str("\n  [fn ");
            eprint_str(int_to_string(i as i32));
            eprint_str("/");
            eprint_str(int_to_string(total_items as i32));
            eprint_str(" ");
            eprint_str(work.fn_name.as_str());
            eprint_str("]");
        }

        let body_entry = &lower_result.bodies[work.body_idx];
        let hir_body = &body_entry.body;

        // Per-function MIR region sits ON TOP of the codegen_region stack.
        // MIR lowering allocations go here, then we pop so codegen uses
        // the parent codegen_region (persistent across all functions).
        let mir_region = region_create(4194304, 8589934592);
        region_activate(mir_region);

        let body = mir_lower::lower_body(
            work.def_id,
            hir_body,
            type_intern::TyId::new(work.return_ty.index),
            work.span,
            &typeck_result.subst_table,
            &typeck_result.method_resolutions,
            &typeck_result.field_resolutions,
        );

        // Pop mir_region — codegen_region becomes active again.
        // MIR data remains valid until region_destroy below.
        region_deactivate();

        // Dump MIR if requested
        if args.dump_mir {
            let fn_name_str = work.fn_name.as_str();
            let should_dump = match &args.dump_mir_filter {
                &Option::Some(ref filter) => str_contains_ref(fn_name_str, filter.as_str()),
                &Option::None => true,
            };
            if should_dump {
                let mir_text = dump_mir::format_mir_body(&body, fn_name_str);
                eprint_str("=== MIR: ");
                eprint_str(fn_name_str);
                eprint_str(" ===\n");
                eprint_str(mir_text.as_str());
                eprint_str("\n");
            }
        }

        // Validate MIR if requested
        if args.validate_mir {
            let fn_name_str = work.fn_name.as_str();
            let errors = validate_mir::validate_body(&body, fn_name_str);
            if errors.len() > 0 {
                eprint_str("=== MIR VALIDATION ERRORS: ");
                eprint_str(fn_name_str);
                eprint_str(" ===\n");
                let mut ei: usize = 0;
                while ei < errors.len() {
                    eprint_str("  ");
                    eprint_str(errors[ei].as_str());
                    eprint_str("\n");
                    ei = ei + 1;
                }
            }
        }

        // Set up call remapping for trait default methods.
        ctx.call_remaps = find_call_remaps_for_def(
            &typeck_result.default_method_remaps,
            work.def_id.index,
        );

        // Set handler op state flags if this is a handler op body
        let is_hop = ctx.is_handler_op_body(work.def_id.index);
        if is_hop {
            ctx.handler_op_state_local = 1;
            ctx.is_handler_op = true;
        }

        // Codegen (no region active — all allocations in global allocator)
        let fn_ir = codegen::generate_function_with_ctx(ctx, &body, work.fn_name.as_str());
        file_append_string(output_path, fn_ir.as_str());

        // Destroy MIR region — frees MIR body data
        region_destroy(mir_region);

        // Clear handler op state flags
        if is_hop {
            ctx.handler_op_state_local = -1;
            ctx.is_handler_op = false;
        }

        // Clear call remaps after generating the function
        ctx.call_remaps = Vec::new();

        i = i + 1;
    }

    true
}

/// Finds the call remapping entries for a given default method DefId.
/// Returns a Vec of CallRemapEntry if the def_id matches a default method,
/// or an empty Vec if not.
fn find_call_remaps_for_def(
    remaps: &Vec<common::DefaultMethodRemap>,
    def_id: u32,
) -> Vec<common::CallRemapEntry> {
    let mut result: Vec<common::CallRemapEntry> = Vec::new();
    let mut i: usize = 0;
    while i < remaps.len() {
        if remaps[i].body_def_id == def_id {
            // Copy the remap entries
            let mut j: usize = 0;
            while j < remaps[i].call_remaps.len() {
                result.push(common::CallRemapEntry::new(
                    remaps[i].call_remaps[j].from_def_id,
                    remaps[i].call_remaps[j].to_def_id,
                ));
                j = j + 1;
            }
            return result;
        }
        i = i + 1;
    }
    result
}

// ============================================================
// Memory Profiling
// ============================================================

/// Reads VmRSS from /proc/self/status and returns the value in KB.
/// Returns 0 if the file cannot be read or parsed.
fn get_rss_kb() -> u64 {
    let status: &str = file_read_to_string("/proc/self/status");
    if status.len() == 0 {
        return 0 as u64;
    }
    // Scan for "VmRSS:" line and parse the number
    let target: &str = "VmRSS:";
    let mut i: usize = 0;
    while i < status.len() {
        // Check if we're at "VmRSS:"
        if i + 6 <= status.len() {
            let ch0 = status.as_bytes()[i];
            let ch1 = status.as_bytes()[i + 1];
            let ch2 = status.as_bytes()[i + 2];
            let ch3 = status.as_bytes()[i + 3];
            let ch4 = status.as_bytes()[i + 4];
            let ch5 = status.as_bytes()[i + 5];
            if ch0 == 86 && ch1 == 109 && ch2 == 82 && ch3 == 83 && ch4 == 83 && ch5 == 58 {
                // Found "VmRSS:" — skip whitespace and parse number
                let mut j: usize = i + 6;
                while j < status.len() {
                    let c = status.as_bytes()[j];
                    if c == 32 || c == 9 {
                        j = j + 1;
                    } else {
                        break;
                    }
                }
                // Parse digits
                let mut value: u64 = 0;
                while j < status.len() {
                    let c = status.as_bytes()[j];
                    if c >= 48 && c <= 57 {
                        value = value * 10 + (c - 48) as u64;
                        j = j + 1;
                    } else {
                        break;
                    }
                }
                return value;
            }
        }
        // Skip to next line
        while i < status.len() && status.as_bytes()[i] != 10 {
            i = i + 1;
        }
        i = i + 1;
    }
    0 as u64
}

/// Formats a byte count as human-readable (e.g., "1234 MB" or "5678 KB").
fn push_bytes_human(s: &mut String, bytes: u64) {
    if bytes >= 1073741824 {
        // GB range
        let gb = bytes / 1073741824;
        let remainder_mb = (bytes % 1073741824) / 10737418;  // two decimal places
        push_u64(s, gb);
        s.push('.');
        if remainder_mb < 10 {
            s.push('0');
        }
        push_u64(s, remainder_mb);
        s.push_str(" GB");
    } else if bytes >= 1048576 {
        // MB range
        let mb = bytes / 1048576;
        let remainder_kb = (bytes % 1048576) / 10485;  // two decimal places
        push_u64(s, mb);
        s.push('.');
        if remainder_kb < 10 {
            s.push('0');
        }
        push_u64(s, remainder_kb);
        s.push_str(" MB");
    } else {
        let kb = bytes / 1024;
        push_u64(s, kb);
        s.push_str(" KB");
    }
}

/// Prints a memory snapshot for a single phase boundary.
/// label: phase name (e.g., "After parse")
/// regions: list of (name, region_id) pairs to report on
fn print_mem_phase(label: &str, parse_region: u64, hir_region: u64, codegen_region: u64) {
    let rss_kb = get_rss_kb();
    let sys_live = system_alloc_live_bytes();

    let mut msg = String::new();
    msg.push_str("\n  [mem] ");
    msg.push_str(label);
    msg.push_str("\n");

    // RSS
    msg.push_str("    RSS:              ");
    push_bytes_human(&mut msg, rss_kb * 1024);
    msg.push('\n');

    // System allocator
    msg.push_str("    System heap:      ");
    push_bytes_human(&mut msg, sys_live);
    msg.push('\n');

    // Parse region
    if parse_region != 0 {
        msg.push_str("    parse_region:     used=");
        push_bytes_human(&mut msg, region_used(parse_region) as u64);
        msg.push_str("  committed=");
        push_bytes_human(&mut msg, region_committed(parse_region) as u64);
        msg.push_str("  allocs=");
        push_u64(&mut msg, region_alloc_count(parse_region));
        msg.push('\n');
    }

    // HIR region
    if hir_region != 0 {
        msg.push_str("    hir_region:       used=");
        push_bytes_human(&mut msg, region_used(hir_region) as u64);
        msg.push_str("  committed=");
        push_bytes_human(&mut msg, region_committed(hir_region) as u64);
        msg.push_str("  allocs=");
        push_u64(&mut msg, region_alloc_count(hir_region));
        msg.push('\n');
    }

    // Codegen region
    if codegen_region != 0 {
        msg.push_str("    codegen_region:   used=");
        push_bytes_human(&mut msg, region_used(codegen_region) as u64);
        msg.push_str("  committed=");
        push_bytes_human(&mut msg, region_committed(codegen_region) as u64);
        msg.push_str("  allocs=");
        push_u64(&mut msg, region_alloc_count(codegen_region));
        msg.push('\n');
    }

    // Realloc diagnostics (cumulative since last reset)
    let ra_count = realloc_diag_count();
    let ra_wasted = realloc_diag_wasted();
    let ra_inplace = realloc_diag_inplace();
    let ra_inplace_bytes = realloc_diag_inplace_bytes();
    msg.push_str("    realloc:          count=");
    push_u64(&mut msg, ra_count);
    msg.push_str("  wasted=");
    push_bytes_human(&mut msg, ra_wasted);
    msg.push_str("  inplace_eligible=");
    push_u64(&mut msg, ra_inplace);
    msg.push_str("  inplace_savings=");
    push_bytes_human(&mut msg, ra_inplace_bytes);
    msg.push('\n');
    msg.push_str("    realloc_delta:    offset_saved=");
    push_bytes_human(&mut msg, realloc_diag_offset_delta());
    msg.push('\n');

    eprint_str(msg.as_str());
    print_alloc_hist();
    realloc_stats_reset();
}

// ============================================================
// Streaming Compilation
// ============================================================

/// Compiles a source file using streaming codegen, writing IR directly to output_path.
/// Returns true on success, false on error (errors are printed directly).
///
/// Uses phase-scoped regions to manage memory:
/// - Parse region: holds AST nodes (destroyed after HIR lowering)
/// - HIR region: holds HIR/typeck data (destroyed after codegen)
/// - Per-function MIR regions: hold MIR bodies (destroyed after each function's IR is written)
fn compile_file_streaming(path: &str, output_path: &str, args: &Args) -> bool {
    let compile_start = blood_clock_millis();

    // === Build cache check ===
    let base_dir = source::parent_dir(path);
    let cache_dir = build_cache::ensure_cache_dir(base_dir.as_str());
    let exe_path: &str = args_get(0);
    let source_hash: u64 = if args.no_cache { 0 as u64 } else {
        build_cache::try_cache(base_dir.as_str(), path, exe_path)
    };

    if source_hash != 0 {
        let cached_path = build_cache::cache_ll_path(cache_dir.as_str(), source_hash);
        if file_exists(cached_path.as_str()) {
            // Cache hit — copy cached IR to output
            let cached_content: &str = file_read_to_string(cached_path.as_str());
            file_write_string(output_path, cached_content);
            eprint_str("[CACHE HIT] ");
            eprint_str(output_path);
            eprint_str("\n");
            return true;
        }
    }

    // Phase 1: Read source file and compute base_dir (global allocator — small)
    let read_result = source::read_file(path);
    if !read_result.success {
        print_error("Failed to read source file");
        return false;
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            print_error("No content in file");
            return false;
        }
    };

    // === Parse Phase (parse_region) ===
    // 2 MB initial, 10 GB max — holds AST nodes, tokens, spans.
    // Destroyed after HIR lowering to free AST memory early.
    eprint_str("  Parsing...");
    let parse_start = blood_clock_millis();

    let parse_region = region_create(2097152, 10737418240);
    region_activate(parse_region);

    let parse_result = parser::parse_file(content.as_str());
    let parse_elapsed = blood_clock_millis() - parse_start;
    if parse_result.errors.len() > 0 {
        eprint_str(" FAILED\n");
        print_error("Parse errors:");
        let error_reporter = reporter::ErrorReporter::new(content.as_str(), path);
        let mut i: usize = 0;
        while i < parse_result.errors.len() {
            let diag = &parse_result.errors[i];
            let mut msg = String::new();
            msg.push_str("  ");
            msg.push_str(diag.message.as_str());
            msg.push('\n');
            print_str(msg.as_str());
            i = i + 1;
        }
        region_deactivate();
        region_destroy(parse_region);
        return false;
    }

    let program = match &parse_result.program {
        &Option::Some(ref p) => p,
        &Option::None => {
            eprint_str(" FAILED\n");
            print_error("No program produced by parser");
            region_deactivate();
            region_destroy(parse_region);
            return false;
        }
    };
    eprint_str(" done\n");

    if args.mem_profile {
        print_mem_phase("After parse", parse_region, 0 as u64, 0 as u64);
    }

    // Deactivate parse_region — AST remains readable for HIR lowering.
    region_deactivate();

    // === HIR Lower Phase (hir_region) ===
    // 16 MB initial, 50 GB max — holds HIR items, bodies, types, typeck info.
    eprint_str("  HIR lowering...");
    let hir_start = blood_clock_millis();

    let hir_region = region_create(16777216, 53687091200);
    region_activate(hir_region);

    let lower_result = hir_lower::lower_program_with_base_dir(program, base_dir, content.as_str());
    let hir_elapsed = blood_clock_millis() - hir_start;

    // Check for HIR lowering errors
    let mut has_hir_errors = false;
    let mut di: usize = 0;
    while di < lower_result.diagnostics.len() {
        let diag = &lower_result.diagnostics[di];
        match &diag.level {
            &hir::DiagnosticLevel::Error => {
                has_hir_errors = true;
            }
            &hir::DiagnosticLevel::Warning => {}
            &hir::DiagnosticLevel::Note => {}
            &hir::DiagnosticLevel::Help => {}
        }
        di = di + 1;
    }
    if has_hir_errors {
        eprint_str(" FAILED\n");
        print_error("HIR lowering errors");
        region_deactivate();
        region_destroy(hir_region);
        region_destroy(parse_region);
        return false;
    }
    eprint_str(" done\n");

    if args.mem_profile {
        print_mem_phase("After HIR lowering", parse_region, hir_region, 0 as u64);
    }

    // Trim hir_region to release pages used during lowering but no longer needed
    region_trim(hir_region);

    if args.mem_profile {
        print_mem_phase("After HIR trim", parse_region, hir_region, 0 as u64);
    }

    // Deactivate hir_region temporarily to destroy parse_region
    region_deactivate();

    // AST no longer needed — free parse memory early (before type checking)
    region_destroy(parse_region);

    if args.mem_profile {
        print_mem_phase("After parse_region destroy", 0 as u64, hir_region, 0 as u64);
    }

    // === Type Check Phase (hir_region) ===
    eprint_str("  Type checking...");
    let typeck_start = blood_clock_millis();

    region_activate(hir_region);

    let typeck_result = typeck_driver::check_lower_result(&lower_result);
    let typeck_elapsed = blood_clock_millis() - typeck_start;
    if !typeck_result.success {
        eprint_str(" FAILED\n");
        let mut ti: usize = 0;
        while ti < typeck_result.errors.len() {
            let err = &typeck_result.errors[ti];
            let mut msg = String::new();
            msg.push_str("type error at line ");
            push_usize(&mut msg, err.span.line as usize);
            msg.push('\n');
            print_str(msg.as_str());
            ti = ti + 1;
        }
        region_deactivate();
        region_destroy(hir_region);
        return false;
    }
    eprint_str(" done\n");

    if args.mem_profile {
        print_mem_phase("After type checking", 0 as u64, hir_region, 0 as u64);
    }

    // Dump type resolutions if requested
    if args.dump_types {
        dump_type_resolutions(&typeck_result);
    }

    // Trim hir_region after type checking — release pages from typeck temporaries
    region_trim(hir_region);

    if args.mem_profile {
        print_mem_phase("After typeck trim", 0 as u64, hir_region, 0 as u64);
    }

    // Deactivate hir_region — data remains readable for codegen.
    // New allocations (codegen ctx, def_names) go to global allocator.
    region_deactivate();

    // Phase 5: Streaming codegen (global allocator for ctx persistent state)
    eprint_str("  Codegen...");
    let codegen_start = blood_clock_millis();

    eprint_str("[begin_streaming]");
    let mut ctx = codegen_streaming::begin_streaming_module("main", output_path, &lower_result.items);
    ctx.trace_codegen = args.trace_codegen;
    eprint_str("[done]");

    // Register builtin ADT types (Vec, String, HashMap, Box) in the ADT registry
    eprint_str("[register_adts]");
    codegen::register_builtin_adts(
        &mut ctx,
        &lower_result.builtin_vec_def,
        &lower_result.builtin_string_def,
        &lower_result.builtin_hashmap_def,
        &lower_result.builtin_box_def,
    );
    eprint_str("[populate_adt]");
    codegen::populate_adt_registry(&mut ctx, &lower_result.items);
    eprint_str("[done]");

    // Dump ADT layouts if requested (after registry is fully populated)
    if args.dump_layouts {
        dump_adt_layouts(&ctx);
    }

    eprint_str("[statics]");
    // Collect static DefIds first - needed for name registration filtering.
    let mut static_def_ids: Vec<u32> = Vec::new();
    let mut si: usize = 0;
    while si < lower_result.items.len() {
        let item = &lower_result.items[si].item;
        match &item.kind {
            &hir_item::ItemKind::Static(ref _static_def) => {
                static_def_ids.push(item.def_id.index);
            }
            _ => {}
        }
        si = si + 1;
    }

    // Pass 0: Emit static global variable declarations.
    // This must happen before any functions that reference statics.
    // Also registers static names in ctx using the interner.
    codegen_streaming::emit_static_globals_with_names(&mut ctx, &lower_result.interner, &lower_result.items);
    eprint_str("[pass0_done]");

    // Pass 1a: Register def_names for all function bodies (global allocator)
    // SKIP static bodies - their names are already registered by emit_static_globals_with_names
    let mut body_idx: usize = 0;
    while body_idx < lower_result.bodies.len() {
        let body_entry = &lower_result.bodies[body_idx];
        let body_id = body_entry.body_id;
        let fn_info = driver::find_fn_for_body(&lower_result.items, body_id);
        let def_id = match &fn_info {
            &Option::Some(ref info) => info.def_id.index,
            &Option::None => body_idx as u32,
        };
        // Skip static bodies
        let mut is_static = false;
        let mut sbi: usize = 0;
        while sbi < static_def_ids.len() {
            if static_def_ids[sbi] == def_id {
                is_static = true;
                sbi = static_def_ids.len();
            }
            sbi = sbi + 1;
        }
        if !is_static {
            let fn_name = match &fn_info {
                &Option::Some(ref info) => make_mangled_fn_name(&lower_result.interner, info),
                &Option::None => driver::make_fn_name(body_idx),
            };
            ctx.register_def_name(def_id, fn_name);
        }
        body_idx = body_idx + 1;
    }

    // Pass 1b: Register def_names for ALL function-like items (including those without bodies).
    // This ensures that calls to foreign/builtin functions resolve to the correct name.
    register_all_item_names(&mut ctx, &lower_result.interner, &lower_result.items);
    eprint_str("[pass1_done]");

    // Pass 1c: Register def_names for builtin constructors (String::new, Vec::new, etc.).
    // These DefIds are allocated by the HIR lowering and map to runtime function names.
    let mut bfi: usize = 0;
    while bfi < lower_result.builtin_fn_defs.len() {
        let entry = &lower_result.builtin_fn_defs[bfi];
        ctx.register_def_name(entry.def_id_index, clone_string(&entry.runtime_name));
        bfi = bfi + 1;
    }

    // Pass 1e: Register def_names for enum variant constructors.
    // Enum variants have their own DefIds used when constructing variants (e.g., TokenKind::Ident(...)).
    register_enum_variant_names(&mut ctx, &lower_result.interner, &lower_result.items);

    // Pass 1d: Register def_names for synthetic builtin methods (String::push_str, Vec::push, etc.).
    // These DefIds are allocated by the type checker and map to runtime function names.
    let mut bi: usize = 0;
    while bi < typeck_result.builtin_def_names.len() {
        let entry = &typeck_result.builtin_def_names[bi];
        ctx.register_def_name(entry.def_id_index, clone_string(&entry.runtime_name));
        bi = bi + 1;
    }

    // Collect handler→effect mappings and handler op info for wrapper generation.
    let handler_info = collect_handler_info(&mut ctx, &lower_result.interner, &lower_result.items, &lower_result.bodies);

    // Register handler op body DefIds for state-by-pointer codegen.
    let mut hop_i: usize = 0;
    while hop_i < handler_info.ops.len() {
        ctx.register_handler_op_body(handler_info.ops[hop_i].body_def_id);
        hop_i = hop_i + 1;
    }

    // Build work list: scan bodies once to identify which functions to codegen.
    // Filters out static bodies and duplicates from generic instantiations.
    let worklist = build_codegen_worklist(&lower_result, &static_def_ids);
    eprint_str("[worklist:");
    eprint_str(int_to_string(worklist.items.len() as i32));
    eprint_str("]");

    if args.mem_profile {
        print_mem_phase("Before codegen pass2", 0 as u64, hir_region, 0 as u64);
    }

    // Codegen region: holds all codegen temporaries, string_table growth, etc.
    // Persists across all function compilations. Per-function mir_regions sit
    // on top for MIR lowering, then pop so codegen uses this region.
    // 32 MB initial, 8 GB max — codegen produces ~50-100 MB of IR + metadata.
    let codegen_region = region_create(33554432, 8589934592);
    region_activate(codegen_region);

    // Pass 2: MIR lowering + codegen, writing each function's IR directly to file.
    ctx.flush_write_buffer();
    eprint_str("[pass2_start]");
    let _pass2_ok = codegen_pass2(&mut ctx, &worklist, &lower_result, &typeck_result, output_path, args);
    eprint_str("[pass2_done]");

    if args.mem_profile {
        print_mem_phase("After codegen pass2", 0 as u64, hir_region, codegen_region);
    }

    // Pass 3: Generate stub functions for registered names without bodies.
    // These are enum variant constructors and other synthetic functions that are
    // referenced as function pointers but don't have HIR bodies.
    generate_missing_stubs(&mut ctx, &worklist.defined_names);

    // Pass 4: Generate handler op wrapper functions and __blood_register_handlers.
    // These wrappers adapt the inner handler op bodies to the standard ABI
    // expected by the evidence API runtime (ptr state, ptr args, i64 arg_count, i64 cont) -> i64.
    let handler_wrapper_ir = generate_handler_wrappers(&handler_info, &ctx);
    ctx.buffer_write(handler_wrapper_ir.as_str());

    // Emit inline handler stub functions collected during PushInlineHandler codegen.
    let mut stub_i: usize = 0;
    while stub_i < ctx.inline_stubs.len() {
        let stub_ir = clone_string(&ctx.inline_stubs[stub_i]);
        ctx.buffer_write(stub_ir.as_str());
        stub_i = stub_i + 1;
    }

    // Finish: write string constants and intrinsic declarations
    codegen_streaming::finish_streaming_module(&mut ctx);

    // Write foreign function declarations (runtime builtins)
    let foreign_decls = generate_foreign_declarations(&lower_result.interner, &lower_result.items);
    ctx.buffer_write(foreign_decls.as_str());

    // Final flush: write any remaining buffered IR to disk
    ctx.flush_write_buffer();
    let codegen_elapsed = blood_clock_millis() - codegen_start;
    eprint_str(" done\n");

    if args.mem_profile {
        print_mem_phase("After codegen complete", 0 as u64, hir_region, codegen_region);
    }

    // Free codegen temporaries and ctx growth
    region_deactivate();
    region_destroy(codegen_region);

    // HIR/typeck data no longer needed — free hir_region
    region_destroy(hir_region);

    if args.mem_profile {
        print_mem_phase("After all regions destroyed", 0 as u64, 0 as u64, 0 as u64);
    }

    // === Store in cache ===
    if source_hash != 0 {
        let cached_path = build_cache::cache_ll_path(cache_dir.as_str(), source_hash);
        let compiled_ir: &str = file_read_to_string(output_path);
        file_write_string(cached_path.as_str(), compiled_ir);
    }

    let compile_elapsed = blood_clock_millis() - compile_start;

    // Print timing summary if requested
    if args.timings {
        print_str("\nTimings:\n");
        print_str("  Parse                ");
        print_timing_ms(parse_elapsed);
        print_str("  HIR lowering         ");
        print_timing_ms(hir_elapsed);
        print_str("  Type checking        ");
        print_timing_ms(typeck_elapsed);
        print_str("  Codegen              ");
        print_timing_ms(codegen_elapsed);
        print_str("  ─────────────────────────\n");
        print_str("  Compiler total       ");
        print_timing_ms(compile_elapsed);
    }

    true
}

// ============================================================
// Debug Dump: Type Resolutions
// ============================================================

/// Dumps type/field/method resolution tables to stderr.
fn dump_type_resolutions(typeck_result: &typeck_driver::TypeCheckResult) {
    // Field resolutions
    eprint_str("=== Field Resolutions (");
    let mut field_count_str = String::new();
    push_usize(&mut field_count_str, typeck_result.field_resolutions.len());
    eprint_str(field_count_str.as_str());
    eprint_str(" entries) ===\n");
    let mut fi: usize = 0;
    while fi < typeck_result.field_resolutions.len() {
        let entry = &typeck_result.field_resolutions[fi];
        let mut line = String::new();
        line.push_str("  field[body=d");
        push_usize(&mut line, entry.body_def_id as usize);
        line.push_str(", span=");
        push_usize(&mut line, entry.span_start);
        line.push_str("] -> idx ");
        push_usize(&mut line, entry.field_idx as usize);
        line.push('\n');
        eprint_str(line.as_str());
        fi = fi + 1;
    }

    // Method resolutions
    eprint_str("=== Method Resolutions (");
    let mut meth_count_str = String::new();
    push_usize(&mut meth_count_str, typeck_result.method_resolutions.len());
    eprint_str(meth_count_str.as_str());
    eprint_str(" entries) ===\n");
    let mut mi: usize = 0;
    while mi < typeck_result.method_resolutions.len() {
        let entry = &typeck_result.method_resolutions[mi];
        let mut line = String::new();
        line.push_str("  method[body=d");
        push_usize(&mut line, entry.body_def_id as usize);
        line.push_str(", span=");
        push_usize(&mut line, entry.span_start);
        line.push_str("] -> def");
        push_usize(&mut line, entry.def_id_index as usize);
        line.push('\n');
        eprint_str(line.as_str());
        mi = mi + 1;
    }

    // Type variable substitutions
    eprint_str("=== Type Variable Substitutions (");
    let mut tv_count_str = String::new();
    push_usize(&mut tv_count_str, typeck_result.subst_table.ty_substs.len());
    eprint_str(tv_count_str.as_str());
    eprint_str(" entries) ===\n");
    let mut ti: usize = 0;
    while ti < typeck_result.subst_table.ty_substs.len() {
        let subst = &typeck_result.subst_table.ty_substs[ti];
        let mut line = String::new();
        line.push_str("  ?");
        push_usize(&mut line, subst.var_id.index as usize);
        line.push_str(" -> ");
        let type_ty = type_intern::ty_id_to_type(subst.ty);
        let type_str = dump_mir::format_type(&type_ty);
        line.push_str(type_str.as_str());
        line.push('\n');
        eprint_str(line.as_str());
        ti = ti + 1;
    }

    // Builtin def names
    eprint_str("=== Builtin Def Names (");
    let mut bdn_count_str = String::new();
    push_usize(&mut bdn_count_str, typeck_result.builtin_def_names.len());
    eprint_str(bdn_count_str.as_str());
    eprint_str(" entries) ===\n");
    let mut bi: usize = 0;
    while bi < typeck_result.builtin_def_names.len() {
        let entry = &typeck_result.builtin_def_names[bi];
        let mut line = String::new();
        line.push_str("  def");
        push_usize(&mut line, entry.def_id_index as usize);
        line.push_str(" -> ");
        line.push_str(entry.runtime_name.as_str());
        line.push('\n');
        eprint_str(line.as_str());
        bi = bi + 1;
    }
}

/// Dumps ADT layouts (struct/enum sizes, fields, variant layouts) to stderr.
fn dump_adt_layouts(ctx: &codegen_ctx::CodegenCtx) {
    eprint_str("=== ADT Layouts (");
    let mut count_str = String::new();
    push_usize(&mut count_str, ctx.adt_registry.len());
    eprint_str(count_str.as_str());
    eprint_str(" entries) ===\n");

    let mut i: usize = 0;
    while i < ctx.adt_registry.len() {
        match &ctx.adt_registry[i] {
            &codegen_ctx::AdtEntry::Struct(ref layout) => {
                let total_size = codegen_size::llvm_type_size(layout.llvm_type.as_str());
                // Header: struct defN: SIZE bytes
                let mut line = String::new();
                line.push_str("  struct def");
                push_usize(&mut line, layout.def_id as usize);
                // Try to resolve the name
                match ctx.lookup_def_name(layout.def_id) {
                    Option::Some(ref name) => {
                        line.push_str(" (");
                        line.push_str(name.as_str());
                        line.push(')');
                    }
                    Option::None => {}
                }
                line.push_str(": ");
                push_u64(&mut line, total_size);
                line.push_str(" bytes, llvm ");
                line.push_str(layout.llvm_type.as_str());
                line.push('\n');
                eprint_str(line.as_str());

                // Fields
                let mut fi: usize = 0;
                while fi < layout.fields.len() {
                    let field = &layout.fields[fi];
                    let field_size = codegen_size::llvm_type_size(field.llvm_type.as_str());
                    let mut fline = String::new();
                    fline.push_str("      field ");
                    push_usize(&mut fline, fi);
                    fline.push_str(": ");
                    fline.push_str(field.llvm_type.as_str());
                    fline.push_str(" (");
                    push_u64(&mut fline, field_size);
                    fline.push_str(" bytes)");
                    match &field.hir_type {
                        &Option::Some(ty_id) => {
                            let ty = type_intern::ty_id_to_type(ty_id);
                            fline.push_str("  // ");
                            let type_str = dump_mir::format_type(&ty);
                            fline.push_str(type_str.as_str());
                        }
                        &Option::None => {}
                    }
                    fline.push('\n');
                    eprint_str(fline.as_str());
                    fi = fi + 1;
                }
            }
            &codegen_ctx::AdtEntry::Enum(ref layout) => {
                let total_size = codegen_size::llvm_type_size(layout.llvm_type.as_str());
                let disc_size = codegen_size::llvm_type_size(layout.discriminant_type.as_str());
                // Header: enum defN: SIZE bytes
                let mut line = String::new();
                line.push_str("  enum def");
                push_usize(&mut line, layout.def_id as usize);
                match ctx.lookup_def_name(layout.def_id) {
                    Option::Some(ref name) => {
                        line.push_str(" (");
                        line.push_str(name.as_str());
                        line.push(')');
                    }
                    Option::None => {}
                }
                line.push_str(": ");
                push_u64(&mut line, total_size);
                line.push_str(" bytes, llvm ");
                line.push_str(layout.llvm_type.as_str());
                line.push('\n');
                eprint_str(line.as_str());

                // Discriminant
                let mut dline = String::new();
                dline.push_str("      discriminant: ");
                dline.push_str(layout.discriminant_type.as_str());
                dline.push_str(" (");
                push_u64(&mut dline, disc_size);
                dline.push_str(" bytes)\n");
                eprint_str(dline.as_str());

                // Max payload
                let mut pline = String::new();
                pline.push_str("      max_payload: ");
                push_u64(&mut pline, layout.max_payload_size);
                pline.push_str(" bytes\n");
                eprint_str(pline.as_str());

                // Variants
                let mut vi: usize = 0;
                while vi < layout.variants.len() {
                    let variant = &layout.variants[vi];
                    let mut vline = String::new();
                    vline.push_str("      variant ");
                    push_usize(&mut vline, variant.variant_idx as usize);
                    vline.push_str(": payload ");
                    vline.push_str(variant.payload_llvm_type.as_str());
                    let vsize = codegen_size::llvm_type_size(variant.payload_llvm_type.as_str());
                    vline.push_str(" (");
                    push_u64(&mut vline, vsize);
                    vline.push_str(" bytes)\n");
                    eprint_str(vline.as_str());

                    // Variant fields
                    let mut vfi: usize = 0;
                    while vfi < variant.fields.len() {
                        let field = &variant.fields[vfi];
                        let field_size = codegen_size::llvm_type_size(field.llvm_type.as_str());
                        let mut fline = String::new();
                        fline.push_str("          field ");
                        push_usize(&mut fline, vfi);
                        fline.push_str(": ");
                        fline.push_str(field.llvm_type.as_str());
                        fline.push_str(" (");
                        push_u64(&mut fline, field_size);
                        fline.push_str(" bytes)");
                        match &field.hir_type {
                            &Option::Some(ty_id) => {
                                let ty = type_intern::ty_id_to_type(ty_id);
                                fline.push_str("  // ");
                                let type_str = dump_mir::format_type(&ty);
                                fline.push_str(type_str.as_str());
                            }
                            &Option::None => {}
                        }
                        fline.push('\n');
                        eprint_str(fline.as_str());
                        vfi = vfi + 1;
                    }
                    vi = vi + 1;
                }
            }
        }
        i = i + 1;
    }
}

/// Formats and prints a millisecond timing value with right-aligned ms suffix.
fn print_timing_ms(ms: u64) {
    let mut buf = String::new();
    push_u64(&mut buf, ms);
    buf.push_str("ms\n");
    print_str(buf.as_str());
}

/// Pushes a u64 value with comma separators into a string.
fn push_u64(s: &mut String, val: u64) {
    if val == 0 {
        s.push('0');
        return;
    }
    // Build digits in reverse
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    // Push in reverse order with comma separators
    let len = digits.len();
    let mut i = len;
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
        let pos_from_right = i;
        if pos_from_right > 0 && pos_from_right % 3 == 0 {
            s.push(',');
        }
    }
}

/// Pushes a usize as decimal digits into a string.
fn push_usize(s: &mut String, val: usize) {
    if val == 0 {
        s.push('0');
        return;
    }
    // Build digits in reverse
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    // Push in reverse order
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}
