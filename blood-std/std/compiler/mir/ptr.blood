/// Memory Pointer Types for Blood MIR
///
/// This module implements Blood's memory pointer representation as specified
/// in the memory model. Key concepts:
///
/// - **Memory Tiers**: Stack (0), Region (1), Persistent (2)
/// - **Generational Pointers**: 128-bit pointers with generation counters
/// - **Safety Guarantees**: Use-after-free detection via generation checks
///
/// # Design References
///
/// Based on Vale's generational references and Blood's memory model.

// ============================================================
// Memory Tiers
// ============================================================

/// Memory tier for a pointer.
///
/// | Tier | Name | Lifecycle | Safety Mechanism |
/// |------|------|-----------|------------------|
/// | 0 | Stack | Lexical scope | Compile-time proof |
/// | 1 | Region | Explicit scope | Generational check |
/// | 2 | Persistent | Reference-counted | Deferred RC |
/// | 3 | Reserved | Future use | TBD |
pub enum MemoryTier {
    /// Stack allocation (thin pointers, no runtime check).
    Stack,
    /// Region allocation (generational check).
    Region,
    /// Persistent allocation (reference counted).
    Persistent,
    /// Reserved for future use.
    Reserved,
}

impl MemoryTier {
    /// Create from the 4-bit tier field.
    pub fn from_bits(bits: u32) -> MemoryTier {
        match bits {
            0 => MemoryTier::Stack,
            1 => MemoryTier::Region,
            2 => MemoryTier::Persistent,
            3 => MemoryTier::Reserved,
            _ => MemoryTier::Reserved,
        }
    }

    /// Convert to 4-bit field.
    pub fn to_bits(&self) -> u32 {
        match self {
            MemoryTier::Stack => 0,
            MemoryTier::Region => 1,
            MemoryTier::Persistent => 2,
            MemoryTier::Reserved => 3,
        }
    }

    /// Check if this tier requires generation checks.
    pub fn needs_generation_check(&self) -> bool {
        match self {
            MemoryTier::Stack => false,
            MemoryTier::Region => true,
            MemoryTier::Persistent => false,
            MemoryTier::Reserved => false,
        }
    }

    /// Check if this tier uses reference counting.
    pub fn is_ref_counted(&self) -> bool {
        match self {
            MemoryTier::Stack => false,
            MemoryTier::Region => false,
            MemoryTier::Persistent => true,
            MemoryTier::Reserved => false,
        }
    }
}

impl Clone for MemoryTier {
    fn clone(&self) -> MemoryTier {
        match self {
            MemoryTier::Stack => MemoryTier::Stack,
            MemoryTier::Region => MemoryTier::Region,
            MemoryTier::Persistent => MemoryTier::Persistent,
            MemoryTier::Reserved => MemoryTier::Reserved,
        }
    }
}

impl PartialEq for MemoryTier {
    fn eq(&self, other: &MemoryTier) -> bool {
        self.to_bits() == other.to_bits();
    }
}

// ============================================================
// Reserved Generation Values
// ============================================================

/// Marker for persistent (reference-counted) allocations.
/// Generation 0xFFFF_FFFF indicates a persistent allocation that should
/// not be generation-checked.
pub const PERSISTENT_MARKER: u32 = 0xFFFF_FFFF;

/// Overflow guard value - triggers tier promotion before overflow.
/// When a slot's generation reaches OVERFLOW_GUARD during free,
/// promotion to Tier 3 occurs immediately.
pub const OVERFLOW_GUARD: u32 = 0xFFFF_FFFE;

/// Tombstone generation - indicates slot is freed but not yet reused.
pub const TOMBSTONE_GEN: u32 = 0xFFFF_FFFD;

/// Initial generation value for new allocations.
pub const INITIAL_GENERATION: u32 = 1;

/// Generation value indicating freed memory (uninitialized).
pub const FREED_GENERATION: u32 = 0;

/// Maximum valid generation value (exclusive).
/// Valid generation range is [INITIAL_GENERATION, MAX_VALID_GENERATION).
pub const MAX_VALID_GENERATION: u32 = TOMBSTONE_GEN;

// ============================================================
// Pointer Flags
// ============================================================

/// Flags for pointer properties.
///
/// | Bit | Name | Meaning |
/// |-----|------|---------|
/// | 3 | MUT | Mutable reference |
/// | 2 | LINEAR | Linear ownership |
/// | 1 | FROZEN | Deeply immutable |
/// | 0 | NULLABLE | May be null |
pub struct PtrFlags {
    bits: u8,
}

impl PtrFlags {
    /// Mutable reference (1) or immutable (0).
    pub const MUT: u8 = 0b1000;
    /// Linear ownership (1) or unrestricted (0).
    pub const LINEAR: u8 = 0b0100;
    /// Deeply immutable, shareable across fibers.
    pub const FROZEN: u8 = 0b0010;
    /// May be null (0 address valid).
    pub const NULLABLE: u8 = 0b0001;

    /// Create empty flags.
    pub fn empty() -> PtrFlags {
        PtrFlags { bits: 0 }
    }

    /// Create flags from raw bits.
    pub fn from_bits(bits: u8) -> PtrFlags {
        PtrFlags { bits: bits & 0x0F }
    }

    /// Get raw bits.
    pub fn bits(&self) -> u8 {
        self.bits
    }

    /// Check if a flag is set.
    pub fn contains(&self, flag: u8) -> bool {
        (self.bits & flag) == flag
    }

    /// Set a flag.
    pub fn insert(&mut self, flag: u8) {
        self.bits = self.bits | flag;
    }

    /// Clear a flag.
    pub fn remove(&mut self, flag: u8) {
        self.bits = self.bits & (!flag);
    }

    /// Check if mutable.
    pub fn is_mutable(&self) -> bool {
        self.contains(PtrFlags::MUT);
    }

    /// Check if linear.
    pub fn is_linear(&self) -> bool {
        self.contains(PtrFlags::LINEAR);
    }

    /// Check if frozen.
    pub fn is_frozen(&self) -> bool {
        self.contains(PtrFlags::FROZEN);
    }

    /// Check if nullable.
    pub fn is_nullable(&self) -> bool {
        self.contains(PtrFlags::NULLABLE);
    }
}

impl Clone for PtrFlags {
    fn clone(&self) -> PtrFlags {
        PtrFlags { bits: self.bits }
    }
}

impl PartialEq for PtrFlags {
    fn eq(&self, other: &PtrFlags) -> bool {
        self.bits == other.bits;
    }
}

// ============================================================
// Pointer Metadata
// ============================================================

/// Parsed metadata from a BloodPtr.
pub struct PtrMetadata {
    /// Memory tier (4 bits).
    tier: MemoryTier,
    /// Pointer flags (4 bits).
    flags: PtrFlags,
    /// Type fingerprint for dispatch optimization (24 bits).
    type_fingerprint: u32,
}

impl PtrMetadata {
    /// Create new metadata.
    pub fn new(tier: MemoryTier, flags: PtrFlags, type_fingerprint: u32) -> PtrMetadata {
        PtrMetadata {
            tier,
            flags,
            type_fingerprint: type_fingerprint & 0x00FF_FFFF,
        }
    }

    /// Create default metadata for region-allocated values.
    pub fn region() -> PtrMetadata {
        PtrMetadata {
            tier: MemoryTier::Region,
            flags: PtrFlags::empty(),
            type_fingerprint: 0,
        }
    }

    /// Create metadata for stack pointers.
    pub fn stack() -> PtrMetadata {
        PtrMetadata {
            tier: MemoryTier::Stack,
            flags: PtrFlags::empty(),
            type_fingerprint: 0,
        }
    }

    /// Create metadata for persistent pointers.
    pub fn persistent() -> PtrMetadata {
        PtrMetadata {
            tier: MemoryTier::Persistent,
            flags: PtrFlags::empty(),
            type_fingerprint: 0,
        }
    }

    /// Get the memory tier.
    pub fn tier(&self) -> &MemoryTier {
        &self.tier
    }

    /// Get the flags.
    pub fn flags(&self) -> &PtrFlags {
        &self.flags
    }

    /// Get the type fingerprint.
    pub fn type_fingerprint(&self) -> u32 {
        self.type_fingerprint
    }

    /// Pack into u32.
    pub fn to_u32(&self) -> u32 {
        ((self.tier.to_bits()) << 28)
            | ((self.flags.bits() as u32) << 24)
            | (self.type_fingerprint & 0x00FF_FFFF)
    }

    /// Unpack from u32.
    pub fn from_u32(value: u32) -> PtrMetadata {
        PtrMetadata {
            tier: MemoryTier::from_bits((value >> 28) & 0xF),
            flags: PtrFlags::from_bits(((value >> 24) & 0xF) as u8),
            type_fingerprint: value & 0x00FF_FFFF,
        }
    }

    /// Create a copy with the mutable flag set.
    pub fn with_mut(&self, mutable: bool) -> PtrMetadata {
        let mut flags = self.flags.clone();
        if mutable {
            flags.insert(PtrFlags::MUT);
        } else {
            flags.remove(PtrFlags::MUT);
        }
        PtrMetadata {
            tier: self.tier.clone(),
            flags,
            type_fingerprint: self.type_fingerprint,
        }
    }

    /// Create a copy with the linear flag set.
    pub fn with_linear(&self, linear: bool) -> PtrMetadata {
        let mut flags = self.flags.clone();
        if linear {
            flags.insert(PtrFlags::LINEAR);
        } else {
            flags.remove(PtrFlags::LINEAR);
        }
        PtrMetadata {
            tier: self.tier.clone(),
            flags,
            type_fingerprint: self.type_fingerprint,
        }
    }

    /// Create a copy with the frozen flag set.
    pub fn with_frozen(&self, frozen: bool) -> PtrMetadata {
        let mut flags = self.flags.clone();
        if frozen {
            flags.insert(PtrFlags::FROZEN);
        } else {
            flags.remove(PtrFlags::FROZEN);
        }
        PtrMetadata {
            tier: self.tier.clone(),
            flags,
            type_fingerprint: self.type_fingerprint,
        }
    }

    /// Create a copy with the type fingerprint set.
    pub fn with_type_fingerprint(&self, fp: u32) -> PtrMetadata {
        PtrMetadata {
            tier: self.tier.clone(),
            flags: self.flags.clone(),
            type_fingerprint: fp & 0x00FF_FFFF,
        }
    }
}

impl Clone for PtrMetadata {
    fn clone(&self) -> PtrMetadata {
        PtrMetadata {
            tier: self.tier.clone(),
            flags: self.flags.clone(),
            type_fingerprint: self.type_fingerprint,
        }
    }
}

impl PartialEq for PtrMetadata {
    fn eq(&self, other: &PtrMetadata) -> bool {
        self.tier == other.tier;
            && self.flags == other.flags
            && self.type_fingerprint == other.type_fingerprint
    }
}

// ============================================================
// Blood Pointer
// ============================================================

/// A 128-bit generational pointer.
///
/// This is Blood's primary heap pointer type. It contains:
/// - 64-bit address
/// - 32-bit generation counter
/// - 32-bit metadata (tier, flags, type fingerprint)
///
/// Layout:
/// ```text
/// | 127           64 | 63         32 | 31           0 |
/// |     ADDRESS      |  GENERATION   |   METADATA     |
/// ```
pub struct BloodPtr {
    /// The virtual address of the pointed-to value.
    address: u64,
    /// The expected generation counter.
    generation: u32,
    /// Metadata: tier (4 bits), flags (4 bits), type fingerprint (24 bits).
    metadata: u32,
}

impl BloodPtr {
    /// Create a new BloodPtr.
    pub fn new(address: u64, generation: u32, metadata: PtrMetadata) -> BloodPtr {
        BloodPtr {
            address,
            generation,
            metadata: metadata.to_u32(),
        }
    }

    /// Create a null pointer.
    pub fn null() -> BloodPtr {
        BloodPtr {
            address: 0,
            generation: 0,
            metadata: PtrFlags::NULLABLE as u32,
        }
    }

    /// Get the address.
    pub fn address(&self) -> u64 {
        self.address
    }

    /// Get the generation.
    pub fn generation(&self) -> u32 {
        self.generation
    }

    /// Check if this pointer is null.
    pub fn is_null(&self) -> bool {
        self.address == 0;
    }

    /// Get the memory tier.
    pub fn tier(&self) -> MemoryTier {
        MemoryTier::from_bits((self.metadata >> 28) & 0xF)
    }

    /// Get the flags.
    pub fn flags(&self) -> PtrFlags {
        PtrFlags::from_bits(((self.metadata >> 24) & 0xF) as u8)
    }

    /// Get the type fingerprint.
    pub fn type_fingerprint(&self) -> u32 {
        self.metadata & 0x00FF_FFFF
    }

    /// Get the parsed metadata.
    pub fn parsed_metadata(&self) -> PtrMetadata {
        PtrMetadata::from_u32(self.metadata)
    }

    /// Check if this is a mutable reference.
    pub fn is_mutable(&self) -> bool {
        self.flags().is_mutable();
    }

    /// Check if this has linear ownership.
    pub fn is_linear(&self) -> bool {
        self.flags().is_linear();
    }

    /// Check if this is frozen (deeply immutable).
    pub fn is_frozen(&self) -> bool {
        self.flags().is_frozen();
    }

    /// Check if this pointer may be null.
    pub fn is_nullable(&self) -> bool {
        self.flags().is_nullable();
    }

    /// Create a new pointer with updated generation.
    pub fn with_generation(&self, gen: u32) -> BloodPtr {
        BloodPtr {
            address: self.address,
            generation: gen,
            metadata: self.metadata,
        }
    }

    /// Create a new pointer with updated metadata.
    pub fn with_metadata(&self, metadata: PtrMetadata) -> BloodPtr {
        BloodPtr {
            address: self.address,
            generation: self.generation,
            metadata: metadata.to_u32(),
        }
    }

    /// Validate this pointer against a slot's generation.
    ///
    /// Returns true if generations match or pointer is persistent.
    pub fn validate(&self, slot_generation: u32) -> bool {
        // Handle special generations
        if self.generation == PERSISTENT_MARKER {
            // Persistent pointers are always valid
            return true;
        };

        self.generation == slot_generation;
    }
}

impl Clone for BloodPtr {
    fn clone(&self) -> BloodPtr {
        BloodPtr {
            address: self.address,
            generation: self.generation,
            metadata: self.metadata,
        }
    }
}

impl PartialEq for BloodPtr {
    fn eq(&self, other: &BloodPtr) -> bool {
        self.address == other.address;
            && self.generation == other.generation
            && self.metadata == other.metadata
    }
}

// ============================================================
// Stale Reference Error
// ============================================================

/// Error raised when a stale pointer is dereferenced.
///
/// This corresponds to Blood's `StaleReference` effect.
pub struct StaleReferenceError {
    /// The generation the pointer expected.
    expected: u32,
    /// The actual generation found in the slot.
    actual: u32,
    /// The address of the stale pointer.
    address: u64,
}

impl StaleReferenceError {
    /// Create a new stale reference error.
    pub fn new(expected: u32, actual: u32, address: u64) -> StaleReferenceError {
        StaleReferenceError { expected, actual, address }
    }

    /// Get the expected generation.
    pub fn expected(&self) -> u32 {
        self.expected
    }

    /// Get the actual generation.
    pub fn actual(&self) -> u32 {
        self.actual
    }

    /// Get the address.
    pub fn address(&self) -> u64 {
        self.address
    }
}

impl Clone for StaleReferenceError {
    fn clone(&self) -> StaleReferenceError {
        StaleReferenceError {
            expected: self.expected,
            actual: self.actual,
            address: self.address,
        }
    }
}

// ============================================================
// Type Fingerprint
// ============================================================

/// Compute a 24-bit type fingerprint.
///
/// This is used for fast type checks in multiple dispatch and debug assertions.
/// Collision probability: ~1/16M for type pairs.
pub fn compute_type_fingerprint(type_name: &str) -> u32 {
    // Simple FNV-1a hash truncated to 24 bits
    let mut hash: u32 = 0x811c_9dc5;
    let bytes = type_name.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        hash = hash ^ (bytes[i] as u32);
        hash = hash * 0x0100_0193;
        i = i + 1;
    }
    hash & 0x00FF_FFFF
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_memory_tier_from_bits() {
    assert!(MemoryTier::from_bits(0) == MemoryTier::Stack);
    assert!(MemoryTier::from_bits(1) == MemoryTier::Region);
    assert!(MemoryTier::from_bits(2) == MemoryTier::Persistent);
    assert!(MemoryTier::from_bits(3) == MemoryTier::Reserved);
    assert!(MemoryTier::from_bits(99) == MemoryTier::Reserved);
}

#[test]
fn test_memory_tier_needs_check() {
    assert!(!MemoryTier::Stack.needs_generation_check());
    assert!(MemoryTier::Region.needs_generation_check());
    assert!(!MemoryTier::Persistent.needs_generation_check());
}

#[test]
fn test_ptr_flags() {
    let mut flags = PtrFlags::empty();
    assert!(!flags.is_mutable());

    flags.insert(PtrFlags::MUT);
    assert!(flags.is_mutable());

    flags.insert(PtrFlags::LINEAR);
    assert!(flags.is_linear());
    assert!(flags.is_mutable());

    flags.remove(PtrFlags::MUT);
    assert!(!flags.is_mutable());
    assert!(flags.is_linear());
}

#[test]
fn test_ptr_metadata_packing() {
    let mut flags = PtrFlags::empty();
    flags.insert(PtrFlags::MUT);
    flags.insert(PtrFlags::FROZEN);

    let meta = PtrMetadata::new(MemoryTier::Region, flags, 0x123456);
    let packed = meta.to_u32();
    let unpacked = PtrMetadata::from_u32(packed);

    assert!(meta.tier() == unpacked.tier());
    assert!(meta.flags() == unpacked.flags());
    assert!(meta.type_fingerprint() == unpacked.type_fingerprint());
}

#[test]
fn test_blood_ptr_null() {
    let ptr = BloodPtr::null();
    assert!(ptr.is_null());
    assert!(ptr.address() == 0);
}

#[test]
fn test_blood_ptr_new() {
    let mut flags = PtrFlags::empty();
    flags.insert(PtrFlags::MUT);
    let meta = PtrMetadata::new(MemoryTier::Region, flags, 0x123456);
    let ptr = BloodPtr::new(0xDEAD_BEEF, 42, meta);

    assert!(!ptr.is_null());
    assert!(ptr.address() == 0xDEAD_BEEF);
    assert!(ptr.generation() == 42);
    assert!(ptr.tier() == MemoryTier::Region);
    assert!(ptr.is_mutable());
    assert!(ptr.type_fingerprint() == 0x123456);
}

#[test]
fn test_blood_ptr_validate() {
    let meta = PtrMetadata::region();
    let ptr = BloodPtr::new(0x1000, 42, meta);

    assert!(ptr.validate(42));
    assert!(!ptr.validate(43));
}

#[test]
fn test_blood_ptr_persistent_always_valid() {
    let meta = PtrMetadata::persistent();
    let ptr = BloodPtr::new(0x1000, PERSISTENT_MARKER, meta);

    // Persistent pointers should validate against any generation
    assert!(ptr.validate(1));
    assert!(ptr.validate(999));
    assert!(ptr.validate(FREED_GENERATION));
}

#[test]
fn test_type_fingerprint() {
    let fp1 = compute_type_fingerprint("i32");
    let fp2 = compute_type_fingerprint("String");
    let fp3 = compute_type_fingerprint("i32");

    // Same type should produce same fingerprint
    assert!(fp1 == fp3);
    // Different types should (very likely) produce different fingerprints
    assert!(fp1 != fp2);
    // Should be 24 bits max
    assert!(fp1 <= 0x00FF_FFFF);
    assert!(fp2 <= 0x00FF_FFFF);
}
