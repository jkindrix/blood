/// Core MIR Types for Blood
///
/// This module defines the fundamental types for Blood's MIR representation.
/// MIR (Mid-level Intermediate Representation) is a control-flow graph based
/// IR designed for:
/// - Explicit control flow (no nested structures)
/// - Flattened expressions
/// - Optimization and memory safety analysis
///
/// # Type Hierarchy
///
/// ```text
/// MirBody
/// └── BasicBlockData
///     ├── [Statement]
///     │   └── StatementKind
///     │       ├── Assign(Place, Rvalue)
///     │       ├── StorageLive(LocalId)
///     │       ├── StorageDead(LocalId)
///     │       └── ...
///     └── Terminator
///         └── TerminatorKind
///             ├── Goto { target }
///             ├── SwitchInt { discr, targets }
///             ├── Return
///             ├── Call { func, args, destination }
///             └── ...
/// ```
///
/// # Design References
///
/// Based on Rust MIR and RFC 1211.

use std.compiler.parser::{Span};
use std.compiler.typeck.types::{Type, DefId};

// ============================================================
// Local Variable ID
// ============================================================

/// Unique identifier for a local variable within a function.
///
/// Local variables follow a specific convention:
/// - _0: Return place
/// - _1..=_n: Parameters (where n = param_count)
/// - _(n+1)..: Temporaries and user variables
pub struct LocalId {
    index: u32,
}

impl LocalId {
    /// Create a new LocalId.
    pub fn new(index: u32) -> LocalId {
        LocalId { index }
    }

    /// Get the index value.
    pub fn index(&self) -> u32 {
        self.index
    }

    /// Return place (always index 0).
    pub fn return_place() -> LocalId {
        LocalId { index: 0 }
    }
}

impl Clone for LocalId {
    fn clone(&self) -> LocalId {
        LocalId { index: self.index }
    }
}

impl PartialEq for LocalId {
    fn eq(&self, other: &LocalId) -> bool {
        self.index == other.index;
    }
}

// ============================================================
// Basic Block ID
// ============================================================

/// A unique identifier for a basic block within a function.
pub struct BasicBlockId {
    id: u32,
}

impl BasicBlockId {
    /// The entry block ID (always 0).
    pub fn entry() -> BasicBlockId {
        BasicBlockId { id: 0 }
    }

    /// Create a new BasicBlockId.
    pub fn new(id: u32) -> BasicBlockId {
        BasicBlockId { id }
    }

    /// Get the index value.
    pub fn index(&self) -> u32 {
        self.id
    }
}

impl Clone for BasicBlockId {
    fn clone(&self) -> BasicBlockId {
        BasicBlockId { id: self.id }
    }
}

impl PartialEq for BasicBlockId {
    fn eq(&self, other: &BasicBlockId) -> bool {
        self.id == other.id;
    }
}

// ============================================================
// Basic Block
// ============================================================

/// A basic block in the control-flow graph.
///
/// A basic block is a sequence of statements, followed by a single terminator.
/// Statements have exactly one successor (the next statement or terminator).
/// Terminators can have multiple successors.
pub struct BasicBlockData {
    /// Statements executed sequentially.
    statements: [Statement],
    /// The terminator that ends this block.
    terminator: Option<Terminator>,
}

impl BasicBlockData {
    /// Create a new empty basic block.
    pub fn new() -> BasicBlockData {
        BasicBlockData {
            statements: [],
            terminator: Option::None,
        }
    }

    /// Get the statements.
    pub fn statements(&self) -> &[Statement] {
        &self.statements
    }

    /// Get the terminator.
    pub fn terminator(&self) -> &Option<Terminator> {
        &self.terminator
    }

    /// Check if this block has a terminator.
    pub fn is_terminated(&self) -> bool {
        match &self.terminator {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Push a statement to this block.
    pub fn push_statement(&mut self, stmt: Statement) {
        self.statements.push(stmt);
    }

    /// Set the terminator for this block.
    pub fn set_terminator(&mut self, term: Terminator) {
        self.terminator = Option::Some(term);
    }

    /// Get successor blocks.
    pub fn successors(&self) -> [BasicBlockId] {
        match &self.terminator {
            Option::Some(term) => term.successors(),
            Option::None => [],
        }
    }
}

impl Clone for BasicBlockData {
    fn clone(&self) -> BasicBlockData {
        BasicBlockData {
            statements: self.statements.clone(),
            terminator: self.terminator.clone(),
        }
    }
}

// ============================================================
// Statements
// ============================================================

/// A statement in a basic block.
///
/// Statements have exactly one successor (the next statement or terminator).
pub struct Statement {
    /// The kind of statement.
    kind: StatementKind,
    /// Source location for error reporting.
    span: Span,
}

impl Statement {
    /// Create a new statement.
    pub fn new(kind: StatementKind, span: Span) -> Statement {
        Statement { kind, span }
    }

    /// Get the statement kind.
    pub fn kind(&self) -> &StatementKind {
        &self.kind
    }

    /// Get the span.
    pub fn span(&self) -> &Span {
        &self.span
    }
}

impl Clone for Statement {
    fn clone(&self) -> Statement {
        Statement {
            kind: self.kind.clone(),
            span: self.span.clone(),
        }
    }
}

/// The kind of a statement.
pub enum StatementKind {
    /// Assignment: `place = rvalue`
    Assign { place: Place, rvalue: Rvalue },

    /// Mark storage as live (for borrow checking/LLVM).
    StorageLive { local: LocalId },

    /// Mark storage as dead.
    StorageDead { local: LocalId },

    /// Drop a value (run destructor if applicable).
    Drop { place: Place },

    /// Increment generation counter for a slot.
    IncrementGeneration { place: Place },

    /// Capture generation snapshot for effect handler.
    CaptureSnapshot { local: LocalId },

    /// Validate generation (runtime check).
    ValidateGeneration {
        /// The pointer to validate.
        ptr: Place,
        /// The expected generation.
        expected_gen: Operand,
    },

    /// Push an effect handler onto the evidence vector.
    PushHandler {
        /// The handler definition ID.
        handler_id: DefId,
        /// The handler state place (pointer to handler state struct).
        state_place: Place,
    },

    /// Pop an effect handler from the evidence vector.
    PopHandler,

    /// No-op (placeholder for removed statements).
    Nop,
}

impl Clone for StatementKind {
    fn clone(&self) -> StatementKind {
        match self {
            StatementKind::Assign { place, rvalue } => {
                StatementKind::Assign {
                    place: place.clone(),
                    rvalue: rvalue.clone(),
                }
            }
            StatementKind::StorageLive { local } => {
                StatementKind::StorageLive { local: local.clone() }
            }
            StatementKind::StorageDead { local } => {
                StatementKind::StorageDead { local: local.clone() }
            }
            StatementKind::Drop { place } => {
                StatementKind::Drop { place: place.clone() }
            }
            StatementKind::IncrementGeneration { place } => {
                StatementKind::IncrementGeneration { place: place.clone() }
            }
            StatementKind::CaptureSnapshot { local } => {
                StatementKind::CaptureSnapshot { local: local.clone() }
            }
            StatementKind::ValidateGeneration { ptr, expected_gen } => {
                StatementKind::ValidateGeneration {
                    ptr: ptr.clone(),
                    expected_gen: expected_gen.clone(),
                }
            }
            StatementKind::PushHandler { handler_id, state_place } => {
                StatementKind::PushHandler {
                    handler_id: handler_id.clone(),
                    state_place: state_place.clone(),
                }
            }
            StatementKind::PopHandler => StatementKind::PopHandler,
            StatementKind::Nop => StatementKind::Nop,
        }
    }
}

// ============================================================
// Terminators
// ============================================================

/// A terminator ends a basic block.
///
/// Terminators can have multiple successors (unlike statements).
pub struct Terminator {
    /// The kind of terminator.
    kind: TerminatorKind,
    /// Source location for error reporting.
    span: Span,
}

impl Terminator {
    /// Create a new terminator.
    pub fn new(kind: TerminatorKind, span: Span) -> Terminator {
        Terminator { kind, span }
    }

    /// Get the terminator kind.
    pub fn kind(&self) -> &TerminatorKind {
        &self.kind
    }

    /// Get the span.
    pub fn span(&self) -> &Span {
        &self.span
    }

    /// Get all successor blocks.
    pub fn successors(&self) -> [BasicBlockId] {
        self.kind.successors();
    }
}

impl Clone for Terminator {
    fn clone(&self) -> Terminator {
        Terminator {
            kind: self.kind.clone(),
            span: self.span.clone(),
        }
    }
}

/// The kind of a terminator.
pub enum TerminatorKind {
    /// Unconditional jump.
    Goto { target: BasicBlockId },

    /// Conditional branch based on integer discriminant.
    SwitchInt {
        /// The value being switched on.
        discr: Operand,
        /// Switch targets.
        targets: SwitchTargets,
    },

    /// Return from the function.
    Return,

    /// Unreachable code (e.g., after diverging expression).
    Unreachable,

    /// Function call.
    Call {
        /// The function to call.
        func: Operand,
        /// Arguments to the function.
        args: [Operand],
        /// Where to store the result.
        destination: Place,
        /// Block to jump to after call completes.
        target: Option<BasicBlockId>,
        /// Block to jump to if call unwinds (panics).
        unwind: Option<BasicBlockId>,
    },

    /// Assert condition is true, otherwise panic.
    Assert {
        /// The condition to check.
        cond: Operand,
        /// Whether we expect true or false.
        expected: bool,
        /// Message for assertion failure.
        msg: String,
        /// Block to jump to on success.
        target: BasicBlockId,
        /// Block to jump to on failure (cleanup).
        unwind: Option<BasicBlockId>,
    },

    /// Drop a value and continue.
    DropAndReplace {
        /// Place to drop.
        place: Place,
        /// New value to assign.
        value: Operand,
        /// Next block.
        target: BasicBlockId,
        /// Cleanup on unwind.
        unwind: Option<BasicBlockId>,
    },

    /// Effect operation: perform.
    Perform {
        /// Effect being performed.
        effect_id: DefId,
        /// Operation index within the effect.
        op_index: u32,
        /// Arguments to the operation.
        args: [Operand],
        /// Where to store the result.
        destination: Place,
        /// Block to continue to (after handler resumes).
        target: BasicBlockId,
        /// Whether this effect operation is tail-resumptive.
        is_tail_resumptive: bool,
    },

    /// Resume from an effect handler.
    Resume { value: Option<Operand> },

    /// Stale reference detected (effect).
    StaleReference {
        /// The pointer that was stale.
        ptr: Place,
        /// Expected generation.
        expected: u32,
        /// Actual generation found.
        actual: u32,
    },
}

impl TerminatorKind {
    /// Get all successor blocks for this terminator.
    pub fn successors(&self) -> [BasicBlockId] {
        match self {
            TerminatorKind::Goto { target } => [target.clone()],
            TerminatorKind::SwitchInt { targets, discr: _ } => targets.all_targets(),
            TerminatorKind::Return => [],
            TerminatorKind::Unreachable => [],
            TerminatorKind::Call { target, unwind, func: _, args: _, destination: _ } => {
                let mut succs: [BasicBlockId] = [];
                match target {
                    Option::Some(t) => succs.push(t.clone()),
                    Option::None => {}
                };
                match unwind {
                    Option::Some(u) => succs.push(u.clone()),
                    Option::None => {}
                }
                succs
            }
            TerminatorKind::Assert { target, unwind, cond: _, expected: _, msg: _ } => {
                let mut succs: [BasicBlockId] = [target.clone()];
                match unwind {
                    Option::Some(u) => succs.push(u.clone()),
                    Option::None => {}
                }
                succs
            }
            TerminatorKind::DropAndReplace { target, unwind, place: _, value: _ } => {
                let mut succs: [BasicBlockId] = [target.clone()];
                match unwind {
                    Option::Some(u) => succs.push(u.clone()),
                    Option::None => {}
                }
                succs
            }
            TerminatorKind::Perform { target, effect_id: _, op_index: _, args: _, destination: _, is_tail_resumptive: _ } => {
                [target.clone()]
            }
            TerminatorKind::Resume { value: _ } => [],
            TerminatorKind::StaleReference { ptr: _, expected: _, actual: _ } => [],
        }
    }

    /// Check if this terminator is a return.
    pub fn is_return(&self) -> bool {
        match self {
            TerminatorKind::Return => true,
            TerminatorKind::Goto { target: _ } => false,
            TerminatorKind::SwitchInt { discr: _, targets: _ } => false,
            TerminatorKind::Unreachable => false,
            TerminatorKind::Call { func: _, args: _, destination: _, target: _, unwind: _ } => false,
            TerminatorKind::Assert { cond: _, expected: _, msg: _, target: _, unwind: _ } => false,
            TerminatorKind::DropAndReplace { place: _, value: _, target: _, unwind: _ } => false,
            TerminatorKind::Perform { effect_id: _, op_index: _, args: _, destination: _, target: _, is_tail_resumptive: _ } => false,
            TerminatorKind::Resume { value: _ } => false,
            TerminatorKind::StaleReference { ptr: _, expected: _, actual: _ } => false,
        }
    }

    /// Check if this terminator diverges (no successors).
    pub fn is_diverging(&self) -> bool {
        self.successors().len() == 0
    }
}

impl Clone for TerminatorKind {
    fn clone(&self) -> TerminatorKind {
        match self {
            TerminatorKind::Goto { target } => {
                TerminatorKind::Goto { target: target.clone() }
            }
            TerminatorKind::SwitchInt { discr, targets } => {
                TerminatorKind::SwitchInt {
                    discr: discr.clone(),
                    targets: targets.clone(),
                }
            }
            TerminatorKind::Return => TerminatorKind::Return,
            TerminatorKind::Unreachable => TerminatorKind::Unreachable,
            TerminatorKind::Call { func, args, destination, target, unwind } => {
                TerminatorKind::Call {
                    func: func.clone(),
                    args: args.clone(),
                    destination: destination.clone(),
                    target: target.clone(),
                    unwind: unwind.clone(),
                }
            }
            TerminatorKind::Assert { cond, expected, msg, target, unwind } => {
                TerminatorKind::Assert {
                    cond: cond.clone(),
                    expected: *expected,
                    msg: msg.clone(),
                    target: target.clone(),
                    unwind: unwind.clone(),
                }
            }
            TerminatorKind::DropAndReplace { place, value, target, unwind } => {
                TerminatorKind::DropAndReplace {
                    place: place.clone(),
                    value: value.clone(),
                    target: target.clone(),
                    unwind: unwind.clone(),
                }
            }
            TerminatorKind::Perform { effect_id, op_index, args, destination, target, is_tail_resumptive } => {
                TerminatorKind::Perform {
                    effect_id: effect_id.clone(),
                    op_index: *op_index,
                    args: args.clone(),
                    destination: destination.clone(),
                    target: target.clone(),
                    is_tail_resumptive: *is_tail_resumptive,
                }
            }
            TerminatorKind::Resume { value } => {
                TerminatorKind::Resume { value: value.clone() }
            }
            TerminatorKind::StaleReference { ptr, expected, actual } => {
                TerminatorKind::StaleReference {
                    ptr: ptr.clone(),
                    expected: *expected,
                    actual: *actual,
                }
            }
        }
    }
}

// ============================================================
// Switch Targets
// ============================================================

/// Switch targets for SwitchInt terminator.
pub struct SwitchTargets {
    /// Value -> target block mappings.
    branches: [(u128, BasicBlockId)],
    /// Default/otherwise block.
    otherwise: BasicBlockId,
}

impl SwitchTargets {
    /// Create new switch targets.
    pub fn new(branches: [(u128, BasicBlockId)], otherwise: BasicBlockId) -> SwitchTargets {
        SwitchTargets { branches, otherwise }
    }

    /// Get the branches.
    pub fn branches(&self) -> &[(u128, BasicBlockId)] {
        &self.branches
    }

    /// Get the otherwise/default target.
    pub fn otherwise(&self) -> &BasicBlockId {
        &self.otherwise
    }

    /// Get all target blocks.
    pub fn all_targets(&self) -> [BasicBlockId] {
        let mut targets: [BasicBlockId] = [];
        let mut i = 0;
        while i < self.branches.len() {
            let (_, target) = &self.branches[i];
            targets.push(target.clone());
            i = i + 1;
        };
        targets.push(self.otherwise.clone());
        targets
    }

    /// Find target for a specific value.
    pub fn target_for_value(&self, value: u128) -> BasicBlockId {
        let mut i = 0;
        while i < self.branches.len() {
            let (v, target) = &self.branches[i];
            if *v == value {
                return target.clone();
            };
            i = i + 1;
        };
        self.otherwise.clone();
    }
}

impl Clone for SwitchTargets {
    fn clone(&self) -> SwitchTargets {
        SwitchTargets {
            branches: self.branches.clone(),
            otherwise: self.otherwise.clone(),
        }
    }
}

// ============================================================
// Places and Operands
// ============================================================

/// A place (memory location) that can be read or written.
///
/// Places represent paths to memory locations.
pub struct Place {
    /// The base local variable.
    local: LocalId,
    /// Projections applied to the base.
    projection: [PlaceElem],
}

impl Place {
    /// Create a place from just a local.
    pub fn local(id: LocalId) -> Place {
        Place {
            local: id,
            projection: [],
        }
    }

    /// Create a place with projections.
    pub fn projected(local: LocalId, projection: [PlaceElem]) -> Place {
        Place { local, projection }
    }

    /// Get the base local.
    pub fn base_local(&self) -> &LocalId {
        &self.local
    }

    /// Get the projections.
    pub fn projection(&self) -> &[PlaceElem] {
        &self.projection
    }

    /// Add a projection element.
    pub fn project(&self, elem: PlaceElem) -> Place {
        let mut proj = self.projection.clone();
        proj.push(elem);
        Place {
            local: self.local.clone(),
            projection: proj,
        }
    }

    /// Check if this is just a local (no projections).
    pub fn is_local(&self) -> bool {
        self.projection.len() == 0
    }
}

impl Clone for Place {
    fn clone(&self) -> Place {
        Place {
            local: self.local.clone(),
            projection: self.projection.clone(),
        }
    }
}

impl PartialEq for Place {
    fn eq(&self, other: &Place) -> bool {
        if self.local != other.local {
            return false;
        };
        if self.projection.len() != other.projection.len() {
            return false;
        };
        let mut i = 0;
        while i < self.projection.len() {
            if self.projection[i] != other.projection[i] {
                return false;
            };
            i = i + 1;
        }
        true
    }
}

/// A projection element for places.
pub enum PlaceElem {
    /// Dereference: `*place`
    Deref,
    /// Field access: `place.field`
    Field { index: u32 },
    /// Array/slice indexing with local: `place[local]`
    Index { local: LocalId },
    /// Constant index into array/slice.
    ConstantIndex {
        /// Offset from start or end.
        offset: u64,
        /// Minimum length required.
        min_length: u64,
        /// If true, offset is from end.
        from_end: bool,
    },
    /// Subslice: `place[from..to]`
    Subslice {
        from: u64,
        to: u64,
        from_end: bool,
    },
    /// Enum variant downcast.
    Downcast { variant: u32 },
}

impl Clone for PlaceElem {
    fn clone(&self) -> PlaceElem {
        match self {
            PlaceElem::Deref => PlaceElem::Deref,
            PlaceElem::Field { index } => PlaceElem::Field { index: *index },
            PlaceElem::Index { local } => PlaceElem::Index { local: local.clone() },
            PlaceElem::ConstantIndex { offset, min_length, from_end } => {
                PlaceElem::ConstantIndex {
                    offset: *offset,
                    min_length: *min_length,
                    from_end: *from_end,
                }
            }
            PlaceElem::Subslice { from, to, from_end } => {
                PlaceElem::Subslice {
                    from: *from,
                    to: *to,
                    from_end: *from_end,
                }
            }
            PlaceElem::Downcast { variant } => PlaceElem::Downcast { variant: *variant },
        }
    }
}

impl PartialEq for PlaceElem {
    fn eq(&self, other: &PlaceElem) -> bool {
        match (self, other) {
            (PlaceElem::Deref, PlaceElem::Deref) => true,
            (PlaceElem::Field { index: a }, PlaceElem::Field { index: b }) => *a == *b,
            (PlaceElem::Index { local: a }, PlaceElem::Index { local: b }) => *a == *b,
            (PlaceElem::ConstantIndex { offset: o1, min_length: m1, from_end: f1 },
             PlaceElem::ConstantIndex { offset: o2, min_length: m2, from_end: f2 }) => {
                *o1 == *o2 && *m1 == *m2 && *f1 == *f2
            }
            (PlaceElem::Subslice { from: fr1, to: t1, from_end: fe1 },
             PlaceElem::Subslice { from: fr2, to: t2, from_end: fe2 }) => {
                *fr1 == *fr2 && *t1 == *t2 && *fe1 == *fe2
            }
            (PlaceElem::Downcast { variant: a }, PlaceElem::Downcast { variant: b }) => *a == *b,
            (_, _) => false,
        }
    }
}

// ============================================================
// Operands
// ============================================================

/// An operand in an expression.
///
/// Operands are the "read-only" inputs to operations.
pub enum Operand {
    /// Copy from a place (for Copy types).
    Copy { place: Place },
    /// Move from a place (transfers ownership).
    Move { place: Place },
    /// A constant value.
    Constant { value: Constant },
}

impl Operand {
    /// Create a copy operand.
    pub fn copy(place: Place) -> Operand {
        Operand::Copy { place }
    }

    /// Create a move operand.
    pub fn move_op(place: Place) -> Operand {
        Operand::Move { place }
    }

    /// Create a constant operand.
    pub fn constant(c: Constant) -> Operand {
        Operand::Constant { value: c }
    }

    /// Get the place if this is a Copy or Move.
    pub fn place(&self) -> Option<&Place> {
        match self {
            Operand::Copy { place } => Option::Some(place),
            Operand::Move { place } => Option::Some(place),
            Operand::Constant { value: _ } => Option::None,
        }
    }
}

impl Clone for Operand {
    fn clone(&self) -> Operand {
        match self {
            Operand::Copy { place } => Operand::Copy { place: place.clone() },
            Operand::Move { place } => Operand::Move { place: place.clone() },
            Operand::Constant { value } => Operand::Constant { value: value.clone() },
        }
    }
}

// ============================================================
// Rvalues
// ============================================================

/// An rvalue (right-hand side of an assignment).
///
/// Rvalues produce values that can be assigned to places.
pub enum Rvalue {
    /// Use an operand directly.
    Use { operand: Operand },

    /// Create a reference to a place.
    Ref {
        place: Place,
        mutable: bool,
    },

    /// Create a raw pointer to a place.
    AddressOf {
        place: Place,
        mutable: bool,
    },

    /// Binary operation.
    BinaryOp {
        op: BinOp,
        left: Operand,
        right: Operand,
    },

    /// Checked binary operation (returns (result, overflow)).
    CheckedBinaryOp {
        op: BinOp,
        left: Operand,
        right: Operand,
    },

    /// Unary operation.
    UnaryOp {
        op: UnOp,
        operand: Operand,
    },

    /// Type cast.
    Cast {
        operand: Operand,
        target_ty: Type,
    },

    /// Get discriminant of an enum.
    Discriminant { place: Place },

    /// Compute length of an array/slice.
    Len { place: Place },

    /// Create an aggregate value (struct, tuple, array).
    Aggregate {
        kind: AggregateKind,
        operands: [Operand],
    },

    /// Null check: returns true if pointer is valid.
    NullCheck { operand: Operand },

    /// Read generation from a generational pointer.
    ReadGeneration { place: Place },

    /// Create a generational pointer.
    MakeGenPtr {
        address: Operand,
        generation: Operand,
        metadata: Operand,
    },

    /// Zero-initialize a value of the given type.
    ZeroInit { ty: Type },
}

impl Clone for Rvalue {
    fn clone(&self) -> Rvalue {
        match self {
            Rvalue::Use { operand } => Rvalue::Use { operand: operand.clone() },
            Rvalue::Ref { place, mutable } => {
                Rvalue::Ref { place: place.clone(), mutable: *mutable }
            }
            Rvalue::AddressOf { place, mutable } => {
                Rvalue::AddressOf { place: place.clone(), mutable: *mutable }
            }
            Rvalue::BinaryOp { op, left, right } => {
                Rvalue::BinaryOp { op: op.clone(), left: left.clone(), right: right.clone() }
            }
            Rvalue::CheckedBinaryOp { op, left, right } => {
                Rvalue::CheckedBinaryOp { op: op.clone(), left: left.clone(), right: right.clone() }
            }
            Rvalue::UnaryOp { op, operand } => {
                Rvalue::UnaryOp { op: op.clone(), operand: operand.clone() }
            }
            Rvalue::Cast { operand, target_ty } => {
                Rvalue::Cast { operand: operand.clone(), target_ty: target_ty.clone() }
            }
            Rvalue::Discriminant { place } => Rvalue::Discriminant { place: place.clone() },
            Rvalue::Len { place } => Rvalue::Len { place: place.clone() },
            Rvalue::Aggregate { kind, operands } => {
                Rvalue::Aggregate { kind: kind.clone(), operands: operands.clone() }
            }
            Rvalue::NullCheck { operand } => Rvalue::NullCheck { operand: operand.clone() },
            Rvalue::ReadGeneration { place } => Rvalue::ReadGeneration { place: place.clone() },
            Rvalue::MakeGenPtr { address, generation, metadata } => {
                Rvalue::MakeGenPtr {
                    address: address.clone(),
                    generation: generation.clone(),
                    metadata: metadata.clone(),
                }
            }
            Rvalue::ZeroInit { ty } => Rvalue::ZeroInit { ty: ty.clone() },
        }
    }
}

// ============================================================
// Binary and Unary Operations
// ============================================================

/// Binary operations.
pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    BitAnd,
    BitOr,
    BitXor,
    Shl,
    Shr,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    /// Pointer offset
    Offset,
}

impl Clone for BinOp {
    fn clone(&self) -> BinOp {
        match self {
            BinOp::Add => BinOp::Add,
            BinOp::Sub => BinOp::Sub,
            BinOp::Mul => BinOp::Mul,
            BinOp::Div => BinOp::Div,
            BinOp::Rem => BinOp::Rem,
            BinOp::BitAnd => BinOp::BitAnd,
            BinOp::BitOr => BinOp::BitOr,
            BinOp::BitXor => BinOp::BitXor,
            BinOp::Shl => BinOp::Shl,
            BinOp::Shr => BinOp::Shr,
            BinOp::Eq => BinOp::Eq,
            BinOp::Ne => BinOp::Ne,
            BinOp::Lt => BinOp::Lt,
            BinOp::Le => BinOp::Le,
            BinOp::Gt => BinOp::Gt,
            BinOp::Ge => BinOp::Ge,
            BinOp::Offset => BinOp::Offset,
        }
    }
}

impl PartialEq for BinOp {
    fn eq(&self, other: &BinOp) -> bool {
        match (self, other) {
            (BinOp::Add, BinOp::Add) => true,
            (BinOp::Sub, BinOp::Sub) => true,
            (BinOp::Mul, BinOp::Mul) => true,
            (BinOp::Div, BinOp::Div) => true,
            (BinOp::Rem, BinOp::Rem) => true,
            (BinOp::BitAnd, BinOp::BitAnd) => true,
            (BinOp::BitOr, BinOp::BitOr) => true,
            (BinOp::BitXor, BinOp::BitXor) => true,
            (BinOp::Shl, BinOp::Shl) => true,
            (BinOp::Shr, BinOp::Shr) => true,
            (BinOp::Eq, BinOp::Eq) => true,
            (BinOp::Ne, BinOp::Ne) => true,
            (BinOp::Lt, BinOp::Lt) => true,
            (BinOp::Le, BinOp::Le) => true,
            (BinOp::Gt, BinOp::Gt) => true,
            (BinOp::Ge, BinOp::Ge) => true,
            (BinOp::Offset, BinOp::Offset) => true,
            (_, _) => false,
        }
    }
}

/// Unary operations.
pub enum UnOp {
    Not,
    Neg,
}

impl Clone for UnOp {
    fn clone(&self) -> UnOp {
        match self {
            UnOp::Not => UnOp::Not,
            UnOp::Neg => UnOp::Neg,
        }
    }
}

impl PartialEq for UnOp {
    fn eq(&self, other: &UnOp) -> bool {
        match (self, other) {
            (UnOp::Not, UnOp::Not) => true,
            (UnOp::Neg, UnOp::Neg) => true,
            (_, _) => false,
        }
    }
}

// ============================================================
// Aggregate Kind
// ============================================================

/// Kind of aggregate value being constructed.
pub enum AggregateKind {
    /// Tuple.
    Tuple,
    /// Array.
    Array { element_ty: Type },
    /// Struct or enum.
    Adt {
        def_id: DefId,
        variant_idx: Option<u32>,
        /// Type arguments for generic ADTs.
        type_args: [Type],
    },
    /// Anonymous record.
    Record,
    /// Closure (captures).
    Closure { def_id: DefId },
    /// Range (start, end, [exhausted]).
    Range {
        element: Type,
        inclusive: bool,
    },
}

impl Clone for AggregateKind {
    fn clone(&self) -> AggregateKind {
        match self {
            AggregateKind::Tuple => AggregateKind::Tuple,
            AggregateKind::Array { element_ty } => {
                AggregateKind::Array { element_ty: element_ty.clone() }
            }
            AggregateKind::Adt { def_id, variant_idx, type_args } => {
                AggregateKind::Adt {
                    def_id: def_id.clone(),
                    variant_idx: variant_idx.clone(),
                    type_args: type_args.clone(),
                }
            }
            AggregateKind::Record => AggregateKind::Record,
            AggregateKind::Closure { def_id } => {
                AggregateKind::Closure { def_id: def_id.clone() }
            }
            AggregateKind::Range { element, inclusive } => {
                AggregateKind::Range { element: element.clone(), inclusive: *inclusive }
            }
        }
    }
}

// ============================================================
// Constants
// ============================================================

/// A constant value in MIR.
pub struct Constant {
    /// The type of the constant.
    ty: Type,
    /// The constant value.
    kind: ConstantKind,
}

impl Constant {
    /// Create a new constant.
    pub fn new(ty: Type, kind: ConstantKind) -> Constant {
        Constant { ty, kind }
    }

    /// Get the type.
    pub fn ty(&self) -> &Type {
        &self.ty
    }

    /// Get the constant kind.
    pub fn kind(&self) -> &ConstantKind {
        &self.kind
    }

    /// Create an integer constant.
    pub fn int(value: i128, ty: Type) -> Constant {
        Constant::new(ty, ConstantKind::Int { value })
    }

    /// Create an unsigned integer constant.
    pub fn uint(value: u128, ty: Type) -> Constant {
        Constant::new(ty, ConstantKind::Uint { value })
    }

    /// Create a boolean constant.
    pub fn bool(value: bool, ty: Type) -> Constant {
        Constant::new(ty, ConstantKind::Bool { value })
    }

    /// Create a unit constant.
    pub fn unit(ty: Type) -> Constant {
        Constant::new(ty, ConstantKind::Unit)
    }
}

impl Clone for Constant {
    fn clone(&self) -> Constant {
        Constant {
            ty: self.ty.clone(),
            kind: self.kind.clone(),
        }
    }
}

/// The kind of a constant.
pub enum ConstantKind {
    /// Integer constant.
    Int { value: i128 },
    /// Unsigned integer constant.
    Uint { value: u128 },
    /// Floating-point constant.
    Float { value: f64 },
    /// Boolean constant.
    Bool { value: bool },
    /// Character constant.
    Char { value: char },
    /// String constant (interned).
    String { value: String },
    /// Unit value.
    Unit,
    /// Function reference.
    FnDef { def_id: DefId },
    /// Const item reference.
    ConstDef { def_id: DefId },
    /// Static item reference.
    StaticDef { def_id: DefId },
    /// Zero-sized type value.
    ZeroSized,
}

impl Clone for ConstantKind {
    fn clone(&self) -> ConstantKind {
        match self {
            ConstantKind::Int { value } => ConstantKind::Int { value: *value },
            ConstantKind::Uint { value } => ConstantKind::Uint { value: *value },
            ConstantKind::Float { value } => ConstantKind::Float { value: *value },
            ConstantKind::Bool { value } => ConstantKind::Bool { value: *value },
            ConstantKind::Char { value } => ConstantKind::Char { value: *value },
            ConstantKind::String { value } => ConstantKind::String { value: value.clone() },
            ConstantKind::Unit => ConstantKind::Unit,
            ConstantKind::FnDef { def_id } => ConstantKind::FnDef { def_id: def_id.clone() },
            ConstantKind::ConstDef { def_id } => ConstantKind::ConstDef { def_id: def_id.clone() },
            ConstantKind::StaticDef { def_id } => ConstantKind::StaticDef { def_id: def_id.clone() },
            ConstantKind::ZeroSized => ConstantKind::ZeroSized,
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_local_id() {
    let id = LocalId::new(5);
    assert!(id.index() == 5);

    let ret = LocalId::return_place();
    assert!(ret.index() == 0);
}

#[test]
fn test_basic_block_id() {
    let entry = BasicBlockId::entry();
    assert!(entry.index() == 0);

    let bb = BasicBlockId::new(5);
    assert!(bb.index() == 5);
}

#[test]
fn test_place_local() {
    let place = Place::local(LocalId::new(5));
    assert!(place.is_local());
    assert!(place.base_local().index() == 5);
}

#[test]
fn test_place_projection() {
    let place = Place::local(LocalId::new(0))
        .project(PlaceElem::Field { index: 1 })
        .project(PlaceElem::Deref);
    assert!(!place.is_local());
    assert!(place.projection().len() == 2);
}

#[test]
fn test_switch_targets() {
    let targets = SwitchTargets::new(
        [(0, BasicBlockId::new(1)), (1, BasicBlockId::new(2))],
        BasicBlockId::new(3),
    );
    assert!(targets.target_for_value(0) == BasicBlockId::new(1));
    assert!(targets.target_for_value(1) == BasicBlockId::new(2));
    assert!(targets.target_for_value(99) == BasicBlockId::new(3));
    assert!(targets.all_targets().len() == 3);
}

#[test]
fn test_operand_place() {
    let place = Place::local(LocalId::new(0));
    let copy_op = Operand::copy(place.clone());
    let move_op = Operand::move_op(place.clone());

    match copy_op.place() {
        Option::Some(_) => {}
        Option::None => panic("Expected Some"),
    };
    match move_op.place() {
        Option::Some(_) => {}
        Option::None => panic("Expected Some"),
    }
}

#[test]
fn test_constant_creation() {
    let ty = Type::i32();
    let c = Constant::int(42, ty.clone());
    match c.kind() {
        ConstantKind::Int { value } => assert!(*value == 42),
        _ => panic("Expected Int"),
    }
}
