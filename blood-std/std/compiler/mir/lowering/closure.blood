/// Closure Body Lowering
///
/// This module contains the `ClosureLowering` struct which handles lowering
/// closure bodies from HIR to MIR. Closures differ from regular functions in
/// that they capture variables from their environment.
///
/// # Key Differences from Functions
///
/// 1. **Environment Parameter**: Closures have an implicit first parameter
///    containing captured variables. This is represented as a struct.
///
/// 2. **Capture Access**: Captured variables are accessed through field
///    projections on the environment parameter.
///
/// 3. **Nested Closures**: Closures can themselves contain closures, which
///    may capture from both the outer closure's environment and new captures.
///
/// # Capture Representation
///
/// Captures are lowered to an environment struct:
/// ```
/// struct ClosureEnv {
///     capture_0: T0,
///     capture_1: T1,
///     ...
/// }
/// ```
///
/// When a captured variable is used, we:
/// 1. Access the environment parameter (local 1, after return place)
/// 2. Project to the appropriate field index
/// 3. Dereference if captured by reference

use std.collections::HashMap;
use crate.compiler.hir::{
    Body, Expr, ExprKind, Local,
    LiteralValue, BinOp as HirBinOp, UnaryOp as HirUnaryOp,
    Pattern, PatternKind, MatchArm, Stmt, FieldExpr, RecordFieldExpr,
    Capture, InlineOpHandler, FieldPattern,
    LocalId as HirLocalId, LoopId, BodyId, Crate as HirCrate, Span,
};
use crate.compiler.mir::{
    LocalId as MirLocalId, BasicBlockId, BasicBlockData,
    Statement, StatementKind, Terminator, TerminatorKind,
    Place, PlaceElem, Operand, Rvalue,
    BinOp as MirBinOp, UnOp as MirUnOp, AggregateKind,
    Constant, ConstantKind, SwitchTargets,
    MirBody, MirBodyBuilder, MirLocal, LocalKind, SourceScope,
};
use crate.compiler.typeck::types::{Type, DefId};
use crate.compiler.mir::lowering::util::{
    convert_binop, convert_unop, lower_literal, is_irrefutable_pattern,
    LoopContext, CLOSURE_DEF_ID_START, INLINE_HANDLER_DEF_ID_START,
};

// ============================================================
// Closure Lowering Context
// ============================================================

/// Per-closure lowering context.
///
/// This struct maintains all state needed while lowering a closure body
/// from HIR to MIR. It's similar to FunctionLowering but handles captures.
pub struct ClosureLowering<'hir> {
    /// The synthetic DefId assigned to this closure.
    def_id: DefId,
    /// The HIR body being lowered.
    body: &'hir Body,
    /// Reference to the full HIR crate.
    hir: &'hir HirCrate,
    /// The captures and their types.
    captures: [(Capture, Type)],
    /// The MIR body builder.
    builder: MirBodyBuilder,
    /// Mapping from HIR LocalIds to MIR LocalIds.
    local_map: HashMap<u32, MirLocalId>,
    /// Mapping from captured HIR LocalIds to environment field indices.
    capture_map: HashMap<u32, u32>,
    /// The environment local (parameter 1).
    env_local: MirLocalId,
    /// The current basic block being built.
    current_block: BasicBlockId,
    /// Stack of loop contexts for break/continue.
    loop_stack: [(Option<LoopId>, LoopContext)],
    /// Counter for generating temporary locals.
    temp_counter: u32,
    /// Discovered nested closures pending lowering.
    pending_closures: [(BodyId, DefId, [(Capture, Type)])],
    /// Counter for generating synthetic closure DefIds.
    closure_counter: u32,
    /// Counter for generating synthetic inline handler DefIds.
    inline_handler_counter: u32,
    /// Nested handler depth.
    handler_depth: usize,
}

impl<'hir> ClosureLowering<'hir> {
    /// Create a new closure lowering context.
    pub fn new(
        def_id: DefId,
        body: &'hir Body,
        hir: &'hir HirCrate,
        captures: [(Capture, Type)],
        closure_counter: u32,
    ) -> ClosureLowering<'hir> {
        let builder = MirBodyBuilder::new();

        // Build capture map
        let mut capture_map: HashMap<u32, u32> = HashMap::new();
        let mut i: u32 = 0;
        while i < captures.len() as u32 {
            let (cap, _) = &captures[i as usize];
            capture_map.insert(cap.local_id.index(), i);
            i = i + 1;
        }

        ClosureLowering {
            def_id,
            body,
            hir,
            captures,
            builder,
            local_map: HashMap::new(),
            capture_map,
            env_local: MirLocalId::new(1), // Will be set properly in create_locals
            current_block: BasicBlockId::entry(),
            loop_stack: [],
            temp_counter: 0,
            pending_closures: [],
            closure_counter,
            inline_handler_counter: 0,
            handler_depth: 0,
        }
    }

    // ========================================================================
    // Main Entry Point
    // ========================================================================

    /// Lower the closure body to MIR.
    ///
    /// Returns the completed MIR body, any nested closures discovered,
    /// and the updated closure counter.
    pub fn lower(mut self) -> (MirBody, [(BodyId, DefId, [(Capture, Type)])], u32) {
        // Step 1: Create locals (including environment parameter);
        self.create_locals();

        // Step 2: Create entry block
        self.current_block = self.builder.new_block();

        // Step 3: Lower the body expression
        let result = self.lower_expr(&self.body.expr);

        // Step 4: Assign result to return place and terminate
        match result {
            Result::Ok(operand) => {
                let return_place = Place::local(MirLocalId::return_place());
                self.push_assign(return_place, Rvalue::Use { operand });
                if !self.is_terminated() {
                    self.terminate(TerminatorKind::Return);
                }
            }
            Result::Err(_) => {
                self.terminate(TerminatorKind::Unreachable);
            }
        };

        // Step 5: Build and return
        let mir_body = self.builder.build();
        (mir_body, self.pending_closures, self.closure_counter)
    }

    // ========================================================================
    // Local Variable Management
    // ========================================================================

    /// Create MIR locals from HIR locals plus environment parameter.
    fn create_locals(&mut self) {
        // Local 0: Return place
        // Local 1: Environment parameter (captures struct)
        // Local 2+: Parameters (shifted by 1 from HIR)
        // After parameters: temporaries and user variables

        let mut i: usize = 0;
        while i < self.body.locals.len() {
            let hir_local = &self.body.locals[i];

            if i == 0 {
                // Return place
                let mir_local = MirLocal {
                    kind: LocalKind::ReturnPlace,
                    ty: hir_local.ty.clone(),
                    mutable: false,
                    name: Option::None,
                    span: hir_local.span.clone(),
                };
                let mir_id = self.builder.push_local(mir_local);
                self.local_map.insert(hir_local.id.index(), mir_id);
            } else if i == 1 {
                // First HIR parameter becomes second MIR parameter (after env)
                // But first, add the environment parameter
                let env_ty = self.build_env_type();
                let env_local = MirLocal {
                    kind: LocalKind::Arg,
                    ty: env_ty,
                    mutable: false,
                    name: Option::Some("__env".to_string()),
                    span: Span::dummy(),
                };
                self.env_local = self.builder.push_local(env_local);

                // Now add the HIR parameter
                let mir_local = MirLocal {
                    kind: LocalKind::Arg,
                    ty: hir_local.ty.clone(),
                    mutable: hir_local.mutable,
                    name: hir_local.name.clone(),
                    span: hir_local.span.clone(),
                };
                let mir_id = self.builder.push_local(mir_local);
                self.local_map.insert(hir_local.id.index(), mir_id);
            } else if i <= self.body.param_count {
                // Remaining parameters
                let mir_local = MirLocal {
                    kind: LocalKind::Arg,
                    ty: hir_local.ty.clone(),
                    mutable: hir_local.mutable,
                    name: hir_local.name.clone(),
                    span: hir_local.span.clone(),
                };
                let mir_id = self.builder.push_local(mir_local);
                self.local_map.insert(hir_local.id.index(), mir_id);
            } else {
                // Variables and temporaries
                let mir_local = MirLocal {
                    kind: LocalKind::Var,
                    ty: hir_local.ty.clone(),
                    mutable: hir_local.mutable,
                    name: hir_local.name.clone(),
                    span: hir_local.span.clone(),
                };
                let mir_id = self.builder.push_local(mir_local);
                self.local_map.insert(hir_local.id.index(), mir_id);
            };

            i = i + 1;
        };

        // If body has no parameters, we still need the env parameter
        if self.body.param_count == 0 && self.body.locals.len() <= 1 {
            let env_ty = self.build_env_type();
            let env_local = MirLocal {
                kind: LocalKind::Arg,
                ty: env_ty,
                mutable: false,
                name: Option::Some("__env".to_string()),
                span: Span::dummy(),
            };
            self.env_local = self.builder.push_local(env_local);
        }
    }

    /// Build the environment type as a tuple of capture types.
    fn build_env_type(&self) -> Type {
        let mut types: [Type] = [];
        let mut i: usize = 0;
        while i < self.captures.len() {
            let (cap, ty) = &self.captures[i];
            if cap.by_ref {
                types.push(Type::reference(ty.clone(), cap.mutable));
            } else {
                types.push(ty.clone());
            };
            i = i + 1;
        }
        Type::tuple(types)
    }

    /// Map a HIR LocalId to a MIR LocalId, checking captures first.
    fn map_local(&self, hir_id: HirLocalId) -> MirLocalId {
        // First check if this is a captured variable
        match self.capture_map.get(&hir_id.index()) {
            Option::Some(_) => {
                // Captured variable - will be accessed via environment
                // Return a placeholder; actual access goes through get_capture_place
                MirLocalId::new(0)
            }
            Option::None => {
                // Regular local
                match self.local_map.get(&hir_id.index()) {
                    Option::Some(mir_id) => mir_id.clone(),
                    Option::None => MirLocalId::new(0),
                }
            }
        }
    }

    /// Check if a HIR local is captured.
    fn is_captured(&self, hir_id: &HirLocalId) -> bool {
        self.capture_map.contains_key(&hir_id.index());
    }

    /// Get the capture field index for a captured variable.
    fn get_capture_field(&self, hir_id: &HirLocalId) -> Option<u32> {
        self.capture_map.get(&hir_id.index()).cloned();
    }

    /// Get the place for accessing a captured variable.
    fn get_capture_place(&self, hir_id: &HirLocalId) -> Option<Place> {
        match self.get_capture_field(hir_id) {
            Option::Some(field_idx) => {
                let env_place = Place::local(self.env_local.clone());
                Option::Some(env_place.project(PlaceElem::Field { index: field_idx }))
            }
            Option::None => Option::None,
        }
    }

    /// Create a new temporary local.
    fn new_temp(&mut self, ty: Type, span: Span) -> MirLocalId {
        let mir_local = MirLocal {
            kind: LocalKind::Temp,
            ty,
            mutable: false,
            name: Option::None,
            span,
        };
        self.builder.push_local(mir_local);
    }

    // ========================================================================
    // Statement and Terminator Helpers
    // ========================================================================

    fn push_assign(&mut self, place: Place, rvalue: Rvalue) {
        let stmt = Statement::new(
            StatementKind::Assign { place, rvalue },
            Span::dummy(),
        );
        self.builder.push_statement(self.current_block.clone(), stmt);
    }

    fn push_stmt(&mut self, kind: StatementKind, span: Span) {
        let stmt = Statement::new(kind, span);
        self.builder.push_statement(self.current_block.clone(), stmt);
    }

    fn terminate(&mut self, kind: TerminatorKind) {
        let term = Terminator::new(kind, Span::dummy());
        self.builder.set_terminator(self.current_block.clone(), term);
    }

    fn is_terminated(&self) -> bool {
        self.builder.is_block_terminated(self.current_block.clone());
    }

    // ========================================================================
    // Loop Context Management
    // ========================================================================

    fn push_loop_context(&mut self, label: Option<LoopId>, ctx: LoopContext) {
        self.loop_stack.push((label, ctx));
    }

    fn pop_loop_context(&mut self) {
        self.loop_stack.pop();
    }

    fn get_loop_context(&self, label: Option<LoopId>) -> Option<&LoopContext> {
        match label {
            Option::None => {
                if self.loop_stack.len() > 0 {
                    let (_, ctx) = &self.loop_stack[self.loop_stack.len() - 1];
                    Option::Some(ctx)
                } else {
                    Option::None
                }
            }
            Option::Some(target_label) => {
                let mut i: usize = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    let (maybe_label, ctx) = &self.loop_stack[i];
                    match maybe_label {
                        Option::Some(l) => {
                            if l.eq(&target_label) {
                                return Option::Some(ctx);
                            }
                        }
                        Option::None => {}
                    }
                }
                Option::None
            }
        }
    }

    // ========================================================================
    // Expression Lowering
    // ========================================================================

    /// Lower an expression to a MIR operand.
    ///
    /// The key difference from function lowering is handling of captured
    /// variables: they are accessed via the environment parameter.
    pub fn lower_expr(&mut self, expr: &Expr) -> Result<Operand, [String]> {
        match &expr.kind {
            ExprKind::Literal(lit) => {
                let constant = lower_literal(lit, &expr.ty);
                Result::Ok(Operand::constant(constant))
            }

            ExprKind::Local(local_id) => {
                // Check if this is a captured variable
                match self.get_capture_place(local_id) {
                    Option::Some(capture_place) => {
                        // Access captured variable through environment
                        let (cap, _) = self.get_capture_by_id(local_id);
                        if cap.by_ref {
                            // Captured by reference - need to deref
                            let deref_place = capture_place.project(PlaceElem::Deref);
                            Result::Ok(Operand::copy(deref_place))
                        } else {
                            Result::Ok(Operand::copy(capture_place))
                        }
                    }
                    Option::None => {
                        // Regular local
                        let mir_local = match self.local_map.get(&local_id.index()) {
                            Option::Some(id) => id.clone(),
                            Option::None => MirLocalId::new(0),
                        };
                        Result::Ok(Operand::copy(Place::local(mir_local)))
                    }
                }
            }

            ExprKind::Def(def_id) => {
                let constant = Constant::new(
                    expr.ty.clone(),
                    ConstantKind::FnDef { def_id: def_id.clone() },
                );
                Result::Ok(Operand::constant(constant))
            }

            ExprKind::Binary { op, left, right } => {
                self.lower_binary(op, left, right, &expr.ty, expr.span.clone());
            }

            ExprKind::Unary { op, operand } => {
                self.lower_unary(op, operand, &expr.ty, expr.span.clone());
            }

            ExprKind::Call { callee, args } => {
                self.lower_call(callee, args, &expr.ty, expr.span.clone());
            }

            ExprKind::MethodCall { receiver, method, args } => {
                self.lower_method_call(receiver, method, args, &expr.ty, expr.span.clone());
            }

            ExprKind::Field { base, field_idx } => {
                self.lower_field(base, *field_idx, &expr.ty, expr.span.clone());
            }

            ExprKind::Index { base, index } => {
                self.lower_index(base, index, &expr.ty, expr.span.clone());
            }

            ExprKind::Tuple(elems) => {
                self.lower_tuple(elems, &expr.ty, expr.span.clone());
            }

            ExprKind::Array(elems) => {
                self.lower_array(elems, &expr.ty, expr.span.clone());
            }

            ExprKind::Repeat { value, count } => {
                self.lower_repeat(value, *count, &expr.ty, expr.span.clone());
            }

            ExprKind::Struct { def_id, fields, base } => {
                self.lower_struct(def_id, fields, base, &expr.ty, expr.span.clone());
            }

            ExprKind::Record { fields } => {
                self.lower_record(fields, &expr.ty, expr.span.clone());
            }

            ExprKind::Variant { def_id, variant_idx, fields } => {
                self.lower_variant(def_id, *variant_idx, fields, &expr.ty, expr.span.clone());
            }

            ExprKind::Cast { expr: inner, target_ty } => {
                self.lower_cast(inner, target_ty, expr.span.clone());
            }

            ExprKind::Assign { target, value } => {
                self.lower_assign(target, value, expr.span.clone());
            }

            ExprKind::Block { stmts, expr: maybe_expr } => {
                self.lower_block(stmts, maybe_expr, &expr.ty, expr.span.clone());
            }

            ExprKind::If { condition, then_branch, else_branch } => {
                self.lower_if(condition, then_branch, else_branch, &expr.ty, expr.span.clone());
            }

            ExprKind::Match { scrutinee, arms } => {
                self.lower_match(scrutinee, arms, &expr.ty, expr.span.clone());
            }

            ExprKind::Loop { body, label } => {
                self.lower_loop(body, label, &expr.ty, expr.span.clone());
            }

            ExprKind::While { condition, body, label } => {
                self.lower_while(condition, body, label, &expr.ty, expr.span.clone());
            }

            ExprKind::Return(value) => {
                self.lower_return(value, expr.span.clone());
            }

            ExprKind::Break { label, value } => {
                self.lower_break(label, value, expr.span.clone());
            }

            ExprKind::Continue { label } => {
                self.lower_continue(label, expr.span.clone());
            }

            ExprKind::Closure { body_id, captures } => {
                self.lower_nested_closure(body_id, captures, &expr.ty, expr.span.clone());
            }

            ExprKind::Borrow { expr: inner, mutable } => {
                self.lower_borrow(inner, *mutable, &expr.ty, expr.span.clone());
            }

            ExprKind::Deref(inner) => {
                self.lower_deref(inner, &expr.ty, expr.span.clone());
            }

            ExprKind::AddrOf { expr: inner, mutable } => {
                self.lower_addr_of(inner, *mutable, &expr.ty, expr.span.clone());
            }

            ExprKind::Let { pattern, init } => {
                self.lower_let(pattern, init, expr.span.clone());
            }

            ExprKind::Unsafe(inner) => {
                self.lower_expr(inner);
            }

            ExprKind::Perform { effect_id, op_index, args } => {
                self.lower_perform(effect_id, *op_index, args, &expr.ty, expr.span.clone());
            }

            ExprKind::Resume { value } => {
                self.lower_resume(value, expr.span.clone());
            }

            ExprKind::Handle { body, handler_id, handler_instance } => {
                self.lower_handle(body, handler_id, handler_instance, &expr.ty, expr.span.clone());
            }

            ExprKind::InlineHandle { body, handlers } => {
                self.lower_inline_handle(body, handlers, &expr.ty, expr.span.clone());
            }

            ExprKind::Range { start, end, inclusive } => {
                self.lower_range(start, end, *inclusive, &expr.ty, expr.span.clone());
            }

            ExprKind::Default => {
                let temp = self.new_temp(expr.ty.clone(), expr.span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::ZeroInit { ty: expr.ty.clone() },
                );
                Result::Ok(Operand::copy(Place::local(temp)))
            }

            ExprKind::Error => {
                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
        }
    }

    /// Get capture info by HIR LocalId.
    fn get_capture_by_id(&self, hir_id: &HirLocalId) -> &(Capture, Type) {
        match self.capture_map.get(&hir_id.index()) {
            Option::Some(idx) => &self.captures[*idx as usize],
            Option::None => &self.captures[0], // Should not happen
        }
    }

    // ========================================================================
    // Expression Lowering Helpers (largely similar to FunctionLowering)
    // ========================================================================

    fn lower_binary(
        &mut self,
        op: &HirBinOp,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Handle short-circuit operators
        match op {
            HirBinOp::And => return self.lower_short_circuit_and(left, right, ty, span),
            HirBinOp::Or => return self.lower_short_circuit_or(left, right, ty, span),
            _ => {}
        };

        let left_op = self.lower_expr(left)?;
        let right_op = self.lower_expr(right)?;
        let result = self.new_temp(ty.clone(), span);
        let mir_op = convert_binop(op);

        self.push_assign(
            Place::local(result.clone()),
            Rvalue::BinaryOp { op: mir_op, left: left_op, right: right_op },
        );

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_short_circuit_and(
        &mut self,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span.clone());
        let right_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        let left_op = self.lower_expr(left)?;

        self.terminate(TerminatorKind::SwitchInt {
            discr: left_op.clone(),
            targets: SwitchTargets::new([(1, right_block.clone())], join_block.clone()),
        });

        self.current_block = join_block.clone();
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: left_op });
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        self.current_block = right_block;
        let right_op = self.lower_expr(right)?;
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: right_op });
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        self.current_block = join_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_short_circuit_or(
        &mut self,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span.clone());
        let right_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        let left_op = self.lower_expr(left)?;

        self.terminate(TerminatorKind::SwitchInt {
            discr: left_op.clone(),
            targets: SwitchTargets::new([(0, right_block.clone())], join_block.clone()),
        });

        self.current_block = join_block.clone();
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: left_op });
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        self.current_block = right_block;
        let right_op = self.lower_expr(right)?;
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: right_op });
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        self.current_block = join_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_unary(
        &mut self,
        op: &HirUnaryOp,
        operand: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        match op {
            HirUnaryOp::Deref => self.lower_deref(operand, ty, span),
            HirUnaryOp::Ref => self.lower_borrow(operand, false, ty, span),
            HirUnaryOp::RefMut => self.lower_borrow(operand, true, ty, span),
            HirUnaryOp::Neg | HirUnaryOp::Not => {
                let inner = self.lower_expr(operand)?;
                let mir_op = convert_unop(op).unwrap();
                let result = self.new_temp(ty.clone(), span);
                self.push_assign(
                    Place::local(result.clone()),
                    Rvalue::UnaryOp { op: mir_op, operand: inner },
                );
                Result::Ok(Operand::copy(Place::local(result)))
            }
        }
    }

    fn lower_call(
        &mut self,
        callee: &Expr,
        args: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let func_op = self.lower_expr(callee)?;
        let mut arg_ops: [Operand] = [];
        let mut i: usize = 0;
        while i < args.len() {
            let op = self.lower_expr(&args[i])?;
            arg_ops.push(op);
            i = i + 1;
        };

        let dest = self.new_temp(ty.clone(), span);
        let dest_place = Place::local(dest.clone());
        let next_block = self.builder.new_block();

        self.terminate(TerminatorKind::Call {
            func: func_op,
            args: arg_ops,
            destination: dest_place.clone(),
            target: Option::Some(next_block.clone()),
            unwind: Option::None,
        });

        self.current_block = next_block;
        Result::Ok(Operand::copy(dest_place))
    }

    fn lower_method_call(
        &mut self,
        receiver: &Expr,
        method: &DefId,
        args: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let receiver_op = self.lower_expr(receiver)?;
        let func_op = Operand::constant(Constant::new(
            Type::fn_def(method.clone()),
            ConstantKind::FnDef { def_id: method.clone() },
        ));

        let mut arg_ops: [Operand] = [receiver_op];
        let mut i: usize = 0;
        while i < args.len() {
            arg_ops.push(self.lower_expr(&args[i])?);
            i = i + 1;
        };

        let dest = self.new_temp(ty.clone(), span);
        let dest_place = Place::local(dest.clone());
        let next_block = self.builder.new_block();

        self.terminate(TerminatorKind::Call {
            func: func_op,
            args: arg_ops,
            destination: dest_place.clone(),
            target: Option::Some(next_block.clone()),
            unwind: Option::None,
        });

        self.current_block = next_block;
        Result::Ok(Operand::copy(dest_place))
    }

    fn lower_field(
        &mut self,
        base: &Expr,
        field_idx: u32,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let base_place = self.lower_place(base)?;
        let field_place = base_place.project(PlaceElem::Field { index: field_idx });
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Use { operand: Operand::copy(field_place) },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_index(
        &mut self,
        base: &Expr,
        index: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let base_place = self.lower_place(base)?;
        let index_op = self.lower_expr(index)?;

        let index_local = match index_op.place() {
            Option::Some(p) => p.base_local().clone(),
            Option::None => {
                let temp = self.new_temp(Type::usize(), span.clone());
                self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: index_op });
                temp
            }
        };

        let index_place = base_place.project(PlaceElem::Index { local: index_local });
        let result = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: Operand::copy(index_place) },
        );
        Result::Ok(Operand::copy(Place::local(result)))
    }

    /// Lower an expression to a place.
    fn lower_place(&mut self, expr: &Expr) -> Result<Place, [String]> {
        match &expr.kind {
            ExprKind::Local(local_id) => {
                // Check for captured variable
                match self.get_capture_place(local_id) {
                    Option::Some(capture_place) => {
                        let (cap, _) = self.get_capture_by_id(local_id);
                        if cap.by_ref {
                            Result::Ok(capture_place.project(PlaceElem::Deref))
                        } else {
                            Result::Ok(capture_place)
                        }
                    }
                    Option::None => {
                        let mir_local = match self.local_map.get(&local_id.index()) {
                            Option::Some(id) => id.clone(),
                            Option::None => MirLocalId::new(0),
                        };
                        Result::Ok(Place::local(mir_local))
                    }
                }
            }
            ExprKind::Field { base, field_idx } => {
                let base_place = self.lower_place(base)?;
                Result::Ok(base_place.project(PlaceElem::Field { index: *field_idx }))
            }
            ExprKind::Index { base, index } => {
                let base_place = self.lower_place(base)?;
                let index_op = self.lower_expr(index)?;
                let index_local = match index_op.place() {
                    Option::Some(p) => p.base_local().clone(),
                    Option::None => {
                        let temp = self.new_temp(Type::usize(), expr.span.clone());
                        self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: index_op });
                        temp
                    }
                };
                Result::Ok(base_place.project(PlaceElem::Index { local: index_local }))
            }
            ExprKind::Deref(inner) => {
                let inner_place = self.lower_place(inner)?;
                Result::Ok(inner_place.project(PlaceElem::Deref))
            }
            _ => {
                let val = self.lower_expr(expr)?;
                match val.place() {
                    Option::Some(p) => Result::Ok(p.clone()),
                    Option::None => {
                        let temp = self.new_temp(expr.ty.clone(), expr.span.clone());
                        self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: val });
                        Result::Ok(Place::local(temp))
                    }
                }
            }
        }
    }

    // ========================================================================
    // Aggregate Construction
    // ========================================================================

    fn lower_tuple(&mut self, elems: &[Expr], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < elems.len() {
            operands.push(self.lower_expr(&elems[i])?);
            i = i + 1;
        };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Tuple, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_array(&mut self, elems: &[Expr], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < elems.len() {
            operands.push(self.lower_expr(&elems[i])?);
            i = i + 1;
        };
        let elem_ty = if elems.len() > 0 { elems[0].ty.clone() } else { Type::unit() };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Array { element_ty: elem_ty }, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_repeat(&mut self, value: &Expr, count: u64, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let value_op = self.lower_expr(value)?;
        let mut operands: [Operand] = [];
        let mut i: u64 = 0;
        while i < count {
            operands.push(value_op.clone());
            i = i + 1;
        };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Array { element_ty: value.ty.clone() }, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_struct(&mut self, def_id: &DefId, fields: &[FieldExpr], _base: &Option<Box<Expr>>, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut indexed: [(u32, Operand)] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            indexed.push((fields[i].field_idx, self.lower_expr(&fields[i].value)?));
            i = i + 1;
        };
        indexed.sort_by_key(|(idx, _)| *idx);
        let mut operands: [Operand] = [];
        let mut j: usize = 0;
        while j < indexed.len() {
            operands.push(indexed[j].1.clone());
            j = j + 1;
        };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Adt { def_id: def_id.clone(), variant_idx: Option::None, type_args: [] }, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_record(&mut self, fields: &[RecordFieldExpr], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            operands.push(self.lower_expr(&fields[i].value)?);
            i = i + 1;
        };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Record, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_variant(&mut self, def_id: &DefId, variant_idx: u32, fields: &[Expr], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            operands.push(self.lower_expr(&fields[i])?);
            i = i + 1;
        };
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Adt { def_id: def_id.clone(), variant_idx: Option::Some(variant_idx), type_args: [] }, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    // ========================================================================
    // Cast and Reference Operations
    // ========================================================================

    fn lower_cast(&mut self, inner: &Expr, target_ty: &Type, span: Span) -> Result<Operand, [String]> {
        let inner_op = self.lower_expr(inner)?;
        let temp = self.new_temp(target_ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Cast { operand: inner_op, target_ty: target_ty.clone() });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_borrow(&mut self, inner: &Expr, mutable: bool, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let place = self.lower_place(inner)?;
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Ref { place, mutable });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_deref(&mut self, inner: &Expr, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let inner_val = self.lower_expr(inner)?;
        let inner_place = match inner_val.place() {
            Option::Some(p) => p.clone(),
            Option::None => {
                let temp = self.new_temp(inner.ty.clone(), span.clone());
                self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: inner_val });
                Place::local(temp)
            }
        };

        // Generation validation
        let gen_temp = self.new_temp(Type::u32(), span.clone());
        self.push_assign(Place::local(gen_temp.clone()), Rvalue::ReadGeneration { place: inner_place.clone() });
        self.push_stmt(StatementKind::ValidateGeneration { ptr: inner_place.clone(), expected_gen: Operand::copy(Place::local(gen_temp)) }, span.clone());

        let deref_place = inner_place.project(PlaceElem::Deref);
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: Operand::copy(deref_place) });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_addr_of(&mut self, inner: &Expr, mutable: bool, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let place = self.lower_place(inner)?;
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::AddressOf { place, mutable });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    // ========================================================================
    // Assignment and Let
    // ========================================================================

    fn lower_assign(&mut self, target: &Expr, value: &Expr, _span: Span) -> Result<Operand, [String]> {
        let place = self.lower_place(target)?;
        let val = self.lower_expr(value)?;
        self.push_assign(place, Rvalue::Use { operand: val });
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_let(&mut self, pattern: &Pattern, init: &Expr, _span: Span) -> Result<Operand, [String]> {
        let init_val = self.lower_expr(init)?;
        let temp = self.new_temp(init.ty.clone(), init.span.clone());
        self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: init_val });
        self.bind_pattern(pattern, &Place::local(temp))?;
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    // ========================================================================
    // Control Flow
    // ========================================================================

    fn lower_block(&mut self, stmts: &[Stmt], expr: &Option<Box<Expr>>, _ty: &Type, _span: Span) -> Result<Operand, [String]> {
        let mut i: usize = 0;
        while i < stmts.len() {
            self.lower_stmt(&stmts[i])?;
            i = i + 1;
        };
        match expr {
            Option::Some(e) => self.lower_expr(e),
            Option::None => Result::Ok(Operand::constant(Constant::unit(Type::unit()))),
        }
    }

    fn lower_stmt(&mut self, stmt: &Stmt) -> Result<(), [String]> {
        match stmt {
            Stmt::Expr(expr) => {
                let _ = self.lower_expr(expr)?;
                Result::Ok(())
            }
            Stmt::Let { pattern, init, ty: _ } => {
                let init_val = self.lower_expr(init)?;
                let temp = self.new_temp(init.ty.clone(), init.span.clone());
                self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: init_val });
                self.bind_pattern(pattern, &Place::local(temp))?;
                Result::Ok(())
            }
        }
    }

    fn lower_if(&mut self, condition: &Expr, then_branch: &Expr, else_branch: &Option<Box<Expr>>, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span);
        let then_block = self.builder.new_block();
        let else_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        let cond_op = self.lower_expr(condition)?;
        self.terminate(TerminatorKind::SwitchInt { discr: cond_op, targets: SwitchTargets::new([(1, then_block.clone())], else_block.clone()) });

        self.current_block = then_block;
        let then_val = self.lower_expr(then_branch)?;
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: then_val });
        if !self.is_terminated() { self.terminate(TerminatorKind::Goto { target: join_block.clone() }); }

        self.current_block = else_block;
        let else_val = match else_branch {
            Option::Some(e) => self.lower_expr(e)?,
            Option::None => Operand::constant(Constant::unit(Type::unit())),
        };
        self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: else_val });
        if !self.is_terminated() { self.terminate(TerminatorKind::Goto { target: join_block.clone() }); }

        self.current_block = join_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_loop(&mut self, body: &Expr, label: &Option<LoopId>, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let loop_block = self.builder.new_block();
        let exit_block = self.builder.new_block();
        let result = self.new_temp(ty.clone(), span);

        self.push_loop_context(label.clone(), LoopContext::new(exit_block.clone(), loop_block.clone(), Option::Some(Place::local(result.clone()))));
        self.terminate(TerminatorKind::Goto { target: loop_block.clone() });

        self.current_block = loop_block;
        let _ = self.lower_expr(body)?;
        if !self.is_terminated() { self.terminate(TerminatorKind::Goto { target: loop_block.clone() }); }

        self.pop_loop_context();
        self.current_block = exit_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_while(&mut self, condition: &Expr, body: &Expr, label: &Option<LoopId>, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let cond_block = self.builder.new_block();
        let body_block = self.builder.new_block();
        let exit_block = self.builder.new_block();
        let result = self.new_temp(ty.clone(), span);

        self.push_loop_context(label.clone(), LoopContext::new(exit_block.clone(), cond_block.clone(), Option::Some(Place::local(result.clone()))));
        self.terminate(TerminatorKind::Goto { target: cond_block.clone() });

        self.current_block = cond_block.clone();
        let cond_op = self.lower_expr(condition)?;
        self.terminate(TerminatorKind::SwitchInt { discr: cond_op, targets: SwitchTargets::new([(1, body_block.clone())], exit_block.clone()) });

        self.current_block = body_block;
        let _ = self.lower_expr(body)?;
        if !self.is_terminated() { self.terminate(TerminatorKind::Goto { target: cond_block }); }

        self.pop_loop_context();
        self.current_block = exit_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_return(&mut self, value: &Option<Box<Expr>>, _span: Span) -> Result<Operand, [String]> {
        let return_place = Place::local(MirLocalId::return_place());
        let val = match value {
            Option::Some(e) => self.lower_expr(e)?,
            Option::None => Operand::constant(Constant::unit(Type::unit())),
        };
        self.push_assign(return_place, Rvalue::Use { operand: val });
        self.terminate(TerminatorKind::Return);
        let next = self.builder.new_block();
        self.current_block = next;
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_break(&mut self, label: &Option<LoopId>, value: &Option<Box<Expr>>, _span: Span) -> Result<Operand, [String]> {
        match self.get_loop_context(label.clone()) {
            Option::Some(ctx) => {
                let break_block = ctx.break_block.clone();
                let result_place = ctx.result_place.clone();
                if let Option::Some(v) = value {
                    let val = self.lower_expr(v)?;
                    if let Option::Some(rp) = result_place { self.push_assign(rp, Rvalue::Use { operand: val }); }
                };
                self.terminate(TerminatorKind::Goto { target: break_block });
                let next = self.builder.new_block();
                self.current_block = next;
                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
            Option::None => Result::Err(["break outside of loop".to_string()]),
        }
    }

    fn lower_continue(&mut self, label: &Option<LoopId>, _span: Span) -> Result<Operand, [String]> {
        match self.get_loop_context(label.clone()) {
            Option::Some(ctx) => {
                self.terminate(TerminatorKind::Goto { target: ctx.continue_block.clone() });
                let next = self.builder.new_block();
                self.current_block = next;
                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
            Option::None => Result::Err(["continue outside of loop".to_string()]),
        }
    }

    // ========================================================================
    // Nested Closure Lowering
    // ========================================================================

    fn lower_nested_closure(&mut self, body_id: &BodyId, captures: &[Capture], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let synthetic_id = CLOSURE_DEF_ID_START + self.closure_counter;
        self.closure_counter = self.closure_counter + 1;
        let closure_def_id = DefId::new(synthetic_id);

        let mut capture_pairs: [(Capture, Type)] = [];
        let mut i: usize = 0;
        while i < captures.len() {
            let cap = &captures[i];
            // Get type from our local map or captures
            let cap_ty = self.get_local_type_or_capture(&cap.local_id);
            capture_pairs.push((cap.clone(), cap_ty));
            i = i + 1;
        };

        self.pending_closures.push((body_id.clone(), closure_def_id.clone(), capture_pairs));

        // Build environment
        let mut capture_ops: [Operand] = [];
        let mut j: usize = 0;
        while j < captures.len() {
            let cap = &captures[j];
            let cap_place = match self.get_capture_place(&cap.local_id) {
                Option::Some(p) => {
                    let (orig_cap, _) = self.get_capture_by_id(&cap.local_id);
                    if orig_cap.by_ref { p.project(PlaceElem::Deref) } else { p }
                }
                Option::None => {
                    let mir_local = match self.local_map.get(&cap.local_id.index()) {
                        Option::Some(id) => id.clone(),
                        Option::None => MirLocalId::new(0),
                    };
                    Place::local(mir_local)
                }
            };

            let cap_op = if cap.by_ref {
                let ref_temp = self.new_temp(Type::reference(cap.ty.clone(), cap.mutable), span.clone());
                self.push_assign(Place::local(ref_temp.clone()), Rvalue::Ref { place: cap_place, mutable: cap.mutable });
                Operand::copy(Place::local(ref_temp))
            } else {
                Operand::copy(cap_place)
            };
            capture_ops.push(cap_op);
            j = j + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Closure { def_id: closure_def_id }, operands: capture_ops });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn get_local_type_or_capture(&self, local_id: &HirLocalId) -> Type {
        match self.capture_map.get(&local_id.index()) {
            Option::Some(idx) => {
                let (_, ty) = &self.captures[*idx as usize];
                ty.clone();
            }
            Option::None => {
                // Try body locals
                match self.body.get_local(local_id) {
                    Option::Some(local) => local.ty.clone(),
                    Option::None => Type::unit(),
                }
            }
        }
    }

    // ========================================================================
    // Range and Effects
    // ========================================================================

    fn lower_range(&mut self, start: &Option<Box<Expr>>, end: &Option<Box<Expr>>, inclusive: bool, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        match start {
            Option::Some(s) => operands.push(self.lower_expr(s)?),
            Option::None => operands.push(Operand::constant(Constant::int(0, Type::i64()))),
        };
        match end {
            Option::Some(e) => operands.push(self.lower_expr(e)?),
            Option::None => operands.push(Operand::constant(Constant::int(i64::MAX as i128, Type::i64()))),
        };
        if inclusive { operands.push(Operand::constant(Constant::bool(false, Type::bool()))); }

        let elem_ty = match start {
            Option::Some(s) => s.ty.clone(),
            Option::None => match end { Option::Some(e) => e.ty.clone(), Option::None => Type::i64() }
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(temp.clone()), Rvalue::Aggregate { kind: AggregateKind::Range { element: elem_ty, inclusive }, operands });
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_perform(&mut self, effect_id: &DefId, op_index: u32, args: &[Expr], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let mut arg_ops: [Operand] = [];
        let mut i: usize = 0;
        while i < args.len() {
            arg_ops.push(self.lower_expr(&args[i])?);
            i = i + 1;
        };
        let dest = self.new_temp(ty.clone(), span);
        let next_block = self.builder.new_block();
        self.terminate(TerminatorKind::Perform { effect_id: effect_id.clone(), op_index, args: arg_ops, destination: Place::local(dest.clone()), target: next_block.clone(), is_tail_resumptive: false });
        self.current_block = next_block;
        Result::Ok(Operand::copy(Place::local(dest)))
    }

    fn lower_resume(&mut self, value: &Option<Box<Expr>>, _span: Span) -> Result<Operand, [String]> {
        let resume_val = match value {
            Option::Some(v) => Option::Some(self.lower_expr(v)?),
            Option::None => Option::None,
        };
        self.terminate(TerminatorKind::Resume { value: resume_val });
        let next = self.builder.new_block();
        self.current_block = next;
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_handle(&mut self, body: &Expr, handler_id: &DefId, handler_instance: &Expr, ty: &Type, span: Span) -> Result<Operand, [String]> {
        let state_op = self.lower_expr(handler_instance)?;
        let state_local = self.new_temp(handler_instance.ty.clone(), span.clone());
        self.push_assign(Place::local(state_local.clone()), Rvalue::Use { operand: state_op });
        self.push_stmt(StatementKind::PushHandler { handler_id: handler_id.clone(), state_place: Place::local(state_local) }, span.clone());
        self.handler_depth = self.handler_depth + 1;
        let body_result = self.lower_expr(body)?;
        self.handler_depth = self.handler_depth - 1;
        self.push_stmt(StatementKind::PopHandler, span.clone());
        let dest = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(dest.clone()), Rvalue::Use { operand: body_result });
        Result::Ok(Operand::copy(Place::local(dest)))
    }

    fn lower_inline_handle(&mut self, body: &Expr, _handlers: &[InlineOpHandler], ty: &Type, span: Span) -> Result<Operand, [String]> {
        self.handler_depth = self.handler_depth + 1;
        let body_result = self.lower_expr(body)?;
        self.handler_depth = self.handler_depth - 1;
        let dest = self.new_temp(ty.clone(), span);
        self.push_assign(Place::local(dest.clone()), Rvalue::Use { operand: body_result });
        Result::Ok(Operand::copy(Place::local(dest)))
    }

    // ========================================================================
    // Pattern Matching (simplified - delegates to test_pattern/bind_pattern)
    // ========================================================================

    fn lower_match(&mut self, scrutinee: &Expr, arms: &[MatchArm], ty: &Type, span: Span) -> Result<Operand, [String]> {
        let scrutinee_val = self.lower_expr(scrutinee)?;
        let scrutinee_place = match scrutinee_val.place() {
            Option::Some(p) => p.clone(),
            Option::None => {
                let temp = self.new_temp(scrutinee.ty.clone(), scrutinee.span.clone());
                self.push_assign(Place::local(temp.clone()), Rvalue::Use { operand: scrutinee_val });
                Place::local(temp)
            }
        };

        let result = self.new_temp(ty.clone(), span.clone());
        let join_block = self.builder.new_block();

        let mut arm_blocks: [BasicBlockId] = [];
        let mut i: usize = 0;
        while i < arms.len() { arm_blocks.push(self.builder.new_block()); i = i + 1; }
        let fallthrough_block = self.builder.new_block();

        let mut current_test_block = self.current_block.clone();
        let mut j: usize = 0;
        while j < arms.len() {
            let arm_block = arm_blocks[j].clone();
            let next_test_block = if j + 1 < arms.len() { self.builder.new_block() } else { fallthrough_block.clone() };
            self.current_block = current_test_block.clone();
            let matches = self.test_pattern(&arms[j].pattern, &scrutinee_place)?;
            self.terminate(TerminatorKind::SwitchInt { discr: matches, targets: SwitchTargets::new([(1, arm_block)], next_test_block.clone()) });
            current_test_block = next_test_block;
            j = j + 1;
        };

        self.current_block = fallthrough_block;
        self.terminate(TerminatorKind::Unreachable);

        let mut k: usize = 0;
        while k < arms.len() {
            self.current_block = arm_blocks[k].clone();
            self.bind_pattern(&arms[k].pattern, &scrutinee_place)?;
            match &arms[k].guard {
                Option::Some(guard) => {
                    let guard_pass = self.builder.new_block();
                    let guard_fail = if k + 1 < arms.len() { arm_blocks[k + 1].clone() } else { fallthrough_block.clone() };
                    let guard_result = self.lower_expr(guard)?;
                    self.terminate(TerminatorKind::SwitchInt { discr: guard_result, targets: SwitchTargets::new([(1, guard_pass.clone())], guard_fail) });
                    self.current_block = guard_pass;
                }
                Option::None => {}
            };
            let arm_val = self.lower_expr(&arms[k].body)?;
            self.push_assign(Place::local(result.clone()), Rvalue::Use { operand: arm_val });
            self.terminate(TerminatorKind::Goto { target: join_block.clone() });
            k = k + 1;
        };

        self.current_block = join_block;
        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn test_pattern(&mut self, pattern: &Pattern, place: &Place) -> Result<Operand, [String]> {
        match &pattern.kind {
            PatternKind::Wildcard => Result::Ok(Operand::constant(Constant::bool(true, Type::bool()))),
            PatternKind::Binding { subpattern, .. } => {
                match subpattern { Option::Some(sub) => self.test_pattern(sub, place), Option::None => Result::Ok(Operand::constant(Constant::bool(true, Type::bool()))) }
            }
            PatternKind::Literal(lit) => {
                let lit_const = lower_literal(lit, &pattern.ty);
                let result = self.new_temp(Type::bool(), pattern.span.clone());
                self.push_assign(Place::local(result.clone()), Rvalue::BinaryOp { op: MirBinOp::Eq, left: Operand::copy(place.clone()), right: Operand::constant(lit_const) });
                Result::Ok(Operand::copy(Place::local(result)))
            }
            _ => Result::Ok(Operand::constant(Constant::bool(true, Type::bool()))),
        }
    }

    fn bind_pattern(&mut self, pattern: &Pattern, place: &Place) -> Result<(), [String]> {
        match &pattern.kind {
            PatternKind::Wildcard => Result::Ok(()),
            PatternKind::Binding { local_id, mutable, subpattern, .. } => {
                let mir_local = match self.local_map.get(&local_id.index()) {
                    Option::Some(id) => id.clone(),
                    Option::None => MirLocalId::new(0),
                };
                if pattern.ty.is_ref() {
                    self.push_assign(Place::local(mir_local.clone()), Rvalue::Ref { place: place.clone(), mutable: *mutable });
                } else {
                    self.push_assign(Place::local(mir_local.clone()), Rvalue::Use { operand: Operand::copy(place.clone()) });
                };
                match subpattern { Option::Some(sub) => self.bind_pattern(sub, &Place::local(mir_local)), Option::None => Result::Ok(()) }
            }
            PatternKind::Tuple(pats) => {
                let mut i: usize = 0;
                while i < pats.len() {
                    self.bind_pattern(&pats[i], &place.project(PlaceElem::Field { index: i as u32 }))?;
                    i = i + 1;
                }
                Result::Ok(())
            }
            PatternKind::Struct { fields, .. } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    self.bind_pattern(&fields[i].pattern, &place.project(PlaceElem::Field { index: fields[i].field_idx }))?;
                    i = i + 1;
                }
                Result::Ok(())
            }
            PatternKind::Variant { variant_idx, fields, .. } => {
                let variant_place = place.project(PlaceElem::Downcast { variant: *variant_idx });
                let mut i: usize = 0;
                while i < fields.len() {
                    self.bind_pattern(&fields[i], &variant_place.project(PlaceElem::Field { index: i as u32 }))?;
                    i = i + 1;
                }
                Result::Ok(())
            }
            _ => Result::Ok(()),
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_closure_lowering_new() {
    assert!(true);
}
