/// Function Body Lowering
///
/// This module contains the `FunctionLowering` struct which handles the
/// lowering of individual function bodies from HIR to MIR.
///
/// # Key Responsibilities
///
/// - Create MIR local variables from HIR locals
/// - Lower expressions to MIR statements and terminators
/// - Handle control flow (if, match, loops)
/// - Handle pattern matching (test and bind)
/// - Handle effect operations (perform, resume, handle)
/// - Track loop contexts for break/continue
/// - Discover closures for later lowering
///
/// # Architecture
///
/// FunctionLowering operates on a single function body at a time.
/// It maintains:
/// - A MirBodyBuilder for constructing the MIR body
/// - A mapping from HIR LocalIds to MIR LocalIds
/// - A stack of loop contexts for break/continue handling
/// - Lists of discovered closures and inline handlers
///
/// Expression lowering returns an `Operand` representing the result.
/// Complex expressions are broken down into simple MIR statements.

use std.collections::HashMap;
use std.compiler.hir::{
    Body, Expr, ExprKind, Local,
    LiteralValue, BinOp as HirBinOp, UnaryOp as HirUnaryOp,
    Pattern, PatternKind, MatchArm, Stmt, FieldExpr, RecordFieldExpr,
    Capture, InlineOpHandler, FieldPattern,
    LocalId as HirLocalId, LoopId, BodyId, Crate as HirCrate, Span,
};
use std.compiler.mir::{
    LocalId as MirLocalId, BasicBlockId, BasicBlockData,
    Statement, StatementKind, Terminator, TerminatorKind,
    Place, PlaceElem, Operand, Rvalue,
    BinOp as MirBinOp, UnOp as MirUnOp, AggregateKind,
    Constant, ConstantKind, SwitchTargets,
    MirBody, MirBodyBuilder, MirLocal, LocalKind, SourceScope,
};
use std.compiler.typeck::types::{Type, DefId};
use std.compiler.mir::lowering::util::{
    convert_binop, convert_unop, lower_literal, is_irrefutable_pattern,
    LoopContext, CLOSURE_DEF_ID_START, INLINE_HANDLER_DEF_ID_START,
};

// ============================================================
// Function Lowering Context
// ============================================================

/// Per-function lowering context.
///
/// This struct maintains all state needed while lowering a single function
/// body from HIR to MIR.
pub struct FunctionLowering<'hir> {
    /// The DefId of the function being lowered.
    def_id: DefId,
    /// The HIR body being lowered.
    body: &'hir Body,
    /// Reference to the full HIR crate.
    hir: &'hir HirCrate,
    /// The MIR body builder.
    builder: MirBodyBuilder,
    /// Mapping from HIR LocalIds to MIR LocalIds.
    local_map: HashMap<u32, MirLocalId>,
    /// The current basic block being built.
    current_block: BasicBlockId,
    /// Stack of loop contexts for break/continue.
    loop_stack: [(Option<LoopId>, LoopContext)],
    /// Counter for generating temporary locals.
    temp_counter: u32,
    /// Discovered closures pending lowering: (BodyId, synthetic DefId, captures).
    pending_closures: [(BodyId, DefId, [(Capture, Type)])],
    /// Counter for generating synthetic closure DefIds.
    closure_counter: u32,
    /// Counter for generating synthetic inline handler DefIds.
    inline_handler_counter: u32,
    /// Nested handler depth (for inline evidence mode analysis).
    handler_depth: usize,
}

impl<'hir> FunctionLowering<'hir> {
    /// Create a new function lowering context.
    pub fn new(
        def_id: DefId,
        body: &'hir Body,
        hir: &'hir HirCrate,
    ) -> FunctionLowering<'hir> {
        let builder = MirBodyBuilder::new();

        FunctionLowering {
            def_id,
            body,
            hir,
            builder,
            local_map: HashMap::new(),
            current_block: BasicBlockId::entry(),
            loop_stack: [],
            temp_counter: 0,
            pending_closures: [],
            closure_counter: 0,
            inline_handler_counter: 0,
            handler_depth: 0,
        }
    }

    // ========================================================================
    // Main Entry Point
    // ========================================================================

    /// Lower the function body to MIR.
    ///
    /// Returns the completed MIR body and any discovered closures.
    pub fn lower(mut self) -> (MirBody, [(BodyId, DefId, [(Capture, Type)])]) {
        // Step 1: Create locals
        self.create_locals();

        // Step 2: Create entry block
        self.current_block = self.builder.new_block();

        // Step 3: Lower the body expression
        let result = self.lower_expr(&self.body.expr);

        // Step 4: Assign result to return place and terminate
        match result {
            Result::Ok(operand) => {
                let return_place = Place::local(MirLocalId::return_place());
                self.push_assign(return_place, Rvalue::Use { operand });
                if !self.is_terminated() {
                    self.terminate(TerminatorKind::Return);
                }
            }
            Result::Err(diags) => {
                // Error during lowering - terminate with unreachable
                self.terminate(TerminatorKind::Unreachable);
            }
        };

        // Step 5: Build and return
        let mir_body = self.builder.build();
        (mir_body, self.pending_closures)
    }

    // ========================================================================
    // Local Variable Management
    // ========================================================================

    /// Create MIR locals from HIR locals.
    fn create_locals(&mut self) {
        let mut i: usize = 0;
        while i < self.body.locals.len() {
            let hir_local = &self.body.locals[i];
            let kind = if i == 0 {
                LocalKind::ReturnPlace
            } else if i <= self.body.param_count {
                LocalKind::Arg
            } else {
                LocalKind::Var
            };

            let mir_local = MirLocal {
                kind,
                ty: hir_local.ty.clone(),
                mutable: hir_local.mutable,
                name: hir_local.name.clone(),
                span: hir_local.span.clone(),
            };

            let mir_id = self.builder.push_local(mir_local);
            self.local_map.insert(hir_local.id.index(), mir_id);
            i = i + 1;
        }
    }

    /// Map a HIR LocalId to a MIR LocalId.
    fn map_local(&self, hir_id: HirLocalId) -> MirLocalId {
        match self.local_map.get(&hir_id.index()) {
            Option::Some(mir_id) => mir_id.clone(),
            Option::None => {
                // This should not happen - indicates a bug
                MirLocalId::new(0)
            }
        }
    }

    /// Create a new temporary local.
    fn new_temp(&mut self, ty: Type, span: Span) -> MirLocalId {
        let mir_local = MirLocal {
            kind: LocalKind::Temp,
            ty,
            mutable: false,
            name: Option::None,
            span,
        };
        self.builder.push_local(mir_local);
    }

    // ========================================================================
    // Statement and Terminator Helpers
    // ========================================================================

    /// Push an assignment statement to the current block.
    fn push_assign(&mut self, place: Place, rvalue: Rvalue) {
        let stmt = Statement::new(
            StatementKind::Assign { place, rvalue },
            Span::dummy(),
        );
        self.builder.push_statement(self.current_block.clone(), stmt);
    }

    /// Push a statement to the current block.
    fn push_stmt(&mut self, kind: StatementKind, span: Span) {
        let stmt = Statement::new(kind, span);
        self.builder.push_statement(self.current_block.clone(), stmt);
    }

    /// Set the terminator for the current block.
    fn terminate(&mut self, kind: TerminatorKind) {
        let term = Terminator::new(kind, Span::dummy());
        self.builder.set_terminator(self.current_block.clone(), term);
    }

    /// Check if the current block has a terminator.
    fn is_terminated(&self) -> bool {
        self.builder.is_block_terminated(self.current_block.clone());
    }

    // ========================================================================
    // Loop Context Management
    // ========================================================================

    /// Push a loop context onto the stack.
    fn push_loop_context(&mut self, label: Option<LoopId>, ctx: LoopContext) {
        self.loop_stack.push((label, ctx));
    }

    /// Pop a loop context from the stack.
    fn pop_loop_context(&mut self) {
        self.loop_stack.pop();
    }

    /// Get the loop context for a given label (or innermost if None).
    fn get_loop_context(&self, label: Option<LoopId>) -> Option<&LoopContext> {
        match label {
            Option::None => {
                // Get innermost loop
                if self.loop_stack.len() > 0 {
                    let (_, ctx) = &self.loop_stack[self.loop_stack.len() - 1];
                    Option::Some(ctx)
                } else {
                    Option::None
                }
            }
            Option::Some(target_label) => {
                // Find loop with matching label
                let mut i: usize = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    let (maybe_label, ctx) = &self.loop_stack[i];
                    match maybe_label {
                        Option::Some(l) => {
                            if l.eq(&target_label) {
                                return Option::Some(ctx);
                            }
                        }
                        Option::None => {}
                    }
                }
                Option::None
            }
        }
    }

    // ========================================================================
    // Expression Lowering
    // ========================================================================

    /// Lower an expression to a MIR operand.
    pub fn lower_expr(&mut self, expr: &Expr) -> Result<Operand, [String]> {
        match &expr.kind {
            ExprKind::Literal(lit) => {
                let constant = lower_literal(lit, &expr.ty);
                Result::Ok(Operand::constant(constant))
            }

            ExprKind::Local(local_id) => {
                let mir_local = self.map_local(local_id.clone());
                Result::Ok(Operand::copy(Place::local(mir_local)))
            }

            ExprKind::Def(def_id) => {
                // Reference to a definition (function, constant);
                let constant = Constant::new(
                    expr.ty.clone(),
                    ConstantKind::FnDef { def_id: def_id.clone() },
                );
                Result::Ok(Operand::constant(constant))
            }

            ExprKind::Binary { op, left, right } => {
                self.lower_binary(op, left, right, &expr.ty, expr.span.clone());
            }

            ExprKind::Unary { op, operand } => {
                self.lower_unary(op, operand, &expr.ty, expr.span.clone());
            }

            ExprKind::Call { callee, args } => {
                self.lower_call(callee, args, &expr.ty, expr.span.clone());
            }

            ExprKind::MethodCall { receiver, method, args } => {
                self.lower_method_call(receiver, method, args, &expr.ty, expr.span.clone());
            }

            ExprKind::Field { base, field_idx } => {
                self.lower_field(base, *field_idx, &expr.ty, expr.span.clone());
            }

            ExprKind::Index { base, index } => {
                self.lower_index(base, index, &expr.ty, expr.span.clone());
            }

            ExprKind::Tuple(elems) => {
                self.lower_tuple(elems, &expr.ty, expr.span.clone());
            }

            ExprKind::Array(elems) => {
                self.lower_array(elems, &expr.ty, expr.span.clone());
            }

            ExprKind::Repeat { value, count } => {
                self.lower_repeat(value, *count, &expr.ty, expr.span.clone());
            }

            ExprKind::Struct { def_id, fields, base } => {
                self.lower_struct(def_id, fields, base, &expr.ty, expr.span.clone());
            }

            ExprKind::Record { fields } => {
                self.lower_record(fields, &expr.ty, expr.span.clone());
            }

            ExprKind::Variant { def_id, variant_idx, fields } => {
                self.lower_variant(def_id, *variant_idx, fields, &expr.ty, expr.span.clone());
            }

            ExprKind::Cast { expr: inner, target_ty } => {
                self.lower_cast(inner, target_ty, expr.span.clone());
            }

            ExprKind::Assign { target, value } => {
                self.lower_assign(target, value, expr.span.clone());
            }

            ExprKind::Block { stmts, expr: maybe_expr } => {
                self.lower_block(stmts, maybe_expr, &expr.ty, expr.span.clone());
            }

            ExprKind::If { condition, then_branch, else_branch } => {
                self.lower_if(condition, then_branch, else_branch, &expr.ty, expr.span.clone());
            }

            ExprKind::Match { scrutinee, arms } => {
                self.lower_match(scrutinee, arms, &expr.ty, expr.span.clone());
            }

            ExprKind::Loop { body, label } => {
                self.lower_loop(body, label, &expr.ty, expr.span.clone());
            }

            ExprKind::While { condition, body, label } => {
                self.lower_while(condition, body, label, &expr.ty, expr.span.clone());
            }

            ExprKind::Return(value) => {
                self.lower_return(value, expr.span.clone());
            }

            ExprKind::Break { label, value } => {
                self.lower_break(label, value, expr.span.clone());
            }

            ExprKind::Continue { label } => {
                self.lower_continue(label, expr.span.clone());
            }

            ExprKind::Closure { body_id, captures } => {
                self.lower_closure(body_id, captures, &expr.ty, expr.span.clone());
            }

            ExprKind::Borrow { expr: inner, mutable } => {
                self.lower_borrow(inner, *mutable, &expr.ty, expr.span.clone());
            }

            ExprKind::Deref(inner) => {
                self.lower_deref(inner, &expr.ty, expr.span.clone());
            }

            ExprKind::AddrOf { expr: inner, mutable } => {
                self.lower_addr_of(inner, *mutable, &expr.ty, expr.span.clone());
            }

            ExprKind::Let { pattern, init } => {
                self.lower_let(pattern, init, expr.span.clone());
            }

            ExprKind::Unsafe(inner) => {
                // Unsafe blocks are transparent at MIR level
                self.lower_expr(inner);
            }

            ExprKind::Perform { effect_id, op_index, args } => {
                self.lower_perform(effect_id, *op_index, args, &expr.ty, expr.span.clone());
            }

            ExprKind::Resume { value } => {
                self.lower_resume(value, expr.span.clone());
            }

            ExprKind::Handle { body, handler_id, handler_instance } => {
                self.lower_handle(body, handler_id, handler_instance, &expr.ty, expr.span.clone());
            }

            ExprKind::InlineHandle { body, handlers } => {
                self.lower_inline_handle(body, handlers, &expr.ty, expr.span.clone());
            }

            ExprKind::Range { start, end, inclusive } => {
                self.lower_range(start, end, *inclusive, &expr.ty, expr.span.clone());
            }

            ExprKind::Default => {
                // Default value - use zero-initialized
                let temp = self.new_temp(expr.ty.clone(), expr.span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::ZeroInit { ty: expr.ty.clone() },
                );
                Result::Ok(Operand::copy(Place::local(temp)))
            }

            ExprKind::Error => {
                // Error expression - return unit
                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
        }
    }

    // ========================================================================
    // Binary and Unary Operations
    // ========================================================================

    fn lower_binary(
        &mut self,
        op: &HirBinOp,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Handle short-circuit operators specially
        match op {
            HirBinOp::And => {
                return self.lower_short_circuit_and(left, right, ty, span);
            }
            HirBinOp::Or => {
                return self.lower_short_circuit_or(left, right, ty, span);
            }
            _ => {}
        };

        // Lower operands
        let left_op = self.lower_expr(left)?;
        let right_op = self.lower_expr(right)?;

        // Create result temp
        let result = self.new_temp(ty.clone(), span.clone());
        let mir_op = convert_binop(op);

        self.push_assign(
            Place::local(result.clone()),
            Rvalue::BinaryOp {
                op: mir_op,
                left: left_op,
                right: right_op,
            },
        );

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_short_circuit_and(
        &mut self,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span.clone());
        let right_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        // Evaluate left
        let left_op = self.lower_expr(left)?;

        // If left is false, result is false; otherwise evaluate right
        self.terminate(TerminatorKind::SwitchInt {
            discr: left_op.clone(),
            targets: SwitchTargets::new(
                [(1, right_block.clone())],
                join_block.clone(),
            ),
        });

        // False branch: result = false
        self.current_block = join_block.clone();
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: left_op },
        );
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        // True branch: evaluate right and use as result
        let saved_block = self.current_block.clone();
        self.current_block = right_block;
        let right_op = self.lower_expr(right)?;
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: right_op },
        );
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        // Continue at join
        self.current_block = join_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_short_circuit_or(
        &mut self,
        left: &Expr,
        right: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span.clone());
        let right_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        // Evaluate left
        let left_op = self.lower_expr(left)?;

        // If left is true, result is true; otherwise evaluate right
        self.terminate(TerminatorKind::SwitchInt {
            discr: left_op.clone(),
            targets: SwitchTargets::new(
                [(0, right_block.clone())],
                join_block.clone(),
            ),
        });

        // True branch: result = true
        self.current_block = join_block.clone();
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: left_op },
        );
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        // False branch: evaluate right
        self.current_block = right_block;
        let right_op = self.lower_expr(right)?;
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: right_op },
        );
        self.terminate(TerminatorKind::Goto { target: join_block.clone() });

        // Continue at join
        self.current_block = join_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_unary(
        &mut self,
        op: &HirUnaryOp,
        operand: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        match op {
            HirUnaryOp::Deref => {
                self.lower_deref(operand, ty, span);
            }
            HirUnaryOp::Ref => {
                self.lower_borrow(operand, false, ty, span);
            }
            HirUnaryOp::RefMut => {
                self.lower_borrow(operand, true, ty, span);
            }
            HirUnaryOp::Neg | HirUnaryOp::Not => {
                let inner = self.lower_expr(operand)?;
                let mir_op = convert_unop(op).unwrap();
                let result = self.new_temp(ty.clone(), span);
                self.push_assign(
                    Place::local(result.clone()),
                    Rvalue::UnaryOp { op: mir_op, operand: inner },
                );
                Result::Ok(Operand::copy(Place::local(result)))
            }
        }
    }

    // ========================================================================
    // Call Expressions
    // ========================================================================

    fn lower_call(
        &mut self,
        callee: &Expr,
        args: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Lower callee
        let func_op = self.lower_expr(callee)?;

        // Lower arguments
        let mut arg_ops: [Operand] = [];
        let mut i: usize = 0;
        while i < args.len() {
            let arg_op = self.lower_expr(&args[i])?;
            arg_ops.push(arg_op);
            i = i + 1;
        };

        // Create destination
        let dest = self.new_temp(ty.clone(), span.clone());
        let dest_place = Place::local(dest.clone());
        let next_block = self.builder.new_block();

        // Generate call terminator
        self.terminate(TerminatorKind::Call {
            func: func_op,
            args: arg_ops,
            destination: dest_place.clone(),
            target: Option::Some(next_block.clone()),
            unwind: Option::None,
        });

        // Continue in next block
        self.current_block = next_block;

        Result::Ok(Operand::copy(dest_place))
    }

    fn lower_method_call(
        &mut self,
        receiver: &Expr,
        method: &DefId,
        args: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Method calls are desugared to regular function calls with receiver as first arg
        let receiver_op = self.lower_expr(receiver)?;

        // Create function operand from method DefId
        let func_op = Operand::constant(Constant::new(
            Type::fn_def(method.clone()),
            ConstantKind::FnDef { def_id: method.clone() },
        ));

        // Lower remaining arguments
        let mut arg_ops: [Operand] = [receiver_op];
        let mut i: usize = 0;
        while i < args.len() {
            let arg_op = self.lower_expr(&args[i])?;
            arg_ops.push(arg_op);
            i = i + 1;
        };

        // Create destination and call
        let dest = self.new_temp(ty.clone(), span.clone());
        let dest_place = Place::local(dest.clone());
        let next_block = self.builder.new_block();

        self.terminate(TerminatorKind::Call {
            func: func_op,
            args: arg_ops,
            destination: dest_place.clone(),
            target: Option::Some(next_block.clone()),
            unwind: Option::None,
        });

        self.current_block = next_block;

        Result::Ok(Operand::copy(dest_place))
    }

    // ========================================================================
    // Place and Field Operations
    // ========================================================================

    fn lower_field(
        &mut self,
        base: &Expr,
        field_idx: u32,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let base_place = self.lower_place(base)?;
        let field_place = base_place.project(PlaceElem::Field { index: field_idx });
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Use { operand: Operand::copy(field_place) },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_index(
        &mut self,
        base: &Expr,
        index: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let base_place = self.lower_place(base)?;
        let index_op = self.lower_expr(index)?;

        // Index needs to be a local for PlaceElem::Index
        let index_local = match index_op.place() {
            Option::Some(p) => p.base_local().clone(),
            Option::None => {
                let temp = self.new_temp(Type::usize(), span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::Use { operand: index_op },
                );
                temp
            }
        };

        let index_place = base_place.project(PlaceElem::Index { local: index_local });
        let result = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: Operand::copy(index_place) },
        );
        Result::Ok(Operand::copy(Place::local(result)))
    }

    /// Lower an expression to a place (for assignment targets).
    fn lower_place(&mut self, expr: &Expr) -> Result<Place, [String]> {
        match &expr.kind {
            ExprKind::Local(local_id) => {
                let mir_local = self.map_local(local_id.clone());
                Result::Ok(Place::local(mir_local))
            }
            ExprKind::Field { base, field_idx } => {
                let base_place = self.lower_place(base)?;
                Result::Ok(base_place.project(PlaceElem::Field { index: *field_idx }))
            }
            ExprKind::Index { base, index } => {
                let base_place = self.lower_place(base)?;
                let index_op = self.lower_expr(index)?;
                let index_local = match index_op.place() {
                    Option::Some(p) => p.base_local().clone(),
                    Option::None => {
                        let temp = self.new_temp(Type::usize(), expr.span.clone());
                        self.push_assign(
                            Place::local(temp.clone()),
                            Rvalue::Use { operand: index_op },
                        );
                        temp
                    }
                };
                Result::Ok(base_place.project(PlaceElem::Index { local: index_local }))
            }
            ExprKind::Deref(inner) => {
                let inner_place = self.lower_place(inner)?;
                Result::Ok(inner_place.project(PlaceElem::Deref))
            }
            ExprKind::Unary { op: HirUnaryOp::Deref, operand } => {
                let inner_place = self.lower_place(operand)?;
                Result::Ok(inner_place.project(PlaceElem::Deref))
            }
            _ => {
                // Not a place - lower to value and store in temp
                let val = self.lower_expr(expr)?;
                match val.place() {
                    Option::Some(p) => Result::Ok(p.clone()),
                    Option::None => {
                        let temp = self.new_temp(expr.ty.clone(), expr.span.clone());
                        self.push_assign(
                            Place::local(temp.clone()),
                            Rvalue::Use { operand: val },
                        );
                        Result::Ok(Place::local(temp))
                    }
                }
            }
        }
    }

    // ========================================================================
    // Aggregate Construction
    // ========================================================================

    fn lower_tuple(
        &mut self,
        elems: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < elems.len() {
            let op = self.lower_expr(&elems[i])?;
            operands.push(op);
            i = i + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate { kind: AggregateKind::Tuple, operands },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_array(
        &mut self,
        elems: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < elems.len() {
            let op = self.lower_expr(&elems[i])?;
            operands.push(op);
            i = i + 1;
        };

        // Extract element type
        let elem_ty = if elems.len() > 0 {
            elems[0].ty.clone()
        } else {
            Type::unit()
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Array { element_ty: elem_ty },
                operands,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_repeat(
        &mut self,
        value: &Expr,
        count: u64,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let value_op = self.lower_expr(value)?;

        // Create array by repeating value
        let mut operands: [Operand] = [];
        let mut i: u64 = 0;
        while i < count {
            operands.push(value_op.clone());
            i = i + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Array { element_ty: value.ty.clone() },
                operands,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_struct(
        &mut self,
        def_id: &DefId,
        fields: &[FieldExpr],
        base: &Option<Box<Expr>>,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Collect field operands, sorted by field index
        let mut indexed_fields: [(u32, Operand)] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            let op = self.lower_expr(&fields[i].value)?;
            indexed_fields.push((fields[i].field_idx, op));
            i = i + 1;
        };

        // Sort by field index
        indexed_fields.sort_by_key(|(idx, _)| *idx);

        let mut operands: [Operand] = [];
        let mut j: usize = 0;
        while j < indexed_fields.len() {
            let (_, op) = &indexed_fields[j];
            operands.push(op.clone());
            j = j + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Adt {
                    def_id: def_id.clone(),
                    variant_idx: Option::None,
                    type_args: [],
                },
                operands,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_record(
        &mut self,
        fields: &[RecordFieldExpr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            let op = self.lower_expr(&fields[i].value)?;
            operands.push(op);
            i = i + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate { kind: AggregateKind::Record, operands },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_variant(
        &mut self,
        def_id: &DefId,
        variant_idx: u32,
        fields: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];
        let mut i: usize = 0;
        while i < fields.len() {
            let op = self.lower_expr(&fields[i])?;
            operands.push(op);
            i = i + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Adt {
                    def_id: def_id.clone(),
                    variant_idx: Option::Some(variant_idx),
                    type_args: [],
                },
                operands,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    // ========================================================================
    // Cast and Borrow Operations
    // ========================================================================

    fn lower_cast(
        &mut self,
        inner: &Expr,
        target_ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let inner_op = self.lower_expr(inner)?;
        let temp = self.new_temp(target_ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Cast { operand: inner_op, target_ty: target_ty.clone() },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_borrow(
        &mut self,
        inner: &Expr,
        mutable: bool,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let place = self.lower_place(inner)?;
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Ref { place, mutable },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_deref(
        &mut self,
        inner: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let inner_val = self.lower_expr(inner)?;
        let inner_place = match inner_val.place() {
            Option::Some(p) => p.clone(),
            Option::None => {
                let temp = self.new_temp(inner.ty.clone(), span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::Use { operand: inner_val },
                );
                Place::local(temp)
            }
        };

        // Emit generation validation for generational pointers
        let gen_temp = self.new_temp(Type::u32(), span.clone());
        self.push_assign(
            Place::local(gen_temp.clone()),
            Rvalue::ReadGeneration { place: inner_place.clone() },
        );
        self.push_stmt(
            StatementKind::ValidateGeneration {
                ptr: inner_place.clone(),
                expected_gen: Operand::copy(Place::local(gen_temp)),
            },
            span.clone(),
        );

        // Dereference
        let deref_place = inner_place.project(PlaceElem::Deref);
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Use { operand: Operand::copy(deref_place) },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn lower_addr_of(
        &mut self,
        inner: &Expr,
        mutable: bool,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let place = self.lower_place(inner)?;
        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::AddressOf { place, mutable },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    // ========================================================================
    // Assignment and Let
    // ========================================================================

    fn lower_assign(
        &mut self,
        target: &Expr,
        value: &Expr,
        span: Span,
    ) -> Result<Operand, [String]> {
        let place = self.lower_place(target)?;
        let val = self.lower_expr(value)?;
        self.push_assign(place, Rvalue::Use { operand: val });
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_let(
        &mut self,
        pattern: &Pattern,
        init: &Expr,
        span: Span,
    ) -> Result<Operand, [String]> {
        let init_val = self.lower_expr(init)?;
        let temp = self.new_temp(init.ty.clone(), init.span.clone());
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Use { operand: init_val },
        );
        self.bind_pattern(pattern, &Place::local(temp))?;
        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    // ========================================================================
    // Control Flow
    // ========================================================================

    fn lower_block(
        &mut self,
        stmts: &[Stmt],
        expr: &Option<Box<Expr>>,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Lower each statement
        let mut i: usize = 0;
        while i < stmts.len() {
            self.lower_stmt(&stmts[i])?;
            i = i + 1;
        };

        // Lower final expression or return unit
        match expr {
            Option::Some(e) => self.lower_expr(e),
            Option::None => Result::Ok(Operand::constant(Constant::unit(Type::unit()))),
        }
    }

    fn lower_stmt(&mut self, stmt: &Stmt) -> Result<(), [String]> {
        match stmt {
            Stmt::Expr(expr) => {
                let _ = self.lower_expr(expr)?;
                Result::Ok(())
            }
            Stmt::Let { pattern, init, ty: _ } => {
                let init_val = self.lower_expr(init)?;
                let temp = self.new_temp(init.ty.clone(), init.span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::Use { operand: init_val },
                );
                self.bind_pattern(pattern, &Place::local(temp))?;
                Result::Ok(())
            }
        }
    }

    fn lower_if(
        &mut self,
        condition: &Expr,
        then_branch: &Expr,
        else_branch: &Option<Box<Expr>>,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let result = self.new_temp(ty.clone(), span.clone());
        let then_block = self.builder.new_block();
        let else_block = self.builder.new_block();
        let join_block = self.builder.new_block();

        // Lower condition
        let cond_op = self.lower_expr(condition)?;

        // Branch based on condition
        self.terminate(TerminatorKind::SwitchInt {
            discr: cond_op,
            targets: SwitchTargets::new(
                [(1, then_block.clone())],
                else_block.clone(),
            ),
        });

        // Then branch
        self.current_block = then_block;
        let then_val = self.lower_expr(then_branch)?;
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: then_val },
        );
        if !self.is_terminated() {
            self.terminate(TerminatorKind::Goto { target: join_block.clone() });
        };

        // Else branch
        self.current_block = else_block;
        let else_val = match else_branch {
            Option::Some(e) => self.lower_expr(e)?,
            Option::None => Operand::constant(Constant::unit(Type::unit())),
        };
        self.push_assign(
            Place::local(result.clone()),
            Rvalue::Use { operand: else_val },
        );
        if !self.is_terminated() {
            self.terminate(TerminatorKind::Goto { target: join_block.clone() });
        };

        // Continue at join
        self.current_block = join_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_loop(
        &mut self,
        body: &Expr,
        label: &Option<LoopId>,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let loop_block = self.builder.new_block();
        let exit_block = self.builder.new_block();
        let result = self.new_temp(ty.clone(), span);

        // Push loop context
        self.push_loop_context(
            label.clone(),
            LoopContext::new(
                exit_block.clone(),
                loop_block.clone(),
                Option::Some(Place::local(result.clone())),
            ),
        );

        // Jump to loop
        self.terminate(TerminatorKind::Goto { target: loop_block.clone() });

        // Loop body
        self.current_block = loop_block;
        let _ = self.lower_expr(body)?;

        // Loop back
        if !self.is_terminated() {
            self.terminate(TerminatorKind::Goto { target: loop_block.clone() });
        };

        // Pop context
        self.pop_loop_context();

        // Continue at exit
        self.current_block = exit_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_while(
        &mut self,
        condition: &Expr,
        body: &Expr,
        label: &Option<LoopId>,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let cond_block = self.builder.new_block();
        let body_block = self.builder.new_block();
        let exit_block = self.builder.new_block();
        let result = self.new_temp(ty.clone(), span);

        // Push loop context
        self.push_loop_context(
            label.clone(),
            LoopContext::new(
                exit_block.clone(),
                cond_block.clone(),
                Option::Some(Place::local(result.clone())),
            ),
        );

        // Jump to condition
        self.terminate(TerminatorKind::Goto { target: cond_block.clone() });

        // Condition block
        self.current_block = cond_block.clone();
        let cond_op = self.lower_expr(condition)?;
        self.terminate(TerminatorKind::SwitchInt {
            discr: cond_op,
            targets: SwitchTargets::new(
                [(1, body_block.clone())],
                exit_block.clone(),
            ),
        });

        // Body block
        self.current_block = body_block;
        let _ = self.lower_expr(body)?;
        if !self.is_terminated() {
            self.terminate(TerminatorKind::Goto { target: cond_block });
        };

        // Pop context
        self.pop_loop_context();

        // Exit block
        self.current_block = exit_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    fn lower_return(
        &mut self,
        value: &Option<Box<Expr>>,
        span: Span,
    ) -> Result<Operand, [String]> {
        let return_place = Place::local(MirLocalId::return_place());

        let val = match value {
            Option::Some(e) => self.lower_expr(e)?,
            Option::None => Operand::constant(Constant::unit(Type::unit())),
        };

        self.push_assign(return_place, Rvalue::Use { operand: val });
        self.terminate(TerminatorKind::Return);

        // Create unreachable block for code after return
        let next = self.builder.new_block();
        self.current_block = next;

        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_break(
        &mut self,
        label: &Option<LoopId>,
        value: &Option<Box<Expr>>,
        span: Span,
    ) -> Result<Operand, [String]> {
        match self.get_loop_context(label.clone()) {
            Option::Some(ctx) => {
                let break_block = ctx.break_block.clone();
                let result_place = ctx.result_place.clone();

                if let Option::Some(v) = value {
                    let val = self.lower_expr(v)?;
                    if let Option::Some(rp) = result_place {
                        self.push_assign(rp, Rvalue::Use { operand: val });
                    }
                };

                self.terminate(TerminatorKind::Goto { target: break_block });

                let next = self.builder.new_block();
                self.current_block = next;

                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
            Option::None => {
                Result::Err(["break outside of loop".to_string()])
            }
        }
    }

    fn lower_continue(
        &mut self,
        label: &Option<LoopId>,
        span: Span,
    ) -> Result<Operand, [String]> {
        match self.get_loop_context(label.clone()) {
            Option::Some(ctx) => {
                let continue_block = ctx.continue_block.clone();
                self.terminate(TerminatorKind::Goto { target: continue_block });

                let next = self.builder.new_block();
                self.current_block = next;

                Result::Ok(Operand::constant(Constant::unit(Type::unit())))
            }
            Option::None => {
                Result::Err(["continue outside of loop".to_string()])
            }
        }
    }

    // ========================================================================
    // Closure Lowering
    // ========================================================================

    fn lower_closure(
        &mut self,
        body_id: &BodyId,
        captures: &[Capture],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Assign synthetic DefId for closure
        let synthetic_id = CLOSURE_DEF_ID_START + self.closure_counter;
        self.closure_counter = self.closure_counter + 1;
        let closure_def_id = DefId::new(synthetic_id);

        // Collect capture types and register for later lowering
        let mut capture_pairs: [(Capture, Type)] = [];
        let mut i: usize = 0;
        while i < captures.len() {
            let cap = &captures[i];
            let cap_ty = self.get_local_type(&cap.local_id);
            capture_pairs.push((cap.clone(), cap_ty));
            i = i + 1;
        };

        self.pending_closures.push((body_id.clone(), closure_def_id.clone(), capture_pairs));

        // Build closure environment aggregate
        let mut capture_ops: [Operand] = [];
        let mut j: usize = 0;
        while j < captures.len() {
            let cap = &captures[j];
            let mir_local = self.map_local(cap.local_id.clone());
            let cap_op = if cap.by_ref {
                // Capture by reference - create ref
                let place = Place::local(mir_local);
                let ref_temp = self.new_temp(Type::reference(cap.ty.clone(), cap.mutable), span.clone());
                self.push_assign(
                    Place::local(ref_temp.clone()),
                    Rvalue::Ref { place, mutable: cap.mutable },
                );
                Operand::copy(Place::local(ref_temp))
            } else {
                // Capture by value - copy/move
                Operand::copy(Place::local(mir_local))
            };
            capture_ops.push(cap_op);
            j = j + 1;
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Closure { def_id: closure_def_id },
                operands: capture_ops,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    fn get_local_type(&self, local_id: &HirLocalId) -> Type {
        match self.body.get_local(local_id) {
            Option::Some(local) => local.ty.clone(),
            Option::None => Type::unit(),
        }
    }

    // ========================================================================
    // Range Expression
    // ========================================================================

    fn lower_range(
        &mut self,
        start: &Option<Box<Expr>>,
        end: &Option<Box<Expr>>,
        inclusive: bool,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut operands: [Operand] = [];

        // Lower start
        match start {
            Option::Some(s) => {
                let op = self.lower_expr(s)?;
                operands.push(op);
            }
            Option::None => {
                operands.push(Operand::constant(Constant::int(0, Type::i64())));
            }
        };

        // Lower end
        match end {
            Option::Some(e) => {
                let op = self.lower_expr(e)?;
                operands.push(op);
            }
            Option::None => {
                operands.push(Operand::constant(Constant::int(i64::MAX as i128, Type::i64())));
            }
        };

        // For inclusive ranges, add exhausted flag
        if inclusive {
            operands.push(Operand::constant(Constant::bool(false, Type::bool())));
        };

        let elem_ty = match start {
            Option::Some(s) => s.ty.clone(),
            Option::None => match end {
                Option::Some(e) => e.ty.clone(),
                Option::None => Type::i64(),
            }
        };

        let temp = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(temp.clone()),
            Rvalue::Aggregate {
                kind: AggregateKind::Range { element: elem_ty, inclusive },
                operands,
            },
        );
        Result::Ok(Operand::copy(Place::local(temp)))
    }

    // ========================================================================
    // Effect Operations
    // ========================================================================

    fn lower_perform(
        &mut self,
        effect_id: &DefId,
        op_index: u32,
        args: &[Expr],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let mut arg_ops: [Operand] = [];
        let mut i: usize = 0;
        while i < args.len() {
            let op = self.lower_expr(&args[i])?;
            arg_ops.push(op);
            i = i + 1;
        };

        let dest = self.new_temp(ty.clone(), span);
        let dest_place = Place::local(dest.clone());
        let next_block = self.builder.new_block();

        self.terminate(TerminatorKind::Perform {
            effect_id: effect_id.clone(),
            op_index,
            args: arg_ops,
            destination: dest_place.clone(),
            target: next_block.clone(),
            is_tail_resumptive: false,
        });

        self.current_block = next_block;

        Result::Ok(Operand::copy(dest_place))
    }

    fn lower_resume(
        &mut self,
        value: &Option<Box<Expr>>,
        span: Span,
    ) -> Result<Operand, [String]> {
        let resume_val = match value {
            Option::Some(v) => Option::Some(self.lower_expr(v)?),
            Option::None => Option::None,
        };

        self.terminate(TerminatorKind::Resume { value: resume_val });

        let next = self.builder.new_block();
        self.current_block = next;

        Result::Ok(Operand::constant(Constant::unit(Type::unit())))
    }

    fn lower_handle(
        &mut self,
        body: &Expr,
        handler_id: &DefId,
        handler_instance: &Expr,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Lower handler state
        let state_op = self.lower_expr(handler_instance)?;
        let state_local = self.new_temp(handler_instance.ty.clone(), span.clone());
        let state_place = Place::local(state_local.clone());
        self.push_assign(state_place.clone(), Rvalue::Use { operand: state_op });

        // Push handler
        self.push_stmt(
            StatementKind::PushHandler {
                handler_id: handler_id.clone(),
                state_place: state_place.clone(),
            },
            span.clone(),
        );

        // Increment handler depth
        self.handler_depth = self.handler_depth + 1;

        // Lower body
        let body_result = self.lower_expr(body)?;

        // Decrement handler depth
        self.handler_depth = self.handler_depth - 1;

        // Pop handler
        self.push_stmt(StatementKind::PopHandler, span.clone());

        // Result is the body result
        let dest = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(dest.clone()),
            Rvalue::Use { operand: body_result },
        );

        Result::Ok(Operand::copy(Place::local(dest)))
    }

    fn lower_inline_handle(
        &mut self,
        body: &Expr,
        handlers: &[InlineOpHandler],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        // For inline handlers, we generate synthetic DefIds and bodies
        // This is a simplified version - full implementation would extract
        // handler bodies for separate lowering

        // Increment handler depth
        self.handler_depth = self.handler_depth + 1;

        // Lower body
        let body_result = self.lower_expr(body)?;

        // Decrement handler depth
        self.handler_depth = self.handler_depth - 1;

        let dest = self.new_temp(ty.clone(), span);
        self.push_assign(
            Place::local(dest.clone()),
            Rvalue::Use { operand: body_result },
        );

        Result::Ok(Operand::copy(Place::local(dest)))
    }

    // ========================================================================
    // Pattern Matching
    // ========================================================================

    fn lower_match(
        &mut self,
        scrutinee: &Expr,
        arms: &[MatchArm],
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let scrutinee_val = self.lower_expr(scrutinee)?;

        // Materialize scrutinee to a place
        let scrutinee_place = match scrutinee_val.place() {
            Option::Some(p) => p.clone(),
            Option::None => {
                let temp = self.new_temp(scrutinee.ty.clone(), scrutinee.span.clone());
                self.push_assign(
                    Place::local(temp.clone()),
                    Rvalue::Use { operand: scrutinee_val },
                );
                Place::local(temp)
            }
        };

        // Create result and join block
        let result = self.new_temp(ty.clone(), span.clone());
        let join_block = self.builder.new_block();

        // Create blocks for each arm
        let mut arm_blocks: [BasicBlockId] = [];
        let mut i: usize = 0;
        while i < arms.len() {
            arm_blocks.push(self.builder.new_block());
            i = i + 1;
        };
        let fallthrough_block = self.builder.new_block();

        // Lower pattern tests
        let mut current_test_block = self.current_block.clone();
        let mut j: usize = 0;
        while j < arms.len() {
            let arm = &arms[j];
            let arm_block = arm_blocks[j].clone();
            let next_test_block = if j + 1 < arms.len() {
                self.builder.new_block();
            } else {
                fallthrough_block.clone();
            };

            self.current_block = current_test_block.clone();

            let matches = self.test_pattern(&arm.pattern, &scrutinee_place)?;

            self.terminate(TerminatorKind::SwitchInt {
                discr: matches,
                targets: SwitchTargets::new(
                    [(1, arm_block)],
                    next_test_block.clone(),
                ),
            });

            current_test_block = next_test_block;
            j = j + 1;
        };

        // Fallthrough unreachable
        self.current_block = fallthrough_block;
        self.terminate(TerminatorKind::Unreachable);

        // Lower arm bodies
        let mut k: usize = 0;
        while k < arms.len() {
            let arm = &arms[k];
            self.current_block = arm_blocks[k].clone();

            self.bind_pattern(&arm.pattern, &scrutinee_place)?;

            // Handle guard
            match &arm.guard {
                Option::Some(guard) => {
                    let guard_pass = self.builder.new_block();
                    let guard_fail = if k + 1 < arms.len() {
                        arm_blocks[k + 1].clone()
                    } else {
                        fallthrough_block.clone();
                    };

                    let guard_result = self.lower_expr(guard)?;
                    self.terminate(TerminatorKind::SwitchInt {
                        discr: guard_result,
                        targets: SwitchTargets::new(
                            [(1, guard_pass.clone())],
                            guard_fail,
                        ),
                    });

                    self.current_block = guard_pass;
                }
                Option::None => {}
            };

            let arm_val = self.lower_expr(&arm.body)?;
            self.push_assign(
                Place::local(result.clone()),
                Rvalue::Use { operand: arm_val },
            );
            self.terminate(TerminatorKind::Goto { target: join_block.clone() });

            k = k + 1;
        };

        self.current_block = join_block;

        Result::Ok(Operand::copy(Place::local(result)))
    }

    /// Test a pattern against a place, returning a boolean operand.
    fn test_pattern(&mut self, pattern: &Pattern, place: &Place) -> Result<Operand, [String]> {
        match &pattern.kind {
            PatternKind::Wildcard => {
                Result::Ok(Operand::constant(Constant::bool(true, Type::bool())))
            }

            PatternKind::Binding { subpattern, name: _, mutable: _, local_id: _ } => {
                match subpattern {
                    Option::Some(sub) => self.test_pattern(sub, place),
                    Option::None => Result::Ok(Operand::constant(Constant::bool(true, Type::bool()))),
                }
            }

            PatternKind::Literal(lit) => {
                let lit_const = lower_literal(lit, &pattern.ty);
                let lit_op = Operand::constant(lit_const);
                let place_val = Operand::copy(place.clone());

                let result = self.new_temp(Type::bool(), pattern.span.clone());
                self.push_assign(
                    Place::local(result.clone()),
                    Rvalue::BinaryOp {
                        op: MirBinOp::Eq,
                        left: place_val,
                        right: lit_op,
                    },
                );
                Result::Ok(Operand::copy(Place::local(result)))
            }

            PatternKind::Tuple(pats) => {
                self.test_pattern_tuple(pats, place, pattern.span.clone());
            }

            PatternKind::Variant { variant_idx, fields, def_id: _ } => {
                self.test_pattern_variant(*variant_idx, fields, place, pattern.span.clone());
            }

            PatternKind::Struct { fields, def_id: _ } => {
                self.test_pattern_struct(fields, place, pattern.span.clone());
            }

            PatternKind::Or(alts) => {
                self.test_pattern_or(alts, place, pattern.span.clone());
            }

            PatternKind::Slice { prefix, slice, suffix } => {
                self.test_pattern_slice(prefix, slice, suffix, place, pattern.span.clone());
            }

            PatternKind::Range { start, end, inclusive } => {
                self.test_pattern_range(start, end, *inclusive, place, &pattern.ty, pattern.span.clone());
            }

            PatternKind::Ref { inner, mutable: _ } => {
                let deref_place = place.project(PlaceElem::Deref);
                self.test_pattern(inner, &deref_place);
            }
        }
    }

    fn test_pattern_tuple(
        &mut self,
        pats: &[Pattern],
        place: &Place,
        span: Span,
    ) -> Result<Operand, [String]> {
        if pats.len() == 0 {
            return Result::Ok(Operand::constant(Constant::bool(true, Type::bool())));
        };

        let field_place = place.project(PlaceElem::Field { index: 0 });
        let mut result = self.test_pattern(&pats[0], &field_place)?;

        let mut i: usize = 1;
        while i < pats.len() {
            let field_place = place.project(PlaceElem::Field { index: i as u32 });
            let field_result = self.test_pattern(&pats[i], &field_place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitAnd,
                    left: result,
                    right: field_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            i = i + 1;
        }

        Result::Ok(result)
    }

    fn test_pattern_variant(
        &mut self,
        variant_idx: u32,
        fields: &[Pattern],
        place: &Place,
        span: Span,
    ) -> Result<Operand, [String]> {
        // Check discriminant
        let discr_temp = self.new_temp(Type::u32(), span.clone());
        self.push_assign(
            Place::local(discr_temp.clone()),
            Rvalue::Discriminant { place: place.clone() },
        );

        let expected = Operand::constant(Constant::uint(variant_idx as u128, Type::u32()));

        let discr_matches = self.new_temp(Type::bool(), span.clone());
        self.push_assign(
            Place::local(discr_matches.clone()),
            Rvalue::BinaryOp {
                op: MirBinOp::Eq,
                left: Operand::copy(Place::local(discr_temp)),
                right: expected,
            },
        );

        if fields.len() == 0 {
            return Result::Ok(Operand::copy(Place::local(discr_matches)));
        };

        // Check fields
        let variant_place = place.project(PlaceElem::Downcast { variant: variant_idx });
        let mut result = Operand::copy(Place::local(discr_matches));

        let mut i: usize = 0;
        while i < fields.len() {
            let field_place = variant_place.project(PlaceElem::Field { index: i as u32 });
            let field_result = self.test_pattern(&fields[i], &field_place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitAnd,
                    left: result,
                    right: field_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            i = i + 1;
        }

        Result::Ok(result)
    }

    fn test_pattern_struct(
        &mut self,
        fields: &[FieldPattern],
        place: &Place,
        span: Span,
    ) -> Result<Operand, [String]> {
        if fields.len() == 0 {
            return Result::Ok(Operand::constant(Constant::bool(true, Type::bool())));
        };

        let field_place = place.project(PlaceElem::Field { index: fields[0].field_idx });
        let mut result = self.test_pattern(&fields[0].pattern, &field_place)?;

        let mut i: usize = 1;
        while i < fields.len() {
            let field_place = place.project(PlaceElem::Field { index: fields[i].field_idx });
            let field_result = self.test_pattern(&fields[i].pattern, &field_place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitAnd,
                    left: result,
                    right: field_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            i = i + 1;
        }

        Result::Ok(result)
    }

    fn test_pattern_or(
        &mut self,
        alts: &[Pattern],
        place: &Place,
        span: Span,
    ) -> Result<Operand, [String]> {
        if alts.len() == 0 {
            return Result::Ok(Operand::constant(Constant::bool(false, Type::bool())));
        };

        let mut result = self.test_pattern(&alts[0], place)?;

        let mut i: usize = 1;
        while i < alts.len() {
            let alt_result = self.test_pattern(&alts[i], place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitOr,
                    left: result,
                    right: alt_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            i = i + 1;
        }

        Result::Ok(result)
    }

    fn test_pattern_slice(
        &mut self,
        prefix: &[Pattern],
        slice: &Option<Box<Pattern>>,
        suffix: &[Pattern],
        place: &Place,
        span: Span,
    ) -> Result<Operand, [String]> {
        let min_len = prefix.len() + suffix.len();

        // Get slice length
        let len_temp = self.new_temp(Type::usize(), span.clone());
        self.push_assign(
            Place::local(len_temp.clone()),
            Rvalue::Len { place: place.clone() },
        );

        // Check length
        let min_len_const = Operand::constant(Constant::uint(min_len as u128, Type::usize()));

        let len_check = match slice {
            Option::Some(_) => {
                // With rest: length >= min_len
                let check = self.new_temp(Type::bool(), span.clone());
                self.push_assign(
                    Place::local(check.clone()),
                    Rvalue::BinaryOp {
                        op: MirBinOp::Ge,
                        left: Operand::copy(Place::local(len_temp)),
                        right: min_len_const,
                    },
                );
                Operand::copy(Place::local(check))
            }
            Option::None => {
                // Without rest: length == min_len
                let check = self.new_temp(Type::bool(), span.clone());
                self.push_assign(
                    Place::local(check.clone()),
                    Rvalue::BinaryOp {
                        op: MirBinOp::Eq,
                        left: Operand::copy(Place::local(len_temp)),
                        right: min_len_const,
                    },
                );
                Operand::copy(Place::local(check))
            }
        };

        let mut result = len_check;

        // Check prefix patterns
        let mut i: usize = 0;
        while i < prefix.len() {
            let elem_place = place.project(PlaceElem::ConstantIndex {
                offset: i as u64,
                min_length: min_len as u64,
                from_end: false,
            });
            let pat_result = self.test_pattern(&prefix[i], &elem_place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitAnd,
                    left: result,
                    right: pat_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            i = i + 1;
        };

        // Check suffix patterns
        let mut j: usize = 0;
        while j < suffix.len() {
            let offset_from_end = (suffix.len() - 1 - j) as u64;
            let elem_place = place.project(PlaceElem::ConstantIndex {
                offset: offset_from_end,
                min_length: min_len as u64,
                from_end: true,
            });
            let pat_result = self.test_pattern(&suffix[j], &elem_place)?;

            let combined = self.new_temp(Type::bool(), span.clone());
            self.push_assign(
                Place::local(combined.clone()),
                Rvalue::BinaryOp {
                    op: MirBinOp::BitAnd,
                    left: result,
                    right: pat_result,
                },
            );
            result = Operand::copy(Place::local(combined));
            j = j + 1;
        }

        Result::Ok(result)
    }

    fn test_pattern_range(
        &mut self,
        start: &Option<Box<Pattern>>,
        end: &Option<Box<Pattern>>,
        inclusive: bool,
        place: &Place,
        ty: &Type,
        span: Span,
    ) -> Result<Operand, [String]> {
        let place_val = Operand::copy(place.clone());
        let mut result: Option<Operand> = Option::None;

        // Check start bound: value >= start
        match start {
            Option::Some(start_pat) => {
                match &start_pat.kind {
                    PatternKind::Literal(lit) => {
                        let start_const = lower_literal(lit, ty);
                        let start_check = self.new_temp(Type::bool(), span.clone());
                        self.push_assign(
                            Place::local(start_check.clone()),
                            Rvalue::BinaryOp {
                                op: MirBinOp::Ge,
                                left: place_val.clone(),
                                right: Operand::constant(start_const),
                            },
                        );
                        result = Option::Some(Operand::copy(Place::local(start_check)));
                    }
                    _ => {}
                }
            }
            Option::None => {}
        };

        // Check end bound
        match end {
            Option::Some(end_pat) => {
                match &end_pat.kind {
                    PatternKind::Literal(lit) => {
                        let end_const = lower_literal(lit, ty);
                        let end_op = if inclusive { MirBinOp::Le } else { MirBinOp::Lt };
                        let end_check = self.new_temp(Type::bool(), span.clone());
                        self.push_assign(
                            Place::local(end_check.clone()),
                            Rvalue::BinaryOp {
                                op: end_op,
                                left: place_val,
                                right: Operand::constant(end_const),
                            },
                        );

                        match result {
                            Option::Some(prev) => {
                                let combined = self.new_temp(Type::bool(), span.clone());
                                self.push_assign(
                                    Place::local(combined.clone()),
                                    Rvalue::BinaryOp {
                                        op: MirBinOp::BitAnd,
                                        left: prev,
                                        right: Operand::copy(Place::local(end_check)),
                                    },
                                );
                                result = Option::Some(Operand::copy(Place::local(combined)));
                            }
                            Option::None => {
                                result = Option::Some(Operand::copy(Place::local(end_check)));
                            }
                        }
                    }
                    _ => {}
                }
            }
            Option::None => {}
        };

        match result {
            Option::Some(r) => Result::Ok(r),
            Option::None => Result::Ok(Operand::constant(Constant::bool(true, Type::bool()))),
        }
    }

    /// Bind pattern variables to a place.
    fn bind_pattern(&mut self, pattern: &Pattern, place: &Place) -> Result<(), [String]> {
        match &pattern.kind {
            PatternKind::Wildcard => {
                // Nothing to bind
                Result::Ok(())
            }

            PatternKind::Binding { local_id, mutable, subpattern, name: _ } => {
                let mir_local = self.map_local(local_id.clone());

                // Check if this is a ref binding
                if pattern.ty.is_ref() {
                    self.push_assign(
                        Place::local(mir_local.clone()),
                        Rvalue::Ref { place: place.clone(), mutable: *mutable },
                    );
                } else {
                    self.push_assign(
                        Place::local(mir_local.clone()),
                        Rvalue::Use { operand: Operand::copy(place.clone()) },
                    );
                };

                match subpattern {
                    Option::Some(sub) => self.bind_pattern(sub, &Place::local(mir_local)),
                    Option::None => Result::Ok(()),
                }
            }

            PatternKind::Literal(_) => {
                // Literals don't bind
                Result::Ok(())
            }

            PatternKind::Tuple(pats) => {
                let mut i: usize = 0;
                while i < pats.len() {
                    let field_place = place.project(PlaceElem::Field { index: i as u32 });
                    self.bind_pattern(&pats[i], &field_place)?;
                    i = i + 1;
                }
                Result::Ok(())
            }

            PatternKind::Struct { fields, def_id: _ } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    let field_place = place.project(PlaceElem::Field { index: fields[i].field_idx });
                    self.bind_pattern(&fields[i].pattern, &field_place)?;
                    i = i + 1;
                }
                Result::Ok(())
            }

            PatternKind::Variant { variant_idx, fields, def_id: _ } => {
                let variant_place = place.project(PlaceElem::Downcast { variant: *variant_idx });
                let mut i: usize = 0;
                while i < fields.len() {
                    let field_place = variant_place.project(PlaceElem::Field { index: i as u32 });
                    self.bind_pattern(&fields[i], &field_place)?;
                    i = i + 1;
                }
                Result::Ok(())
            }

            PatternKind::Slice { prefix, slice, suffix } => {
                let min_length = (prefix.len() + suffix.len()) as u64;

                let mut i: usize = 0;
                while i < prefix.len() {
                    let idx_place = place.project(PlaceElem::ConstantIndex {
                        offset: i as u64,
                        min_length,
                        from_end: false,
                    });
                    self.bind_pattern(&prefix[i], &idx_place)?;
                    i = i + 1;
                };

                let mut j: usize = 0;
                while j < suffix.len() {
                    let offset_from_end = (suffix.len() - 1 - j) as u64;
                    let idx_place = place.project(PlaceElem::ConstantIndex {
                        offset: offset_from_end,
                        min_length,
                        from_end: true,
                    });
                    self.bind_pattern(&suffix[j], &idx_place)?;
                    j = j + 1;
                };

                match slice {
                    Option::Some(rest_pat) => {
                        let subslice_place = place.project(PlaceElem::Subslice {
                            from: prefix.len() as u64,
                            to: suffix.len() as u64,
                            from_end: true,
                        });
                        self.bind_pattern(rest_pat, &subslice_place)?;
                    }
                    Option::None => {}
                }

                Result::Ok(())
            }

            PatternKind::Or(alternatives) => {
                // Bind from first alternative only
                match alternatives.first() {
                    Option::Some(first_alt) => self.bind_pattern(first_alt, place),
                    Option::None => Result::Ok(()),
                }
            }

            PatternKind::Ref { inner, mutable: _ } => {
                let deref_place = place.project(PlaceElem::Deref);
                self.bind_pattern(inner, &deref_place);
            }

            PatternKind::Range { start: _, end: _, inclusive: _ } => {
                // Range patterns don't bind
                Result::Ok(())
            }
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_function_lowering_new() {
    // Basic construction test
    // Full test would require HIR structures
    assert!(true);
}
