/// Utility Functions for MIR Lowering
///
/// This module provides shared utility functions for HIRâ†’MIR lowering.
/// These are used by both `FunctionLowering` and `ClosureLowering` to
/// avoid code duplication.
///
/// # Functions
///
/// - `convert_binop`: Convert HIR binary operator to MIR binary operator
/// - `convert_unop`: Convert HIR unary operator to MIR unary operator
/// - `lower_literal`: Convert HIR literal to MIR constant
/// - `is_irrefutable_pattern`: Check if a pattern always matches
///
/// # Types
///
/// - `LoopContext`: Information about the current loop for break/continue
/// - `LoweringResult`: Result type for lowering operations

use crate.compiler.hir::{
    BinOp as HirBinOp,
    UnaryOp as HirUnaryOp,
    LiteralValue,
    Pattern,
    PatternKind,
};
use crate.compiler.mir::{
    BinOp as MirBinOp,
    UnOp as MirUnOp,
    Constant,
    ConstantKind,
    BasicBlockId,
    Place,
};
use crate.compiler.typeck::types::Type;

// ============================================================
// Operator Conversion
// ============================================================

/// Convert a HIR binary operator to a MIR binary operator.
///
/// # Examples
///
/// ```
/// let hir_op = HirBinOp::Add;
/// let mir_op = convert_binop(&hir_op);
/// // mir_op == MirBinOp::Add
/// ```
pub fn convert_binop(op: &HirBinOp) -> MirBinOp {
    match op {
        HirBinOp::Add => MirBinOp::Add,
        HirBinOp::Sub => MirBinOp::Sub,
        HirBinOp::Mul => MirBinOp::Mul,
        HirBinOp::Div => MirBinOp::Div,
        HirBinOp::Rem => MirBinOp::Rem,
        HirBinOp::BitAnd => MirBinOp::BitAnd,
        HirBinOp::BitOr => MirBinOp::BitOr,
        HirBinOp::BitXor => MirBinOp::BitXor,
        HirBinOp::Shl => MirBinOp::Shl,
        HirBinOp::Shr => MirBinOp::Shr,
        HirBinOp::Eq => MirBinOp::Eq,
        HirBinOp::Ne => MirBinOp::Ne,
        HirBinOp::Lt => MirBinOp::Lt,
        HirBinOp::Le => MirBinOp::Le,
        HirBinOp::Gt => MirBinOp::Gt,
        HirBinOp::Ge => MirBinOp::Ge,
        // Logical operators are represented as bitwise ops at MIR level
        // since they operate on boolean values (0/1)
        HirBinOp::And => MirBinOp::BitAnd,
        HirBinOp::Or => MirBinOp::BitOr,
    }
}

/// Convert a HIR unary operator to a MIR unary operator.
///
/// Returns `None` for operators that require special handling:
/// - `Deref`: Creates a dereferenced place projection
/// - `Ref`/`RefMut`: Creates a reference to a place
///
/// These operators are handled directly in the lowering code.
pub fn convert_unop(op: &HirUnaryOp) -> Option<MirUnOp> {
    match op {
        HirUnaryOp::Neg => Option::Some(MirUnOp::Neg),
        HirUnaryOp::Not => Option::Some(MirUnOp::Not),
        // These require special place-based handling
        HirUnaryOp::Deref => Option::None,
        HirUnaryOp::Ref => Option::None,
        HirUnaryOp::RefMut => Option::None,
    }
}

// ============================================================
// Literal Conversion
// ============================================================

/// Convert a HIR literal value to a MIR constant.
///
/// This is a pure utility function used during expression lowering
/// to convert HIR literal values into MIR constants.
pub fn lower_literal(lit: &LiteralValue, ty: &Type) -> Constant {
    let kind = match lit {
        LiteralValue::Int(v) => ConstantKind::Int { value: *v },
        LiteralValue::Uint(v) => ConstantKind::Uint { value: *v },
        LiteralValue::Float(v) => ConstantKind::Float { value: *v },
        LiteralValue::Bool(v) => ConstantKind::Bool { value: *v },
        LiteralValue::Char(v) => ConstantKind::Char { value: *v },
        LiteralValue::String(v) => ConstantKind::String { value: v.clone() },
        LiteralValue::ByteString(_) => {
            // Byte strings are represented as arrays of u8
            // For now, return unit as placeholder
            ConstantKind::Unit
        }
    };
    Constant::new(ty.clone(), kind)
}

// ============================================================
// Pattern Analysis
// ============================================================

/// Check if a pattern is irrefutable (always matches).
///
/// An irrefutable pattern is one that will match any value of its type.
/// This includes:
/// - Wildcard patterns (`_`)
/// - Simple bindings (`x`)
/// - Tuple patterns with all irrefutable sub-patterns
/// - Reference patterns with irrefutable inner patterns
/// - Struct patterns with all irrefutable field patterns
/// - Slice patterns with a rest element (`..`)
///
/// Refutable patterns (which may not match) include:
/// - Literal patterns (`1`, `"hello"`)
/// - Or patterns (`a | b`)
/// - Variant patterns (`Some(x)`)
/// - Range patterns (`1..10`)
pub fn is_irrefutable_pattern(pattern: &Pattern) -> bool {
    match &pattern.kind {
        PatternKind::Wildcard => true,

        PatternKind::Binding { subpattern, name: _, mutable: _, local_id: _ } => {
            match subpattern {
                Option::Some(sub) => is_irrefutable_pattern(sub),
                Option::None => true,
            }
        }

        PatternKind::Tuple(pats) => {
            let mut i: usize = 0;
            while i < pats.len() {
                if !is_irrefutable_pattern(&pats[i]) {
                    return false;
                };
                i = i + 1;
            }
            true
        }

        PatternKind::Ref { inner, mutable: _ } => is_irrefutable_pattern(inner),

        // Struct patterns are irrefutable if all field patterns are irrefutable
        PatternKind::Struct { fields, def_id: _ } => {
            let mut i: usize = 0;
            while i < fields.len() {
                if !is_irrefutable_pattern(&fields[i].pattern) {
                    return false;
                };
                i = i + 1;
            }
            true
        }

        // Slice patterns with a rest element (..) are irrefutable
        PatternKind::Slice { prefix, slice, suffix } => {
            match slice {
                Option::Some(_) => {
                    // Has rest pattern, check prefix and suffix
                    let mut i: usize = 0;
                    while i < prefix.len() {
                        if !is_irrefutable_pattern(&prefix[i]) {
                            return false;
                        };
                        i = i + 1;
                    };
                    let mut j: usize = 0;
                    while j < suffix.len() {
                        if !is_irrefutable_pattern(&suffix[j]) {
                            return false;
                        };
                        j = j + 1;
                    }
                    true
                }
                Option::None => false, // Without rest, must match exact length
            }
        }

        // These patterns are refutable (may not match)
        PatternKind::Literal(_) => false,
        PatternKind::Or(_) => false,
        PatternKind::Variant { def_id: _, variant_idx: _, fields: _ } => false,
        PatternKind::Range { start: _, end: _, inclusive: _ } => false,
    }
}

// ============================================================
// Loop Context
// ============================================================

/// Information about the current loop context for break/continue.
///
/// This struct provides context needed when lowering break and continue
/// expressions inside loops. It tracks:
/// - The block to jump to on `break`
/// - The block to jump to on `continue`
/// - An optional place to store break values (for `loop` expressions)
pub struct LoopContext {
    /// Block to jump to on break.
    pub break_block: BasicBlockId,
    /// Block to jump to on continue.
    pub continue_block: BasicBlockId,
    /// Optional place to store break values.
    pub result_place: Option<Place>,
}

impl LoopContext {
    /// Create a new loop context.
    pub fn new(
        break_block: BasicBlockId,
        continue_block: BasicBlockId,
        result_place: Option<Place>,
    ) -> LoopContext {
        LoopContext {
            break_block,
            continue_block,
            result_place,
        }
    }
}

impl Clone for LoopContext {
    fn clone(&self) -> LoopContext {
        LoopContext {
            break_block: self.break_block.clone(),
            continue_block: self.continue_block.clone(),
            result_place: self.result_place.clone(),
        }
    }
}

// ============================================================
// Synthetic DefId Ranges
// ============================================================

/// Starting range for synthetic closure DefIds.
///
/// Closures discovered during lowering are assigned DefIds starting from
/// this value. This keeps them separate from user-defined definitions.
pub const CLOSURE_DEF_ID_START: u32 = 0xFFFF_0000;

/// Starting range for synthetic inline handler DefIds.
///
/// Inline handlers (from try/with expressions) are assigned DefIds starting
/// from this value.
pub const INLINE_HANDLER_DEF_ID_START: u32 = 0xFFFE_0000;

// ============================================================
// Tests
// ============================================================

#[test]
fn test_convert_binop() {
    let add = convert_binop(&HirBinOp::Add);
    assert!(add == MirBinOp::Add);

    let eq = convert_binop(&HirBinOp::Eq);
    assert!(eq == MirBinOp::Eq);
}

#[test]
fn test_convert_unop() {
    let neg = convert_unop(&HirUnaryOp::Neg);
    match neg {
        Option::Some(op) => assert!(op == MirUnOp::Neg),
        Option::None => assert!(false),
    };

    // Deref returns None
    let deref = convert_unop(&HirUnaryOp::Deref);
    match deref {
        Option::Some(_) => assert!(false),
        Option::None => assert!(true),
    }
}

#[test]
fn test_is_irrefutable_wildcard() {
    let pat = Pattern {
        kind: PatternKind::Wildcard,
        ty: Type::unit(),
        span: Span::dummy(),
    };
    assert!(is_irrefutable_pattern(&pat));
}

#[test]
fn test_loop_context() {
    let ctx = LoopContext::new(
        BasicBlockId::new(1),
        BasicBlockId::new(0),
        Option::None,
    );
    assert!(ctx.break_block.index() == 1);
    assert!(ctx.continue_block.index() == 0);
}
