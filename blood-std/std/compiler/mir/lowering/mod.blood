/// HIR to MIR Lowering
///
/// This module provides the HIR→MIR lowering pass, transforming the typed
/// AST (HIR) into the control-flow graph based MIR representation.
///
/// # Architecture
///
/// The lowering process uses a two-pass approach:
///
/// 1. **Function Pass**: Lower all top-level function bodies, collecting
///    any closures discovered during lowering.
///
/// 2. **Closure Pass**: Iteratively lower discovered closures. Nested
///    closures may discover more closures, so this continues until no
///    new closures are found.
///
/// # Module Structure
///
/// - `mod.blood`: Main entry point, `MirLowering` struct
/// - `function.blood`: `FunctionLowering` for function bodies
/// - `closure.blood`: `ClosureLowering` for closure bodies
/// - `util.blood`: Shared utilities and operator conversion
///
/// # Synthetic DefIds
///
/// Closures and inline handlers are assigned synthetic DefIds:
/// - Closures: `0xFFFF_0000 + counter`
/// - Inline handlers: `0xFFFE_0000 + counter`
///
/// These ranges are reserved to avoid collision with user-defined DefIds.
///
/// # Usage
///
/// ```
/// let hir_crate = /* ... */;
/// let lowering = MirLowering::new(&hir_crate);
/// let (mir_bodies, diagnostics) = lowering.lower_crate();
/// ```

use std.collections::HashMap;
use std.compiler.hir::{
    Crate as HirCrate, Item, ItemKind, Body, BodyId, Capture,
    LocalId as HirLocalId, Span,
};
use std.compiler.mir::{
    MirBody, MirBodyBuilder, MirLocal, LocalKind,
    LocalId as MirLocalId, BasicBlockId,
};
use std.compiler.typeck::types::{Type, DefId};
use std.compiler.mir::lowering::function::FunctionLowering;
use std.compiler.mir::lowering::closure::ClosureLowering;
use std.compiler.mir::lowering::util::{CLOSURE_DEF_ID_START, INLINE_HANDLER_DEF_ID_START};

// ============================================================
// Module Exports
// ============================================================

pub mod function;
pub mod closure;
pub mod util;

// Re-exports for convenience
pub use function::FunctionLowering;
pub use closure::ClosureLowering;
pub use util::{
    convert_binop,
    convert_unop,
    lower_literal,
    is_irrefutable_pattern,
    LoopContext,
    CLOSURE_DEF_ID_START,
    INLINE_HANDLER_DEF_ID_START,
};

// ============================================================
// Inline Handler Body Storage
// ============================================================

/// Storage for inline handler bodies discovered during lowering.
///
/// Inline handlers (from try/with expressions) are lowered to separate
/// functions. This struct stores the MIR bodies keyed by their synthetic
/// DefId for later code generation.
pub struct InlineHandlerBodies {
    /// Map from synthetic DefId to MIR body.
    bodies: HashMap<u32, MirBody>,
}

impl InlineHandlerBodies {
    /// Create an empty inline handler bodies storage.
    pub fn new() -> InlineHandlerBodies {
        InlineHandlerBodies {
            bodies: HashMap::new(),
        }
    }

    /// Insert an inline handler body.
    pub fn insert(&mut self, def_id: DefId, body: MirBody) {
        self.bodies.insert(def_id.index, body);
    }

    /// Get an inline handler body by DefId.
    pub fn get(&self, def_id: &DefId) -> Option<&MirBody> {
        self.bodies.get(&def_id.index);
    }

    /// Check if a DefId is an inline handler.
    pub fn contains(&self, def_id: &DefId) -> bool {
        self.bodies.contains_key(&def_id.index);
    }

    /// Get the number of inline handler bodies.
    pub fn len(&self) -> usize {
        self.bodies.len();
    }
}

impl Clone for InlineHandlerBodies {
    fn clone(&self) -> InlineHandlerBodies {
        InlineHandlerBodies {
            bodies: self.bodies.clone(),
        }
    }
}

// ============================================================
// Diagnostic
// ============================================================

/// A diagnostic message from lowering.
pub struct Diagnostic {
    /// The diagnostic message.
    pub message: String,
    /// Source location.
    pub span: Span,
    /// Whether this is an error or warning.
    pub is_error: bool,
}

impl Diagnostic {
    /// Create an error diagnostic.
    pub fn error(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            message,
            span,
            is_error: true,
        }
    }

    /// Create a warning diagnostic.
    pub fn warning(message: String, span: Span) -> Diagnostic {
        Diagnostic {
            message,
            span,
            is_error: false,
        }
    }
}

impl Clone for Diagnostic {
    fn clone(&self) -> Diagnostic {
        Diagnostic {
            message: self.message.clone(),
            span: self.span.clone(),
            is_error: self.is_error,
        }
    }
}

// ============================================================
// Main MIR Lowering Entry Point
// ============================================================

/// Main entry point for HIR→MIR lowering.
///
/// `MirLowering` coordinates the lowering of an entire HIR crate to MIR.
/// It uses a two-pass approach:
///
/// 1. Lower all top-level functions
/// 2. Iteratively lower discovered closures
///
/// # Example
///
/// ```
/// let hir_crate = /* ... */;
/// let lowering = MirLowering::new(&hir_crate);
/// let (bodies, diagnostics) = lowering.lower_crate();
///
/// for (def_id, mir_body) in bodies {
///     // Process MIR body...
/// }
/// ```
pub struct MirLowering<'hir> {
    /// Reference to the HIR crate being lowered.
    hir: &'hir HirCrate,
    /// Accumulated MIR bodies, keyed by DefId.
    bodies: HashMap<u32, MirBody>,
    /// Accumulated diagnostic messages.
    diagnostics: [Diagnostic],
    /// Counter for generating synthetic closure DefIds.
    closure_counter: u32,
    /// Counter for generating synthetic inline handler DefIds.
    inline_handler_counter: u32,
    /// Pending closures to be lowered: (BodyId, synthetic DefId, captures).
    pending_closures: [(BodyId, DefId, [(Capture, Type)])],
    /// Inline handler bodies discovered during lowering.
    inline_handler_bodies: InlineHandlerBodies,
}

impl<'hir> MirLowering<'hir> {
    /// Create a new MIR lowering context.
    pub fn new(hir: &'hir HirCrate) -> MirLowering<'hir> {
        MirLowering {
            hir,
            bodies: HashMap::new(),
            diagnostics: [],
            closure_counter: 0,
            inline_handler_counter: 0,
            pending_closures: [],
            inline_handler_bodies: InlineHandlerBodies::new(),
        }
    }

    /// Lower the entire HIR crate to MIR.
    ///
    /// Returns a map of DefId → MirBody and any diagnostics.
    pub fn lower_crate(mut self) -> (HashMap<u32, MirBody>, [Diagnostic], InlineHandlerBodies) {
        // Pass 1: Lower all top-level functions
        self.lower_all_functions();

        // Pass 2: Iteratively lower discovered closures
        self.lower_all_closures();

        (self.bodies, self.diagnostics, self.inline_handler_bodies)
    }

    /// Lower all top-level function items.
    fn lower_all_functions(&mut self) {
        // Iterate over all items in the HIR crate
        // Note: This assumes HirCrate provides iteration capability
        // Implementation would use crate's item iteration method

        // For now, we iterate using a pattern that matches the crate API
        let mut item_id: u32 = 0;
        while item_id < 0x10000 {  // Reasonable upper bound for user definitions
            let def_id = DefId::new(item_id);
            match self.hir.get_item(&def_id) {
                Option::Some(item) => {
                    self.lower_item(&def_id, item);
                }
                Option::None => {}
            };
            item_id = item_id + 1;
        }
    }

    /// Lower a single item if it's a function.
    fn lower_item(&mut self, def_id: &DefId, item: &Item) {
        match &item.kind {
            ItemKind::Fn(fn_def) => {
                // Get the body for this function
                match self.hir.get_body(&fn_def.body_id) {
                    Option::Some(body) => {
                        self.lower_function(def_id.clone(), body);
                    }
                    Option::None => {
                        // No body - might be extern or builtin
                    }
                }
            }
            // Other item kinds don't have bodies to lower
            ItemKind::Struct(_) => {}
            ItemKind::Enum(_) => {}
            ItemKind::Effect { operations: _, generics: _ } => {}
            ItemKind::Handler(_) => {
                // Handlers have operation implementations to lower
                // This would be handled similarly to functions
            }
            ItemKind::Trait { items: _, generics: _, supertraits: _ } => {}
            ItemKind::Impl { items: _, self_ty: _, trait_ref: _, generics: _ } => {
                // Impl items have method bodies to lower
            }
            ItemKind::Module(_) => {}
            ItemKind::TypeAlias { ty: _, generics: _ } => {}
            ItemKind::Const { ty: _, value: _ } => {}
            ItemKind::Static { ty: _, value: _, mutable: _ } => {}
            ItemKind::ExternBlock(_) => {}
            ItemKind::Bridge(_) => {}
            ItemKind::Use { path: _, alias: _ } => {}
        }
    }

    /// Lower a single function body.
    fn lower_function(&mut self, def_id: DefId, body: &Body) {
        let lowering = FunctionLowering::new(def_id.clone(), body, self.hir);
        let (mir_body, discovered_closures) = lowering.lower();

        // Store the MIR body
        self.bodies.insert(def_id.index, mir_body);

        // Queue discovered closures for later lowering
        let mut i: usize = 0;
        while i < discovered_closures.len() {
            let closure = discovered_closures[i].clone();
            self.pending_closures.push(closure);
            i = i + 1;
        }
    }

    /// Lower all discovered closures iteratively.
    ///
    /// Closures may discover nested closures, so we continue until
    /// no new closures are found.
    fn lower_all_closures(&mut self) {
        while self.pending_closures.len() > 0 {
            // Take the current batch of closures
            let closures_to_lower = self.pending_closures.clone();
            self.pending_closures = [];

            // Lower each closure
            let mut i: usize = 0;
            while i < closures_to_lower.len() {
                let (body_id, closure_def_id, captures) = &closures_to_lower[i];
                self.lower_closure(body_id, closure_def_id, captures);
                i = i + 1;
            }
        }
    }

    /// Lower a single closure body.
    fn lower_closure(
        &mut self,
        body_id: &BodyId,
        closure_def_id: &DefId,
        captures: &[(Capture, Type)],
    ) {
        match self.hir.get_body(body_id) {
            Option::Some(body) => {
                let lowering = ClosureLowering::new(
                    closure_def_id.clone(),
                    body,
                    self.hir,
                    captures.clone(),
                    self.closure_counter,
                );
                let (mir_body, nested_closures, new_counter) = lowering.lower();

                // Update closure counter
                self.closure_counter = new_counter;

                // Store the MIR body
                self.bodies.insert(closure_def_id.index, mir_body);

                // Queue nested closures
                let mut i: usize = 0;
                while i < nested_closures.len() {
                    self.pending_closures.push(nested_closures[i].clone());
                    i = i + 1;
                }
            }
            Option::None => {
                // Missing body - add diagnostic
                self.diagnostics.push(Diagnostic::error(
                    "missing closure body".to_string(),
                    Span::dummy(),
                ));
            }
        }
    }

    /// Add a diagnostic message.
    pub fn add_diagnostic(&mut self, diag: Diagnostic) {
        self.diagnostics.push(diag);
    }

    /// Check if any errors were encountered.
    pub fn has_errors(&self) -> bool {
        let mut i: usize = 0;
        while i < self.diagnostics.len() {
            if self.diagnostics[i].is_error {
                return true;
            };
            i = i + 1;
        }
        false
    }

    /// Get the number of lowered bodies.
    pub fn body_count(&self) -> usize {
        self.bodies.len();
    }
}

// ============================================================
// Convenience Functions
// ============================================================

/// Lower an entire HIR crate to MIR.
///
/// This is a convenience function that creates a `MirLowering` instance
/// and performs the lowering in one call.
///
/// # Returns
///
/// - HashMap of DefId → MirBody
/// - Array of diagnostics
/// - Inline handler bodies
pub fn lower_crate(
    hir: &HirCrate,
) -> (HashMap<u32, MirBody>, [Diagnostic], InlineHandlerBodies) {
    let lowering = MirLowering::new(hir);
    lowering.lower_crate();
}

/// Check if a DefId is a synthetic closure DefId.
pub fn is_closure_def_id(def_id: &DefId) -> bool {
    def_id.index >= CLOSURE_DEF_ID_START && def_id.index < INLINE_HANDLER_DEF_ID_START
}

/// Check if a DefId is a synthetic inline handler DefId.
pub fn is_inline_handler_def_id(def_id: &DefId) -> bool {
    def_id.index >= INLINE_HANDLER_DEF_ID_START
}

/// Check if a DefId is a synthetic DefId (closure or inline handler).
pub fn is_synthetic_def_id(def_id: &DefId) -> bool {
    def_id.index >= INLINE_HANDLER_DEF_ID_START || def_id.index >= CLOSURE_DEF_ID_START
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_mir_lowering_new() {
    // Basic construction test
    // Full test would require a HIR crate
    assert!(true);
}

#[test]
fn test_inline_handler_bodies() {
    let mut bodies = InlineHandlerBodies::new();
    assert!(bodies.len() == 0);
}

#[test]
fn test_is_closure_def_id() {
    let user_def = DefId::new(100);
    assert!(!is_closure_def_id(&user_def));

    let closure_def = DefId::new(CLOSURE_DEF_ID_START + 5);
    assert!(is_closure_def_id(&closure_def));
}

#[test]
fn test_is_inline_handler_def_id() {
    let closure_def = DefId::new(CLOSURE_DEF_ID_START + 5);
    assert!(!is_inline_handler_def_id(&closure_def));

    let handler_def = DefId::new(INLINE_HANDLER_DEF_ID_START + 3);
    assert!(is_inline_handler_def_id(&handler_def));
}

#[test]
fn test_diagnostic() {
    let err = Diagnostic::error("test error".to_string(), Span::dummy());
    assert!(err.is_error);

    let warn = Diagnostic::warning("test warning".to_string(), Span::dummy());
    assert!(!warn.is_error);
}
