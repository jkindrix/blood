/// MIR Function Bodies
///
/// This module defines the structure of MIR function bodies.
///
/// # Body Structure
///
/// A MIR body contains:
/// - **Locals**: All local variables (return place, parameters, temporaries)
/// - **Basic Blocks**: The control-flow graph
/// - **Metadata**: Span information, source scopes
///
/// # Local Convention
///
/// Following Rust MIR convention:
/// - `_0`: Return place
/// - `_1..=_n`: Parameters (where n = param_count)
/// - `_(n+1)..`: Temporaries and user variables

use std.compiler.parser::{Span};
use std.compiler.typeck.types::{Type, DefId};
use std.compiler.mir.types::{
    LocalId, BasicBlockId, BasicBlockData, Statement, Terminator, TerminatorKind,
};
use std.collections::{HashMap};

// ============================================================
// Local Kind
// ============================================================

/// The kind of a local variable.
pub enum LocalKind {
    /// Return place (always index 0).
    ReturnPlace,
    /// Function argument.
    Arg,
    /// User-declared variable.
    Var,
    /// Compiler-generated temporary.
    Temp,
}

impl Clone for LocalKind {
    fn clone(&self) -> LocalKind {
        match self {
            LocalKind::ReturnPlace => LocalKind::ReturnPlace,
            LocalKind::Arg => LocalKind::Arg,
            LocalKind::Var => LocalKind::Var,
            LocalKind::Temp => LocalKind::Temp,
        }
    }
}

impl PartialEq for LocalKind {
    fn eq(&self, other: &LocalKind) -> bool {
        match (self, other) {
            (LocalKind::ReturnPlace, LocalKind::ReturnPlace) => true,
            (LocalKind::Arg, LocalKind::Arg) => true,
            (LocalKind::Var, LocalKind::Var) => true,
            (LocalKind::Temp, LocalKind::Temp) => true,
            (_, _) => false,
        }
    }
}

// ============================================================
// MIR Local
// ============================================================

/// A local variable in MIR.
pub struct MirLocal {
    /// The local ID.
    id: LocalId,
    /// The type of this local.
    ty: Type,
    /// The kind of local (return, param, temp, user).
    kind: LocalKind,
    /// Whether this local is mutable.
    mutable: bool,
    /// The name (for debugging/error messages).
    name: Option<String>,
    /// Source span where this local was declared.
    span: Span,
}

impl MirLocal {
    /// Create a new MIR local.
    pub fn new(id: LocalId, ty: Type, kind: LocalKind, span: Span) -> MirLocal {
        MirLocal {
            id,
            ty,
            kind,
            mutable: false,
            name: Option::None,
            span,
        }
    }

    /// Get the local ID.
    pub fn id(&self) -> &LocalId {
        &self.id
    }

    /// Get the type.
    pub fn ty(&self) -> &Type {
        &self.ty
    }

    /// Set the type.
    pub fn set_ty(&mut self, ty: Type) {
        self.ty = ty;
    }

    /// Get the kind.
    pub fn kind(&self) -> &LocalKind {
        &self.kind
    }

    /// Check if mutable.
    pub fn is_mutable(&self) -> bool {
        self.mutable
    }

    /// Set mutable.
    pub fn set_mutable(&mut self, mutable: bool) {
        self.mutable = mutable;
    }

    /// Get the name.
    pub fn name(&self) -> &Option<String> {
        &self.name
    }

    /// Set the name.
    pub fn set_name(&mut self, name: String) {
        self.name = Option::Some(name);
    }

    /// Get the span.
    pub fn span(&self) -> &Span {
        &self.span
    }

    /// Check if this is the return place.
    pub fn is_return_place(&self) -> bool {
        self.id.index() == 0
    }

    /// Check if this is a parameter.
    pub fn is_param(&self) -> bool {
        match &self.kind {
            LocalKind::Arg => true,
            LocalKind::ReturnPlace => false,
            LocalKind::Var => false,
            LocalKind::Temp => false,
        }
    }

    /// Check if this is a temporary.
    pub fn is_temp(&self) -> bool {
        match &self.kind {
            LocalKind::Temp => true,
            LocalKind::ReturnPlace => false,
            LocalKind::Arg => false,
            LocalKind::Var => false,
        }
    }
}

impl Clone for MirLocal {
    fn clone(&self) -> MirLocal {
        MirLocal {
            id: self.id.clone(),
            ty: self.ty.clone(),
            kind: self.kind.clone(),
            mutable: self.mutable,
            name: self.name.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// Source Scope
// ============================================================

/// Source scope information for debugging.
pub struct SourceScope {
    /// Parent scope (if any).
    parent: Option<u32>,
    /// Span of this scope.
    span: Span,
}

impl SourceScope {
    /// Create a new source scope.
    pub fn new(parent: Option<u32>, span: Span) -> SourceScope {
        SourceScope { parent, span }
    }

    /// Get the parent scope index.
    pub fn parent(&self) -> &Option<u32> {
        &self.parent
    }

    /// Get the span.
    pub fn span(&self) -> &Span {
        &self.span
    }
}

impl Clone for SourceScope {
    fn clone(&self) -> SourceScope {
        SourceScope {
            parent: self.parent.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// MIR Body
// ============================================================

/// A MIR function body.
///
/// This is the main data structure representing a function in MIR form.
pub struct MirBody {
    /// The definition ID of this function.
    def_id: DefId,
    /// All local variables (return place at index 0, then params, then temps).
    locals: [MirLocal],
    /// Number of parameters (not counting return place).
    param_count: u32,
    /// The basic blocks of the CFG.
    basic_blocks: [BasicBlockData],
    /// Source span for the function.
    span: Span,
    /// Source scopes for debugging.
    source_scopes: [SourceScope],
}

impl MirBody {
    /// Create a new MIR body.
    pub fn new(def_id: DefId, span: Span) -> MirBody {
        MirBody {
            def_id,
            locals: [],
            param_count: 0,
            basic_blocks: [],
            span,
            source_scopes: [],
        }
    }

    /// Get the definition ID.
    pub fn def_id(&self) -> &DefId {
        &self.def_id
    }

    /// Get the source span.
    pub fn span(&self) -> &Span {
        &self.span
    }

    /// Get all locals.
    pub fn locals(&self) -> &[MirLocal] {
        &self.locals
    }

    /// Get the parameter count.
    pub fn param_count(&self) -> u32 {
        self.param_count
    }

    /// Get the return place (always local 0).
    pub fn return_place(&self) -> LocalId {
        LocalId::new(0)
    }

    /// Get the return type.
    pub fn return_type(&self) -> &Type {
        &self.locals[0].ty()
    }

    /// Get a local by ID.
    pub fn get_local(&self, id: &LocalId) -> Option<&MirLocal> {
        let idx = id.index() as usize;
        if idx < self.locals.len() {
            Option::Some(&self.locals[idx])
        } else {
            Option::None
        }
    }

    /// Allocate a new local and return its ID.
    pub fn new_local(&mut self, ty: Type, kind: LocalKind, span: Span) -> LocalId {
        let id = LocalId::new(self.locals.len() as u32);
        self.locals.push(MirLocal::new(id.clone(), ty, kind, span));
        id
    }

    /// Allocate a new temporary local.
    pub fn new_temp(&mut self, ty: Type, span: Span) -> LocalId {
        self.new_local(ty, LocalKind::Temp, span);
    }

    /// Get all basic blocks.
    pub fn basic_blocks(&self) -> &[BasicBlockData] {
        &self.basic_blocks
    }

    /// Get a basic block by ID.
    pub fn get_block(&self, id: &BasicBlockId) -> Option<&BasicBlockData> {
        let idx = id.index() as usize;
        if idx < self.basic_blocks.len() {
            Option::Some(&self.basic_blocks[idx])
        } else {
            Option::None
        }
    }

    /// Get a mutable reference to a basic block.
    pub fn get_block_mut(&mut self, id: &BasicBlockId) -> Option<&mut BasicBlockData> {
        let idx = id.index() as usize;
        if idx < self.basic_blocks.len() {
            Option::Some(&mut self.basic_blocks[idx])
        } else {
            Option::None
        }
    }

    /// Allocate a new basic block and return its ID.
    pub fn new_block(&mut self) -> BasicBlockId {
        let id = BasicBlockId::new(self.basic_blocks.len() as u32);
        self.basic_blocks.push(BasicBlockData::new());
        id
    }

    /// Get the entry block.
    pub fn entry_block(&self) -> &BasicBlockData {
        &self.basic_blocks[0]
    }

    /// Check if all blocks are terminated.
    pub fn is_complete(&self) -> bool {
        let mut i = 0;
        while i < self.basic_blocks.len() {
            if !self.basic_blocks[i].is_terminated() {
                return false;
            };
            i = i + 1;
        }
        true
    }

    /// Add a statement to a block.
    pub fn push_statement(&mut self, block: &BasicBlockId, stmt: Statement) {
        match self.get_block_mut(block) {
            Option::Some(bb) => bb.push_statement(stmt),
            Option::None => {}
        }
    }

    /// Set the terminator for a block.
    pub fn set_terminator(&mut self, block: &BasicBlockId, term: Terminator) {
        match self.get_block_mut(block) {
            Option::Some(bb) => bb.set_terminator(term),
            Option::None => {}
        }
    }

    /// Compute predecessors for all blocks.
    pub fn predecessors(&self) -> HashMap<u32, [BasicBlockId]> {
        let mut preds: HashMap<u32, [BasicBlockId]> = HashMap::new();

        // Initialize all blocks with empty predecessor lists
        let mut i = 0;
        while i < self.basic_blocks.len() {
            preds.insert(i as u32, []);
            i = i + 1;
        };

        // Populate predecessors from successors
        i = 0;
        while i < self.basic_blocks.len() {
            let id = BasicBlockId::new(i as u32);
            let succs = self.basic_blocks[i].successors();
            let mut j = 0;
            while j < succs.len() {
                let succ_idx = succs[j].index();
                match preds.get_mut(&succ_idx) {
                    Option::Some(pred_list) => {
                        pred_list.push(id.clone());
                    }
                    Option::None => {}
                };
                j = j + 1;
            };
            i = i + 1;
        }

        preds
    }

    /// Check if a block is reachable from entry.
    pub fn is_reachable(&self, target: &BasicBlockId) -> bool {
        let mut visited: [bool] = [];
        let mut i = 0;
        while i < self.basic_blocks.len() {
            visited.push(false);
            i = i + 1;
        };

        let mut worklist: [BasicBlockId] = [BasicBlockId::entry()];

        while worklist.len() > 0 {
            let bb = worklist.pop().unwrap();
            if bb == *target {
                return true;
            };
            let idx = bb.index() as usize;
            if visited[idx] {
                continue;
            }
            visited[idx] = true;

            match self.get_block(&bb) {
                Option::Some(block) => {
                    let succs = block.successors();
                    let mut j = 0;
                    while j < succs.len() {
                        let succ_idx = succs[j].index() as usize;
                        if !visited[succ_idx] {
                            worklist.push(succs[j].clone());
                        };
                        j = j + 1;
                    }
                }
                Option::None => {}
            }
        }

        false
    }

    /// Get blocks in reverse postorder (for dataflow analysis).
    pub fn reverse_postorder(&self) -> [BasicBlockId] {
        let mut visited: [bool] = [];
        let mut i = 0;
        while i < self.basic_blocks.len() {
            visited.push(false);
            i = i + 1;
        };

        let mut postorder: [BasicBlockId] = [];
        self.visit_postorder(BasicBlockId::entry(), &mut visited, &mut postorder);

        // Reverse the postorder
        let mut result: [BasicBlockId] = [];
        let mut j = postorder.len();
        while j > 0 {
            j = j - 1;
            result.push(postorder[j].clone());
        }
        result
    }

    fn visit_postorder(
        &self,
        bb: BasicBlockId,
        visited: &mut [bool],
        postorder: &mut [BasicBlockId],
    ) {
        let idx = bb.index() as usize;
        if visited[idx] {
            return;
        }
        visited[idx] = true;

        match self.get_block(&bb) {
            Option::Some(block) => {
                let succs = block.successors();
                let mut i = 0;
                while i < succs.len() {
                    self.visit_postorder(succs[i].clone(), visited, postorder);
                    i = i + 1;
                }
            }
            Option::None => {}
        };

        postorder.push(bb);
    }
}

impl Clone for MirBody {
    fn clone(&self) -> MirBody {
        MirBody {
            def_id: self.def_id.clone(),
            locals: self.locals.clone(),
            param_count: self.param_count,
            basic_blocks: self.basic_blocks.clone(),
            span: self.span.clone(),
            source_scopes: self.source_scopes.clone(),
        }
    }
}

// ============================================================
// MIR Body Builder
// ============================================================

/// Builder for constructing MIR bodies.
pub struct MirBodyBuilder {
    body: MirBody,
    current_block: BasicBlockId,
}

impl MirBodyBuilder {
    /// Create a new builder.
    pub fn new(def_id: DefId, span: Span) -> MirBodyBuilder {
        let mut body = MirBody::new(def_id, span);
        let entry = body.new_block();
        MirBodyBuilder {
            body,
            current_block: entry,
        }
    }

    /// Get the underlying body.
    pub fn body(&self) -> &MirBody {
        &self.body
    }

    /// Get the underlying body mutably.
    pub fn body_mut(&mut self) -> &mut MirBody {
        &mut self.body
    }

    /// Set the return type (creates return place).
    pub fn set_return_type(&mut self, ty: Type) {
        let span = self.body.span.clone();
        if self.body.locals.len() == 0 {
            let id = LocalId::new(0);
            self.body.locals.push(MirLocal::new(id, ty, LocalKind::ReturnPlace, span));
        } else {
            self.body.locals[0].set_ty(ty);
        }
    }

    /// Add a parameter.
    pub fn add_param(&mut self, name: Option<String>, ty: Type, span: Span) -> LocalId {
        let id = LocalId::new(self.body.locals.len() as u32);
        let mut local = MirLocal::new(id.clone(), ty, LocalKind::Arg, span);
        match name {
            Option::Some(n) => local.set_name(n),
            Option::None => {}
        };
        self.body.locals.push(local);
        self.body.param_count = self.body.param_count + 1;
        id
    }

    /// Create a new temporary.
    pub fn new_temp(&mut self, ty: Type, span: Span) -> LocalId {
        self.body.new_temp(ty, span);
    }

    /// Update a local's type.
    pub fn set_local_type(&mut self, local: &LocalId, ty: Type) {
        let idx = local.index() as usize;
        if idx < self.body.locals.len() {
            self.body.locals[idx].set_ty(ty);
        }
    }

    /// Get a local's type.
    pub fn get_local_type(&self, local: &LocalId) -> Option<&Type> {
        let idx = local.index() as usize;
        if idx < self.body.locals.len() {
            Option::Some(self.body.locals[idx].ty())
        } else {
            Option::None
        }
    }

    /// Create a new basic block.
    pub fn new_block(&mut self) -> BasicBlockId {
        self.body.new_block();
    }

    /// Get the current block.
    pub fn current_block(&self) -> BasicBlockId {
        self.current_block.clone();
    }

    /// Switch to a different block.
    pub fn switch_to(&mut self, block: BasicBlockId) {
        self.current_block = block;
    }

    /// Push a statement to the current block.
    pub fn push_stmt(&mut self, stmt: Statement) {
        self.body.push_statement(&self.current_block, stmt);
    }

    /// Terminate the current block.
    pub fn terminate(&mut self, term: Terminator) {
        self.body.set_terminator(&self.current_block, term);
    }

    /// Check if the current block is terminated.
    pub fn is_current_terminated(&self) -> bool {
        match self.body.get_block(&self.current_block) {
            Option::Some(b) => b.is_terminated(),
            Option::None => false,
        }
    }

    /// Finish building and return the body.
    pub fn finish(self) -> MirBody {
        self.body
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_local_kind() {
    let ret = LocalKind::ReturnPlace;
    let arg = LocalKind::Arg;
    let var = LocalKind::Var;
    let temp = LocalKind::Temp;

    assert!(ret == LocalKind::ReturnPlace);
    assert!(arg == LocalKind::Arg);
    assert!(var == LocalKind::Var);
    assert!(temp == LocalKind::Temp);
    assert!(ret != arg);
}

#[test]
fn test_mir_local() {
    let span = Span::dummy();
    let ty = Type::i32();
    let local = MirLocal::new(LocalId::new(0), ty, LocalKind::ReturnPlace, span);

    assert!(local.is_return_place());
    assert!(!local.is_param());
    assert!(!local.is_temp());

    let param = MirLocal::new(LocalId::new(1), Type::bool(), LocalKind::Arg, Span::dummy());
    assert!(!param.is_return_place());
    assert!(param.is_param());

    let temp = MirLocal::new(LocalId::new(2), Type::i32(), LocalKind::Temp, Span::dummy());
    assert!(temp.is_temp());
}

#[test]
fn test_mir_body_new() {
    let body = MirBody::new(DefId::new(0), Span::dummy());
    assert!(body.locals().len() == 0);
    assert!(body.basic_blocks().len() == 0);
    assert!(body.param_count() == 0);
}

#[test]
fn test_mir_body_new_local() {
    let mut body = MirBody::new(DefId::new(0), Span::dummy());
    let id = body.new_local(Type::i32(), LocalKind::Temp, Span::dummy());
    assert!(id.index() == 0);
    assert!(body.locals().len() == 1);
}

#[test]
fn test_mir_body_new_block() {
    let mut body = MirBody::new(DefId::new(0), Span::dummy());
    let bb0 = body.new_block();
    let bb1 = body.new_block();
    assert!(bb0.index() == 0);
    assert!(bb1.index() == 1);
    assert!(body.basic_blocks().len() == 2);
}

#[test]
fn test_mir_body_builder() {
    let mut builder = MirBodyBuilder::new(DefId::new(0), Span::dummy());

    builder.set_return_type(Type::i32());
    let p1 = builder.add_param(Option::Some("x".to_string()), Type::i32(), Span::dummy());

    assert!(p1.index() == 1);
    assert!(builder.body().param_count() == 1);

    let body = builder.finish();
    assert!(body.locals().len() == 2);
    assert!(body.basic_blocks().len() == 1);
}
