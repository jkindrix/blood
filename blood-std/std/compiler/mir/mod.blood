/// Mid-level Intermediate Representation (MIR) for Blood
///
/// MIR is a control-flow graph based intermediate representation that sits
/// between the type-checked AST (HIR) and LLVM IR. It is designed for:
///
/// - **Explicit control flow**: No nested structures, all control flow via CFG edges
/// - **Flattened expressions**: Complex expressions broken into simple operations
/// - **Memory safety analysis**: Escape analysis for tier determination
/// - **Optimization**: Enable dead code elimination, inlining, etc.
///
/// # Module Structure
///
/// - `types`: Core MIR types (BasicBlock, Statement, Terminator, Place, Operand, Rvalue)
/// - `body`: MIR function bodies (MirBody, MirLocal, MirBodyBuilder)
/// - `ptr`: Memory pointer types (MemoryTier, BloodPtr, generation management)
/// - `escape`: Escape analysis (EscapeState, EscapeResults, EscapeAnalyzer)
/// - `lowering`: HIR→MIR lowering (MirLowering, FunctionLowering, ClosureLowering)
///
/// # Compilation Pipeline
///
/// ```text
/// HIR (High-level IR from type checker)
///     ↓
/// MIR Lowering (HIR → MIR)
///     ↓
/// MIR (Control Flow Graph)
///     ↓
/// Escape Analysis (determine memory allocation strategy)
///     ↓
/// MIR Codegen (MIR → LLVM IR)
///     ↓
/// LLVM IR
/// ```
///
/// # Design References
///
/// - [Rust MIR](https://rustc-dev-guide.rust-lang.org/mir/index.html)
/// - [RFC 1211](https://rust-lang.github.io/rfcs/1211-mir.html)
/// - Blood MEMORY_MODEL.md

// ============================================================
// Module Exports
// ============================================================

pub mod types;
pub mod body;
pub mod ptr;
pub mod escape;
pub mod lowering;

// ============================================================
// Re-exports for Convenience
// ============================================================

// From types module
pub use types::{
    LocalId,
    BasicBlockId,
    BasicBlockData,
    Statement,
    StatementKind,
    Terminator,
    TerminatorKind,
    SwitchTargets,
    Place,
    PlaceElem,
    Operand,
    Rvalue,
    BinOp,
    UnOp,
    AggregateKind,
    Constant,
    ConstantKind,
};

// From body module
pub use body::{
    LocalKind,
    MirLocal,
    SourceScope,
    MirBody,
    MirBodyBuilder,
};

// From ptr module
pub use ptr::{
    MemoryTier,
    PtrFlags,
    PtrMetadata,
    BloodPtr,
    StaleReferenceError,
    PERSISTENT_MARKER,
    OVERFLOW_GUARD,
    TOMBSTONE_GEN,
    INITIAL_GENERATION,
    FREED_GENERATION,
    MAX_VALID_GENERATION,
    compute_type_fingerprint,
};

// From escape module
pub use escape::{
    EscapeState,
    EscapeResults,
    EscapeAnalyzer,
    EscapeStatistics,
};

// From lowering module
pub use lowering::{
    MirLowering,
    FunctionLowering,
    ClosureLowering,
    InlineHandlerBodies,
    Diagnostic,
    lower_crate,
    is_closure_def_id,
    is_inline_handler_def_id,
    is_synthetic_def_id,
    convert_binop,
    convert_unop,
    lower_literal,
    is_irrefutable_pattern,
    LoopContext,
    CLOSURE_DEF_ID_START,
    INLINE_HANDLER_DEF_ID_START,
};

// ============================================================
// Module-Level Documentation Tests
// ============================================================

#[test]
fn test_mir_module_exists() {
    // Verify the module loads correctly
    let tier = MemoryTier::Stack;
    assert!(tier == MemoryTier::Stack);
}

#[test]
fn test_mir_basic_types() {
    let local = LocalId::new(5);
    assert!(local.index() == 5);

    let bb = BasicBlockId::new(3);
    assert!(bb.index() == 3);
}

#[test]
fn test_mir_escape_integration() {
    let state = EscapeState::NoEscape;
    let tier = state.recommended_tier();
    assert!(tier == MemoryTier::Stack);
}

#[test]
fn test_mir_lowering_exports() {
    // Verify lowering module exports are accessible
    assert!(CLOSURE_DEF_ID_START == 0xFFFF_0000);
    assert!(INLINE_HANDLER_DEF_ID_START == 0xFFFE_0000);

    // Test synthetic DefId detection
    let user_def = DefId::new(100);
    assert!(!is_synthetic_def_id(&user_def));

    let closure_def = DefId::new(CLOSURE_DEF_ID_START + 1);
    assert!(is_closure_def_id(&closure_def));
}
