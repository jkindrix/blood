// Blood Self-Hosted Compiler - Pattern Parsing
//
// This module handles parsing of patterns:
// - Literal patterns (integers, strings, booleans)
// - Identifier patterns (bindings)
// - Path patterns (enum variants)
// - Struct patterns (destructuring)
// - Tuple patterns
// - Slice patterns
// - Reference patterns
// - Wildcard patterns

mod parser_base;
mod common;
mod token;
mod ast;
mod parser_type;

// ============================================================
// Pattern Parsing
// ============================================================

/// Parse a pattern, including or-patterns: `A | B | C`.
pub fn parse_pattern(parser: &mut parser_base::Parser) -> ast::Pattern {
    let start = parser.current.span;
    let kind = parse_pattern_kind(parser);
    let end_span = parser.previous.span;
    let first = ast::Pattern {
        kind: kind,
        span: common::Span { start: start.start, end: end_span.end, line: start.line, column: start.column },
    };

    // Check for or-pattern: `A | B | C`
    if parser.check(token::TokenKind::Or) {
        let mut patterns: Vec<ast::Pattern> = Vec::new();
        patterns.push(first);
        while parser.try_consume(token::TokenKind::Or) {
            let alt_start = parser.current.span;
            let alt_kind = parse_pattern_kind(parser);
            let alt_end = parser.previous.span;
            patterns.push(ast::Pattern {
                kind: alt_kind,
                span: common::Span { start: alt_start.start, end: alt_end.end, line: alt_start.line, column: alt_start.column },
            });
        }
        let or_end = parser.previous.span;
        ast::Pattern {
            kind: ast::PatternKind::Or(patterns),
            span: common::Span { start: start.start, end: or_end.end, line: start.line, column: start.column },
        }
    } else {
        first
    }
}

/// Parse a pattern kind.
fn parse_pattern_kind(parser: &mut parser_base::Parser) -> ast::PatternKind {
    match parser.current.kind {
        // Negative literal pattern: -42, -3.14 (with range check: -1..=1)
        token::TokenKind::Minus => {
            let neg_start = parser.current.span;
            parser.advance(); // consume '-'
            if parser.check(token::TokenKind::IntLit) {
                let pat_start = parser.current.span;
                let int_val = parser_base::parse_int_value_from_span(parser, pat_start);
                let int_suffix = parser_base::parse_int_suffix_from_span(parser, pat_start);
                parser.advance();
                let neg_span = common::Span { start: neg_start.start, end: pat_start.end, line: neg_start.line, column: neg_start.column };
                let lit = ast::Literal {
                    kind: ast::LiteralKind::Int { val: int_val, suffix: int_suffix },
                    span: neg_span,
                };
                return maybe_range_pattern(parser, ast::PatternKind::Literal(lit), neg_span);
            } else if parser.check(token::TokenKind::FloatLit) {
                let pat_start = parser.current.span;
                let float_bits = parser_base::parse_float_bits_from_span(parser, pat_start);
                let float_suffix = parser_base::parse_float_suffix_from_span(parser, pat_start);
                parser.advance();
                // Negate by flipping the sign bit (bit 63)
                let neg_bits = float_bits ^ 9223372036854775808;
                let neg_span = common::Span { start: neg_start.start, end: pat_start.end, line: neg_start.line, column: neg_start.column };
                let lit = ast::Literal {
                    kind: ast::LiteralKind::Float { bits: neg_bits, suffix: float_suffix },
                    span: neg_span,
                };
                return maybe_range_pattern(parser, ast::PatternKind::Literal(lit), neg_span);
            } else {
                parser.error_expected("number after `-`");
                return ast::PatternKind::Wildcard;
            }
        }

        // Rest pattern: ..
        token::TokenKind::DotDot => {
            parser.advance();
            return ast::PatternKind::Rest;
        }

        // Literal patterns (with range check: 0..5, 0..=9)
        token::TokenKind::IntLit => {
            let pat_start = parser.current.span;
            let int_val = parser_base::parse_int_value_from_span(parser, pat_start);
            let int_suffix = parser_base::parse_int_suffix_from_span(parser, pat_start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Int { val: int_val, suffix: int_suffix },
                span: pat_start,
            };
            return maybe_range_pattern(parser, ast::PatternKind::Literal(lit), pat_start);
        }
        token::TokenKind::FloatLit => {
            let pat_start = parser.current.span;
            let float_bits = parser_base::parse_float_bits_from_span(parser, pat_start);
            let float_suffix = parser_base::parse_float_suffix_from_span(parser, pat_start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Float { bits: float_bits, suffix: float_suffix },
                span: pat_start,
            };
            return maybe_range_pattern(parser, ast::PatternKind::Literal(lit), pat_start);
        }
        token::TokenKind::StringLit => {
            let pat_start = parser.current.span;
            let str_val = parser_base::parse_string_from_span(parser, pat_start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Str(str_val),
                span: pat_start,
            };
            return ast::PatternKind::Literal(lit);
        }
        token::TokenKind::CharLit => {
            let pat_start = parser.current.span;
            let char_val = parser_base::parse_char_from_span(parser, pat_start);
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Char(char_val),
                span: pat_start,
            };
            return maybe_range_pattern(parser, ast::PatternKind::Literal(lit), pat_start);
        }
        token::TokenKind::True => {
            let pat_start = parser.current.span;
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(true),
                span: pat_start,
            };
            return ast::PatternKind::Literal(lit);
        }
        token::TokenKind::False => {
            let pat_start = parser.current.span;
            parser.advance();
            let lit = ast::Literal {
                kind: ast::LiteralKind::Bool(false),
                span: pat_start,
            };
            return ast::PatternKind::Literal(lit);
        }

        // Reference pattern: &pat or &mut pat
        token::TokenKind::And => {
            parser.advance();
            let is_mut = parser.try_consume(token::TokenKind::Mut);
            let inner = parse_pattern(parser);
            return ast::PatternKind::Ref {
                is_mut: is_mut,
                inner: Box::new(inner),
            };
        }

        // mut binding
        token::TokenKind::Mut => {
            parser.advance();
            let name = parser.parse_spanned_symbol();
            let subpattern = if parser.try_consume(token::TokenKind::At) {
                Option::Some(Box::new(parse_pattern(parser)))
            } else {
                Option::None
            };
            return ast::PatternKind::Ident {
                by_ref: false,
                is_mut: true,
                name: name,
                subpattern: subpattern,
            };
        }

        // ref binding
        token::TokenKind::Ref => {
            parser.advance();
            let is_mut = parser.try_consume(token::TokenKind::Mut);
            let name = parser.parse_spanned_symbol();
            let subpattern = if parser.try_consume(token::TokenKind::At) {
                Option::Some(Box::new(parse_pattern(parser)))
            } else {
                Option::None
            };
            return ast::PatternKind::Ident {
                by_ref: true,
                is_mut: is_mut,
                name: name,
                subpattern: subpattern,
            };
        }

        // Tuple pattern: (pat, pat, ...)
        token::TokenKind::LParen => {
            return parse_tuple_pattern(parser);
        }

        // Slice pattern: [pat, pat, ...]
        token::TokenKind::LBracket => {
            return parse_slice_pattern(parser);
        }

        // Identifier or path pattern
        token::TokenKind::Ident => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::TypeIdent => {
            return parse_ident_or_path_pattern(parser);
        }
        // Keywords that can be used as identifiers in pattern position
        token::TokenKind::Default => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Handle => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Handler => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Effect => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Op => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Deep => {
            return parse_ident_or_path_pattern(parser);
        }
        token::TokenKind::Shallow => {
            return parse_ident_or_path_pattern(parser);
        }

        // Path starting with ::
        token::TokenKind::ColonColon => {
            return parse_path_pattern(parser);
        }

        token::TokenKind::Error => {
            return ast::PatternKind::Wildcard;
        }

        _ => {
            parser.error_expected("pattern");
            return ast::PatternKind::Wildcard;
        }
    }
}

fn parse_tuple_pattern(parser: &mut parser_base::Parser) -> ast::PatternKind {
    parser.advance(); // consume '('

    // Empty tuple: ()
    if parser.check(token::TokenKind::RParen) {
        parser.advance();
        return ast::PatternKind::Tuple {
            fields: Vec::new(),
            rest_pos: Option::None,
        };
    }

    // Check for (..) rest pattern
    if parser.check(token::TokenKind::DotDot) {
        parser.advance();
        parser.expect(token::TokenKind::RParen);
        return ast::PatternKind::Tuple {
            fields: Vec::new(),
            rest_pos: Option::Some(0 as usize),
        };
    }

    // Parse the first pattern
    let first = parse_pattern(parser);

    // If no comma follows, this is a parenthesized pattern, not a tuple
    if !parser.try_consume(token::TokenKind::Comma) {
        parser.expect(token::TokenKind::RParen);
        return ast::PatternKind::Paren(Box::new(first));
    }

    // Comma was consumed â€” this is a tuple pattern
    let mut fields: Vec<ast::Pattern> = Vec::new();
    fields.push(first);
    let mut rest_pos: Option<usize> = Option::None;
    let mut idx: usize = 1;

    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            rest_pos = Option::Some(idx);
        } else {
            let pat = parse_pattern(parser);
            fields.push(pat);
            idx = idx + 1;
        }

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RParen);

    ast::PatternKind::Tuple {
        fields: fields,
        rest_pos: rest_pos,
    }
}

fn parse_slice_pattern(parser: &mut parser_base::Parser) -> ast::PatternKind {
    parser.advance(); // consume '['
    let mut elements: Vec<ast::Pattern> = Vec::new();
    let mut rest_pos: Option<usize> = Option::None;
    let mut idx: usize = 0;

    while !parser.check(token::TokenKind::RBracket) && !parser.is_at_end() {
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            rest_pos = Option::Some(idx);
        } else {
            let pat = parse_pattern(parser);
            elements.push(pat);
            idx = idx + 1;
        }

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBracket);

    ast::PatternKind::Slice {
        elements: elements,
        rest_pos: rest_pos,
    }
}

fn parse_ident_or_path_pattern(parser: &mut parser_base::Parser) -> ast::PatternKind {
    // Check for wildcard pattern: _
    if parser.token_is_underscore(parser.current) {
        parser.advance();
        return ast::PatternKind::Wildcard;
    }

    let first_name = parser.parse_spanned_symbol();

    // Check for :: to see if this is a path
    if parser.check(token::TokenKind::ColonColon) {
        let mut segments: Vec<ast::TypePathSegment> = Vec::new();
        let first_seg = ast::TypePathSegment { name: first_name, args: Option::None };
        segments.push(first_seg);

        while parser.try_consume(token::TokenKind::ColonColon) {
            let seg_name = parser.parse_spanned_symbol();
            let seg = ast::TypePathSegment { name: seg_name, args: Option::None };
            segments.push(seg);
        }

        let path_span = common::Span {
            start: first_name.span.start,
            end: parser.previous.span.end,
            line: first_name.span.line,
            column: first_name.span.column,
        };
        let path = ast::TypePath { segments: segments, span: path_span };

        // Check for struct pattern: Path { ... }
        if parser.check(token::TokenKind::LBrace) {
            return parse_struct_pattern(parser, path);
        }

        // Check for tuple struct pattern: Path(...)
        if parser.check(token::TokenKind::LParen) {
            return parse_tuple_struct_pattern(parser, path);
        }

        return ast::PatternKind::Path(path);
    }

    // Check for @ subpattern
    if parser.try_consume(token::TokenKind::At) {
        let subpat = parse_pattern(parser);
        return ast::PatternKind::Ident {
            by_ref: false,
            is_mut: false,
            name: first_name,
            subpattern: Option::Some(Box::new(subpat)),
        };
    }

    // Check for struct pattern with single ident: Foo { ... }
    if parser.check(token::TokenKind::LBrace) {
        let mut segments: Vec<ast::TypePathSegment> = Vec::new();
        let seg = ast::TypePathSegment { name: first_name, args: Option::None };
        segments.push(seg);
        let path = ast::TypePath { segments: segments, span: first_name.span };
        return parse_struct_pattern(parser, path);
    }

    // Check for tuple struct pattern with single ident: Foo(...)
    if parser.check(token::TokenKind::LParen) {
        let mut segments: Vec<ast::TypePathSegment> = Vec::new();
        let seg = ast::TypePathSegment { name: first_name, args: Option::None };
        segments.push(seg);
        let path = ast::TypePath { segments: segments, span: first_name.span };
        return parse_tuple_struct_pattern(parser, path);
    }

    // Simple identifier pattern
    ast::PatternKind::Ident {
        by_ref: false,
        is_mut: false,
        name: first_name,
        subpattern: Option::None,
    }
}

fn parse_path_pattern(parser: &mut parser_base::Parser) -> ast::PatternKind {
    let path = parser_type::parse_type_path(parser);

    // Check for struct pattern
    if parser.check(token::TokenKind::LBrace) {
        return parse_struct_pattern(parser, path);
    }

    // Check for tuple struct pattern
    if parser.check(token::TokenKind::LParen) {
        return parse_tuple_struct_pattern(parser, path);
    }

    ast::PatternKind::Path(path)
}

fn parse_struct_pattern(parser: &mut parser_base::Parser, path: ast::TypePath) -> ast::PatternKind {
    parser.advance(); // consume '{'
    let mut fields: Vec<ast::StructPatternField> = Vec::new();
    let mut has_rest = false;

    while !parser.check(token::TokenKind::RBrace) && !parser.is_at_end() {
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            has_rest = true;
            break;
        }

        // Check for ref/mut modifiers before field name
        let by_ref = parser.try_consume(token::TokenKind::Ref);
        let is_field_mut = if !by_ref { parser.try_consume(token::TokenKind::Mut) } else { parser.try_consume(token::TokenKind::Mut) };

        let field_start = parser.current.span;
        let field_name = parser.parse_spanned_symbol();

        let pattern = if parser.try_consume(token::TokenKind::Colon) {
            Option::Some(parse_pattern(parser))
        } else {
            // Shorthand: `field` or `ref field` or `mut field` or `ref mut field`
            // All create an ident binding pattern equivalent to `field: field`
            let pat_kind = ast::PatternKind::Ident {
                by_ref: by_ref,
                is_mut: is_field_mut,
                name: field_name,
                subpattern: Option::None,
            };
            Option::Some(ast::Pattern { kind: pat_kind, span: common::Span { start: field_start.start, end: parser.previous.span.end, line: field_start.line, column: field_start.column } })
        };

        let field_end = parser.previous.span;
        let field = ast::StructPatternField {
            name: field_name,
            pattern: pattern,
            span: common::Span { start: field_start.start, end: field_end.end, line: field_start.line, column: field_start.column },
        };
        fields.push(field);

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RBrace);

    ast::PatternKind::Struct {
        path: path,
        fields: fields,
        has_rest: has_rest,
    }
}

fn parse_tuple_struct_pattern(parser: &mut parser_base::Parser, path: ast::TypePath) -> ast::PatternKind {
    parser.advance(); // consume '('
    let mut fields: Vec<ast::Pattern> = Vec::new();
    let mut rest_pos: Option<usize> = Option::None;
    let mut idx: usize = 0;

    while !parser.check(token::TokenKind::RParen) && !parser.is_at_end() {
        if parser.check(token::TokenKind::DotDot) {
            parser.advance();
            rest_pos = Option::Some(idx);
        } else {
            let pat = parse_pattern(parser);
            fields.push(pat);
            idx = idx + 1;
        }

        if !parser.try_consume(token::TokenKind::Comma) {
            break;
        }
    }

    parser.expect(token::TokenKind::RParen);

    ast::PatternKind::TupleStruct {
        path: path,
        fields: fields,
        rest_pos: rest_pos,
    }
}

/// Check if the current token is `..` or `..=` and if so, parse a range pattern.
/// Otherwise return the given pattern kind as-is.
fn maybe_range_pattern(parser: &mut parser_base::Parser, start_kind: ast::PatternKind, start_span: common::Span) -> ast::PatternKind {
    if parser.check(token::TokenKind::DotDot) {
        parser.advance();
        let end_pat = parse_pattern_kind(parser);
        let end_span = parser.previous.span;
        return ast::PatternKind::Range {
            start: Option::Some(Box::new(ast::Pattern {
                kind: start_kind,
                span: start_span,
            })),
            end_val: Option::Some(Box::new(ast::Pattern {
                kind: end_pat,
                span: end_span,
            })),
            inclusive: false,
        };
    }
    if parser.check(token::TokenKind::DotDotEq) {
        parser.advance();
        let end_pat = parse_pattern_kind(parser);
        let end_span = parser.previous.span;
        return ast::PatternKind::Range {
            start: Option::Some(Box::new(ast::Pattern {
                kind: start_kind,
                span: start_span,
            })),
            end_val: Option::Some(Box::new(ast::Pattern {
                kind: end_pat,
                span: end_span,
            })),
            inclusive: true,
        };
    }
    start_kind
}
