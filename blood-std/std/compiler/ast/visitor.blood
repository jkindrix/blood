//! # AST Visitor Pattern
//!
//! Visitor traits and helpers for traversing the Blood AST.
//!
//! ## Overview
//!
//! The visitor pattern allows processing AST nodes without modifying them.
//! This is useful for:
//! - Analysis passes (type checking, name resolution)
//! - Pretty printing
//! - Linting
//! - Code generation
//!
//! ## Visitor Traits
//!
//! | Trait | Use Case |
//! |-------|----------|
//! | `Visitor` | Read-only traversal |
//! | `MutVisitor` | Transforming traversal |
//!
//! ## Usage
//!
//! ```blood
//! struct CountFunctions {
//!     count: usize,
//! }
//!
//! impl Visitor for CountFunctions {
//!     fn visit_fn_decl(self: &mut Self, decl: &FnDecl) {
//!         self.count += 1
//!         walk_fn_decl(self, decl)
//!     }
//! }
//!
//! let mut counter = CountFunctions { count: 0 }
//! counter.visit_program(&program)
//! println("Found {} functions", counter.count)
//! ```
//!
//! ## Walk Functions
//!
//! Walk functions provide default traversal behavior. Override `visit_*`
//! methods to process specific node types, calling the corresponding
//! `walk_*` function to continue traversal into children.

module std.compiler.ast.visitor;

use std.core.Option;
use std.core.Box;
use std.collections.Vec;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.Program;
use std.compiler.ast.node.ModuleDecl;
use std.compiler.ast.node.ModulePath;
use std.compiler.ast.node.Import;
use std.compiler.ast.node.Ident;
use std.compiler.ast.attr.Attribute;
use std.compiler.ast.attr.AttrArgs;
use std.compiler.ast.attr.AttrArg;
use std.compiler.ast.lit.Literal;
use std.compiler.ast.ty.Type;
use std.compiler.ast.ty.TypeKind;
use std.compiler.ast.ty.TypePath;
use std.compiler.ast.ty.TypeParams;
use std.compiler.ast.ty.GenericParam;
use std.compiler.ast.ty.WhereClause;
use std.compiler.ast.ty.WherePredicate;
use std.compiler.ast.ty.EffectRow;
use std.compiler.ast.ty.EffectRowKind;
use std.compiler.ast.ty.TypeArg;
use std.compiler.ast.decl.Declaration;
use std.compiler.ast.decl.FnDecl;
use std.compiler.ast.decl.Param;
use std.compiler.ast.decl.TypeDecl;
use std.compiler.ast.decl.StructDecl;
use std.compiler.ast.decl.StructBody;
use std.compiler.ast.decl.StructField;
use std.compiler.ast.decl.EnumDecl;
use std.compiler.ast.decl.EnumVariant;
use std.compiler.ast.decl.EffectDecl;
use std.compiler.ast.decl.OperationDecl;
use std.compiler.ast.decl.HandlerDecl;
use std.compiler.ast.decl.OperationImpl;
use std.compiler.ast.decl.TraitDecl;
use std.compiler.ast.decl.TraitItem;
use std.compiler.ast.decl.ImplBlock;
use std.compiler.ast.decl.ImplItem;
use std.compiler.ast.decl.ConstDecl;
use std.compiler.ast.decl.StaticDecl;
use std.compiler.ast.decl.ModItemDecl;
use std.compiler.ast.decl.MacroDecl;
use std.compiler.ast.expr.Expr;
use std.compiler.ast.expr.ExprKind;
use std.compiler.ast.expr.ExprPath;
use std.compiler.ast.expr.CallArg;
use std.compiler.ast.expr.MatchArm;
use std.compiler.ast.expr.ClosureParam;
use std.compiler.ast.expr.ArrayExpr;
use std.compiler.ast.expr.ElseBranch;
use std.compiler.ast.expr.BinOp;
use std.compiler.ast.pattern.Pattern;
use std.compiler.ast.pattern.PatternKind;
use std.compiler.ast.pattern.StructPatternField;
use std.compiler.ast.stmt.Block;
use std.compiler.ast.stmt.Statement;
use std.compiler.ast.bridge.BridgeDecl;
use std.compiler.ast.bridge.BridgeItem;
use std.compiler.ast.bridge.BridgeFn;
use std.compiler.ast.bridge.BridgeStruct;
use std.compiler.ast.bridge.BridgeEnum;
use std.compiler.ast.bridge.BridgeUnion;
use std.compiler.ast.bridge.BridgeCallback;

// ============================================================================
// Visitor Trait
// ============================================================================

/// Trait for read-only AST traversal.
///
/// Implement this trait to process AST nodes. Override specific `visit_*`
/// methods to handle nodes of interest, and call the corresponding `walk_*`
/// function to continue traversal into children.
///
/// ## Example
///
/// ```blood
/// struct IdentCollector {
///     idents: Vec<Ident>,
/// }
///
/// impl Visitor for IdentCollector {
///     fn visit_ident(self: &mut Self, ident: &Ident) {
///         self.idents.push(ident.clone())
///     }
/// }
/// ```
pub trait Visitor {
    // ========================================================================
    // Top-Level
    // ========================================================================

    /// Visit a program.
    fn visit_program(self: &mut Self, program: &Program) {
        walk_program(self, program)
    }

    /// Visit a module declaration.
    fn visit_module_decl(self: &mut Self, decl: &ModuleDecl) {
        walk_module_decl(self, decl)
    }

    /// Visit a module path.
    fn visit_module_path(self: &mut Self, path: &ModulePath) {
        walk_module_path(self, path)
    }

    /// Visit an import.
    fn visit_import(self: &mut Self, import: &Import) {
        walk_import(self, import)
    }

    // ========================================================================
    // Declarations
    // ========================================================================

    /// Visit a declaration.
    fn visit_declaration(self: &mut Self, decl: &Declaration) {
        walk_declaration(self, decl)
    }

    /// Visit a function declaration.
    fn visit_fn_decl(self: &mut Self, decl: &FnDecl) {
        walk_fn_decl(self, decl)
    }

    /// Visit a function parameter.
    fn visit_param(self: &mut Self, param: &Param) {
        walk_param(self, param)
    }

    /// Visit a type declaration.
    fn visit_type_decl(self: &mut Self, decl: &TypeDecl) {
        walk_type_decl(self, decl)
    }

    /// Visit a struct declaration.
    fn visit_struct_decl(self: &mut Self, decl: &StructDecl) {
        walk_struct_decl(self, decl)
    }

    /// Visit a struct field.
    fn visit_struct_field(self: &mut Self, field: &StructField) {
        walk_struct_field(self, field)
    }

    /// Visit an enum declaration.
    fn visit_enum_decl(self: &mut Self, decl: &EnumDecl) {
        walk_enum_decl(self, decl)
    }

    /// Visit an enum variant.
    fn visit_enum_variant(self: &mut Self, variant: &EnumVariant) {
        walk_enum_variant(self, variant)
    }

    /// Visit an effect declaration.
    fn visit_effect_decl(self: &mut Self, decl: &EffectDecl) {
        walk_effect_decl(self, decl)
    }

    /// Visit an effect operation.
    fn visit_operation_decl(self: &mut Self, decl: &OperationDecl) {
        walk_operation_decl(self, decl)
    }

    /// Visit a handler declaration.
    fn visit_handler_decl(self: &mut Self, decl: &HandlerDecl) {
        walk_handler_decl(self, decl)
    }

    /// Visit an operation implementation.
    fn visit_operation_impl(self: &mut Self, impl_: &OperationImpl) {
        walk_operation_impl(self, impl_)
    }

    /// Visit a trait declaration.
    fn visit_trait_decl(self: &mut Self, decl: &TraitDecl) {
        walk_trait_decl(self, decl)
    }

    /// Visit a trait item.
    fn visit_trait_item(self: &mut Self, item: &TraitItem) {
        walk_trait_item(self, item)
    }

    /// Visit an impl block.
    fn visit_impl_block(self: &mut Self, impl_: &ImplBlock) {
        walk_impl_block(self, impl_)
    }

    /// Visit an impl item.
    fn visit_impl_item(self: &mut Self, item: &ImplItem) {
        walk_impl_item(self, item)
    }

    /// Visit a const declaration.
    fn visit_const_decl(self: &mut Self, decl: &ConstDecl) {
        walk_const_decl(self, decl)
    }

    /// Visit a static declaration.
    fn visit_static_decl(self: &mut Self, decl: &StaticDecl) {
        walk_static_decl(self, decl)
    }

    /// Visit a module item declaration.
    fn visit_mod_item_decl(self: &mut Self, decl: &ModItemDecl) {
        walk_mod_item_decl(self, decl)
    }

    /// Visit a macro declaration.
    fn visit_macro_decl(self: &mut Self, decl: &MacroDecl) {
        walk_macro_decl(self, decl)
    }

    // ========================================================================
    // Types
    // ========================================================================

    /// Visit a type.
    fn visit_type(self: &mut Self, ty: &Type) {
        walk_type(self, ty)
    }

    /// Visit a type path.
    fn visit_type_path(self: &mut Self, path: &TypePath) {
        walk_type_path(self, path)
    }

    /// Visit type parameters.
    fn visit_type_params(self: &mut Self, params: &TypeParams) {
        walk_type_params(self, params)
    }

    /// Visit a generic parameter.
    fn visit_generic_param(self: &mut Self, param: &GenericParam) {
        walk_generic_param(self, param)
    }

    /// Visit a where clause.
    fn visit_where_clause(self: &mut Self, clause: &WhereClause) {
        walk_where_clause(self, clause)
    }

    /// Visit a where predicate.
    fn visit_where_predicate(self: &mut Self, pred: &WherePredicate) {
        walk_where_predicate(self, pred)
    }

    /// Visit an effect row.
    fn visit_effect_row(self: &mut Self, row: &EffectRow) {
        walk_effect_row(self, row)
    }

    // ========================================================================
    // Expressions
    // ========================================================================

    /// Visit an expression.
    fn visit_expr(self: &mut Self, expr: &Expr) {
        walk_expr(self, expr)
    }

    /// Visit an expression path.
    fn visit_expr_path(self: &mut Self, path: &ExprPath) {
        walk_expr_path(self, path)
    }

    /// Visit a call argument.
    fn visit_call_arg(self: &mut Self, arg: &CallArg) {
        walk_call_arg(self, arg)
    }

    /// Visit a match arm.
    fn visit_match_arm(self: &mut Self, arm: &MatchArm) {
        walk_match_arm(self, arm)
    }

    /// Visit a closure parameter.
    fn visit_closure_param(self: &mut Self, param: &ClosureParam) {
        walk_closure_param(self, param)
    }

    // ========================================================================
    // Patterns
    // ========================================================================

    /// Visit a pattern.
    fn visit_pattern(self: &mut Self, pattern: &Pattern) {
        walk_pattern(self, pattern)
    }

    /// Visit a struct pattern field.
    fn visit_struct_pattern_field(self: &mut Self, field: &StructPatternField) {
        walk_struct_pattern_field(self, field)
    }

    // ========================================================================
    // Statements
    // ========================================================================

    /// Visit a block.
    fn visit_block(self: &mut Self, block: &Block) {
        walk_block(self, block)
    }

    /// Visit a statement.
    fn visit_statement(self: &mut Self, stmt: &Statement) {
        walk_statement(self, stmt)
    }

    // ========================================================================
    // Attributes and Literals
    // ========================================================================

    /// Visit an attribute.
    fn visit_attribute(self: &mut Self, attr: &Attribute) {
        walk_attribute(self, attr)
    }

    /// Visit a literal.
    fn visit_literal(self: &mut Self, lit: &Literal) {
        // No children to visit
    }

    /// Visit an identifier.
    fn visit_ident(self: &mut Self, ident: &Ident) {
        // No children to visit
    }

    // ========================================================================
    // Bridge (FFI)
    // ========================================================================

    /// Visit a bridge declaration.
    fn visit_bridge_decl(self: &mut Self, decl: &BridgeDecl) {
        walk_bridge_decl(self, decl)
    }

    /// Visit a bridge item.
    fn visit_bridge_item(self: &mut Self, item: &BridgeItem) {
        walk_bridge_item(self, item)
    }
}

// ============================================================================
// Walk Functions
// ============================================================================

/// Walk a program, visiting all children.
pub fn walk_program<V: Visitor>(visitor: &mut V, program: &Program) {
    if program.mod_decl.is_some() {
        let mod_decl: &ModuleDecl = program.mod_decl.as_ref().unwrap();
        visitor.visit_module_decl(mod_decl);
    }

    {
        let mut i: usize = 0;
        while i < program.imports.len() {
            if let Option::Some(import) = program.imports.get(i) {
                visitor.visit_import(import);
            };
            i = i + 1usize;
        }
    }

    {
        let mut i: usize = 0;
        while i < program.declarations.len() {
            if let Option::Some(decl) = program.declarations.get(i) {
                visitor.visit_declaration(decl);
            };
            i = i + 1usize;
        }
    }
}

/// Walk a module declaration.
pub fn walk_module_decl<V: Visitor>(visitor: &mut V, decl: &ModuleDecl) {
    visitor.visit_module_path(&decl.path);
}

/// Walk a module path.
pub fn walk_module_path<V: Visitor>(visitor: &mut V, path: &ModulePath) {
    let mut i: usize = 0;
    while i < path.segments.len() {
        if let Option::Some(segment) = path.segments.get(i) {
            visitor.visit_ident(segment);
        };
        i = i + 1usize;
    }
}

/// Walk an import.
pub fn walk_import<V: Visitor>(visitor: &mut V, import: &Import) {
    match import {
        Import::Simple { ref path, .. } => {
            visitor.visit_module_path(path);
        }
        Import::Group { ref path, .. } => {
            visitor.visit_module_path(path);
        }
        Import::Glob { ref path, .. } => {
            visitor.visit_module_path(path);
        }
    }
}

/// Walk a declaration.
pub fn walk_declaration<V: Visitor>(visitor: &mut V, decl: &Declaration) {
    match decl {
        Declaration::Function(ref d) => visitor.visit_fn_decl(d),
        Declaration::Type(ref d) => visitor.visit_type_decl(d),
        Declaration::Struct(ref d) => visitor.visit_struct_decl(d),
        Declaration::Enum(ref d) => visitor.visit_enum_decl(d),
        Declaration::Effect(ref d) => visitor.visit_effect_decl(d),
        Declaration::Handler(ref d) => visitor.visit_handler_decl(d),
        Declaration::Const(ref d) => visitor.visit_const_decl(d),
        Declaration::Static(ref d) => visitor.visit_static_decl(d),
        Declaration::Impl(ref d) => visitor.visit_impl_block(d),
        Declaration::Trait(ref d) => visitor.visit_trait_decl(d),
        Declaration::Module(ref d) => visitor.visit_mod_item_decl(d),
        Declaration::Macro(ref d) => visitor.visit_macro_decl(d),
    }
}

/// Walk a function declaration.
pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, decl: &FnDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    {
        let mut i: usize = 0;
        while i < decl.params.len() {
            if let Option::Some(param) = decl.params.get(i) {
                visitor.visit_param(param);
            };
            i = i + 1usize;
        }
    }

    if let Option::Some(ref ret) = decl.return_type {
        visitor.visit_type(ret);
    };

    if let Option::Some(ref effects) = decl.effects {
        visitor.visit_effect_row(effects);
    };

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    if let Option::Some(ref body) = decl.body {
        visitor.visit_block(body);
    }
}

/// Walk a parameter.
pub fn walk_param<V: Visitor>(visitor: &mut V, param: &Param) {
    visitor.visit_pattern(&param.pattern);
    visitor.visit_type(&param.ty);
}

/// Walk a type declaration.
pub fn walk_type_decl<V: Visitor>(visitor: &mut V, decl: &TypeDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    visitor.visit_type(&decl.ty);
}

/// Walk a struct declaration.
pub fn walk_struct_decl<V: Visitor>(visitor: &mut V, decl: &StructDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    match decl.body {
        StructBody::Record(ref fields) => {
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_struct_field(field);
                };
                i = i + 1usize;
            }
        }
        StructBody::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if let Option::Some(ty) = types.get(i) {
                    visitor.visit_type(ty);
                };
                i = i + 1usize;
            }
        }
        StructBody::Unit => {}
    }
}

/// Walk a struct field.
pub fn walk_struct_field<V: Visitor>(visitor: &mut V, field: &StructField) {
    {
        let mut i: usize = 0;
        while i < field.attrs.len() {
            if let Option::Some(attr) = field.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }
    visitor.visit_ident(&field.name);
    visitor.visit_type(&field.ty);
}

/// Walk an enum declaration.
pub fn walk_enum_decl<V: Visitor>(visitor: &mut V, decl: &EnumDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    {
        let mut i: usize = 0;
        while i < decl.variants.len() {
            if let Option::Some(variant) = decl.variants.get(i) {
                visitor.visit_enum_variant(variant);
            };
            i = i + 1usize;
        }
    }
}

/// Walk an enum variant.
pub fn walk_enum_variant<V: Visitor>(visitor: &mut V, variant: &EnumVariant) {
    {
        let mut i: usize = 0;
        while i < variant.attrs.len() {
            if let Option::Some(attr) = variant.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&variant.name);

    match variant.body {
        StructBody::Record(ref fields) => {
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_struct_field(field);
                };
                i = i + 1usize;
            }
        }
        StructBody::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if let Option::Some(ty) = types.get(i) {
                    visitor.visit_type(ty);
                };
                i = i + 1usize;
            }
        }
        StructBody::Unit => {}
    };

    if let Option::Some(ref disc) = variant.discriminant {
        visitor.visit_expr(disc);
    }
}

/// Walk an effect declaration.
pub fn walk_effect_decl<V: Visitor>(visitor: &mut V, decl: &EffectDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    {
        let mut i: usize = 0;
        while i < decl.extends.len() {
            if let Option::Some(ext) = decl.extends.get(i) {
                visitor.visit_type(ext);
            };
            i = i + 1usize;
        }
    }

    {
        let mut i: usize = 0;
        while i < decl.operations.len() {
            if let Option::Some(op) = decl.operations.get(i) {
                visitor.visit_operation_decl(op);
            };
            i = i + 1usize;
        }
    }
}

/// Walk an operation declaration.
pub fn walk_operation_decl<V: Visitor>(visitor: &mut V, decl: &OperationDecl) {
    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    {
        let mut i: usize = 0;
        while i < decl.params.len() {
            if let Option::Some(param) = decl.params.get(i) {
                visitor.visit_param(param);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_type(&decl.return_type);
}

/// Walk a handler declaration.
pub fn walk_handler_decl<V: Visitor>(visitor: &mut V, decl: &HandlerDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    visitor.visit_type(&decl.effect);

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    {
        let mut i: usize = 0;
        while i < decl.operations.len() {
            if let Option::Some(op) = decl.operations.get(i) {
                visitor.visit_operation_impl(op);
            };
            i = i + 1usize;
        }
    }
}

/// Walk an operation implementation.
pub fn walk_operation_impl<V: Visitor>(visitor: &mut V, impl_: &OperationImpl) {
    visitor.visit_ident(&impl_.name);

    {
        let mut i: usize = 0;
        while i < impl_.params.len() {
            if let Option::Some(param) = impl_.params.get(i) {
                visitor.visit_pattern(param);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_block(&impl_.body);
}

/// Walk a trait declaration.
pub fn walk_trait_decl<V: Visitor>(visitor: &mut V, decl: &TraitDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    {
        let mut i: usize = 0;
        while i < decl.supertraits.len() {
            if let Option::Some(supertrait) = decl.supertraits.get(i) {
                visitor.visit_type(supertrait);
            };
            i = i + 1usize;
        }
    }

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    {
        let mut i: usize = 0;
        while i < decl.items.len() {
            if let Option::Some(item) = decl.items.get(i) {
                visitor.visit_trait_item(item);
            };
            i = i + 1usize;
        }
    }
}

/// Walk a trait item.
pub fn walk_trait_item<V: Visitor>(visitor: &mut V, item: &TraitItem) {
    match item {
        TraitItem::Function(ref f) => visitor.visit_fn_decl(f),
        TraitItem::Type(ref t) => visitor.visit_type_decl(t),
        TraitItem::Const(ref c) => visitor.visit_const_decl(c),
    }
}

/// Walk an impl block.
pub fn walk_impl_block<V: Visitor>(visitor: &mut V, impl_: &ImplBlock) {
    {
        let mut i: usize = 0;
        while i < impl_.attrs.len() {
            if let Option::Some(attr) = impl_.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    if let Option::Some(ref params) = impl_.type_params {
        visitor.visit_type_params(params);
    };

    if let Option::Some(ref trait_ty) = impl_.trait_ty {
        visitor.visit_type(trait_ty);
    };

    visitor.visit_type(&impl_.self_ty);

    if let Option::Some(ref where_clause) = impl_.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    {
        let mut i: usize = 0;
        while i < impl_.items.len() {
            if let Option::Some(item) = impl_.items.get(i) {
                visitor.visit_impl_item(item);
            };
            i = i + 1usize;
        }
    }
}

/// Walk an impl item.
pub fn walk_impl_item<V: Visitor>(visitor: &mut V, item: &ImplItem) {
    match item {
        ImplItem::Function(ref f) => visitor.visit_fn_decl(f),
        ImplItem::Type(ref t) => visitor.visit_type_decl(t),
        ImplItem::Const(ref c) => visitor.visit_const_decl(c),
    }
}

/// Walk a const declaration.
pub fn walk_const_decl<V: Visitor>(visitor: &mut V, decl: &ConstDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);
    visitor.visit_type(&decl.ty);
    visitor.visit_expr(&decl.value);
}

/// Walk a static declaration.
pub fn walk_static_decl<V: Visitor>(visitor: &mut V, decl: &StaticDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);
    visitor.visit_type(&decl.ty);
    visitor.visit_expr(&decl.value);
}

/// Walk a module item declaration.
pub fn walk_mod_item_decl<V: Visitor>(visitor: &mut V, decl: &ModItemDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref body) = decl.body {
        let mut i: usize = 0;
        while i < body.len() {
            if let Option::Some(item) = body.get(i) {
                visitor.visit_declaration(item);
            };
            i = i + 1usize;
        }
    }
}

/// Walk a macro declaration.
pub fn walk_macro_decl<V: Visitor>(visitor: &mut V, decl: &MacroDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);
    // Macro rules contain token streams, not AST nodes
}

/// Walk a type.
pub fn walk_type<V: Visitor>(visitor: &mut V, ty: &Type) {
    match ty.kind {
        TypeKind::Path(ref path) => {
            visitor.visit_type_path(path);
        }
        TypeKind::Reference { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Pointer { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Array { ref element, ref size } => {
            visitor.visit_type(element);
            visitor.visit_expr(size);
        }
        TypeKind::Slice { ref element } => {
            visitor.visit_type(element);
        }
        TypeKind::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if let Option::Some(t) = types.get(i) {
                    visitor.visit_type(t);
                };
                i = i + 1usize;
            }
        }
        TypeKind::Function { ref params, ref return_type, ref effects } => {
            {
                let mut i: usize = 0;
                while i < params.len() {
                    if let Option::Some(p) = params.get(i) {
                        visitor.visit_type(p);
                    };
                    i = i + 1usize;
                }
            }
            visitor.visit_type(return_type);
            if let Option::Some(ref eff) = effects {
                visitor.visit_effect_row(eff);
            }
        }
        TypeKind::Record { ref fields, .. } => {
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_type(&field.ty);
                };
                i = i + 1usize;
            }
        }
        TypeKind::Ownership { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Forall { ref body, .. } => {
            visitor.visit_type(body);
        }
        TypeKind::Paren(ref inner) => {
            visitor.visit_type(inner);
        }
        TypeKind::ImplTrait { ref bounds } | TypeKind::DynTrait { ref bounds } => {
            let mut i: usize = 0;
            while i < bounds.len() {
                if let Option::Some(bound) = bounds.get(i) {
                    visitor.visit_type_path(&bound.path);
                };
                i = i + 1usize;
            }
        }
        TypeKind::Never | TypeKind::Infer | TypeKind::Error => {}
    }
}

/// Walk a type path.
pub fn walk_type_path<V: Visitor>(visitor: &mut V, path: &TypePath) {
    let mut i: usize = 0;
    while i < path.segments.len() {
        if let Option::Some(segment) = path.segments.get(i) {
            visitor.visit_ident(&segment.name);
            if let Option::Some(ref args) = segment.args {
                let mut j: usize = 0;
                while j < args.args.len() {
                    if let Option::Some(arg) = args.args.get(j) {
                        match arg {
                            TypeArg::Type(ref t) => visitor.visit_type(t),
                            TypeArg::Const(ref e) => visitor.visit_expr(e),
                            TypeArg::Lifetime(_) => {}
                            TypeArg::Binding { ref ty, .. } => visitor.visit_type(ty),
                        }
                    };
                    j = j + 1usize;
                }
            }
        };
        i = i + 1usize;
    }
}

/// Walk type parameters.
pub fn walk_type_params<V: Visitor>(visitor: &mut V, params: &TypeParams) {
    let mut i: usize = 0;
    while i < params.params.len() {
        if let Option::Some(param) = params.params.get(i) {
            visitor.visit_generic_param(param);
        };
        i = i + 1usize;
    }
}

/// Walk a generic parameter.
pub fn walk_generic_param<V: Visitor>(visitor: &mut V, param: &GenericParam) {
    match param {
        GenericParam::Type(ref tp) => {
            visitor.visit_ident(&tp.name);
            {
                let mut i: usize = 0;
                while i < tp.bounds.len() {
                    if let Option::Some(bound) = tp.bounds.get(i) {
                        visitor.visit_type_path(&bound.path);
                    };
                    i = i + 1usize;
                }
            }
            if let Option::Some(ref default) = tp.default {
                visitor.visit_type(default);
            }
        }
        GenericParam::Lifetime(ref lp) => {
            visitor.visit_ident(&lp.lifetime.name);
        }
        GenericParam::Const(ref cp) => {
            visitor.visit_ident(&cp.name);
            visitor.visit_type(&cp.ty);
            if let Option::Some(ref default) = cp.default {
                visitor.visit_expr(default);
            }
        }
    }
}

/// Walk a where clause.
pub fn walk_where_clause<V: Visitor>(visitor: &mut V, clause: &WhereClause) {
    let mut i: usize = 0;
    while i < clause.predicates.len() {
        if let Option::Some(pred) = clause.predicates.get(i) {
            visitor.visit_where_predicate(pred);
        };
        i = i + 1usize;
    }
}

/// Walk a where predicate.
pub fn walk_where_predicate<V: Visitor>(visitor: &mut V, pred: &WherePredicate) {
    match pred {
        WherePredicate::TypeBound { ref ty, ref bounds, .. } => {
            visitor.visit_type(ty);
            let mut i: usize = 0;
            while i < bounds.len() {
                if let Option::Some(bound) = bounds.get(i) {
                    visitor.visit_type_path(&bound.path);
                };
                i = i + 1usize;
            }
        }
        WherePredicate::Lifetime { .. } => {}
        WherePredicate::Eq { ref lhs, ref rhs, .. } => {
            visitor.visit_type(lhs);
            visitor.visit_type(rhs);
        }
    }
}

/// Walk an effect row.
pub fn walk_effect_row<V: Visitor>(visitor: &mut V, row: &EffectRow) {
    match row.kind {
        EffectRowKind::Effects { ref effects, .. } => {
            let mut i: usize = 0;
            while i < effects.len() {
                if let Option::Some(eff) = effects.get(i) {
                    visitor.visit_type(eff);
                };
                i = i + 1usize;
            }
        }
        _ => {}
    }
}

/// Walk an expression.
pub fn walk_expr<V: Visitor>(visitor: &mut V, expr: &Expr) {
    match expr.kind {
        ExprKind::Literal(ref lit) => {
            visitor.visit_literal(lit);
        }
        ExprKind::Path(ref path) => {
            visitor.visit_expr_path(path);
        }
        ExprKind::Binary { ref left, ref right, .. } => {
            visitor.visit_expr(left);
            visitor.visit_expr(right);
        }
        ExprKind::Unary { ref operand, .. } => {
            visitor.visit_expr(operand);
        }
        ExprKind::Call { ref callee, ref args } => {
            visitor.visit_expr(callee);
            {
                let mut i: usize = 0;
                while i < args.len() {
                    if let Option::Some(arg) = args.get(i) {
                        visitor.visit_call_arg(arg);
                    };
                    i = i + 1usize;
                }
            }
        }
        ExprKind::MethodCall { ref receiver, ref args, .. } => {
            visitor.visit_expr(receiver);
            {
                let mut i: usize = 0;
                while i < args.len() {
                    if let Option::Some(arg) = args.get(i) {
                        visitor.visit_call_arg(arg);
                    };
                    i = i + 1usize;
                }
            }
        }
        ExprKind::Field { ref base, .. } => {
            visitor.visit_expr(base);
        }
        ExprKind::Index { ref base, ref index } => {
            visitor.visit_expr(base);
            visitor.visit_expr(index);
        }
        ExprKind::Tuple(ref exprs) => {
            let mut i: usize = 0;
            while i < exprs.len() {
                if let Option::Some(e) = exprs.get(i) {
                    visitor.visit_expr(e);
                };
                i = i + 1usize;
            }
        }
        ExprKind::Array(ref arr) => {
            match arr {
                ArrayExpr::List(ref exprs) => {
                    let mut i: usize = 0;
                    while i < exprs.len() {
                        if let Option::Some(e) = exprs.get(i) {
                            visitor.visit_expr(e);
                        };
                        i = i + 1usize;
                    }
                };
                ArrayExpr::Repeat { ref value, ref count } => {
                    visitor.visit_expr(value);
                    visitor.visit_expr(count);
                }
            }
        }
        ExprKind::Record { ref path, ref fields, ref base } => {
            if let Option::Some(ref p) = path {
                visitor.visit_type_path(p);
            };
            {
                let mut i: usize = 0;
                while i < fields.len() {
                    if let Option::Some(field) = fields.get(i) {
                        if let Option::Some(ref v) = field.value {
                            visitor.visit_expr(v);
                        }
                    };
                    i = i + 1usize;
                }
            }
            if let Option::Some(ref b) = base {
                visitor.visit_expr(b);
            }
        }
        ExprKind::Range { ref start, ref end, .. } => {
            if let Option::Some(ref s) = start {
                visitor.visit_expr(s);
            };
            if let Option::Some(ref e) = end {
                visitor.visit_expr(e);
            }
        }
        ExprKind::Cast { ref expr, ref ty } => {
            visitor.visit_expr(expr);
            visitor.visit_type(ty);
        }
        ExprKind::Assign { ref target, ref value } => {
            visitor.visit_expr(target);
            visitor.visit_expr(value);
        }
        ExprKind::AssignOp { ref target, ref value, .. } => {
            visitor.visit_expr(target);
            visitor.visit_expr(value);
        }
        ExprKind::Block(ref block) => {
            visitor.visit_block(block);
        }
        ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            visitor.visit_expr(condition);
            visitor.visit_block(then_branch);
            if let Option::Some(ref eb) = else_branch {
                match eb {
                    ElseBranch::Block(ref b) => visitor.visit_block(b),
                    ElseBranch::If(ref e) => visitor.visit_expr(e),
                }
            }
        }
        ExprKind::IfLet { ref pattern, ref scrutinee, ref then_branch, ref else_branch } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(scrutinee);
            visitor.visit_block(then_branch);
            if let Option::Some(ref eb) = else_branch {
                match eb {
                    ElseBranch::Block(ref b) => visitor.visit_block(b),
                    ElseBranch::If(ref e) => visitor.visit_expr(e),
                }
            }
        }
        ExprKind::Match { ref scrutinee, ref arms } => {
            visitor.visit_expr(scrutinee);
            {
                let mut i: usize = 0;
                while i < arms.len() {
                    if let Option::Some(arm) = arms.get(i) {
                        visitor.visit_match_arm(arm);
                    };
                    i = i + 1usize;
                }
            }
        }
        ExprKind::Loop { ref body, .. } => {
            visitor.visit_block(body);
        }
        ExprKind::While { ref condition, ref body, .. } => {
            visitor.visit_expr(condition);
            visitor.visit_block(body);
        }
        ExprKind::WhileLet { ref pattern, ref scrutinee, ref body, .. } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(scrutinee);
            visitor.visit_block(body);
        }
        ExprKind::For { ref pattern, ref iter, ref body, .. } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(iter);
            visitor.visit_block(body);
        }
        ExprKind::Return(ref value) => {
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        ExprKind::Break { ref value, .. } => {
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        ExprKind::Continue { .. } => {}
        ExprKind::Closure { ref params, ref return_type, ref body, .. } => {
            {
                let mut i: usize = 0;
                while i < params.len() {
                    if let Option::Some(param) = params.get(i) {
                        visitor.visit_closure_param(param);
                    };
                    i = i + 1usize;
                }
            }
            if let Option::Some(ref ret) = return_type {
                visitor.visit_type(ret);
            };
            visitor.visit_expr(body);
        }
        ExprKind::WithHandle { ref handler, ref body } => {
            visitor.visit_expr(handler);
            visitor.visit_expr(body);
        }
        ExprKind::Perform { ref args, .. } => {
            let mut i: usize = 0;
            while i < args.len() {
                if let Option::Some(arg) = args.get(i) {
                    visitor.visit_expr(arg);
                };
                i = i + 1usize;
            }
        }
        ExprKind::Resume(ref value) => {
            visitor.visit_expr(value);
        }
        ExprKind::TryWith { ref body, ref handlers } => {
            visitor.visit_block(body);
            let mut i: usize = 0;
            while i < handlers.len() {
                if let Option::Some(handler) = handlers.get(i) {
                    let mut j: usize = 0;
                    while j < handler.params.len() {
                        if let Option::Some(param) = handler.params.get(j) {
                            visitor.visit_pattern(param);
                        };
                        j = j + 1usize;
                    }
                    visitor.visit_block(&handler.body);
                };
                i = i + 1usize;
            }
        }
        ExprKind::Unsafe(ref block) | ExprKind::Region { ref body: block, .. } => {
            visitor.visit_block(block);
        }
        ExprKind::Paren(ref inner) => {
            visitor.visit_expr(inner);
        }
        ExprKind::Default => {}
        ExprKind::MacroCall { ref path, .. } => {
            visitor.visit_expr_path(path);
        }
        ExprKind::Error => {}
    }
}

/// Walk an expression path.
pub fn walk_expr_path<V: Visitor>(visitor: &mut V, path: &ExprPath) {
    let mut i: usize = 0;
    while i < path.segments.len() {
        if let Option::Some(segment) = path.segments.get(i) {
            visitor.visit_ident(&segment.name);
        };
        i = i + 1usize;
    }
}

/// Walk a call argument.
pub fn walk_call_arg<V: Visitor>(visitor: &mut V, arg: &CallArg) {
    if let Option::Some(ref name) = arg.name {
        visitor.visit_ident(name);
    };
    visitor.visit_expr(&arg.value);
}

/// Walk a match arm.
pub fn walk_match_arm<V: Visitor>(visitor: &mut V, arm: &MatchArm) {
    visitor.visit_pattern(&arm.pattern);
    if let Option::Some(ref guard) = arm.guard {
        visitor.visit_expr(guard);
    };
    visitor.visit_expr(&arm.body);
}

/// Walk a closure parameter.
pub fn walk_closure_param<V: Visitor>(visitor: &mut V, param: &ClosureParam) {
    visitor.visit_pattern(&param.pattern);
    if let Option::Some(ref ty) = param.ty {
        visitor.visit_type(ty);
    }
}

/// Walk a pattern.
pub fn walk_pattern<V: Visitor>(visitor: &mut V, pattern: &Pattern) {
    match pattern.kind {
        PatternKind::Wildcard | PatternKind::Rest => {}
        PatternKind::Literal(ref lit) => {
            visitor.visit_literal(lit);
        }
        PatternKind::Ident { ref name, ref subpattern, .. } => {
            visitor.visit_ident(name);
            if let Option::Some(ref sub) = subpattern {
                visitor.visit_pattern(sub);
            }
        }
        PatternKind::Ref { ref inner, .. } => {
            visitor.visit_pattern(inner);
        }
        PatternKind::Struct { ref path, ref fields, .. } => {
            visitor.visit_type_path(path);
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_struct_pattern_field(field);
                };
                i = i + 1usize;
            }
        }
        PatternKind::TupleStruct { ref path, ref fields, .. } => {
            visitor.visit_type_path(path);
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_pattern(field);
                };
                i = i + 1usize;
            }
        }
        PatternKind::Tuple { ref fields, .. } => {
            let mut i: usize = 0;
            while i < fields.len() {
                if let Option::Some(field) = fields.get(i) {
                    visitor.visit_pattern(field);
                };
                i = i + 1usize;
            }
        }
        PatternKind::Slice { ref elements, .. } => {
            let mut i: usize = 0;
            while i < elements.len() {
                if let Option::Some(elem) = elements.get(i) {
                    visitor.visit_pattern(elem);
                };
                i = i + 1usize;
            }
        }
        PatternKind::Or(ref patterns) => {
            let mut i: usize = 0;
            while i < patterns.len() {
                if let Option::Some(pat) = patterns.get(i) {
                    visitor.visit_pattern(pat);
                };
                i = i + 1usize;
            }
        }
        PatternKind::Range { ref start, ref end, .. } => {
            if let Option::Some(ref s) = start {
                visitor.visit_pattern(s);
            };
            if let Option::Some(ref e) = end {
                visitor.visit_pattern(e);
            }
        }
        PatternKind::Path(ref path) => {
            visitor.visit_type_path(path);
        }
        PatternKind::Paren(ref inner) => {
            visitor.visit_pattern(inner);
        }
    }
}

/// Walk a struct pattern field.
pub fn walk_struct_pattern_field<V: Visitor>(visitor: &mut V, field: &StructPatternField) {
    visitor.visit_ident(&field.name);
    if let Option::Some(ref pat) = field.pattern {
        visitor.visit_pattern(pat);
    }
}

/// Walk a block.
pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {
    let mut i: usize = 0;
    while i < block.statements.len() {
        if let Option::Some(stmt) = block.statements.get(i) {
            visitor.visit_statement(stmt);
        };
        i = i + 1usize;
    }
    if let Option::Some(ref expr) = block.expr {
        visitor.visit_expr(expr);
    }
}

/// Walk a statement.
pub fn walk_statement<V: Visitor>(visitor: &mut V, stmt: &Statement) {
    match stmt {
        Statement::Let { ref pattern, ref ty, ref value, .. } => {
            visitor.visit_pattern(pattern);
            if let Option::Some(ref t) = ty {
                visitor.visit_type(t);
            };
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        Statement::Expr { ref expr, .. } => {
            visitor.visit_expr(expr);
        }
        Statement::Item(ref decl) => {
            visitor.visit_declaration(decl);
        }
    }
}

/// Walk an attribute.
pub fn walk_attribute<V: Visitor>(visitor: &mut V, attr: &Attribute) {
    // Visit path segments
    {
        let mut i: usize = 0;
        while i < attr.path.segments.len() {
            if let Option::Some(segment) = attr.path.segments.get(i) {
                visitor.visit_ident(segment);
            };
            i = i + 1usize;
        }
    }

    // Visit args if present
    if let Option::Some(ref args) = attr.args {
        match args {
            AttrArgs::Eq { ref value, .. } => {
                visitor.visit_literal(value);
            }
            AttrArgs::List { ref args, .. } => {
                let mut i: usize = 0;
                while i < args.len() {
                    if let Option::Some(arg) = args.get(i) {
                        walk_attr_arg(visitor, arg);
                    };
                    i = i + 1usize;
                }
            }
        }
    }
}

fn walk_attr_arg<V: Visitor>(visitor: &mut V, arg: &AttrArg) {
    match arg {
        AttrArg::Ident { ref ident, .. } => {
            visitor.visit_ident(ident);
        }
        AttrArg::KeyValue { ref key, ref value, .. } => {
            visitor.visit_ident(key);
            visitor.visit_literal(value);
        }
        AttrArg::Literal { ref literal, .. } => {
            visitor.visit_literal(literal);
        }
        AttrArg::Call { ref name, ref args, .. } => {
            visitor.visit_ident(name);
            let mut i: usize = 0;
            while i < args.len() {
                if let Option::Some(a) = args.get(i) {
                    walk_attr_arg(visitor, a);
                };
                i = i + 1usize;
            }
        }
        AttrArg::Path { ref path, .. } => {
            let mut i: usize = 0;
            while i < path.segments.len() {
                if let Option::Some(segment) = path.segments.get(i) {
                    visitor.visit_ident(segment);
                };
                i = i + 1usize;
            }
        }
    }
}

/// Walk a bridge declaration.
pub fn walk_bridge_decl<V: Visitor>(visitor: &mut V, decl: &BridgeDecl) {
    {
        let mut i: usize = 0;
        while i < decl.attrs.len() {
            if let Option::Some(attr) = decl.attrs.get(i) {
                visitor.visit_attribute(attr);
            };
            i = i + 1usize;
        }
    }

    visitor.visit_ident(&decl.name);

    {
        let mut i: usize = 0;
        while i < decl.items.len() {
            if let Option::Some(item) = decl.items.get(i) {
                visitor.visit_bridge_item(item);
            };
            i = i + 1usize;
        }
    }
}

/// Walk a bridge item.
pub fn walk_bridge_item<V: Visitor>(visitor: &mut V, item: &BridgeItem) {
    match item {
        BridgeItem::Function(ref f) => {
            {
                let mut i: usize = 0;
                while i < f.attrs.len() {
                    if let Option::Some(attr) = f.attrs.get(i) {
                        visitor.visit_attribute(attr);
                    };
                    i = i + 1usize;
                }
            }
            visitor.visit_ident(&f.name);
            {
                let mut i: usize = 0;
                while i < f.params.len() {
                    if let Option::Some(param) = f.params.get(i) {
                        visitor.visit_ident(&param.name);
                        visitor.visit_type(&param.ty);
                    };
                    i = i + 1usize;
                }
            }
            if let Option::Some(ref ret) = f.return_type {
                visitor.visit_type(ret);
            }
        }
        BridgeItem::Const(ref c) => {
            visitor.visit_ident(&c.name);
            visitor.visit_type(&c.ty);
            visitor.visit_literal(&c.value);
        }
        BridgeItem::OpaqueType(ref t) => {
            visitor.visit_ident(&t.name);
        }
        BridgeItem::TypeAlias(ref t) => {
            visitor.visit_ident(&t.name);
            visitor.visit_type(&t.ty);
        }
        BridgeItem::Struct(ref s) => {
            {
                let mut i: usize = 0;
                while i < s.attrs.len() {
                    if let Option::Some(attr) = s.attrs.get(i) {
                        visitor.visit_attribute(attr);
                    };
                    i = i + 1usize;
                }
            }
            visitor.visit_ident(&s.name);
            {
                let mut i: usize = 0;
                while i < s.fields.len() {
                    if let Option::Some(field) = s.fields.get(i) {
                        visitor.visit_ident(&field.name);
                        visitor.visit_type(&field.ty);
                    };
                    i = i + 1usize;
                }
            }
        }
        BridgeItem::Enum(ref e) => {
            {
                let mut i: usize = 0;
                while i < e.attrs.len() {
                    if let Option::Some(attr) = e.attrs.get(i) {
                        visitor.visit_attribute(attr);
                    };
                    i = i + 1usize;
                }
            }
            visitor.visit_ident(&e.name);
            {
                let mut i: usize = 0;
                while i < e.variants.len() {
                    if let Option::Some(variant) = e.variants.get(i) {
                        visitor.visit_ident(&variant.name);
                        if let Option::Some(ref disc) = variant.discriminant {
                            visitor.visit_literal(disc);
                        }
                    };
                    i = i + 1usize;
                }
            }
        }
        BridgeItem::Union(ref u) => {
            {
                let mut i: usize = 0;
                while i < u.attrs.len() {
                    if let Option::Some(attr) = u.attrs.get(i) {
                        visitor.visit_attribute(attr);
                    };
                    i = i + 1usize;
                }
            }
            visitor.visit_ident(&u.name);
            {
                let mut i: usize = 0;
                while i < u.fields.len() {
                    if let Option::Some(field) = u.fields.get(i) {
                        visitor.visit_ident(&field.name);
                        visitor.visit_type(&field.ty);
                    };
                    i = i + 1usize;
                }
            }
        }
        BridgeItem::Callback(ref cb) => {
            visitor.visit_ident(&cb.name);
            {
                let mut i: usize = 0;
                while i < cb.params.len() {
                    if let Option::Some(param) = cb.params.get(i) {
                        visitor.visit_type(param);
                    };
                    i = i + 1usize;
                }
            }
            if let Option::Some(ref ret) = cb.return_type {
                visitor.visit_type(ret);
            }
        }
        BridgeItem::Link(_) => {}
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_visitor_can_be_implemented() {
    struct CountExpressions {
        count: usize,
    }

    impl Visitor for CountExpressions {
        fn visit_expr(self: &mut Self, expr: &Expr) {
            self.count += 1
            walk_expr(self, expr)
        }
    }

    // Test visitor pattern with expressions
    let lit_left = Literal::int(1i64, Option::None, Span::dummy());
    let lit_right = Literal::int(2i64, Option::None, Span::dummy());
    let expr_left = Expr::new(ExprKind::Literal(lit_left), Span::dummy());
    let expr_right = Expr::new(ExprKind::Literal(lit_right), Span::dummy());
    let expr = Expr::new(
        ExprKind::Binary {
            op: BinOp::Add,
            left: Box::new(expr_left),
            right: Box::new(expr_right),
        },
        Span::dummy(),
    );
    let mut counter = CountExpressions { count: 0 };
    counter.visit_expr(&expr);
    assert(counter.count == 3);
}
