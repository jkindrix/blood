//! # AST Visitor Pattern
//!
//! Visitor traits and helpers for traversing the Blood AST.
//!
//! ## Overview
//!
//! The visitor pattern allows processing AST nodes without modifying them.
//! This is useful for:
//! - Analysis passes (type checking, name resolution)
//! - Pretty printing
//! - Linting
//! - Code generation
//!
//! ## Visitor Traits
//!
//! | Trait | Use Case |
//! |-------|----------|
//! | `Visitor` | Read-only traversal |
//! | `MutVisitor` | Transforming traversal |
//!
//! ## Usage
//!
//! ```blood
//! struct CountFunctions {
//!     count: USize,
//! }
//!
//! impl Visitor for CountFunctions {
//!     fn visit_fn_decl(mut self, decl: &FnDecl) {
//!         self.count += 1
//!         walk_fn_decl(self, decl)
//!     }
//! }
//!
//! let mut counter = CountFunctions { count: 0 }
//! counter.visit_program(&program)
//! println("Found {} functions", counter.count)
//! ```
//!
//! ## Walk Functions
//!
//! Walk functions provide default traversal behavior. Override `visit_*`
//! methods to process specific node types, calling the corresponding
//! `walk_*` function to continue traversal into children.

module std.compiler.ast.visitor;

use std.compiler.ast.node.Program;
use std.compiler.ast.node.ModuleDecl;
use std.compiler.ast.node.ModulePath;
use std.compiler.ast.node.Import;
use std.compiler.ast.node.Ident;
use std.compiler.ast.attr.Attribute;
use std.compiler.ast.attr.AttrArgs;
use std.compiler.ast.attr.AttrArg;
use std.compiler.ast.lit.Literal;
use std.compiler.ast.ty.Type;
use std.compiler.ast.ty.TypeKind;
use std.compiler.ast.ty.TypePath;
use std.compiler.ast.ty.TypeParams;
use std.compiler.ast.ty.GenericParam;
use std.compiler.ast.ty.WhereClause;
use std.compiler.ast.ty.WherePredicate;
use std.compiler.ast.ty.EffectRow;
use std.compiler.ast.decl.Declaration;
use std.compiler.ast.decl.FnDecl;
use std.compiler.ast.decl.Param;
use std.compiler.ast.decl.TypeDecl;
use std.compiler.ast.decl.StructDecl;
use std.compiler.ast.decl.StructBody;
use std.compiler.ast.decl.StructField;
use std.compiler.ast.decl.EnumDecl;
use std.compiler.ast.decl.EnumVariant;
use std.compiler.ast.decl.EffectDecl;
use std.compiler.ast.decl.OperationDecl;
use std.compiler.ast.decl.HandlerDecl;
use std.compiler.ast.decl.OperationImpl;
use std.compiler.ast.decl.TraitDecl;
use std.compiler.ast.decl.TraitItem;
use std.compiler.ast.decl.ImplBlock;
use std.compiler.ast.decl.ImplItem;
use std.compiler.ast.decl.ConstDecl;
use std.compiler.ast.decl.StaticDecl;
use std.compiler.ast.decl.ModItemDecl;
use std.compiler.ast.decl.MacroDecl;
use std.compiler.ast.expr.Expr;
use std.compiler.ast.expr.ExprKind;
use std.compiler.ast.expr.ExprPath;
use std.compiler.ast.expr.CallArg;
use std.compiler.ast.expr.MatchArm;
use std.compiler.ast.expr.ClosureParam;
use std.compiler.ast.pattern.Pattern;
use std.compiler.ast.pattern.PatternKind;
use std.compiler.ast.pattern.StructPatternField;
use std.compiler.ast.stmt.Block;
use std.compiler.ast.stmt.Statement;
use std.compiler.ast.bridge.BridgeDecl;
use std.compiler.ast.bridge.BridgeItem;
use std.compiler.ast.bridge.BridgeFn;
use std.compiler.ast.bridge.BridgeStruct;
use std.compiler.ast.bridge.BridgeEnum;
use std.compiler.ast.bridge.BridgeUnion;
use std.compiler.ast.bridge.BridgeCallback;

// ============================================================================
// Visitor Trait
// ============================================================================

/// Trait for read-only AST traversal.
///
/// Implement this trait to process AST nodes. Override specific `visit_*`
/// methods to handle nodes of interest, and call the corresponding `walk_*`
/// function to continue traversal into children.
///
/// ## Example
///
/// ```blood
/// struct IdentCollector {
///     idents: Vec<Ident>,
/// }
///
/// impl Visitor for IdentCollector {
///     fn visit_ident(mut self, ident: &Ident) {
///         self.idents.push(ident.clone())
///     }
/// }
/// ```
pub trait Visitor {
    // ========================================================================
    // Top-Level
    // ========================================================================

    /// Visit a program.
    fn visit_program(mut self, program: &Program) {
        walk_program(self, program)
    }

    /// Visit a module declaration.
    fn visit_module_decl(mut self, decl: &ModuleDecl) {
        walk_module_decl(self, decl)
    }

    /// Visit a module path.
    fn visit_module_path(mut self, path: &ModulePath) {
        walk_module_path(self, path)
    }

    /// Visit an import.
    fn visit_import(mut self, import: &Import) {
        walk_import(self, import)
    }

    // ========================================================================
    // Declarations
    // ========================================================================

    /// Visit a declaration.
    fn visit_declaration(mut self, decl: &Declaration) {
        walk_declaration(self, decl)
    }

    /// Visit a function declaration.
    fn visit_fn_decl(mut self, decl: &FnDecl) {
        walk_fn_decl(self, decl)
    }

    /// Visit a function parameter.
    fn visit_param(mut self, param: &Param) {
        walk_param(self, param)
    }

    /// Visit a type declaration.
    fn visit_type_decl(mut self, decl: &TypeDecl) {
        walk_type_decl(self, decl)
    }

    /// Visit a struct declaration.
    fn visit_struct_decl(mut self, decl: &StructDecl) {
        walk_struct_decl(self, decl)
    }

    /// Visit a struct field.
    fn visit_struct_field(mut self, field: &StructField) {
        walk_struct_field(self, field)
    }

    /// Visit an enum declaration.
    fn visit_enum_decl(mut self, decl: &EnumDecl) {
        walk_enum_decl(self, decl)
    }

    /// Visit an enum variant.
    fn visit_enum_variant(mut self, variant: &EnumVariant) {
        walk_enum_variant(self, variant)
    }

    /// Visit an effect declaration.
    fn visit_effect_decl(mut self, decl: &EffectDecl) {
        walk_effect_decl(self, decl)
    }

    /// Visit an effect operation.
    fn visit_operation_decl(mut self, decl: &OperationDecl) {
        walk_operation_decl(self, decl)
    }

    /// Visit a handler declaration.
    fn visit_handler_decl(mut self, decl: &HandlerDecl) {
        walk_handler_decl(self, decl)
    }

    /// Visit an operation implementation.
    fn visit_operation_impl(mut self, impl_: &OperationImpl) {
        walk_operation_impl(self, impl_)
    }

    /// Visit a trait declaration.
    fn visit_trait_decl(mut self, decl: &TraitDecl) {
        walk_trait_decl(self, decl)
    }

    /// Visit a trait item.
    fn visit_trait_item(mut self, item: &TraitItem) {
        walk_trait_item(self, item)
    }

    /// Visit an impl block.
    fn visit_impl_block(mut self, impl_: &ImplBlock) {
        walk_impl_block(self, impl_)
    }

    /// Visit an impl item.
    fn visit_impl_item(mut self, item: &ImplItem) {
        walk_impl_item(self, item)
    }

    /// Visit a const declaration.
    fn visit_const_decl(mut self, decl: &ConstDecl) {
        walk_const_decl(self, decl)
    }

    /// Visit a static declaration.
    fn visit_static_decl(mut self, decl: &StaticDecl) {
        walk_static_decl(self, decl)
    }

    /// Visit a module item declaration.
    fn visit_mod_item_decl(mut self, decl: &ModItemDecl) {
        walk_mod_item_decl(self, decl)
    }

    /// Visit a macro declaration.
    fn visit_macro_decl(mut self, decl: &MacroDecl) {
        walk_macro_decl(self, decl)
    }

    // ========================================================================
    // Types
    // ========================================================================

    /// Visit a type.
    fn visit_type(mut self, ty: &Type) {
        walk_type(self, ty)
    }

    /// Visit a type path.
    fn visit_type_path(mut self, path: &TypePath) {
        walk_type_path(self, path)
    }

    /// Visit type parameters.
    fn visit_type_params(mut self, params: &TypeParams) {
        walk_type_params(self, params)
    }

    /// Visit a generic parameter.
    fn visit_generic_param(mut self, param: &GenericParam) {
        walk_generic_param(self, param)
    }

    /// Visit a where clause.
    fn visit_where_clause(mut self, clause: &WhereClause) {
        walk_where_clause(self, clause)
    }

    /// Visit a where predicate.
    fn visit_where_predicate(mut self, pred: &WherePredicate) {
        walk_where_predicate(self, pred)
    }

    /// Visit an effect row.
    fn visit_effect_row(mut self, row: &EffectRow) {
        walk_effect_row(self, row)
    }

    // ========================================================================
    // Expressions
    // ========================================================================

    /// Visit an expression.
    fn visit_expr(mut self, expr: &Expr) {
        walk_expr(self, expr)
    }

    /// Visit an expression path.
    fn visit_expr_path(mut self, path: &ExprPath) {
        walk_expr_path(self, path)
    }

    /// Visit a call argument.
    fn visit_call_arg(mut self, arg: &CallArg) {
        walk_call_arg(self, arg)
    }

    /// Visit a match arm.
    fn visit_match_arm(mut self, arm: &MatchArm) {
        walk_match_arm(self, arm)
    }

    /// Visit a closure parameter.
    fn visit_closure_param(mut self, param: &ClosureParam) {
        walk_closure_param(self, param)
    }

    // ========================================================================
    // Patterns
    // ========================================================================

    /// Visit a pattern.
    fn visit_pattern(mut self, pattern: &Pattern) {
        walk_pattern(self, pattern)
    }

    /// Visit a struct pattern field.
    fn visit_struct_pattern_field(mut self, field: &StructPatternField) {
        walk_struct_pattern_field(self, field)
    }

    // ========================================================================
    // Statements
    // ========================================================================

    /// Visit a block.
    fn visit_block(mut self, block: &Block) {
        walk_block(self, block)
    }

    /// Visit a statement.
    fn visit_statement(mut self, stmt: &Statement) {
        walk_statement(self, stmt)
    }

    // ========================================================================
    // Attributes and Literals
    // ========================================================================

    /// Visit an attribute.
    fn visit_attribute(mut self, attr: &Attribute) {
        walk_attribute(self, attr)
    }

    /// Visit a literal.
    fn visit_literal(mut self, lit: &Literal) {
        // No children to visit
    }

    /// Visit an identifier.
    fn visit_ident(mut self, ident: &Ident) {
        // No children to visit
    }

    // ========================================================================
    // Bridge (FFI)
    // ========================================================================

    /// Visit a bridge declaration.
    fn visit_bridge_decl(mut self, decl: &BridgeDecl) {
        walk_bridge_decl(self, decl)
    }

    /// Visit a bridge item.
    fn visit_bridge_item(mut self, item: &BridgeItem) {
        walk_bridge_item(self, item)
    }
}

// ============================================================================
// Walk Functions
// ============================================================================

/// Walk a program, visiting all children.
pub fn walk_program<V: Visitor>(visitor: &mut V, program: &Program) {
    if let Option::Some(ref module) = program.module {
        visitor.visit_module_decl(module);
    };

    for import in program.imports.iter() {
        visitor.visit_import(import);
    };

    for decl in program.declarations.iter() {
        visitor.visit_declaration(decl);
    }
}

/// Walk a module declaration.
pub fn walk_module_decl<V: Visitor>(visitor: &mut V, decl: &ModuleDecl) {
    visitor.visit_module_path(&decl.path);
}

/// Walk a module path.
pub fn walk_module_path<V: Visitor>(visitor: &mut V, path: &ModulePath) {
    for segment in path.segments.iter() {
        visitor.visit_ident(segment);
    }
}

/// Walk an import.
pub fn walk_import<V: Visitor>(visitor: &mut V, import: &Import) {
    match import {
        Import::Simple { ref path, .. } => {
            visitor.visit_module_path(path);
        }
        Import::Group { ref path, .. } => {
            visitor.visit_module_path(path);
        }
        Import::Glob { ref path, .. } => {
            visitor.visit_module_path(path);
        }
    }
}

/// Walk a declaration.
pub fn walk_declaration<V: Visitor>(visitor: &mut V, decl: &Declaration) {
    match decl {
        Declaration::Function(ref d) => visitor.visit_fn_decl(d),
        Declaration::Type(ref d) => visitor.visit_type_decl(d),
        Declaration::Struct(ref d) => visitor.visit_struct_decl(d),
        Declaration::Enum(ref d) => visitor.visit_enum_decl(d),
        Declaration::Effect(ref d) => visitor.visit_effect_decl(d),
        Declaration::Handler(ref d) => visitor.visit_handler_decl(d),
        Declaration::Const(ref d) => visitor.visit_const_decl(d),
        Declaration::Static(ref d) => visitor.visit_static_decl(d),
        Declaration::Impl(ref d) => visitor.visit_impl_block(d),
        Declaration::Trait(ref d) => visitor.visit_trait_decl(d),
        Declaration::Module(ref d) => visitor.visit_mod_item_decl(d),
        Declaration::Macro(ref d) => visitor.visit_macro_decl(d),
    }
}

/// Walk a function declaration.
pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, decl: &FnDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    for param in decl.params.iter() {
        visitor.visit_param(param);
    };

    if let Option::Some(ref ret) = decl.return_type {
        visitor.visit_type(ret);
    };

    if let Option::Some(ref effects) = decl.effects {
        visitor.visit_effect_row(effects);
    };

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    if let Option::Some(ref body) = decl.body {
        visitor.visit_block(body);
    }
}

/// Walk a parameter.
pub fn walk_param<V: Visitor>(visitor: &mut V, param: &Param) {
    visitor.visit_pattern(&param.pattern);
    visitor.visit_type(&param.ty);
}

/// Walk a type declaration.
pub fn walk_type_decl<V: Visitor>(visitor: &mut V, decl: &TypeDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    visitor.visit_type(&decl.ty);
}

/// Walk a struct declaration.
pub fn walk_struct_decl<V: Visitor>(visitor: &mut V, decl: &StructDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    match decl.body {
        StructBody::Record(ref fields) => {
            for field in fields.iter() {
                visitor.visit_struct_field(field);
            }
        }
        StructBody::Tuple(ref types) => {
            for ty in types.iter() {
                visitor.visit_type(ty);
            }
        }
        StructBody::Unit => {}
    }
}

/// Walk a struct field.
pub fn walk_struct_field<V: Visitor>(visitor: &mut V, field: &StructField) {
    for attr in field.attrs.iter() {
        visitor.visit_attribute(attr);
    };
    visitor.visit_ident(&field.name);
    visitor.visit_type(&field.ty);
}

/// Walk an enum declaration.
pub fn walk_enum_decl<V: Visitor>(visitor: &mut V, decl: &EnumDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    for variant in decl.variants.iter() {
        visitor.visit_enum_variant(variant);
    }
}

/// Walk an enum variant.
pub fn walk_enum_variant<V: Visitor>(visitor: &mut V, variant: &EnumVariant) {
    for attr in variant.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&variant.name);

    match variant.body {
        StructBody::Record(ref fields) => {
            for field in fields.iter() {
                visitor.visit_struct_field(field);
            }
        }
        StructBody::Tuple(ref types) => {
            for ty in types.iter() {
                visitor.visit_type(ty);
            }
        }
        StructBody::Unit => {}
    };

    if let Option::Some(ref disc) = variant.discriminant {
        visitor.visit_expr(disc);
    }
}

/// Walk an effect declaration.
pub fn walk_effect_decl<V: Visitor>(visitor: &mut V, decl: &EffectDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    for ext in decl.extends.iter() {
        visitor.visit_type(ext);
    };

    for op in decl.operations.iter() {
        visitor.visit_operation_decl(op);
    }
}

/// Walk an operation declaration.
pub fn walk_operation_decl<V: Visitor>(visitor: &mut V, decl: &OperationDecl) {
    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    for param in decl.params.iter() {
        visitor.visit_param(param);
    };

    visitor.visit_type(&decl.return_type);
}

/// Walk a handler declaration.
pub fn walk_handler_decl<V: Visitor>(visitor: &mut V, decl: &HandlerDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    visitor.visit_type(&decl.effect);

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    for op in decl.operations.iter() {
        visitor.visit_operation_impl(op);
    }
}

/// Walk an operation implementation.
pub fn walk_operation_impl<V: Visitor>(visitor: &mut V, impl_: &OperationImpl) {
    visitor.visit_ident(&impl_.name);

    for param in impl_.params.iter() {
        visitor.visit_pattern(param);
    };

    visitor.visit_block(&impl_.body);
}

/// Walk a trait declaration.
pub fn walk_trait_decl<V: Visitor>(visitor: &mut V, decl: &TraitDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref params) = decl.type_params {
        visitor.visit_type_params(params);
    };

    for supertrait in decl.supertraits.iter() {
        visitor.visit_type(supertrait);
    };

    if let Option::Some(ref where_clause) = decl.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    for item in decl.items.iter() {
        visitor.visit_trait_item(item);
    }
}

/// Walk a trait item.
pub fn walk_trait_item<V: Visitor>(visitor: &mut V, item: &TraitItem) {
    match item {
        TraitItem::Function(ref f) => visitor.visit_fn_decl(f),
        TraitItem::Type(ref t) => visitor.visit_type_decl(t),
        TraitItem::Const(ref c) => visitor.visit_const_decl(c),
    }
}

/// Walk an impl block.
pub fn walk_impl_block<V: Visitor>(visitor: &mut V, impl_: &ImplBlock) {
    for attr in impl_.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    if let Option::Some(ref params) = impl_.type_params {
        visitor.visit_type_params(params);
    };

    if let Option::Some(ref trait_ty) = impl_.trait_ty {
        visitor.visit_type(trait_ty);
    };

    visitor.visit_type(&impl_.self_ty);

    if let Option::Some(ref where_clause) = impl_.where_clause {
        visitor.visit_where_clause(where_clause);
    };

    for item in impl_.items.iter() {
        visitor.visit_impl_item(item);
    }
}

/// Walk an impl item.
pub fn walk_impl_item<V: Visitor>(visitor: &mut V, item: &ImplItem) {
    match item {
        ImplItem::Function(ref f) => visitor.visit_fn_decl(f),
        ImplItem::Type(ref t) => visitor.visit_type_decl(t),
        ImplItem::Const(ref c) => visitor.visit_const_decl(c),
    }
}

/// Walk a const declaration.
pub fn walk_const_decl<V: Visitor>(visitor: &mut V, decl: &ConstDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);
    visitor.visit_type(&decl.ty);
    visitor.visit_expr(&decl.value);
}

/// Walk a static declaration.
pub fn walk_static_decl<V: Visitor>(visitor: &mut V, decl: &StaticDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);
    visitor.visit_type(&decl.ty);
    visitor.visit_expr(&decl.value);
}

/// Walk a module item declaration.
pub fn walk_mod_item_decl<V: Visitor>(visitor: &mut V, decl: &ModItemDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    if let Option::Some(ref body) = decl.body {
        for item in body.iter() {
            visitor.visit_declaration(item);
        }
    }
}

/// Walk a macro declaration.
pub fn walk_macro_decl<V: Visitor>(visitor: &mut V, decl: &MacroDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);
    // Macro rules contain token streams, not AST nodes
}

/// Walk a type.
pub fn walk_type<V: Visitor>(visitor: &mut V, ty: &Type) {
    match ty.kind {
        TypeKind::Path(ref path) => {
            visitor.visit_type_path(path);
        }
        TypeKind::Reference { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Pointer { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Array { ref element, ref size } => {
            visitor.visit_type(element);
            visitor.visit_expr(size);
        }
        TypeKind::Slice { ref element } => {
            visitor.visit_type(element);
        }
        TypeKind::Tuple(ref types) => {
            for t in types.iter() {
                visitor.visit_type(t);
            }
        }
        TypeKind::Function { ref params, ref return_type, ref effects } => {
            for p in params.iter() {
                visitor.visit_type(p);
            };
            visitor.visit_type(return_type);
            if let Option::Some(ref eff) = effects {
                visitor.visit_effect_row(eff);
            }
        }
        TypeKind::Record { ref fields, .. } => {
            for field in fields.iter() {
                visitor.visit_type(&field.ty);
            }
        }
        TypeKind::Ownership { ref inner, .. } => {
            visitor.visit_type(inner);
        }
        TypeKind::Forall { ref body, .. } => {
            visitor.visit_type(body);
        }
        TypeKind::Paren(ref inner) => {
            visitor.visit_type(inner);
        }
        TypeKind::ImplTrait { ref bounds } | TypeKind::DynTrait { ref bounds } => {
            for bound in bounds.iter() {
                visitor.visit_type_path(&bound.path);
            }
        }
        TypeKind::Never | TypeKind::Infer | TypeKind::Error => {}
    }
}

/// Walk a type path.
pub fn walk_type_path<V: Visitor>(visitor: &mut V, path: &TypePath) {
    for segment in path.segments.iter() {
        visitor.visit_ident(&segment.name);
        if let Option::Some(ref args) = segment.args {
            for arg in args.args.iter() {
                match arg {
                    crate.compiler.ast.ty.TypeArg::Type(ref t) => visitor.visit_type(t),
                    crate.compiler.ast.ty.TypeArg::Const(ref e) => visitor.visit_expr(e),
                    crate.compiler.ast.ty.TypeArg::Lifetime(_) => {}
                    crate.compiler.ast.ty.TypeArg::Binding { ref ty, .. } => visitor.visit_type(ty),
                }
            }
        }
    }
}

/// Walk type parameters.
pub fn walk_type_params<V: Visitor>(visitor: &mut V, params: &TypeParams) {
    for param in params.params.iter() {
        visitor.visit_generic_param(param);
    }
}

/// Walk a generic parameter.
pub fn walk_generic_param<V: Visitor>(visitor: &mut V, param: &GenericParam) {
    match param {
        GenericParam::Type(ref tp) => {
            visitor.visit_ident(&tp.name);
            for bound in tp.bounds.iter() {
                visitor.visit_type_path(&bound.path);
            };
            if let Option::Some(ref default) = tp.default {
                visitor.visit_type(default);
            }
        }
        GenericParam::Lifetime(ref lp) => {
            visitor.visit_ident(&lp.lifetime.name);
        }
        GenericParam::Const(ref cp) => {
            visitor.visit_ident(&cp.name);
            visitor.visit_type(&cp.ty);
            if let Option::Some(ref default) = cp.default {
                visitor.visit_expr(default);
            }
        }
    }
}

/// Walk a where clause.
pub fn walk_where_clause<V: Visitor>(visitor: &mut V, clause: &WhereClause) {
    for pred in clause.predicates.iter() {
        visitor.visit_where_predicate(pred);
    }
}

/// Walk a where predicate.
pub fn walk_where_predicate<V: Visitor>(visitor: &mut V, pred: &WherePredicate) {
    match pred {
        WherePredicate::TypeBound { ref ty, ref bounds, .. } => {
            visitor.visit_type(ty);
            for bound in bounds.iter() {
                visitor.visit_type_path(&bound.path);
            }
        }
        WherePredicate::Lifetime { .. } => {}
        WherePredicate::Eq { ref lhs, ref rhs, .. } => {
            visitor.visit_type(lhs);
            visitor.visit_type(rhs);
        }
    }
}

/// Walk an effect row.
pub fn walk_effect_row<V: Visitor>(visitor: &mut V, row: &EffectRow) {
    match row.kind {
        crate.compiler.ast.ty.EffectRowKind::Effects { ref effects, .. } => {
            for eff in effects.iter() {
                visitor.visit_type(eff);
            }
        }
        _ => {}
    }
}

/// Walk an expression.
pub fn walk_expr<V: Visitor>(visitor: &mut V, expr: &Expr) {
    match expr.kind {
        ExprKind::Literal(ref lit) => {
            visitor.visit_literal(lit);
        }
        ExprKind::Path(ref path) => {
            visitor.visit_expr_path(path);
        }
        ExprKind::Binary { ref left, ref right, .. } => {
            visitor.visit_expr(left);
            visitor.visit_expr(right);
        }
        ExprKind::Unary { ref operand, .. } => {
            visitor.visit_expr(operand);
        }
        ExprKind::Call { ref callee, ref args } => {
            visitor.visit_expr(callee);
            for arg in args.iter() {
                visitor.visit_call_arg(arg);
            }
        }
        ExprKind::MethodCall { ref receiver, ref args, .. } => {
            visitor.visit_expr(receiver);
            for arg in args.iter() {
                visitor.visit_call_arg(arg);
            }
        }
        ExprKind::Field { ref base, .. } => {
            visitor.visit_expr(base);
        }
        ExprKind::Index { ref base, ref index } => {
            visitor.visit_expr(base);
            visitor.visit_expr(index);
        }
        ExprKind::Tuple(ref exprs) => {
            for e in exprs.iter() {
                visitor.visit_expr(e);
            }
        }
        ExprKind::Array(ref arr) => {
            match arr {
                crate.compiler.ast.expr.ArrayExpr::List(ref exprs) => {
                    for e in exprs.iter() {
                        visitor.visit_expr(e);
                    }
                };
                crate.compiler.ast.expr.ArrayExpr::Repeat { ref value, ref count } => {
                    visitor.visit_expr(value);
                    visitor.visit_expr(count);
                }
            }
        }
        ExprKind::Record { ref path, ref fields, ref base } => {
            if let Option::Some(ref p) = path {
                visitor.visit_type_path(p);
            };
            for field in fields.iter() {
                if let Option::Some(ref v) = field.value {
                    visitor.visit_expr(v);
                }
            };
            if let Option::Some(ref b) = base {
                visitor.visit_expr(b);
            }
        }
        ExprKind::Range { ref start, ref end, .. } => {
            if let Option::Some(ref s) = start {
                visitor.visit_expr(s);
            };
            if let Option::Some(ref e) = end {
                visitor.visit_expr(e);
            }
        }
        ExprKind::Cast { ref expr, ref ty } => {
            visitor.visit_expr(expr);
            visitor.visit_type(ty);
        }
        ExprKind::Assign { ref target, ref value } => {
            visitor.visit_expr(target);
            visitor.visit_expr(value);
        }
        ExprKind::AssignOp { ref target, ref value, .. } => {
            visitor.visit_expr(target);
            visitor.visit_expr(value);
        }
        ExprKind::Block(ref block) => {
            visitor.visit_block(block);
        }
        ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            visitor.visit_expr(condition);
            visitor.visit_block(then_branch);
            if let Option::Some(ref eb) = else_branch {
                match eb {
                    crate.compiler.ast.expr.ElseBranch::Block(ref b) => visitor.visit_block(b),
                    crate.compiler.ast.expr.ElseBranch::If(ref e) => visitor.visit_expr(e),
                }
            }
        }
        ExprKind::IfLet { ref pattern, ref scrutinee, ref then_branch, ref else_branch } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(scrutinee);
            visitor.visit_block(then_branch);
            if let Option::Some(ref eb) = else_branch {
                match eb {
                    crate.compiler.ast.expr.ElseBranch::Block(ref b) => visitor.visit_block(b),
                    crate.compiler.ast.expr.ElseBranch::If(ref e) => visitor.visit_expr(e),
                }
            }
        }
        ExprKind::Match { ref scrutinee, ref arms } => {
            visitor.visit_expr(scrutinee);
            for arm in arms.iter() {
                visitor.visit_match_arm(arm);
            }
        }
        ExprKind::Loop { ref body, .. } => {
            visitor.visit_block(body);
        }
        ExprKind::While { ref condition, ref body, .. } => {
            visitor.visit_expr(condition);
            visitor.visit_block(body);
        }
        ExprKind::WhileLet { ref pattern, ref scrutinee, ref body, .. } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(scrutinee);
            visitor.visit_block(body);
        }
        ExprKind::For { ref pattern, ref iter, ref body, .. } => {
            visitor.visit_pattern(pattern);
            visitor.visit_expr(iter);
            visitor.visit_block(body);
        }
        ExprKind::Return(ref value) => {
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        ExprKind::Break { ref value, .. } => {
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        ExprKind::Continue { .. } => {}
        ExprKind::Closure { ref params, ref return_type, ref body, .. } => {
            for param in params.iter() {
                visitor.visit_closure_param(param);
            };
            if let Option::Some(ref ret) = return_type {
                visitor.visit_type(ret);
            };
            visitor.visit_expr(body);
        }
        ExprKind::WithHandle { ref handler, ref body } => {
            visitor.visit_expr(handler);
            visitor.visit_expr(body);
        }
        ExprKind::Perform { ref args, .. } => {
            for arg in args.iter() {
                visitor.visit_expr(arg);
            }
        }
        ExprKind::Resume(ref value) => {
            visitor.visit_expr(value);
        }
        ExprKind::TryWith { ref body, ref handlers } => {
            visitor.visit_block(body);
            for handler in handlers.iter() {
                for param in handler.params.iter() {
                    visitor.visit_pattern(param);
                };
                visitor.visit_block(&handler.body);
            }
        }
        ExprKind::Unsafe(ref block) | ExprKind::Region { ref body: block, .. } => {
            visitor.visit_block(block);
        }
        ExprKind::Paren(ref inner) => {
            visitor.visit_expr(inner);
        }
        ExprKind::Default => {}
        ExprKind::MacroCall { ref path, .. } => {
            visitor.visit_expr_path(path);
        }
        ExprKind::Error => {}
    }
}

/// Walk an expression path.
pub fn walk_expr_path<V: Visitor>(visitor: &mut V, path: &ExprPath) {
    for segment in path.segments.iter() {
        visitor.visit_ident(&segment.name);
    }
}

/// Walk a call argument.
pub fn walk_call_arg<V: Visitor>(visitor: &mut V, arg: &CallArg) {
    if let Option::Some(ref name) = arg.name {
        visitor.visit_ident(name);
    };
    visitor.visit_expr(&arg.value);
}

/// Walk a match arm.
pub fn walk_match_arm<V: Visitor>(visitor: &mut V, arm: &MatchArm) {
    visitor.visit_pattern(&arm.pattern);
    if let Option::Some(ref guard) = arm.guard {
        visitor.visit_expr(guard);
    };
    visitor.visit_expr(&arm.body);
}

/// Walk a closure parameter.
pub fn walk_closure_param<V: Visitor>(visitor: &mut V, param: &ClosureParam) {
    visitor.visit_pattern(&param.pattern);
    if let Option::Some(ref ty) = param.ty {
        visitor.visit_type(ty);
    }
}

/// Walk a pattern.
pub fn walk_pattern<V: Visitor>(visitor: &mut V, pattern: &Pattern) {
    match pattern.kind {
        PatternKind::Wildcard | PatternKind::Rest => {}
        PatternKind::Literal(ref lit) => {
            visitor.visit_literal(lit);
        }
        PatternKind::Ident { ref name, ref subpattern, .. } => {
            visitor.visit_ident(name);
            if let Option::Some(ref sub) = subpattern {
                visitor.visit_pattern(sub);
            }
        }
        PatternKind::Ref { ref inner, .. } => {
            visitor.visit_pattern(inner);
        }
        PatternKind::Struct { ref path, ref fields, .. } => {
            visitor.visit_type_path(path);
            for field in fields.iter() {
                visitor.visit_struct_pattern_field(field);
            }
        }
        PatternKind::TupleStruct { ref path, ref fields, .. } => {
            visitor.visit_type_path(path);
            for field in fields.iter() {
                visitor.visit_pattern(field);
            }
        }
        PatternKind::Tuple { ref fields, .. } => {
            for field in fields.iter() {
                visitor.visit_pattern(field);
            }
        }
        PatternKind::Slice { ref elements, .. } => {
            for elem in elements.iter() {
                visitor.visit_pattern(elem);
            }
        }
        PatternKind::Or(ref patterns) => {
            for pat in patterns.iter() {
                visitor.visit_pattern(pat);
            }
        }
        PatternKind::Range { ref start, ref end, .. } => {
            if let Option::Some(ref s) = start {
                visitor.visit_pattern(s);
            };
            if let Option::Some(ref e) = end {
                visitor.visit_pattern(e);
            }
        }
        PatternKind::Path(ref path) => {
            visitor.visit_type_path(path);
        }
        PatternKind::Paren(ref inner) => {
            visitor.visit_pattern(inner);
        }
    }
}

/// Walk a struct pattern field.
pub fn walk_struct_pattern_field<V: Visitor>(visitor: &mut V, field: &StructPatternField) {
    visitor.visit_ident(&field.name);
    if let Option::Some(ref pat) = field.pattern {
        visitor.visit_pattern(pat);
    }
}

/// Walk a block.
pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {
    for stmt in block.statements.iter() {
        visitor.visit_statement(stmt);
    };
    if let Option::Some(ref expr) = block.expr {
        visitor.visit_expr(expr);
    }
}

/// Walk a statement.
pub fn walk_statement<V: Visitor>(visitor: &mut V, stmt: &Statement) {
    match stmt {
        Statement::Let { ref pattern, ref ty, ref value, .. } => {
            visitor.visit_pattern(pattern);
            if let Option::Some(ref t) = ty {
                visitor.visit_type(t);
            };
            if let Option::Some(ref v) = value {
                visitor.visit_expr(v);
            }
        }
        Statement::Expr { ref expr, .. } => {
            visitor.visit_expr(expr);
        }
        Statement::Item(ref decl) => {
            visitor.visit_declaration(decl);
        }
    }
}

/// Walk an attribute.
pub fn walk_attribute<V: Visitor>(visitor: &mut V, attr: &Attribute) {
    // Visit path segments
    for segment in attr.path.segments.iter() {
        visitor.visit_ident(segment);
    };

    // Visit args if present
    if let Option::Some(ref args) = attr.args {
        match args {
            AttrArgs::Eq { ref value, .. } => {
                visitor.visit_literal(value);
            }
            AttrArgs::List { ref args, .. } => {
                for arg in args.iter() {
                    walk_attr_arg(visitor, arg)
                }
            }
        }
    }
}

fn walk_attr_arg<V: Visitor>(visitor: &mut V, arg: &AttrArg) {
    match arg {
        AttrArg::Ident { ref ident, .. } => {
            visitor.visit_ident(ident);
        }
        AttrArg::KeyValue { ref key, ref value, .. } => {
            visitor.visit_ident(key);
            visitor.visit_literal(value);
        }
        AttrArg::Literal { ref literal, .. } => {
            visitor.visit_literal(literal);
        }
        AttrArg::Call { ref name, ref args, .. } => {
            visitor.visit_ident(name);
            for arg in args.iter() {
                walk_attr_arg(visitor, arg)
            }
        }
        AttrArg::Path { ref path, .. } => {
            for segment in path.segments.iter() {
                visitor.visit_ident(segment);
            }
        }
    }
}

/// Walk a bridge declaration.
pub fn walk_bridge_decl<V: Visitor>(visitor: &mut V, decl: &BridgeDecl) {
    for attr in decl.attrs.iter() {
        visitor.visit_attribute(attr);
    };

    visitor.visit_ident(&decl.name);

    for item in decl.items.iter() {
        visitor.visit_bridge_item(item);
    }
}

/// Walk a bridge item.
pub fn walk_bridge_item<V: Visitor>(visitor: &mut V, item: &BridgeItem) {
    match item {
        BridgeItem::Function(ref f) => {
            for attr in f.attrs.iter() {
                visitor.visit_attribute(attr);
            };
            visitor.visit_ident(&f.name);
            for param in f.params.iter() {
                visitor.visit_ident(&param.name);
                visitor.visit_type(&param.ty);
            };
            if let Option::Some(ref ret) = f.return_type {
                visitor.visit_type(ret);
            }
        }
        BridgeItem::Const(ref c) => {
            visitor.visit_ident(&c.name);
            visitor.visit_type(&c.ty);
            visitor.visit_literal(&c.value);
        }
        BridgeItem::OpaqueType(ref t) => {
            visitor.visit_ident(&t.name);
        }
        BridgeItem::TypeAlias(ref t) => {
            visitor.visit_ident(&t.name);
            visitor.visit_type(&t.ty);
        }
        BridgeItem::Struct(ref s) => {
            for attr in s.attrs.iter() {
                visitor.visit_attribute(attr);
            };
            visitor.visit_ident(&s.name);
            for field in s.fields.iter() {
                visitor.visit_ident(&field.name);
                visitor.visit_type(&field.ty);
            }
        }
        BridgeItem::Enum(ref e) => {
            for attr in e.attrs.iter() {
                visitor.visit_attribute(attr);
            };
            visitor.visit_ident(&e.name);
            for variant in e.variants.iter() {
                visitor.visit_ident(&variant.name);
                if let Option::Some(ref disc) = variant.discriminant {
                    visitor.visit_literal(disc);
                }
            }
        }
        BridgeItem::Union(ref u) => {
            for attr in u.attrs.iter() {
                visitor.visit_attribute(attr);
            };
            visitor.visit_ident(&u.name);
            for field in u.fields.iter() {
                visitor.visit_ident(&field.name);
                visitor.visit_type(&field.ty);
            }
        }
        BridgeItem::Callback(ref cb) => {
            visitor.visit_ident(&cb.name);
            for param in cb.params.iter() {
                visitor.visit_type(param);
            };
            if let Option::Some(ref ret) = cb.return_type {
                visitor.visit_type(ret);
            }
        }
        BridgeItem::Link(_) => {}
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_visitor_can_be_implemented() {
    struct CountExpressions {
        count: USize,
    }

    impl Visitor for CountExpressions {
        fn visit_expr(mut self, expr: &Expr) {
            self.count += 1
            walk_expr(self, expr)
        }
    }

    // Create a simple expression and count it
    let expr = Expr::new(
        ExprKind::Binary {
            op: crate.compiler.ast.expr.BinOp::Add,
            left: Box::new(Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy())),
            right: Box::new(Expr::new(ExprKind::Literal(Literal::int(2, Span::dummy())), Span::dummy())),
        },
        Span::dummy(),
    );

    let mut counter = CountExpressions { count: 0 };
    counter.visit_expr(&expr);

    // Should count: binary expr + two literal exprs = 3
    assert(counter.count == 3);
}
