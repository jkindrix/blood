//! # AST Pattern Types
//!
//! Pattern definitions for the Blood AST.
//!
//! ## Overview
//!
//! Patterns are used for destructuring and matching in Blood:
//! - Let bindings: `let (x, y) = point`
//! - Match arms: `match opt { Some(v) => v, None => 0 }`
//! - Function parameters: `fn foo((x, y): Point)`
//! - If-let: `if let Some(v) = opt { ... }`
//! - While-let: `while let Some(v) = iter.next() { ... }`
//! - For loops: `for (key, value) in map { ... }`
//!
//! ## Pattern Forms
//!
//! | Form | Example | Description |
//! |------|---------|-------------|
//! | Wildcard | `_` | Matches anything, binds nothing |
//! | Rest | `..` | Matches remaining elements |
//! | Literal | `42`, `"hi"` | Matches exact value |
//! | Identifier | `x`, `mut x` | Binds to variable |
//! | Reference | `&x`, `&mut x` | Matches references |
//! | Struct | `Point { x, y }` | Destructures struct |
//! | Tuple struct | `Some(v)` | Destructures tuple struct/variant |
//! | Tuple | `(a, b, c)` | Destructures tuple |
//! | Slice | `[first, .., last]` | Destructures slice |
//! | Or | `A \| B \| C` | Matches alternatives |
//! | Range | `0..10` | Matches range of values |
//! | Path | `None`, `Color::Red` | Matches unit variant |

module std.compiler.ast.pattern;

use std.core.Option;
use std.collections.Vec;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.Ident;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.lit.Literal;
use std.compiler.ast.ty.TypePath;

// ============================================================================
// Pattern
// ============================================================================

/// A pattern in the Blood AST.
///
/// Patterns are used for destructuring values and binding variables.
#[derive(Clone, PartialEq, Eq)]
pub struct Pattern {
    /// Unique node ID.
    pub id: NodeId,
    /// The pattern kind.
    pub kind: PatternKind,
    /// Span of the pattern.
    pub span: Span,
}

impl Pattern {
    /// Create a new pattern.
    pub fn new(kind: PatternKind, span: Span) -> Pattern {
        Pattern {
            id: NodeId::dummy(),
            kind,
            span,
        }
    }

    /// Create a wildcard pattern `_`.
    pub fn wildcard(span: Span) -> Pattern {
        Pattern::new(PatternKind::Wildcard, span)
    }

    /// Create a rest pattern `..`.
    pub fn rest(span: Span) -> Pattern {
        Pattern::new(PatternKind::Rest, span)
    }

    /// Create a simple identifier pattern.
    pub fn ident(name: Ident, span: Span) -> Pattern {
        Pattern::new(
            PatternKind::Ident {
                by_ref: false,
                mutable: false,
                name,
                subpattern: Option::None,
            },
            span,
        )
    }

    /// Check if this is a wildcard pattern.
    pub fn is_wildcard(self: &Self) -> bool {
        match self.kind {
            PatternKind::Wildcard => true,
            _ => false,
        }
    }

    /// Check if this is a rest pattern.
    pub fn is_rest(self: &Self) -> bool {
        match self.kind {
            PatternKind::Rest => true,
            _ => false,
        }
    }

    /// Check if this pattern is irrefutable (always matches).
    ///
    /// Irrefutable patterns can be used in let bindings without
    /// requiring a refutable pattern context (match, if-let, etc.).
    pub fn is_irrefutable(self: &Self) -> bool {
        match self.kind {
            PatternKind::Wildcard => true,
            PatternKind::Rest => true,
            PatternKind::Ident { ref subpattern, .. } => {
                match subpattern {
                    Option::Some(ref sub) => sub.as_ref().is_irrefutable(),
                    Option::None => true,
                }
            }
            PatternKind::Ref { ref inner, .. } => inner.as_ref().is_irrefutable(),
            PatternKind::Tuple { ref fields, .. } => {
                let mut i = 0usize;
                while i < fields.len() {
                    if let Option::Some(p) = fields.get(i) {
                        if !p.is_irrefutable() {
                            return false;
                        }
                    }
                    i = i + 1;
                }
                true
            }
            PatternKind::Paren(ref inner) => inner.as_ref().is_irrefutable(),
            // All other patterns are potentially refutable
            _ => false,
        }
    }

    /// Check if this pattern binds any variables.
    pub fn binds_variables(self: &Self) -> bool {
        match self.kind {
            PatternKind::Wildcard => false,
            PatternKind::Rest => false,
            PatternKind::Literal(_) => false,
            PatternKind::Ident { .. } => true,
            PatternKind::Ref { ref inner, .. } => inner.as_ref().binds_variables(),
            PatternKind::Struct { ref fields, .. } => {
                let mut i = 0usize;
                while i < fields.len() {
                    if let Option::Some(f) = fields.get(i) {
                        match f.pattern {
                            Option::Some(ref p) => {
                                if p.binds_variables() {
                                    return true;
                                }
                            }
                            Option::None => return true, // Shorthand binds the field name
                        }
                    }
                    i = i + 1;
                }
                false
            }
            PatternKind::TupleStruct { ref fields, .. } => {
                let mut i = 0usize;
                while i < fields.len() {
                    if let Option::Some(p) = fields.get(i) {
                        if p.binds_variables() {
                            return true;
                        }
                    }
                    i = i + 1;
                }
                false
            }
            PatternKind::Tuple { ref fields, .. } => {
                let mut i = 0usize;
                while i < fields.len() {
                    if let Option::Some(p) = fields.get(i) {
                        if p.binds_variables() {
                            return true;
                        }
                    }
                    i = i + 1;
                }
                false
            }
            PatternKind::Slice { ref elements, .. } => {
                let mut i = 0usize;
                while i < elements.len() {
                    if let Option::Some(p) = elements.get(i) {
                        if p.binds_variables() {
                            return true;
                        }
                    }
                    i = i + 1;
                }
                false
            }
            PatternKind::Or(ref patterns) => {
                let mut i = 0usize;
                while i < patterns.len() {
                    if let Option::Some(p) = patterns.get(i) {
                        if p.binds_variables() {
                            return true;
                        }
                    }
                    i = i + 1;
                }
                false
            }
            PatternKind::Range { .. } => false,
            PatternKind::Path(_) => false,
            PatternKind::Paren(ref inner) => inner.as_ref().binds_variables(),
        }
    }
}

// ============================================================================
// Pattern Kind
// ============================================================================

/// The kind of pattern.
#[derive(Clone, PartialEq, Eq)]
pub enum PatternKind {
    /// Wildcard: `_`
    Wildcard,

    /// Rest: `..`
    Rest,

    /// Literal: `42`, `"hello"`, `true`
    Literal(Literal),

    /// Identifier: `x`, `ref x`, `mut x`, `x @ pat`
    Ident {
        /// Bind by reference.
        by_ref: bool,
        /// Mutable binding.
        mutable: bool,
        /// Variable name.
        name: Ident,
        /// Optional subpattern for `@` binding.
        subpattern: Option[Box<Pattern>],
    },

    /// Reference pattern: `&x`, `&mut x`
    Ref {
        /// Mutable reference.
        mutable: bool,
        /// Inner pattern.
        inner: Box<Pattern>,
    },

    /// Struct pattern: `Point { x, y: 0 }`, `Point { x, .. }`
    Struct {
        /// The struct path.
        path: TypePath,
        /// Field patterns.
        fields: Vec<StructPatternField>,
        /// Has rest pattern `..`.
        rest: bool,
    },

    /// Tuple struct pattern: `Some(x)`, `Ok(v)`
    TupleStruct {
        /// The constructor path.
        path: TypePath,
        /// Field patterns.
        fields: Vec<Pattern>,
        /// Position of rest pattern `..` if present.
        rest_pos: Option<usize>,
    },

    /// Tuple pattern: `(x, y)`, `(a, .., z)`
    Tuple {
        /// Element patterns.
        fields: Vec<Pattern>,
        /// Position of rest pattern `..` if present.
        rest_pos: Option<usize>,
    },

    /// Slice pattern: `[first, .., last]`, `[a, b, c]`
    Slice {
        /// Element patterns.
        elements: Vec<Pattern>,
        /// Position of rest pattern `..` if present.
        rest_pos: Option<usize>,
    },

    /// Or pattern: `A | B | C`
    Or(Vec<Pattern>),

    /// Range pattern: `0..10`, `'a'..='z'`
    Range {
        /// Start of range (None for open start).
        start: Option[Box<Pattern>],
        /// End of range (None for open end).
        end: Option[Box<Pattern>],
        /// Is the range inclusive (`..=`)?
        inclusive: bool,
    },

    /// Path pattern: `None`, `Color::Red`
    Path(TypePath),

    /// Parenthesized: `(pat)`
    Paren(Box<Pattern>),
}

// ============================================================================
// Struct Pattern Field
// ============================================================================

/// A field in a struct pattern.
///
/// ## Example
///
/// ```blood
/// match point {
///     Point { x, y: 0 } => ...      // y has explicit pattern
///     Point { x, y } => ...         // shorthand
///     Point { x, .. } => ...        // rest
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct StructPatternField {
    /// Field name.
    pub name: Ident,
    /// Optional explicit pattern (None for shorthand `{ x }` meaning `{ x: x }`).
    pub pattern: Option<Pattern>,
    /// Span of the field.
    pub span: Span,
}

impl StructPatternField {
    /// Check if this uses shorthand syntax.
    pub fn is_shorthand(self) -> bool {
        self.pattern.is_none();
    }
}

// ============================================================================
// Pattern Helpers
// ============================================================================

/// Collect all identifiers bound by a pattern.
pub fn collect_bindings(pattern: &Pattern) -> Vec<Ident> {
    let mut bindings = Vec::new();
    collect_bindings_inner(pattern, &mut bindings)
    bindings
}

fn collect_bindings_inner(pattern: &Pattern, bindings: &mut Vec<Ident>) {
    match pattern.kind {
        PatternKind::Wildcard => {}
        PatternKind::Rest => {}
        PatternKind::Literal(_) => {}

        PatternKind::Ident { ref name, ref subpattern, .. } => {
            // Copy the Ident manually since trait method lookup may not work
            bindings.push(Ident::new(name.symbol(), name.span()));
            if let Option::Some(ref sub) = subpattern {
                collect_bindings_inner(sub.as_ref(), bindings)
            }
        }

        PatternKind::Ref { ref inner, .. } => {
            collect_bindings_inner(inner.as_ref(), bindings)
        }

        PatternKind::Struct { ref fields, .. } => {
            let mut i = 0usize;
            while i < fields.len() {
                if let Option::Some(f) = fields.get(i) {
                    if f.pattern.is_some() {
                        if let Option::Some(p) = f.pattern {
                            collect_bindings_inner(&p, bindings);
                        }
                    } else {
                        // Shorthand - field name is the binding
                        bindings.push(Ident::new(f.name.symbol(), f.name.span()));
                    }
                }
                i = i + 1;
            }
        }

        PatternKind::TupleStruct { ref fields, .. } => {
            let mut i = 0usize;
            while i < fields.len() {
                if let Option::Some(p) = fields.get(i) {
                    collect_bindings_inner(p, bindings);
                }
                i = i + 1;
            }
        }

        PatternKind::Tuple { ref fields, .. } => {
            let mut i = 0usize;
            while i < fields.len() {
                if let Option::Some(p) = fields.get(i) {
                    collect_bindings_inner(p, bindings);
                }
                i = i + 1;
            }
        }

        PatternKind::Slice { ref elements, .. } => {
            let mut i = 0usize;
            while i < elements.len() {
                if let Option::Some(p) = elements.get(i) {
                    collect_bindings_inner(p, bindings);
                }
                i = i + 1;
            }
        }

        PatternKind::Or(ref patterns) => {
            // Or patterns must bind the same variables in all branches
            // We only collect from the first branch
            if let Option::Some(p) = patterns.get(0usize) {
                collect_bindings_inner(p, bindings);
            }
        }

        PatternKind::Range { .. } => {}
        PatternKind::Path(_) => {}

        PatternKind::Paren(ref inner) => {
            collect_bindings_inner(inner.as_ref(), bindings)
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_pattern_wildcard() {
    let pat = Pattern::wildcard(Span::dummy());
    assert(pat.is_wildcard());
    assert(pat.is_irrefutable());
    assert(!pat.binds_variables());
}

#[test]
fn test_pattern_rest() {
    let pat = Pattern::rest(Span::dummy());
    assert(pat.is_rest());
    assert(pat.is_irrefutable());
}

#[test]
fn test_pattern_ident() {
    let name = Ident::dummy();
    let pat = Pattern::ident(name, Span::dummy());

    assert(pat.is_irrefutable());
    assert(pat.binds_variables());
}

#[test]
fn test_pattern_ident_with_subpattern() {
    let name = Ident::dummy();
    let sub = Pattern::wildcard(Span::dummy());
    let pat = Pattern::new(
        PatternKind::Ident {
            by_ref: false,
            mutable: false,
            name,
            subpattern: Option::Some(Box::new(sub)),
        },
        Span::dummy(),
    );

    assert(pat.is_irrefutable());
    assert(pat.binds_variables());
}

// TODO: Re-enable once cross-module Span type resolution is fixed
// #[test]
// fn test_pattern_literal_refutable() {
//     let lit = Literal::int(42i64, Option::None, Span::dummy());
//     let pat = Pattern::new(PatternKind::Literal(lit), Span::dummy());
//
//     assert(!pat.is_irrefutable());
//     assert(!pat.binds_variables());
// }

#[test]
fn test_pattern_tuple_irrefutable() {
    let a = Pattern::ident(Ident::dummy(), Span::dummy());
    let b = Pattern::wildcard(Span::dummy());
    let pat = Pattern::new(
        PatternKind::Tuple {
            fields: vec![a, b],
            rest_pos: Option::None,
        },
        Span::dummy(),
    );

    assert(pat.is_irrefutable());
    assert(pat.binds_variables());
}

// TODO: Re-enable once cross-module Span type resolution is fixed
// #[test]
// fn test_pattern_or_refutable() {
//     let a = Pattern::new(PatternKind::Literal(Literal::int(1i64, Option::None, Span::dummy())), Span::dummy());
//     let b = Pattern::new(PatternKind::Literal(Literal::int(2i64, Option::None, Span::dummy())), Span::dummy());
//     let pat = Pattern::new(PatternKind::Or(vec![a, b]), Span::dummy());
//
//     assert(!pat.is_irrefutable());
// }

#[test]
fn test_struct_pattern_field_shorthand() {
    let shorthand = StructPatternField {
        name: Ident::dummy(),
        pattern: Option::None,
        span: Span::dummy(),
    };
    assert(shorthand.is_shorthand());

    let explicit = StructPatternField {
        name: Ident::dummy(),
        pattern: Option::Some(Pattern::wildcard(Span::dummy())),
        span: Span::dummy(),
    };
    assert(!explicit.is_shorthand());
}

#[test]
fn test_collect_bindings_simple() {
    let name = Ident::new_for_test("x");
    let pat = Pattern::ident(name, Span::dummy());

    let bindings = collect_bindings(&pat);
    assert(bindings.len() == 1);
}

#[test]
fn test_collect_bindings_tuple() {
    let a = Pattern::ident(Ident::new_for_test("a"), Span::dummy());
    let b = Pattern::ident(Ident::new_for_test("b"), Span::dummy());
    let c = Pattern::wildcard(Span::dummy());
    let pat = Pattern::new(
        PatternKind::Tuple {
            fields: vec![a, b, c],
            rest_pos: Option::None,
        },
        Span::dummy(),
    );

    let bindings = collect_bindings(&pat);
    assert(bindings.len() == 2); // a and b, not wildcard
}

#[test]
fn test_collect_bindings_nested() {
    let inner = Pattern::ident(Ident::new_for_test("inner"), Span::dummy());
    let outer = Pattern::new(
        PatternKind::Ident {
            by_ref: false,
            mutable: false,
            name: Ident::new_for_test("outer"),
            subpattern: Option::Some(Box::new(inner)),
        },
        Span::dummy(),
    );

    let bindings = collect_bindings(&outer);
    assert(bindings.len() == 2); // outer and inner
}
