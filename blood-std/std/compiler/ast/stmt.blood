//! # AST Statement Types
//!
//! Statement and block definitions for the Blood AST.
//!
//! ## Overview
//!
//! Statements are the building blocks of imperative code in Blood:
//! - Let bindings: `let x = 1;`
//! - Expression statements: `foo();`
//! - Item declarations (local functions, structs, etc.)
//!
//! Blocks group statements together and optionally have a trailing
//! expression that becomes the block's value.
//!
//! ## Statement Forms
//!
//! | Form | Example | Description |
//! |------|---------|-------------|
//! | Let | `let x = 1;` | Variable binding |
//! | Let (typed) | `let x: Int = 1;` | With type annotation |
//! | Let (pattern) | `let (a, b) = pair;` | Destructuring |
//! | Expression | `foo();` | With semicolon |
//! | Expression | `foo()` | Without semicolon (trailing) |
//! | Item | `fn local() { }` | Local declaration |
//!
//! ## Block Structure
//!
//! ```blood
//! {
//!     let x = 1;        // Statement
//!     let y = 2;        // Statement
//!     process(x);       // Statement (expression with semi)
//!     x + y             // Trailing expression (block value)
//! }
//! ```

module std.compiler.ast.stmt;

use std.option.Option;
use std.collections.Vec;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.ty.Type;
use std.compiler.ast.pattern.Pattern;
use std.compiler.ast.expr.Expr;
use std.compiler.ast.decl.Declaration;

// ============================================================================
// Block
// ============================================================================

/// A block of statements with an optional trailing expression.
///
/// ## Example
///
/// ```blood
/// {
///     let x = 1;
///     let y = 2;
///     x + y        // This expression is the block's value
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct Block {
    /// Unique node ID.
    pub id: NodeId,
    /// Statements in the block.
    pub statements: Vec<Statement>,
    /// Optional trailing expression (the block's value).
    pub expr: Option[Box<Expr>],
    /// Span of the entire block including braces.
    pub span: Span,
}

impl Block {
    /// Create an empty block.
    pub fn empty(span: Span) -> Block {
        Block {
            id: NodeId::dummy(),
            statements: Vec::new(),
            expr: Option::None,
            span,
        }
    }

    /// Create a block with just an expression.
    pub fn expr(e: Expr) -> Block {
        let span = e.span;
        Block {
            id: NodeId::dummy(),
            statements: Vec::new(),
            expr: Option::Some(Box::new(e)),
            span,
        }
    }

    /// Create a block from statements and optional expression.
    pub fn new(statements: Vec<Statement>, expr: Option<Expr>, span: Span) -> Block {
        Block {
            id: NodeId::dummy(),
            statements,
            expr: expr.map(|e| Box::new(e)),
            span,
        }
    }

    /// Check if the block is empty (no statements and no expression).
    pub fn is_empty(self) -> Bool {
        self.statements.is_empty() && self.expr.is_none();
    }

    /// Check if the block has a trailing expression.
    pub fn has_expr(self) -> Bool {
        self.expr.is_some();
    }

    /// Get the number of statements.
    pub fn statement_count(self) -> USize {
        self.statements.len();
    }

    /// Check if this block returns unit (no trailing expression).
    pub fn returns_unit(self) -> Bool {
        self.expr.is_none();
    }
}

// ============================================================================
// Statement
// ============================================================================

/// A statement in a block.
#[derive(Clone, PartialEq, Eq)]
pub enum Statement {
    /// Let binding: `let x = 1;`, `let x: Int = 1;`, `let (a, b) = pair;`
    Let {
        /// Unique node ID.
        id: NodeId,
        /// The binding pattern.
        pattern: Pattern,
        /// Optional type annotation.
        ty: Option<Type>,
        /// Optional initializer.
        value: Option<Expr>,
        /// Span of the entire statement.
        span: Span,
    },

    /// Expression statement: `foo();` or `foo()` (without semicolon for trailing)
    Expr {
        /// The expression.
        expr: Expr,
        /// Whether the statement has a semicolon.
        has_semi: Bool,
    },

    /// Item declaration inside a block (local function, struct, etc.)
    Item(Declaration),
}

impl Statement {
    /// Create a let statement.
    pub fn let_stmt(pattern: Pattern, ty: Option<Type>, value: Option<Expr>, span: Span) -> Statement {
        Statement::Let {
            id: NodeId::dummy(),
            pattern,
            ty,
            value,
            span,
        }
    }

    /// Create an expression statement with semicolon.
    pub fn expr_stmt(expr: Expr) -> Statement {
        Statement::Expr {
            expr,
            has_semi: true,
        }
    }

    /// Create an expression statement without semicolon (trailing).
    pub fn expr_no_semi(expr: Expr) -> Statement {
        Statement::Expr {
            expr,
            has_semi: false,
        }
    }

    /// Create an item statement.
    pub fn item(decl: Declaration) -> Statement {
        Statement::Item(decl)
    }

    /// Get the span of this statement.
    pub fn span(self) -> Span {
        match self {
            Statement::Let { span, .. } => span,
            Statement::Expr { ref expr, .. } => expr.span,
            Statement::Item(ref decl) => decl.span(),
        }
    }

    /// Check if this is a let statement.
    pub fn is_let(self) -> Bool {
        match self {
            Statement::Let { .. } => true,
            _ => false,
        }
    }

    /// Check if this is an expression statement.
    pub fn is_expr(self) -> Bool {
        match self {
            Statement::Expr { .. } => true,
            _ => false,
        }
    }

    /// Check if this is an item statement.
    pub fn is_item(self) -> Bool {
        match self {
            Statement::Item(_) => true,
            _ => false,
        }
    }

    /// Check if this statement has a semicolon.
    ///
    /// Returns true for let statements (always have semi),
    /// expression statements with semi, and item statements.
    pub fn has_semicolon(self) -> Bool {
        match self {
            Statement::Let { .. } => true,
            Statement::Expr { has_semi, .. } => has_semi,
            Statement::Item(_) => true,
        }
    }
}

// ============================================================================
// Let Statement Helpers
// ============================================================================

/// Create a simple let binding: `let name = value;`
pub fn simple_let(name: crate.compiler.ast.node.Ident, value: Expr, span: Span) -> Statement {
    Statement::let_stmt(
        Pattern::ident(name, span),
        Option::None,
        Option::Some(value),
        span,
    )
}

/// Create a typed let binding: `let name: ty = value;`
pub fn typed_let(
    name: crate.compiler.ast.node.Ident,
    ty: Type,
    value: Expr,
    span: Span,
) -> Statement {
    Statement::let_stmt(
        Pattern::ident(name, span),
        Option::Some(ty),
        Option::Some(value),
        span,
    )
}

/// Create an uninitialized let binding: `let name: ty;`
pub fn uninit_let(name: crate.compiler.ast.node.Ident, ty: Type, span: Span) -> Statement {
    Statement::let_stmt(
        Pattern::ident(name, span),
        Option::Some(ty),
        Option::None,
        span,
    )
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_block_empty() {
    let block = Block::empty(Span::dummy());

    assert(block.is_empty());
    assert(!block.has_expr());
    assert(block.statement_count() == 0);
    assert(block.returns_unit());
}

#[test]
fn test_block_with_expr() {
    let expr = Expr::new(ExprKind::Literal(Literal::int(42, Span::dummy())), Span::dummy());
    let block = Block::expr(expr);

    assert(!block.is_empty());
    assert(block.has_expr());
    assert(block.statement_count() == 0);
    assert(!block.returns_unit());
}

#[test]
fn test_block_with_statements() {
    let stmt = Statement::expr_stmt(
        Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy())
    )
    let block = Block::new(vec![stmt], Option::None, Span::dummy());

    assert(!block.is_empty());
    assert(!block.has_expr());
    assert(block.statement_count() == 1);
    assert(block.returns_unit());
}

#[test]
fn test_statement_let() {
    let pattern = Pattern::wildcard(Span::dummy());
    let stmt = Statement::let_stmt(pattern, Option::None, Option::None, Span::dummy());

    assert(stmt.is_let());
    assert(!stmt.is_expr());
    assert(!stmt.is_item());
    assert(stmt.has_semicolon());
}

#[test]
fn test_statement_expr_with_semi() {
    let expr = Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy());
    let stmt = Statement::expr_stmt(expr);

    assert(!stmt.is_let());
    assert(stmt.is_expr());
    assert(stmt.has_semicolon());
}

#[test]
fn test_statement_expr_no_semi() {
    let expr = Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy());
    let stmt = Statement::expr_no_semi(expr);

    assert(stmt.is_expr());
    assert(!stmt.has_semicolon());
}

#[test]
fn test_simple_let_helper() {
    let name = Ident::new_for_test("x");
    let value = Expr::new(ExprKind::Literal(Literal::int(42, Span::dummy())), Span::dummy());
    let stmt = simple_let(name, value, Span::dummy());

    assert(stmt.is_let());
    match stmt {
        Statement::Let { ref ty, ref value, .. } => {
            assert(ty.is_none());
            assert(value.is_some());
        }
        _ => assert(false),
    }
}

#[test]
fn test_typed_let_helper() {
    let name = Ident::new_for_test("x");
    let ty = Type::unit(Span::dummy());
    let value = Expr::new(ExprKind::Tuple(Vec::new()), Span::dummy());
    let stmt = typed_let(name, ty, value, Span::dummy());

    assert(stmt.is_let());
    match stmt {
        Statement::Let { ref ty, ref value, .. } => {
            assert(ty.is_some());
            assert(value.is_some());
        }
        _ => assert(false),
    }
}

#[test]
fn test_uninit_let_helper() {
    let name = Ident::new_for_test("x");
    let ty = Type::unit(Span::dummy());
    let stmt = uninit_let(name, ty, Span::dummy());

    assert(stmt.is_let());
    match stmt {
        Statement::Let { ref ty, ref value, .. } => {
            assert(ty.is_some());
            assert(value.is_none());
        }
        _ => assert(false),
    }
}
