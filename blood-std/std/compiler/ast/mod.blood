//! # Abstract Syntax Tree Module
//!
//! The AST representation for the Blood programming language.
//!
//! ## Overview
//!
//! This module provides the complete Abstract Syntax Tree (AST) that represents
//! parsed Blood programs. The AST closely mirrors the surface syntax and serves
//! as the primary input to subsequent compiler phases.
//!
//! ## Module Structure
//!
//! ```text
//! ast/
//! ├── mod.blood      # This file - module entry point with re-exports
//! ├── node.blood     # Core types: Program, Span, Ident, NodeId, Visibility
//! ├── attr.blood     # Attributes: Attribute, AttrArgs, AttrArg
//! ├── lit.blood      # Literals: Literal, LiteralKind, IntSuffix, FloatSuffix
//! ├── ty.blood       # Types: Type, TypeKind, TypePath, TypeParams, WhereClause
//! ├── decl.blood     # Declarations: FnDecl, StructDecl, EnumDecl, TraitDecl, etc.
//! ├── expr.blood     # Expressions: Expr, ExprKind, BinOp, UnaryOp
//! ├── pattern.blood  # Patterns: Pattern, PatternKind
//! ├── stmt.blood     # Statements: Statement, Block
//! ├── bridge.blood   # FFI: BridgeDecl, BridgeItem, BridgeFn
//! └── visitor.blood  # Visitor: Visitor trait, walk_* functions
//! ```
//!
//! ## Quick Start
//!
//! ```blood
//! use std.compiler.ast
//!
//! // Parse a program
//! let program: ast.Program = parser.parse()
//!
//! // Access declarations
//! for decl in program.declarations {
//!     match decl {
//!         ast.Declaration::Function(f) => {
//!             println("Found function: {}", f.name)
//!         }
//!         ast.Declaration::Struct(s) => {
//!             println("Found struct: {}", s.name)
//!         }
//!         _ => {}
//!     }
//! }
//! ```
//!
//! ## AST Node Types
//!
//! | Category | Types |
//! |----------|-------|
//! | **Core** | `Program`, `ModuleDecl`, `Import`, `Span`, `NodeId`, `Ident` |
//! | **Declarations** | `FnDecl`, `StructDecl`, `EnumDecl`, `TraitDecl`, `ImplBlock` |
//! | **Types** | `Type`, `TypePath`, `TypeParams`, `WhereClause`, `EffectRow` |
//! | **Expressions** | `Expr`, `BinOp`, `UnaryOp`, `CallArg`, `MatchArm` |
//! | **Patterns** | `Pattern`, `StructPatternField` |
//! | **Statements** | `Statement`, `Block` |
//! | **Attributes** | `Attribute`, `AttrArgs`, `AttrArg` |
//! | **Literals** | `Literal`, `LiteralKind`, `IntSuffix`, `FloatSuffix` |
//! | **FFI** | `BridgeDecl`, `BridgeItem`, `BridgeFn`, `BridgeOwnership` |
//!
//! ## Visitor Pattern
//!
//! Use the `Visitor` trait to traverse AST nodes:
//!
//! ```blood
//! use std.compiler.ast.visitor.{Visitor, walk_program}
//!
//! struct FunctionCounter { count: USize }
//!
//! impl Visitor for FunctionCounter {
//!     fn visit_fn_decl(mut self, decl: &FnDecl) {
//!         self.count += 1
//!         walk_fn_decl(self, decl)
//!     }
//! }
//!
//! let mut counter = FunctionCounter { count: 0 }
//! counter.visit_program(&program)
//! println("Functions: {}", counter.count)
//! ```
//!
//! ## Design Principles
//!
//! 1. **Faithful to surface syntax**: The AST represents what the programmer wrote
//! 2. **Complete span information**: Every node tracks its source location
//! 3. **Uniform node IDs**: All nodes have unique identifiers for later phases
//! 4. **Immutable by default**: AST nodes are immutable; use MutVisitor for transforms
//!
//! ## Relationship to Other Modules
//!
//! ```text
//! Source Code
//!     │
//!     ▼
//! ┌─────────┐
//! │  Lexer  │  → Tokens
//! └─────────┘
//!     │
//!     ▼
//! ┌─────────┐
//! │ Parser  │  → AST (this module)
//! └─────────┘
//!     │
//!     ▼
//! ┌─────────┐
//! │ Lowering│  → HIR (High-level IR)
//! └─────────┘
//!     │
//!     ▼
//! ┌─────────┐
//! │ Codegen │  → Target code
//! └─────────┘
//! ```

module std.compiler.ast;

// ============================================================================
// Core Node Types (from node.blood)
// ============================================================================

pub use node.Span;
pub use node.Spanned;
pub use node.NodeId;
pub use node.NodeIdGenerator;
pub use node.Symbol;
pub use node.Ident;
pub use node.Visibility;
pub use node.Program;
pub use node.ModuleDecl;
pub use node.ModulePath;
pub use node.Import;
pub use node.ImportItem;

// ============================================================================
// Attribute Types (from attr.blood)
// ============================================================================

pub use attr.Attribute;
pub use attr.AttrPath;
pub use attr.AttrArgs;
pub use attr.AttrArg;
pub use attr.Attrs;
pub use attr.attr_names;

// ============================================================================
// Literal Types (from lit.blood)
// ============================================================================

pub use lit.Literal;
pub use lit.LiteralKind;
pub use lit.IntSuffix;
pub use lit.FloatSuffix;
pub use lit.IntBase;

// ============================================================================
// Type Types (from ty.blood)
// ============================================================================

pub use ty.Type;
pub use ty.TypeKind;
pub use ty.TypePath;
pub use ty.TypePathSegment;
pub use ty.TypeArgs;
pub use ty.TypeArg;
pub use ty.Lifetime;
pub use ty.EffectRow;
pub use ty.EffectRowKind;
pub use ty.RecordTypeField;
pub use ty.OwnershipQualifier;
pub use ty.TypeBound;
pub use ty.TypeParams;
pub use ty.GenericParam;
pub use ty.TypeParam;
pub use ty.LifetimeParam;
pub use ty.ConstParam;
pub use ty.WhereClause;
pub use ty.WherePredicate;

// ============================================================================
// Declaration Types (from decl.blood)
// ============================================================================

pub use decl.Declaration;
pub use decl.FnDecl;
pub use decl.FnQualifiers;
pub use decl.Param;
pub use decl.ParamQualifier;
pub use decl.TypeDecl;
pub use decl.StructDecl;
pub use decl.StructBody;
pub use decl.StructField;
pub use decl.EnumDecl;
pub use decl.EnumVariant;
pub use decl.EffectDecl;
pub use decl.OperationDecl;
pub use decl.HandlerDecl;
pub use decl.HandlerKind;
pub use decl.HandlerState;
pub use decl.ReturnClause;
pub use decl.OperationImpl;
pub use decl.TryWithHandler;
pub use decl.TraitDecl;
pub use decl.TraitItem;
pub use decl.ImplBlock;
pub use decl.ImplItem;
pub use decl.ConstDecl;
pub use decl.StaticDecl;
pub use decl.ModItemDecl;
pub use decl.MacroDecl;
pub use decl.MacroRule;
pub use decl.MacroPattern;
pub use decl.MacroPatternPart;
pub use decl.FragmentKind;
pub use decl.RepetitionKind;
pub use decl.MacroDelimiter;
pub use decl.MacroExpansion;
pub use decl.MacroExpansionPart;
pub use decl.MacroToken;
pub use decl.HygieneId;

// ============================================================================
// Expression Types (from expr.blood)
// ============================================================================

pub use expr.Expr;
pub use expr.ExprKind;
pub use expr.ExprPath;
pub use expr.ExprPathSegment;
pub use expr.CallArg;
pub use expr.FieldAccess;
pub use expr.ArrayExpr;
pub use expr.RecordExprField;
pub use expr.ElseBranch;
pub use expr.MatchArm;
pub use expr.ClosureParam;
pub use expr.BinOp;
pub use expr.UnaryOp;
pub use expr.MacroCallKind;
pub use expr.VecMacroArgs;

// ============================================================================
// Pattern Types (from pattern.blood)
// ============================================================================

pub use pattern.Pattern;
pub use pattern.PatternKind;
pub use pattern.StructPatternField;
pub use pattern.collect_bindings;

// ============================================================================
// Statement Types (from stmt.blood)
// ============================================================================

pub use stmt.Block;
pub use stmt.Statement;
pub use stmt.simple_let;
pub use stmt.typed_let;
pub use stmt.uninit_let;

// ============================================================================
// Bridge (FFI) Types (from bridge.blood)
// ============================================================================

pub use bridge.BridgeDecl;
pub use bridge.BridgeLanguage;
pub use bridge.BridgeItem;
pub use bridge.LinkSpec;
pub use bridge.LinkKind;
pub use bridge.BridgeFn;
pub use bridge.BridgeParam;
pub use bridge.BridgeOwnership;
pub use bridge.BridgeConst;
pub use bridge.BridgeOpaqueType;
pub use bridge.BridgeTypeAlias;
pub use bridge.BridgeStruct;
pub use bridge.BridgeField;
pub use bridge.BridgeEnum;
pub use bridge.BridgeEnumVariant;
pub use bridge.BridgeUnion;
pub use bridge.BridgeCallback;

// ============================================================================
// Visitor Types (from visitor.blood)
// ============================================================================

pub use visitor.Visitor;
pub use visitor.walk_program;
pub use visitor.walk_module_decl;
pub use visitor.walk_module_path;
pub use visitor.walk_import;
pub use visitor.walk_declaration;
pub use visitor.walk_fn_decl;
pub use visitor.walk_param;
pub use visitor.walk_type_decl;
pub use visitor.walk_struct_decl;
pub use visitor.walk_struct_field;
pub use visitor.walk_enum_decl;
pub use visitor.walk_enum_variant;
pub use visitor.walk_effect_decl;
pub use visitor.walk_operation_decl;
pub use visitor.walk_handler_decl;
pub use visitor.walk_operation_impl;
pub use visitor.walk_trait_decl;
pub use visitor.walk_trait_item;
pub use visitor.walk_impl_block;
pub use visitor.walk_impl_item;
pub use visitor.walk_const_decl;
pub use visitor.walk_static_decl;
pub use visitor.walk_mod_item_decl;
pub use visitor.walk_macro_decl;
pub use visitor.walk_type;
pub use visitor.walk_type_path;
pub use visitor.walk_type_params;
pub use visitor.walk_generic_param;
pub use visitor.walk_where_clause;
pub use visitor.walk_where_predicate;
pub use visitor.walk_effect_row;
pub use visitor.walk_expr;
pub use visitor.walk_expr_path;
pub use visitor.walk_call_arg;
pub use visitor.walk_match_arm;
pub use visitor.walk_closure_param;
pub use visitor.walk_pattern;
pub use visitor.walk_struct_pattern_field;
pub use visitor.walk_block;
pub use visitor.walk_statement;
pub use visitor.walk_attribute;
pub use visitor.walk_bridge_decl;
pub use visitor.walk_bridge_item;

// ============================================================================
// Module-Level Tests
// ============================================================================

#[test]
fn test_module_exports() {
    // Verify that all expected types are accessible through the module

    // Core types
    let _span = Span::dummy();
    let _id = NodeId::dummy();
    let _ident = Ident::dummy();

    // Literals
    let _lit = Literal::int(42, Span::dummy());
    let _kind = LiteralKind::Bool(true);

    // Types
    let _ty = Type::unit(Span::dummy());
    let _never = Type::never(Span::dummy());

    // Patterns
    let _pat = Pattern::wildcard(Span::dummy());

    // Blocks
    let _block = Block::empty(Span::dummy());
}

#[test]
fn test_visitor_integration() {
    // Test that the visitor can traverse a simple program structure

    struct Counter {
        nodes: USize,
    }

    impl Visitor for Counter {
        fn visit_ident(mut self, ident: &Ident) {
            self.nodes += 1
        }
    }

    let program = Program {
        id: NodeId::dummy(),
        module: Option::Some(ModuleDecl {
            path: ModulePath {
                segments: vec![Ident::new_for_test("test")],
                span: Span::dummy(),
            },
            span: Span::dummy(),
        }),
        imports: Vec::new(),
        declarations: Vec::new(),
        span: Span::dummy(),
    };

    let mut counter = Counter { nodes: 0 };
    counter.visit_program(&program);

    // Should have visited the module path segment "test"
    assert(counter.nodes >= 1);
}

#[test]
fn test_declaration_variants() {
    // Test that all declaration variants are accessible

    // Function
    let fn_decl = FnDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Private,
        qualifiers: FnQualifiers::none(),
        name: Ident::dummy(),
        type_params: Option::None,
        params: Vec::new(),
        return_type: Option::None,
        effects: Option::None,
        where_clause: Option::None,
        body: Option::None,
        span: Span::dummy(),
    };
    let _decl = Declaration::Function(fn_decl);

    // Struct
    let struct_decl = StructDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Public,
        name: Ident::dummy(),
        type_params: Option::None,
        body: StructBody::Unit,
        span: Span::dummy(),
    };
    let _decl = Declaration::Struct(struct_decl);

    // Enum
    let enum_decl = EnumDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Public,
        name: Ident::dummy(),
        type_params: Option::None,
        variants: Vec::new(),
        span: Span::dummy(),
    };
    let _decl = Declaration::Enum(enum_decl);
}

#[test]
fn test_expression_variants() {
    // Test common expression kinds

    // Literal
    let lit = Expr::new(ExprKind::Literal(Literal::int(42, Span::dummy())), Span::dummy());
    assert(lit.is_literal());

    // Binary
    let left = Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy());
    let right = Expr::new(ExprKind::Literal(Literal::int(2, Span::dummy())), Span::dummy());
    let binary = Expr::new(
        ExprKind::Binary {
            op: BinOp::Add,
            left: Box::new(left),
            right: Box::new(right),
        },
        Span::dummy(),
    )
    assert(!binary.is_literal());
    assert(binary.requires_semi());

    // Block
    let block_expr = Expr::new(ExprKind::Block(Block::empty(Span::dummy())), Span::dummy());
    assert(block_expr.is_block());
    assert(!block_expr.requires_semi());
}

#[test]
fn test_pattern_bindings() {
    // Test pattern binding collection

    let a = Pattern::ident(Ident::new_for_test("a"), Span::dummy());
    let b = Pattern::ident(Ident::new_for_test("b"), Span::dummy());
    let tuple = Pattern::new(
        PatternKind::Tuple {
            fields: vec![a, b, Pattern::wildcard(Span::dummy())],
            rest_pos: Option::None,
        },
        Span::dummy(),
    )

    let bindings = collect_bindings(&tuple);
    assert(bindings.len() == 2);
}

#[test]
fn test_bridge_types() {
    // Test bridge types are accessible

    let decl = BridgeDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        language: BridgeLanguage::C,
        name: Ident::new_for_test("libc"),
        items: Vec::new(),
        span: Span::dummy(),
    };

    assert(decl.is_c());
    assert(!decl.is_cpp());
    assert(!decl.is_wasm());
}
