//! # AST Literal Types
//!
//! Literal value representations in the Blood AST.
//!
//! ## Overview
//!
//! Literals are constant values that appear directly in source code:
//! - Integer: `42`, `-100`, `0xFF`, `0b1010`
//! - Float: `3.14`, `-0.5`, `1e10`
//! - String: `"hello"`, `"line1\nline2"`
//! - Character: `'a'`, `'\n'`, `'\u{1F600}'`
//! - Boolean: `true`, `false`
//! - Byte: `b'x'`
//! - Byte string: `b"bytes"`
//! - Raw string: `r#"raw"#`
//!
//! ## Numeric Suffixes
//!
//! Numeric literals can have type suffixes:
//! - `42i32`, `100u64` - Sized integers
//! - `3.14f32`, `2.718f64` - Sized floats
//!
//! ## Escape Sequences
//!
//! String and character literals support escapes:
//! - `\n` - Newline
//! - `\r` - Carriage return
//! - `\t` - Tab
//! - `\\` - Backslash
//! - `\"` - Double quote
//! - `\'` - Single quote
//! - `\0` - Null
//! - `\xNN` - Byte escape
//! - `\u{NNNN}` - Unicode escape

module std.compiler.ast.lit;

use std.option.Option;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.node.Symbol;

// ============================================================================
// Literal
// ============================================================================

/// A literal value in the AST.
///
/// Literals represent constant values written directly in source code.
///
/// ## Example
///
/// ```blood
/// let x = 42           // IntLiteral
/// let y = 3.14         // FloatLiteral
/// let s = "hello"      // StringLiteral
/// let c = 'a'          // CharLiteral
/// let b = true         // BoolLiteral
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct Literal {
    /// Unique node ID.
    pub id: NodeId,
    /// The literal kind and value.
    pub kind: LiteralKind,
    /// Span of the literal.
    pub span: Span,
}

impl Literal {
    /// Create a new literal.
    pub fn new(kind: LiteralKind, span: Span) -> Literal {
        Literal {
            id: NodeId::dummy(),
            kind,
            span,
        }
    }

    /// Create an integer literal.
    pub fn int(value: I64, suffix: Option<IntSuffix>, span: Span) -> Literal {
        Literal::new(LiteralKind::Int { value, suffix }, span)
    }

    /// Create a float literal.
    pub fn float(value: F64, suffix: Option<FloatSuffix>, span: Span) -> Literal {
        Literal::new(LiteralKind::Float { value, suffix }, span)
    }

    /// Create a string literal.
    pub fn string(value: String, span: Span) -> Literal {
        Literal::new(LiteralKind::String { value, is_raw: false }, span)
    }

    /// Create a raw string literal.
    pub fn raw_string(value: String, span: Span) -> Literal {
        Literal::new(LiteralKind::String { value, is_raw: true }, span)
    }

    /// Create a character literal.
    pub fn char(value: Char, span: Span) -> Literal {
        Literal::new(LiteralKind::Char(value), span)
    }

    /// Create a boolean literal.
    pub fn bool(value: Bool, span: Span) -> Literal {
        Literal::new(LiteralKind::Bool(value), span)
    }

    /// Create a byte literal.
    pub fn byte(value: U8, span: Span) -> Literal {
        Literal::new(LiteralKind::Byte(value), span)
    }

    /// Create a byte string literal.
    pub fn byte_string(value: Vec<U8>, span: Span) -> Literal {
        Literal::new(LiteralKind::ByteString(value), span)
    }

    /// Check if this is an integer literal.
    pub fn is_int(self) -> Bool {
        match self.kind {
            LiteralKind::Int { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a float literal.
    pub fn is_float(self) -> Bool {
        match self.kind {
            LiteralKind::Float { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a string literal.
    pub fn is_string(self) -> Bool {
        match self.kind {
            LiteralKind::String { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a boolean literal.
    pub fn is_bool(self) -> Bool {
        match self.kind {
            LiteralKind::Bool(_) => true,
            _ => false,
        }
    }

    /// Check if this is a numeric literal (int or float).
    pub fn is_numeric(self) -> Bool {
        self.is_int() || self.is_float();
    }

    /// Try to get as an integer value.
    pub fn as_int(self) -> Option<I64> {
        match self.kind {
            LiteralKind::Int { value, .. } => Option::Some(value),
            _ => Option::None,
        }
    }

    /// Try to get as a float value.
    pub fn as_float(self) -> Option<F64> {
        match self.kind {
            LiteralKind::Float { value, .. } => Option::Some(value),
            _ => Option::None,
        }
    }

    /// Try to get as a string value.
    pub fn as_string(self) -> Option[&String] {
        match self.kind {
            LiteralKind::String { value, .. } => Option::Some(&value),
            _ => Option::None,
        }
    }

    /// Try to get as a boolean value.
    pub fn as_bool(self) -> Option<Bool> {
        match self.kind {
            LiteralKind::Bool(value) => Option::Some(value),
            _ => Option::None,
        }
    }
}

// ============================================================================
// Literal Kind
// ============================================================================

/// The kind of literal value.
///
/// Each variant carries the parsed value and optional type suffix.
#[derive(Clone, PartialEq)]
pub enum LiteralKind {
    /// Integer literal: `42`, `-100`, `0xFF`, `42i32`
    Int {
        /// The integer value.
        value: I64,
        /// Optional type suffix.
        suffix: Option<IntSuffix>,
    },

    /// Float literal: `3.14`, `1e10`, `2.5f32`
    Float {
        /// The float value.
        value: F64,
        /// Optional type suffix.
        suffix: Option<FloatSuffix>,
    },

    /// String literal: `"hello"`, `r#"raw"#`
    String {
        /// The string value (with escapes processed).
        value: String,
        /// Whether this is a raw string.
        is_raw: Bool,
    },

    /// Character literal: `'a'`, `'\n'`
    Char(Char),

    /// Boolean literal: `true`, `false`
    Bool(Bool),

    /// Byte literal: `b'x'`
    Byte(U8),

    /// Byte string literal: `b"bytes"`
    ByteString(Vec<U8>),
}

impl Eq for LiteralKind {
    // Float comparison uses bit equality for AST purposes
}

// ============================================================================
// Numeric Suffixes
// ============================================================================

/// Integer type suffix.
///
/// | Suffix | Type |
/// |--------|------|
/// | `i8` | Signed 8-bit |
/// | `i16` | Signed 16-bit |
/// | `i32` | Signed 32-bit |
/// | `i64` | Signed 64-bit |
/// | `i128` | Signed 128-bit |
/// | `isize` | Pointer-sized signed |
/// | `u8` | Unsigned 8-bit |
/// | `u16` | Unsigned 16-bit |
/// | `u32` | Unsigned 32-bit |
/// | `u64` | Unsigned 64-bit |
/// | `u128` | Unsigned 128-bit |
/// | `usize` | Pointer-sized unsigned |
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum IntSuffix {
    I8,
    I16,
    I32,
    I64,
    I128,
    ISize,
    U8,
    U16,
    U32,
    U64,
    U128,
    USize,
}

impl IntSuffix {
    /// Check if this is a signed suffix.
    pub fn is_signed(self) -> Bool {
        match self {
            IntSuffix::I8 | IntSuffix::I16 | IntSuffix::I32 |
            IntSuffix::I64 | IntSuffix::I128 | IntSuffix::ISize => true,
            _ => false,
        }
    }

    /// Check if this is an unsigned suffix.
    pub fn is_unsigned(self) -> Bool {
        !self.is_signed()
    }

    /// Get the suffix as a string.
    pub fn as_str(self) -> &str {
        match self {
            IntSuffix::I8 => "i8",
            IntSuffix::I16 => "i16",
            IntSuffix::I32 => "i32",
            IntSuffix::I64 => "i64",
            IntSuffix::I128 => "i128",
            IntSuffix::ISize => "isize",
            IntSuffix::U8 => "u8",
            IntSuffix::U16 => "u16",
            IntSuffix::U32 => "u32",
            IntSuffix::U64 => "u64",
            IntSuffix::U128 => "u128",
            IntSuffix::USize => "usize",
        }
    }

    /// Parse a suffix from a string.
    pub fn from_str(s: &str) -> Option<IntSuffix> {
        match s {
            "i8" => Option::Some(IntSuffix::I8),
            "i16" => Option::Some(IntSuffix::I16),
            "i32" => Option::Some(IntSuffix::I32),
            "i64" => Option::Some(IntSuffix::I64),
            "i128" => Option::Some(IntSuffix::I128),
            "isize" => Option::Some(IntSuffix::ISize),
            "u8" => Option::Some(IntSuffix::U8),
            "u16" => Option::Some(IntSuffix::U16),
            "u32" => Option::Some(IntSuffix::U32),
            "u64" => Option::Some(IntSuffix::U64),
            "u128" => Option::Some(IntSuffix::U128),
            "usize" => Option::Some(IntSuffix::USize),
            _ => Option::None,
        }
    }
}

/// Float type suffix.
///
/// | Suffix | Type |
/// |--------|------|
/// | `f32` | 32-bit float |
/// | `f64` | 64-bit float |
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum FloatSuffix {
    F32,
    F64,
}

impl FloatSuffix {
    /// Get the suffix as a string.
    pub fn as_str(self) -> &str {
        match self {
            FloatSuffix::F32 => "f32",
            FloatSuffix::F64 => "f64",
        }
    }

    /// Parse a suffix from a string.
    pub fn from_str(s: &str) -> Option<FloatSuffix> {
        match s {
            "f32" => Option::Some(FloatSuffix::F32),
            "f64" => Option::Some(FloatSuffix::F64),
            _ => Option::None,
        }
    }
}

// ============================================================================
// Integer Base
// ============================================================================

/// The base/radix of an integer literal.
///
/// Used for preserving the original format for pretty-printing.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum IntBase {
    /// Decimal: `42`
    Decimal,
    /// Binary: `0b1010`
    Binary,
    /// Octal: `0o52`
    Octal,
    /// Hexadecimal: `0x2A`
    Hexadecimal,
}

impl IntBase {
    /// Get the radix value.
    pub fn radix(self) -> U32 {
        match self {
            IntBase::Decimal => 10,
            IntBase::Binary => 2,
            IntBase::Octal => 8,
            IntBase::Hexadecimal => 16,
        }
    }

    /// Get the prefix string.
    pub fn prefix(self) -> &str {
        match self {
            IntBase::Decimal => "",
            IntBase::Binary => "0b",
            IntBase::Octal => "0o",
            IntBase::Hexadecimal => "0x",
        }
    }
}

impl Default for IntBase {
    fn default() -> IntBase {
        IntBase::Decimal
    }
}

// ============================================================================
// String Literal Utilities
// ============================================================================

/// Escape sequence information.
pub struct EscapeInfo {
    /// The escape character.
    pub escape_char: Char,
    /// The resulting character.
    pub result_char: Char,
}

/// Process escape sequences in a string.
///
/// Converts escape sequences like `\n` to their actual characters.
pub fn process_escapes(s: &str) -> Result<String, String> {
    let mut result = String::new();
    let mut chars = s.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('r') => result.push('\r'),
                Some('t') => result.push('\t'),
                Some('\\') => result.push('\\'),
                Some('"') => result.push('"'),
                Some('\'') => result.push('\''),
                Some('0') => result.push('\0'),
                Some('x') => {
                    // Byte escape: \xNN
                    let hex = collect_hex_digits(&mut chars, 2)?
                    let byte = u8::from_str_radix(&hex, 16)
                        .map_err(|_| format!("invalid hex escape: \\x{}", hex))?
                    result.push(byte as Char);
                };
                Some('u') => {
                    // Unicode escape: \u{NNNN}
                    if chars.next() != Some('{') {
                        return Err("expected '{' after \\u".to_string());
                    };
                    let hex = collect_until(&mut chars, '}')?
                    let codepoint = u32::from_str_radix(&hex, 16)
                        .map_err(|_| format!("invalid unicode escape: \\u{{{}}}", hex))?
                    let ch = char::from_u32(codepoint)
                        .ok_or_else(|| format!("invalid unicode codepoint: {}", codepoint))?
                    result.push(ch);
                };
                Some(c) => {
                    return Err(format!("unknown escape sequence: \\{}", c));
                };
                None => {
                    return Err("unexpected end of string after backslash".to_string());
                }
            }
        } else {
            result.push(c);
        }
    };

    Ok(result)
}

/// Collect a specific number of hex digits.
fn collect_hex_digits(chars: &mut impl Iterator[Item = Char], count: USize) -> Result<String, String> {
    let mut result = String::new();
    for _ in 0..count {
        match chars.next() {
            Some(c) if c.is_ascii_hexdigit() => result.push(c),
            Some(c) => return Err(format!("expected hex digit, found '{}'", c)),
            None => return Err("unexpected end of string in escape".to_string()),
        }
    };
    Ok(result)
}

/// Collect characters until a delimiter.
fn collect_until(chars: &mut impl Iterator[Item = Char], delim: Char) -> Result<String, String> {
    let mut result = String::new();
    loop {
        match chars.next() {
            Some(c) if c == delim => return Ok(result),
            Some(c) => result.push(c),
            None => return Err(format!("expected '{}' but found end of string", delim)),
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_literal_int() {
    let lit = Literal::int(42, Option::None, Span::dummy());

    assert(lit.is_int());
    assert(!lit.is_float());
    assert(lit.is_numeric());
    assert(lit.as_int() == Option::Some(42));
}

#[test]
fn test_literal_int_with_suffix() {
    let lit = Literal::int(100, Option::Some(IntSuffix::I32), Span::dummy());

    assert(lit.is_int());
    match lit.kind {
        LiteralKind::Int { value, suffix } => {
            assert(value == 100);
            assert(suffix == Option::Some(IntSuffix::I32));
        }
        _ => panic("expected int literal"),
    }
}

#[test]
fn test_literal_float() {
    let lit = Literal::float(3.14, Option::None, Span::dummy());

    assert(lit.is_float());
    assert(!lit.is_int());
    assert(lit.is_numeric());
}

#[test]
fn test_literal_string() {
    let lit = Literal::string("hello", Span::dummy());

    assert(lit.is_string());
    assert(lit.as_string() == Option::Some(&"hello".to_string()));
}

#[test]
fn test_literal_bool() {
    let true_lit = Literal::bool(true, Span::dummy());
    let false_lit = Literal::bool(false, Span::dummy());

    assert(true_lit.is_bool());
    assert(true_lit.as_bool() == Option::Some(true));
    assert(false_lit.as_bool() == Option::Some(false));
}

#[test]
fn test_literal_char() {
    let lit = Literal::char('a', Span::dummy());

    match lit.kind {
        LiteralKind::Char(c) => assert(c == 'a'),
        _ => panic("expected char literal"),
    }
}

#[test]
fn test_int_suffix_signed() {
    assert(IntSuffix::I32.is_signed());
    assert(IntSuffix::I64.is_signed());
    assert(!IntSuffix::U32.is_signed());
    assert(!IntSuffix::U64.is_signed());
}

#[test]
fn test_int_suffix_as_str() {
    assert(IntSuffix::I32.as_str() == "i32");
    assert(IntSuffix::U64.as_str() == "u64");
    assert(IntSuffix::USize.as_str() == "usize");
}

#[test]
fn test_int_suffix_from_str() {
    assert(IntSuffix::from_str("i32") == Option::Some(IntSuffix::I32));
    assert(IntSuffix::from_str("u64") == Option::Some(IntSuffix::U64));
    assert(IntSuffix::from_str("invalid").is_none());
}

#[test]
fn test_float_suffix() {
    assert(FloatSuffix::F32.as_str() == "f32");
    assert(FloatSuffix::F64.as_str() == "f64");
    assert(FloatSuffix::from_str("f32") == Option::Some(FloatSuffix::F32));
}

#[test]
fn test_int_base_radix() {
    assert(IntBase::Decimal.radix() == 10);
    assert(IntBase::Binary.radix() == 2);
    assert(IntBase::Octal.radix() == 8);
    assert(IntBase::Hexadecimal.radix() == 16);
}

#[test]
fn test_int_base_prefix() {
    assert(IntBase::Decimal.prefix() == "");
    assert(IntBase::Binary.prefix() == "0b");
    assert(IntBase::Octal.prefix() == "0o");
    assert(IntBase::Hexadecimal.prefix() == "0x");
}
