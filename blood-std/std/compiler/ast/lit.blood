//! # AST Literal Types
//!
//! Literal value representations in the Blood AST.
//!
//! ## Overview
//!
//! Literals are constant values that appear directly in source code:
//! - Integer: `42`, `-100`, `0xFF`, `0b1010`
//! - Float: `3.14`, `-0.5`, `1e10`
//! - String: `"hello"`, `"line1\nline2"`
//! - Character: `'a'`, `'\n'`, `'\u{1F600}'`
//! - Boolean: `true`, `false`
//! - Byte: `b'x'`
//! - Byte string: `b"bytes"`
//! - Raw string: `r#"raw"#`
//!
//! ## Numeric Suffixes
//!
//! Numeric literals can have type suffixes:
//! - `42i32`, `100u64` - Sized integers
//! - `3.14f32`, `2.718f64` - Sized floats
//!
//! ## Escape Sequences
//!
//! String and character literals support escapes:
//! - `\n` - Newline
//! - `\r` - Carriage return
//! - `\t` - Tab
//! - `\\` - Backslash
//! - `\"` - Double quote
//! - `\'` - Single quote
//! - `\0` - Null
//! - `\xNN` - Byte escape
//! - `\u{NNNN}` - Unicode escape

module std.compiler.ast.lit;

use std.core.Option;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.node.Symbol;

// ============================================================================
// Literal
// ============================================================================

/// A literal value in the AST.
///
/// Literals represent constant values written directly in source code.
///
/// ## Example
///
/// ```blood
/// let x = 42           // IntLiteral
/// let y = 3.14         // FloatLiteral
/// let s = "hello"      // StringLiteral
/// let c = 'a'          // CharLiteral
/// let b = true         // BoolLiteral
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct Literal {
    /// Unique node ID.
    pub id: NodeId,
    /// The literal kind and value.
    pub kind: LiteralKind,
    /// Span of the literal.
    pub span: Span,
}

impl Literal {
    /// Create a new literal.
    pub fn new(kind: LiteralKind, span: Span) -> Literal {
        Literal {
            id: NodeId::dummy(),
            kind,
            span,
        }
    }

    /// Create an integer literal.
    pub fn int(value: i64, suffix: Option<IntSuffix>, span: Span) -> Literal {
        Literal::new(LiteralKind::Int { value, suffix }, span)
    }

    /// Create a float literal.
    pub fn float(value: f64, suffix: Option<FloatSuffix>, span: Span) -> Literal {
        Literal::new(LiteralKind::Float { value, suffix }, span)
    }

    /// Create a string literal.
    pub fn string(value: String, span: Span) -> Literal {
        Literal::new(LiteralKind::String { value, is_raw: false }, span)
    }

    /// Create a raw string literal.
    pub fn raw_string(value: String, span: Span) -> Literal {
        Literal::new(LiteralKind::String { value, is_raw: true }, span)
    }

    /// Create a character literal.
    pub fn char(value: char, span: Span) -> Literal {
        Literal::new(LiteralKind::char(value), span)
    }

    /// Create a boolean literal.
    pub fn bool(value: bool, span: Span) -> Literal {
        Literal::new(LiteralKind::bool(value), span)
    }

    /// Create a byte literal.
    pub fn byte(value: u8, span: Span) -> Literal {
        Literal::new(LiteralKind::Byte(value), span)
    }

    /// Create a byte string literal.
    pub fn byte_string(value: Vec<u8>, span: Span) -> Literal {
        Literal::new(LiteralKind::ByteString(value), span)
    }

    /// Check if this is an integer literal.
    pub fn is_int(self) -> bool {
        match self.kind {
            LiteralKind::Int { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a float literal.
    pub fn is_float(self) -> bool {
        match self.kind {
            LiteralKind::Float { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a string literal.
    pub fn is_string(self) -> bool {
        match self.kind {
            LiteralKind::String { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a boolean literal.
    pub fn is_bool(self) -> bool {
        match self.kind {
            LiteralKind::bool(_) => true,
            _ => false,
        }
    }

    /// Check if this is a numeric literal (int or float).
    pub fn is_numeric(self) -> bool {
        self.is_int() || self.is_float();
    }

    /// Try to get as an integer value.
    pub fn as_int(self) -> Option<i64> {
        match self.kind {
            LiteralKind::Int { value, .. } => Option::Some(value),
            _ => Option::None,
        }
    }

    /// Try to get as a float value.
    pub fn as_float(self) -> Option<f64> {
        match self.kind {
            LiteralKind::Float { value, .. } => Option::Some(value),
            _ => Option::None,
        }
    }

    /// Try to get as a string value.
    pub fn as_string(self) -> Option[&String] {
        match self.kind {
            LiteralKind::String { value, .. } => Option::Some(&value),
            _ => Option::None,
        }
    }

    /// Try to get as a boolean value.
    pub fn as_bool(self) -> Option<bool> {
        match self.kind {
            LiteralKind::bool(value) => Option::Some(value),
            _ => Option::None,
        }
    }
}

// ============================================================================
// Literal Kind
// ============================================================================

/// The kind of literal value.
///
/// Each variant carries the parsed value and optional type suffix.
#[derive(Clone, PartialEq)]
pub enum LiteralKind {
    /// Integer literal: `42`, `-100`, `0xFF`, `42i32`
    Int {
        /// The integer value.
        value: i64,
        /// Optional type suffix.
        suffix: Option<IntSuffix>,
    },

    /// Float literal: `3.14`, `1e10`, `2.5f32`
    Float {
        /// The float value.
        value: f64,
        /// Optional type suffix.
        suffix: Option<FloatSuffix>,
    },

    /// String literal: `"hello"`, `r#"raw"#`
    String {
        /// The string value (with escapes processed).
        value: String,
        /// Whether this is a raw string.
        is_raw: bool,
    },

    /// Character literal: `'a'`, `'\n'`
    char(char),

    /// Boolean literal: `true`, `false`
    bool(bool),

    /// Byte literal: `b'x'`
    Byte(u8),

    /// Byte string literal: `b"bytes"`
    ByteString(Vec<u8>),
}

impl Eq for LiteralKind {
    // Float comparison uses bit equality for AST purposes
}

// ============================================================================
// Numeric Suffixes
// ============================================================================

/// Integer type suffix.
///
/// | Suffix | Type |
/// |--------|------|
/// | `i8` | Signed 8-bit |
/// | `i16` | Signed 16-bit |
/// | `i32` | Signed 32-bit |
/// | `i64` | Signed 64-bit |
/// | `i128` | Signed 128-bit |
/// | `isize` | Pointer-sized signed |
/// | `u8` | Unsigned 8-bit |
/// | `u16` | Unsigned 16-bit |
/// | `u32` | Unsigned 32-bit |
/// | `u64` | Unsigned 64-bit |
/// | `u128` | Unsigned 128-bit |
/// | `usize` | Pointer-sized unsigned |
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum IntSuffix {
    i8,
    i16,
    i32,
    i64,
    i128,
    isize,
    u8,
    u16,
    u32,
    u64,
    u128,
    usize,
}

impl IntSuffix {
    /// Check if this is a signed suffix.
    pub fn is_signed(self) -> bool {
        match self {
            IntSuffix::i8 | IntSuffix::i16 | IntSuffix::i32 |
            IntSuffix::i64 | IntSuffix::i128 | IntSuffix::isize => true,
            _ => false,
        }
    }

    /// Check if this is an unsigned suffix.
    pub fn is_unsigned(self) -> bool {
        !self.is_signed()
    }

    /// Get the suffix as a string.
    pub fn as_str(self) -> &str {
        match self {
            IntSuffix::i8 => "i8",
            IntSuffix::i16 => "i16",
            IntSuffix::i32 => "i32",
            IntSuffix::i64 => "i64",
            IntSuffix::i128 => "i128",
            IntSuffix::isize => "isize",
            IntSuffix::u8 => "u8",
            IntSuffix::u16 => "u16",
            IntSuffix::u32 => "u32",
            IntSuffix::u64 => "u64",
            IntSuffix::u128 => "u128",
            IntSuffix::usize => "usize",
        }
    }

    /// Parse a suffix from a string.
    pub fn from_str(s: &str) -> Option<IntSuffix> {
        match s {
            "i8" => Option::Some(IntSuffix::i8),
            "i16" => Option::Some(IntSuffix::i16),
            "i32" => Option::Some(IntSuffix::i32),
            "i64" => Option::Some(IntSuffix::i64),
            "i128" => Option::Some(IntSuffix::i128),
            "isize" => Option::Some(IntSuffix::isize),
            "u8" => Option::Some(IntSuffix::u8),
            "u16" => Option::Some(IntSuffix::u16),
            "u32" => Option::Some(IntSuffix::u32),
            "u64" => Option::Some(IntSuffix::u64),
            "u128" => Option::Some(IntSuffix::u128),
            "usize" => Option::Some(IntSuffix::usize),
            _ => Option::None,
        }
    }
}

/// Float type suffix.
///
/// | Suffix | Type |
/// |--------|------|
/// | `f32` | 32-bit float |
/// | `f64` | 64-bit float |
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum FloatSuffix {
    f32,
    f64,
}

impl FloatSuffix {
    /// Get the suffix as a string.
    pub fn as_str(self) -> &str {
        match self {
            FloatSuffix::f32 => "f32",
            FloatSuffix::f64 => "f64",
        }
    }

    /// Parse a suffix from a string.
    pub fn from_str(s: &str) -> Option<FloatSuffix> {
        match s {
            "f32" => Option::Some(FloatSuffix::f32),
            "f64" => Option::Some(FloatSuffix::f64),
            _ => Option::None,
        }
    }
}

// ============================================================================
// Integer Base
// ============================================================================

/// The base/radix of an integer literal.
///
/// Used for preserving the original format for pretty-printing.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum IntBase {
    /// Decimal: `42`
    Decimal,
    /// Binary: `0b1010`
    Binary,
    /// Octal: `0o52`
    Octal,
    /// Hexadecimal: `0x2A`
    Hexadecimal,
}

impl IntBase {
    /// Get the radix value.
    pub fn radix(self) -> u32 {
        match self {
            IntBase::Decimal => 10,
            IntBase::Binary => 2,
            IntBase::Octal => 8,
            IntBase::Hexadecimal => 16,
        }
    }

    /// Get the prefix string.
    pub fn prefix(self) -> &str {
        match self {
            IntBase::Decimal => "",
            IntBase::Binary => "0b",
            IntBase::Octal => "0o",
            IntBase::Hexadecimal => "0x",
        }
    }
}

impl Default for IntBase {
    fn default() -> IntBase {
        IntBase::Decimal
    }
}

// ============================================================================
// String Literal Utilities
// ============================================================================

/// Escape sequence information.
pub struct EscapeInfo {
    /// The escape character.
    pub escape_char: char,
    /// The resulting character.
    pub result_char: char,
}

/// Process escape sequences in a string.
// TODO: Re-enable once iterator methods (chars, next, peekable) are supported
// ///
// /// Converts escape sequences like `\n` to their actual characters.
// pub fn process_escapes(s: &str) -> Result<String, String> {
//     let mut result = String::new();
//     let mut chars = s.chars().peekable();
//
//     while let Some(c) = chars.next() {
//         if c == '\\' {
//             match chars.next() {
//                 Some('n') => result.push('\n'),
//                 Some('r') => result.push('\r'),
//                 Some('t') => result.push('\t'),
//                 Some('\\') => result.push('\\'),
//                 Some('"') => result.push('"'),
//                 Some('\'') => result.push('\''),
//                 Some('0') => result.push('\0'),
//                 Some('x') => {
//                     // Byte escape: \xNN
//                     let hex = collect_hex_digits(&mut chars, 2)?;
//                     let byte = u8::from_str_radix(&hex, 16)
//                         .map_err(|_| format!("invalid hex escape: \\x{}", hex))?;
//                     result.push(byte as char);
//                 }
//                 Some('u') => {
//                     // Unicode escape: \u{NNNN}
//                     if chars.next() != Some('{') {
//                         return Err("expected '{' after \\u".to_string());
//                     }
//                     let hex = collect_until(&mut chars, '}')?;
//                     let codepoint = u32::from_str_radix(&hex, 16)
//                         .map_err(|_| format!("invalid unicode escape: \\u{{{}}}", hex))?;
//                     let ch = char::from_u32(codepoint)
//                         .ok_or_else(|| format!("invalid unicode codepoint: {}", codepoint))?;
//                     result.push(ch);
//                 }
//                 Some(c) => {
//                     return Err(format!("unknown escape sequence: \\{}", c));
//                 }
//                 None => {
//                     return Err("unexpected end of string after backslash".to_string());
//                 }
//             }
//         } else {
//             result.push(c);
//         }
//     };
//
//     Ok(result)
// }
//
// /// Collect a specific number of hex digits.
// fn collect_hex_digits(chars: &mut impl Iterator[Item = char], count: usize) -> Result<String, String> {
//     let mut result = String::new();
//     for _ in 0..count {
//         match chars.next() {
//             Some(c) if c.is_ascii_hexdigit() => result.push(c),
//             Some(c) => return Err(format!("expected hex digit, found '{}'", c)),
//             None => return Err("unexpected end of string in escape".to_string()),
//         }
//     };
//     Ok(result)
// }
//
// /// Collect characters until a delimiter.
// fn collect_until(chars: &mut impl Iterator[Item = char], delim: char) -> Result<String, String> {
//     let mut result = String::new();
//     loop {
//         match chars.next() {
//             Some(c) if c == delim => return Ok(result),
//             Some(c) => result.push(c),
//             None => return Err(format!("expected '{}' but found end of string", delim)),
//         }
//     }
// }

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_literal_int() {
    let lit = Literal::int(42i64, Option::None, Span::dummy());

    assert(lit.is_int());
    assert(!lit.is_float());
    assert(lit.is_numeric());
    assert(lit.as_int() == Option::Some(42i64));
}

#[test]
fn test_literal_int_with_suffix() {
    let lit = Literal::int(100i64, Option::Some(IntSuffix::i32), Span::dummy());

    assert(lit.is_int());
    match lit.kind {
        LiteralKind::Int { value, suffix } => {
            assert(value == 100i64);
            assert(suffix == Option::Some(IntSuffix::i32));
        }
        _ => panic("expected int literal"),
    }
}

#[test]
fn test_literal_float() {
    let lit = Literal::float(3.14, Option::None, Span::dummy());

    assert(lit.is_float());
    assert(!lit.is_int());
    assert(lit.is_numeric());
}

// TODO: Re-enable once String::from is available
// #[test]
// fn test_literal_string() {
//     let lit = Literal::string(String::from("hello"), Span::dummy());
//
//     assert(lit.is_string());
//     assert(lit.as_string() == Option::Some(&String::from("hello")));
// }

#[test]
fn test_literal_bool() {
    let true_lit = Literal::bool(true, Span::dummy());
    let false_lit = Literal::bool(false, Span::dummy());

    assert(true_lit.is_bool());
    assert(true_lit.as_bool() == Option::Some(true));
    assert(false_lit.as_bool() == Option::Some(false));
}

#[test]
fn test_literal_char() {
    let lit = Literal::char('a', Span::dummy());

    match lit.kind {
        LiteralKind::char(c) => assert(c == 'a'),
        _ => panic("expected char literal"),
    }
}

#[test]
fn test_int_suffix_signed() {
    assert(IntSuffix::i32.is_signed());
    assert(IntSuffix::i64.is_signed());
    assert(!IntSuffix::u32.is_signed());
    assert(!IntSuffix::u64.is_signed());
}

#[test]
fn test_int_suffix_as_str() {
    assert(IntSuffix::i32.as_str() == "i32");
    assert(IntSuffix::u64.as_str() == "u64");
    assert(IntSuffix::usize.as_str() == "usize");
}

#[test]
fn test_int_suffix_from_str() {
    assert(IntSuffix::from_str("i32") == Option::Some(IntSuffix::i32));
    assert(IntSuffix::from_str("u64") == Option::Some(IntSuffix::u64));
    assert(IntSuffix::from_str("invalid").is_none());
}

#[test]
fn test_float_suffix() {
    assert(FloatSuffix::f32.as_str() == "f32");
    assert(FloatSuffix::f64.as_str() == "f64");
    assert(FloatSuffix::from_str("f32") == Option::Some(FloatSuffix::f32));
}

#[test]
fn test_int_base_radix() {
    assert(IntBase::Decimal.radix() == 10);
    assert(IntBase::Binary.radix() == 2);
    assert(IntBase::Octal.radix() == 8);
    assert(IntBase::Hexadecimal.radix() == 16);
}

#[test]
fn test_int_base_prefix() {
    assert(IntBase::Decimal.prefix() == "");
    assert(IntBase::Binary.prefix() == "0b");
    assert(IntBase::Octal.prefix() == "0o");
    assert(IntBase::Hexadecimal.prefix() == "0x");
}
