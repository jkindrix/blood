//! # AST Expression Types
//!
//! Expression definitions for the Blood AST.
//!
//! ## Overview
//!
//! Expressions are the computational core of Blood programs. They evaluate
//! to values and can appear in many contexts:
//! - Function bodies
//! - Variable initializers
//! - Match arm bodies
//! - Array/record literals
//!
//! ## Expression Categories
//!
//! | Category | Examples |
//! |----------|----------|
//! | Literals | `42`, `"hello"`, `true` |
//! | Paths | `x`, `std.vec.Vec` |
//! | Operations | `a + b`, `!x`, `*ptr` |
//! | Control flow | `if`, `match`, `loop`, `for` |
//! | Functions | `f(x)`, `obj.method()`, `\|x\| x + 1` |
//! | Data | `(a, b)`, `[1, 2, 3]`, `Point { x, y }` |
//! | Effects | `perform`, `resume`, `with handler` |
//!
//! ## Expression Forms
//!
//! ```blood
//! // Literals
//! 42
//! "hello"
//! true
//!
//! // Operations
//! a + b * c
//! !flag
//! &mut value
//!
//! // Control flow
//! if cond { a } else { b }
//! match x { Some(v) => v, None => 0 }
//! for item in iter { process(item) }
//!
//! // Function calls
//! foo(1, 2, 3)
//! obj.method(arg)
//! vec.iter().map(|x| x * 2).collect()
//!
//! // Data construction
//! (1, "two", 3.0)
//! [1, 2, 3]
//! Point { x: 10, y: 20 }
//!
//! // Effect operations
//! perform IO.read()
//! with handler handle { body }
//! ```

module std.compiler.ast.expr;

use std.option.Option;
use std.collections.Vec;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.Ident;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.lit.Literal;
use std.compiler.ast.ty.Type;
use std.compiler.ast.ty.TypePath;
use std.compiler.ast.ty.TypeArgs;
use std.compiler.ast.ty.EffectRow;
use std.compiler.ast.pattern.Pattern;
use std.compiler.ast.stmt.Block;
use std.compiler.ast.decl.TryWithHandler;

// ============================================================================
// Expression
// ============================================================================

/// An expression in the Blood AST.
///
/// Expressions evaluate to values and form the computational core of programs.
#[derive(Clone, PartialEq, Eq)]
pub struct Expr {
    /// Unique node ID.
    pub id: NodeId,
    /// The expression kind.
    pub kind: ExprKind,
    /// Span of the expression.
    pub span: Span,
}

impl Expr {
    /// Create a new expression.
    pub fn new(kind: ExprKind, span: Span) -> Expr {
        Expr {
            id: NodeId::dummy(),
            kind,
            span,
        }
    }

    /// Check if this is a literal expression.
    pub fn is_literal(self) -> Bool {
        match self.kind {
            ExprKind::Literal(_) => true,
            _ => false,
        }
    }

    /// Check if this is a path expression.
    pub fn is_path(self) -> Bool {
        match self.kind {
            ExprKind::Path(_) => true,
            _ => false,
        }
    }

    /// Check if this is a block expression.
    pub fn is_block(self) -> Bool {
        match self.kind {
            ExprKind::Block(_) => true,
            _ => false,
        }
    }

    /// Check if this expression requires a semicolon when used as a statement.
    ///
    /// Block-like expressions (if, match, loop, etc.) don't require semicolons.
    pub fn requires_semi(self) -> Bool {
        match self.kind {
            ExprKind::Block(_)
            | ExprKind::If { .. }
            | ExprKind::IfLet { .. }
            | ExprKind::Match { .. }
            | ExprKind::Loop { .. }
            | ExprKind::While { .. }
            | ExprKind::WhileLet { .. }
            | ExprKind::For { .. }
            | ExprKind::Unsafe(_)
            | ExprKind::Region { .. }
            | ExprKind::TryWith { .. }
            | ExprKind::WithHandle { .. } => false,
            _ => true,
        }
    }

    /// Check if this expression can be the left-hand side of an assignment.
    pub fn is_assignable(self) -> Bool {
        match self.kind {
            ExprKind::Path(_) => true,
            ExprKind::Field { .. } => true,
            ExprKind::Index { .. } => true,
            ExprKind::Unary { op: UnaryOp::Deref, .. } => true,
            ExprKind::Paren(ref inner) => inner.is_assignable(),
            _ => false,
        }
    }
}

// ============================================================================
// Expression Kind
// ============================================================================

/// The kind of expression.
#[derive(Clone, PartialEq, Eq)]
pub enum ExprKind {
    /// Literal: `42`, `"hello"`, `true`
    Literal(Literal),

    /// Path: `x`, `std.vec.Vec`
    Path(ExprPath),

    /// Binary operation: `a + b`, `x && y`
    Binary {
        op: BinOp,
        left: Box<Expr>,
        right: Box<Expr>,
    },

    /// Unary operation: `!x`, `-y`, `*ptr`, `&val`
    Unary {
        op: UnaryOp,
        operand: Box<Expr>,
    },

    /// Function call: `f(x, y)`
    Call {
        callee: Box<Expr>,
        args: Vec<CallArg>,
    },

    /// Method call: `x.foo(y)`, `x.foo[T](y)`
    MethodCall {
        receiver: Box<Expr>,
        method: Ident,
        type_args: Option<TypeArgs>,
        args: Vec<CallArg>,
    },

    /// Field access: `x.field`, `x.0`
    Field {
        base: Box<Expr>,
        field: FieldAccess,
    },

    /// Index: `x[i]`
    Index {
        base: Box<Expr>,
        index: Box<Expr>,
    },

    /// Tuple: `()`, `(x,)`, `(x, y)`
    Tuple(Vec<Expr>),

    /// Array: `[1, 2, 3]` or `[0; 10]`
    Array(ArrayExpr),

    /// Record/struct: `Point { x: 1, y: 2 }` or `{ x, y }`
    Record {
        path: Option<TypePath>,
        fields: Vec<RecordExprField>,
        base: Option[Box<Expr>],
    },

    /// Range: `a..b`, `a..=b`, `..b`, `a..`
    Range {
        start: Option[Box<Expr>],
        end: Option[Box<Expr>],
        inclusive: Bool,
    },

    /// Cast: `x as T`
    Cast {
        expr: Box<Expr>,
        ty: Type,
    },

    /// Assignment: `x = y`
    Assign {
        target: Box<Expr>,
        value: Box<Expr>,
    },

    /// Compound assignment: `x += y`, `x *= 2`
    AssignOp {
        op: BinOp,
        target: Box<Expr>,
        value: Box<Expr>,
    },

    /// Block: `{ statements; expr }`
    Block(Block),

    /// If expression: `if cond { a } else { b }`
    If {
        condition: Box<Expr>,
        then_branch: Block,
        else_branch: Option<ElseBranch>,
    },

    /// If-let expression: `if let Pat = expr { a } else { b }`
    IfLet {
        pattern: Pattern,
        scrutinee: Box<Expr>,
        then_branch: Block,
        else_branch: Option<ElseBranch>,
    },

    /// Match expression: `match x { Pat => expr, ... }`
    Match {
        scrutinee: Box<Expr>,
        arms: Vec<MatchArm>,
    },

    /// Loop: `loop { body }`
    Loop {
        label: Option<Ident>,
        body: Block,
    },

    /// While loop: `while cond { body }`
    While {
        label: Option<Ident>,
        condition: Box<Expr>,
        body: Block,
    },

    /// While-let loop: `while let Pat = expr { body }`
    WhileLet {
        label: Option<Ident>,
        pattern: Pattern,
        scrutinee: Box<Expr>,
        body: Block,
    },

    /// For loop: `for pat in iter { body }`
    For {
        label: Option<Ident>,
        pattern: Pattern,
        iter: Box<Expr>,
        body: Block,
    },

    /// Return: `return`, `return x`
    Return(Option[Box<Expr>]),

    /// Break: `break`, `break 'label`, `break x`
    Break {
        label: Option<Ident>,
        value: Option[Box<Expr>],
    },

    /// Continue: `continue`, `continue 'label`
    Continue {
        label: Option<Ident>,
    },

    /// Closure: `|x| x + 1`, `move |x, y| { x + y }`
    Closure {
        is_move: Bool,
        params: Vec<ClosureParam>,
        return_type: Option<Type>,
        effects: Option<EffectRow>,
        body: Box<Expr>,
    },

    /// With-handle: `with handler handle { body }`
    WithHandle {
        handler: Box<Expr>,
        body: Box<Expr>,
    },

    /// Perform effect operation: `perform IO.read()`, `perform Error.throw(e)`
    Perform {
        effect: Option<TypePath>,
        operation: Ident,
        args: Vec<Expr>,
    },

    /// Resume continuation: `resume(x)`
    Resume(Box<Expr>),

    /// Try-with inline handler: `try { body } with { handlers }`
    TryWith {
        body: Block,
        handlers: Vec<TryWithHandler>,
    },

    /// Unsafe block: `@unsafe { body }`
    Unsafe(Block),

    /// Region: `region 'a { body }`
    Region {
        name: Option<Ident>,
        body: Block,
    },

    /// Parenthesized: `(x)`
    Paren(Box<Expr>),

    /// Default value: `default`
    Default,

    /// Macro call: `name!(args)`, `name![args]`, `name!{args}`
    MacroCall {
        path: ExprPath,
        kind: MacroCallKind,
    },

    /// Error placeholder (for error recovery).
    Error,
}

// ============================================================================
// Expression Path
// ============================================================================

/// A path in expression context: `x`, `std.vec.Vec`, `Option::Some`
#[derive(Clone, PartialEq, Eq)]
pub struct ExprPath {
    /// Path segments.
    pub segments: Vec<ExprPathSegment>,
    /// Span of the entire path.
    pub span: Span,
}

impl ExprPath {
    /// Create a new expression path.
    pub fn new(segments: Vec<ExprPathSegment>, span: Span) -> ExprPath {
        ExprPath { segments, span }
    }

    /// Create a simple single-segment path.
    pub fn simple(name: Ident) -> ExprPath {
        let span = name.span;
        ExprPath {
            segments: vec![ExprPathSegment { name, args: Option::None }],
            span,
        }
    }

    /// Check if this is a single-segment path.
    pub fn is_simple(self) -> Bool {
        self.segments.len() == 1 && self.segments[0].args.is_none();
    }

    /// Get the number of segments.
    pub fn len(self) -> USize {
        self.segments.len();
    }
}

/// A segment in an expression path.
#[derive(Clone, PartialEq, Eq)]
pub struct ExprPathSegment {
    /// Segment name.
    pub name: Ident,
    /// Optional generic arguments (turbofish): `foo[T, U]`
    pub args: Option<TypeArgs>,
}

// ============================================================================
// Call Argument
// ============================================================================

/// An argument in a function or method call.
///
/// ## Example
///
/// ```blood
/// foo(1, 2, 3)           // Positional
/// bar(x: 1, y: 2)        // Named
/// baz(1, z: 3)           // Mixed
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct CallArg {
    /// Optional argument name (for named arguments).
    pub name: Option<Ident>,
    /// Argument value.
    pub value: Expr,
    /// Span of the argument.
    pub span: Span,
}

impl CallArg {
    /// Create a positional argument.
    pub fn positional(value: Expr) -> CallArg {
        let span = value.span;
        CallArg {
            name: Option::None,
            value,
            span,
        }
    }

    /// Create a named argument.
    pub fn named(name: Ident, value: Expr, span: Span) -> CallArg {
        CallArg {
            name: Option::Some(name),
            value,
            span,
        }
    }

    /// Check if this is a named argument.
    pub fn is_named(self) -> Bool {
        self.name.is_some();
    }
}

// ============================================================================
// Field Access
// ============================================================================

/// Field access: named field or tuple index.
#[derive(Clone, PartialEq, Eq)]
pub enum FieldAccess {
    /// Named field: `x.field`
    Named(Ident),
    /// Tuple index: `x.0`
    Index(U32, Span),
}

impl FieldAccess {
    /// Get the span of this field access.
    pub fn span(self) -> Span {
        match self {
            FieldAccess::Named(ident) => ident.span,
            FieldAccess::Index(_, span) => span,
        }
    }
}

// ============================================================================
// Array Expression
// ============================================================================

/// Array expression: list or repeat form.
#[derive(Clone, PartialEq, Eq)]
pub enum ArrayExpr {
    /// List: `[1, 2, 3]`
    List(Vec<Expr>),
    /// Repeat: `[0; 10]`
    Repeat {
        value: Box<Expr>,
        count: Box<Expr>,
    },
}

// ============================================================================
// Record Expression Field
// ============================================================================

/// A field in a record/struct expression.
///
/// ## Example
///
/// ```blood
/// Point { x: 1, y: 2 }    // With values
/// Point { x, y }          // Shorthand
/// Point { x: 1, ..base }  // With base
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct RecordExprField {
    /// Field name.
    pub name: Ident,
    /// Field value (None for shorthand `{ x }` meaning `{ x: x }`).
    pub value: Option<Expr>,
    /// Span of the field.
    pub span: Span,
}

impl RecordExprField {
    /// Check if this uses shorthand syntax.
    pub fn is_shorthand(self) -> Bool {
        self.value.is_none();
    }
}

// ============================================================================
// Else Branch
// ============================================================================

/// The else branch of an if expression.
#[derive(Clone, PartialEq, Eq)]
pub enum ElseBranch {
    /// Block: `else { ... }`
    Block(Block),
    /// Else-if: `else if ... { ... }`
    If(Box<Expr>),
}

impl ElseBranch {
    /// Get the span of this else branch.
    pub fn span(self) -> Span {
        match self {
            ElseBranch::Block(block) => block.span,
            ElseBranch::If(expr) => expr.span,
        }
    }
}

// ============================================================================
// Match Arm
// ============================================================================

/// An arm in a match expression.
///
/// ## Example
///
/// ```blood
/// match x {
///     Some(v) if v > 0 => v,   // With guard
///     Some(v) => -v,           // Without guard
///     None => 0,
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct MatchArm {
    /// The pattern to match.
    pub pattern: Pattern,
    /// Optional guard condition.
    pub guard: Option<Expr>,
    /// The body expression.
    pub body: Expr,
    /// Span of the arm.
    pub span: Span,
}

impl MatchArm {
    /// Check if this arm has a guard.
    pub fn has_guard(self) -> Bool {
        self.guard.is_some();
    }
}

// ============================================================================
// Closure Parameter
// ============================================================================

/// A parameter in a closure.
///
/// ## Example
///
/// ```blood
/// |x| ...              // Inferred type
/// |x: Int| ...         // Explicit type
/// |(a, b)| ...         // Pattern
/// |mut x| ...          // Mutable binding
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct ClosureParam {
    /// Parameter pattern.
    pub pattern: Pattern,
    /// Optional explicit type.
    pub ty: Option<Type>,
    /// Span of the parameter.
    pub span: Span,
}

// ============================================================================
// Binary Operators
// ============================================================================

/// Binary operators.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum BinOp {
    // Arithmetic
    /// Addition: `+`
    Add,
    /// Subtraction: `-`
    Sub,
    /// Multiplication: `*`
    Mul,
    /// Division: `/`
    Div,
    /// Remainder: `%`
    Rem,

    // Comparison
    /// Equality: `==`
    Eq,
    /// Not equal: `!=`
    Ne,
    /// Less than: `<`
    Lt,
    /// Less than or equal: `<=`
    Le,
    /// Greater than: `>`
    Gt,
    /// Greater than or equal: `>=`
    Ge,

    // Logical
    /// Logical and: `&&`
    And,
    /// Logical or: `||`
    Or,

    // Bitwise
    /// Bitwise and: `&`
    BitAnd,
    /// Bitwise or: `|`
    BitOr,
    /// Bitwise xor: `^`
    BitXor,
    /// Left shift: `<<`
    Shl,
    /// Right shift: `>>`
    Shr,

    // Special
    /// Pipe operator: `|>`
    Pipe,
}

impl BinOp {
    /// Get the operator as a string.
    pub fn as_str(self) -> &str {
        match self {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Rem => "%",
            BinOp::Eq => "==",
            BinOp::Ne => "!=",
            BinOp::Lt => "<",
            BinOp::Le => "<=",
            BinOp::Gt => ">",
            BinOp::Ge => ">=",
            BinOp::And => "&&",
            BinOp::Or => "||",
            BinOp::BitAnd => "&",
            BinOp::BitOr => "|",
            BinOp::BitXor => "^",
            BinOp::Shl => "<<",
            BinOp::Shr => ">>",
            BinOp::Pipe => "|>",
        }
    }

    /// Check if this is an arithmetic operator.
    pub fn is_arithmetic(self) -> Bool {
        match self {
            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem => true,
            _ => false,
        }
    }

    /// Check if this is a comparison operator.
    pub fn is_comparison(self) -> Bool {
        match self {
            BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge => true,
            _ => false,
        }
    }

    /// Check if this is a logical operator.
    pub fn is_logical(self) -> Bool {
        match self {
            BinOp::And | BinOp::Or => true,
            _ => false,
        }
    }

    /// Check if this is a bitwise operator.
    pub fn is_bitwise(self) -> Bool {
        match self {
            BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor | BinOp::Shl | BinOp::Shr => true,
            _ => false,
        }
    }

    /// Get the precedence of this operator (higher = tighter binding).
    pub fn precedence(self) -> U8 {
        match self {
            BinOp::Or => 1,
            BinOp::And => 2,
            BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge => 3,
            BinOp::BitOr => 4,
            BinOp::BitXor => 5,
            BinOp::BitAnd => 6,
            BinOp::Shl | BinOp::Shr => 7,
            BinOp::Add | BinOp::Sub => 8,
            BinOp::Mul | BinOp::Div | BinOp::Rem => 9,
            BinOp::Pipe => 0, // Lowest precedence
        }
    }

    /// Check if this operator is right-associative.
    pub fn is_right_associative(self) -> Bool {
        // All Blood binary operators are left-associative
        false
    }
}

// ============================================================================
// Unary Operators
// ============================================================================

/// Unary operators.
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub enum UnaryOp {
    /// Negation: `-x`
    Neg,
    /// Logical not: `!x`
    Not,
    /// Dereference: `*x`
    Deref,
    /// Reference: `&x`
    Ref,
    /// Mutable reference: `&mut x`
    RefMut,
}

impl UnaryOp {
    /// Get the operator as a string.
    pub fn as_str(self) -> &str {
        match self {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
            UnaryOp::Deref => "*",
            UnaryOp::Ref => "&",
            UnaryOp::RefMut => "&mut",
        }
    }

    /// Check if this is a prefix operator.
    pub fn is_prefix(self) -> Bool {
        // All unary operators in Blood are prefix
        true
    }
}

// ============================================================================
// Macro Call
// ============================================================================

/// The kind of macro call.
#[derive(Clone, PartialEq, Eq)]
pub enum MacroCallKind {
    /// Format macro: `format!("...", args)`, `println!(...)`, etc.
    Format {
        format_str: Ident, // Actually a string, but using Ident for span
        args: Vec<Expr>,
    },

    /// Vec macro: `vec![1, 2, 3]` or `vec![0; 10]`
    Vec(VecMacroArgs),

    /// Assert macro: `assert!(cond)` or `assert!(cond, "message")`
    Assert {
        condition: Box<Expr>,
        message: Option[Box<Expr>],
    },

    /// Debug macro: `dbg!(expr)`
    Dbg(Box<Expr>),

    /// Matches macro: `matches!(expr, pattern)`
    Matches {
        expr: Box<Expr>,
        pattern: Box<Pattern>,
    },

    /// Custom/user-defined macro with raw content.
    Custom {
        delim: MacroDelimiter,
        content: String,
    },
}

/// Arguments to the vec! macro.
#[derive(Clone, PartialEq, Eq)]
pub enum VecMacroArgs {
    /// List: `vec![1, 2, 3]`
    List(Vec<Expr>),
    /// Repeat: `vec![0; 10]`
    Repeat {
        value: Box<Expr>,
        count: Box<Expr>,
    },
}

/// Delimiter for macro calls.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum MacroDelimiter {
    /// Parentheses: `()`
    Paren,
    /// Brackets: `[]`
    Bracket,
    /// Braces: `{}`
    Brace,
}

impl MacroDelimiter {
    /// Get the opening delimiter character.
    pub fn open(self) -> &str {
        match self {
            MacroDelimiter::Paren => "(",
            MacroDelimiter::Bracket => "[",
            MacroDelimiter::Brace => "{",
        }
    }

    /// Get the closing delimiter character.
    pub fn close(self) -> &str {
        match self {
            MacroDelimiter::Paren => ")",
            MacroDelimiter::Bracket => "]",
            MacroDelimiter::Brace => "}",
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_expr_literal() {
    let lit = Literal::int(42, Span::dummy());
    let expr = Expr::new(ExprKind::Literal(lit), Span::dummy());

    assert(expr.is_literal());
    assert(!expr.is_path());
    assert(!expr.is_block());
}

#[test]
fn test_expr_requires_semi() {
    // Block-like expressions don't require semicolons
    let block_expr = Expr::new(ExprKind::Block(Block::empty(Span::dummy())), Span::dummy());
    assert(!block_expr.requires_semi());

    // Most expressions require semicolons
    let lit_expr = Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy());
    assert(lit_expr.requires_semi());
}

#[test]
fn test_expr_path_simple() {
    let name = Ident::dummy();
    let path = ExprPath::simple(name);

    assert(path.is_simple());
    assert(path.len() == 1);
}

#[test]
fn test_call_arg() {
    let value = Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy());
    let pos_arg = CallArg::positional(value);
    assert(!pos_arg.is_named());

    let value2 = Expr::new(ExprKind::Literal(Literal::int(2, Span::dummy())), Span::dummy());
    let named_arg = CallArg::named(Ident::dummy(), value2, Span::dummy());
    assert(named_arg.is_named());
}

#[test]
fn test_record_field_shorthand() {
    let shorthand = RecordExprField {
        name: Ident::dummy(),
        value: Option::None,
        span: Span::dummy(),
    };
    assert(shorthand.is_shorthand());

    let explicit = RecordExprField {
        name: Ident::dummy(),
        value: Option::Some(Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy())),
        span: Span::dummy(),
    };
    assert(!explicit.is_shorthand());
}

#[test]
fn test_match_arm_guard() {
    let with_guard = MatchArm {
        pattern: Pattern::wildcard(Span::dummy()),
        guard: Option::Some(Expr::new(ExprKind::Literal(Literal::bool(true, Span::dummy())), Span::dummy())),
        body: Expr::new(ExprKind::Literal(Literal::int(1, Span::dummy())), Span::dummy()),
        span: Span::dummy(),
    };
    assert(with_guard.has_guard());

    let without_guard = MatchArm {
        pattern: Pattern::wildcard(Span::dummy()),
        guard: Option::None,
        body: Expr::new(ExprKind::Literal(Literal::int(0, Span::dummy())), Span::dummy()),
        span: Span::dummy(),
    };
    assert(!without_guard.has_guard());
}

#[test]
fn test_binop_as_str() {
    assert(BinOp::Add.as_str() == "+");
    assert(BinOp::Sub.as_str() == "-");
    assert(BinOp::Mul.as_str() == "*");
    assert(BinOp::Eq.as_str() == "==");
    assert(BinOp::And.as_str() == "&&");
    assert(BinOp::Pipe.as_str() == "|>");
}

#[test]
fn test_binop_categories() {
    assert(BinOp::Add.is_arithmetic());
    assert(!BinOp::Add.is_comparison());

    assert(BinOp::Eq.is_comparison());
    assert(!BinOp::Eq.is_arithmetic());

    assert(BinOp::And.is_logical());
    assert(!BinOp::And.is_bitwise());

    assert(BinOp::BitOr.is_bitwise());
    assert(!BinOp::BitOr.is_logical());
}

#[test]
fn test_binop_precedence() {
    // Multiplication should have higher precedence than addition
    assert(BinOp::Mul.precedence() > BinOp::Add.precedence());
    // Addition should have higher precedence than comparison
    assert(BinOp::Add.precedence() > BinOp::Eq.precedence());
    // Comparison should have higher precedence than logical and
    assert(BinOp::Eq.precedence() > BinOp::And.precedence());
}

#[test]
fn test_unaryop_as_str() {
    assert(UnaryOp::Neg.as_str() == "-");
    assert(UnaryOp::Not.as_str() == "!");
    assert(UnaryOp::Deref.as_str() == "*");
    assert(UnaryOp::Ref.as_str() == "&");
    assert(UnaryOp::RefMut.as_str() == "&mut");
}

#[test]
fn test_macro_delimiter() {
    assert(MacroDelimiter::Paren.open() == "(");
    assert(MacroDelimiter::Paren.close() == ")");
    assert(MacroDelimiter::Bracket.open() == "[");
    assert(MacroDelimiter::Bracket.close() == "]");
    assert(MacroDelimiter::Brace.open() == "{");
    assert(MacroDelimiter::Brace.close() == "}");
}
