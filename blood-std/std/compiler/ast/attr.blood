//! # AST Attribute Types
//!
//! Attribute definitions for the Blood AST.
//!
//! ## Overview
//!
//! Attributes provide metadata annotations on items:
//! - Outer attributes: `#[test]` - Attached to following item
//! - Inner attributes: `#![no_std]` - Attached to enclosing item
//!
//! ## Attribute Forms
//!
//! | Form | Example | Use |
//! |------|---------|-----|
//! | Simple | `#[test]` | Marker attribute |
//! | With value | `#[doc = "..."]` | Key-value pair |
//! | With args | `#[derive(Clone, Debug)]` | Parenthesized arguments |
//! | Nested | `#[repr(align(8))]` | Nested function-like |
//!
//! ## Built-in Attributes
//!
//! Blood supports these built-in attributes:
//! - `#[derive(...)]` - Auto-implement traits
//! - `#[test]` - Mark test functions
//! - `#[repr(...)]` - Control type representation
//! - `#[inline]` - Inlining hint
//! - `#[doc = "..."]` - Documentation
//! - `#[cfg(...)]` - Conditional compilation
//! - `#[allow(...)]`, `#[warn(...)]`, `#[deny(...)]` - Lint control

module std.compiler.ast.attr;

use std.core.Option;
use std.collections.Vec;
use std.compiler.ast.node.Span;
use std.compiler.ast.node.Ident;
use std.compiler.ast.node.NodeId;
use std.compiler.ast.lit.Literal;

// ============================================================================
// Attribute
// ============================================================================

/// An attribute attached to an item.
///
/// Attributes come in two styles:
/// - **Outer attributes** (`#[...]`): Attached to the following item
/// - **Inner attributes** (`#![...]`): Attached to the enclosing item
///
/// ## Examples
///
/// ```blood
/// // Outer attribute on function
/// #[test]
/// fn test_something() { ... }
///
/// // Outer attribute with arguments
/// #[derive(Clone, Debug)]
/// struct Point { x: Int, y: Int }
///
/// // Inner attribute on module
/// #![no_std]
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct Attribute {
    /// Unique node ID.
    pub id: NodeId,
    /// Whether this is an inner attribute (`#![...]`).
    pub is_inner: bool,
    /// The attribute path (e.g., `test`, `derive`, `repr`).
    pub path: AttrPath,
    /// Optional arguments.
    pub args: Option<AttrArgs>,
    /// Span of the entire attribute.
    pub span: Span,
}

impl Attribute {
    /// Create a new outer attribute.
    pub fn outer(path: AttrPath, args: Option<AttrArgs>, span: Span) -> Attribute {
        Attribute {
            id: NodeId::dummy(),
            is_inner: false,
            path,
            args,
            span,
        }
    }

    /// Create a new inner attribute.
    pub fn inner(path: AttrPath, args: Option<AttrArgs>, span: Span) -> Attribute {
        Attribute {
            id: NodeId::dummy(),
            is_inner: true,
            path,
            args,
            span,
        }
    }

    /// Check if this is an outer attribute.
    pub fn is_outer(self) -> bool {
        !self.is_inner
    }

    /// Check if this is a simple attribute (no arguments).
    pub fn is_simple(self) -> bool {
        self.args.is_none();
    }

    /// Check if this attribute has a specific path.
    pub fn has_path(self, name: &str) -> bool {
        self.path.is_word(name);
    }

    /// Get the first path segment name.
    pub fn name(self) -> Option[&Ident] {
        self.path.segments.first();
    }
}

// ============================================================================
// Attribute Path
// ============================================================================

/// The path portion of an attribute.
///
/// Examples:
/// - `test` in `#[test]`
/// - `derive` in `#[derive(Clone)]`
/// - `cfg::feature` in `#[cfg::feature("foo")]`
#[derive(Clone, PartialEq, Eq)]
pub struct AttrPath {
    /// Path segments.
    pub segments: Vec<Ident>,
    /// Span of the path.
    pub span: Span,
}

impl AttrPath {
    /// Create a new attribute path.
    pub fn new(segments: Vec<Ident>, span: Span) -> AttrPath {
        AttrPath { segments, span }
    }

    /// Create a single-segment path.
    pub fn simple(ident: Ident) -> AttrPath {
        let span = ident.span;
        AttrPath {
            segments: vec![ident],
            span,
        }
    }

    /// Check if this is a single-word path matching the given name.
    pub fn is_word(self, name: &str) -> bool {
        // This would require access to the interner to resolve symbols
        // For now, we just check segment count
        self.segments.len() == 1
    }

    /// Get the number of segments.
    pub fn len(self) -> usize {
        self.segments.len();
    }

    /// Check if the path is empty.
    pub fn is_empty(self) -> bool {
        self.segments.is_empty();
    }
}

// ============================================================================
// Attribute Arguments
// ============================================================================

/// Arguments to an attribute.
///
/// There are two forms:
/// - **Eq**: `#[attr = value]` - Assignment form
/// - **List**: `#[attr(args)]` - Parenthesized form
#[derive(Clone, PartialEq, Eq)]
pub enum AttrArgs {
    /// Assignment form: `#[attr = "value"]`
    Eq {
        /// The value after the `=`.
        value: Literal,
        /// Span of the `= value` part.
        span: Span,
    },

    /// Parenthesized form: `#[attr(arg1, arg2)]`
    List {
        /// The arguments.
        args: Vec<AttrArg>,
        /// Span of the `(args)` part.
        span: Span,
    },
}

impl AttrArgs {
    /// Check if this is an eq-style argument.
    pub fn is_eq(self) -> bool {
        match self {
            AttrArgs::Eq { .. } => true,
            AttrArgs::List { .. } => false,
        }
    }

    /// Check if this is a list-style argument.
    pub fn is_list(self) -> bool {
        match self {
            AttrArgs::Eq { .. } => false,
            AttrArgs::List { .. } => true,
        }
    }

    /// Get the span.
    pub fn span(self) -> Span {
        match self {
            AttrArgs::Eq { span, .. } => span,
            AttrArgs::List { span, .. } => span,
        }
    }
}

// ============================================================================
// Attribute Argument
// ============================================================================

/// A single argument within an attribute.
///
/// | Form | Example | AttrArg variant |
/// |------|---------|-----------------|
/// | Identifier | `Clone` in `derive(Clone)` | `Ident` |
/// | Key-value | `name = "foo"` | `KeyValue` |
/// | Literal | `"value"` | `Literal` |
/// | Nested call | `align(8)` | `Call` |
/// | Nested path | `feature::foo` | `Path` |
#[derive(Clone, PartialEq, Eq)]
pub enum AttrArg {
    /// Just an identifier: `#[derive(Clone)]` -> `Clone`
    Ident {
        ident: Ident,
        span: Span,
    },

    /// Key-value pair: `#[cfg(feature = "foo")]`
    KeyValue {
        key: Ident,
        value: Literal,
        span: Span,
    },

    /// Literal value: `#[doc("description")]`
    Literal {
        literal: Literal,
        span: Span,
    },

    /// Call-style nested: `#[repr(align(8))]` -> `align(8)`
    Call {
        name: Ident,
        args: Vec<AttrArg>,
        span: Span,
    },

    /// Path: `#[cfg(feature::experimental)]`
    Path {
        path: AttrPath,
        span: Span,
    },
}

impl AttrArg {
    /// Get the span.
    pub fn span(self) -> Span {
        match self {
            AttrArg::Ident { span, .. } => span,
            AttrArg::KeyValue { span, .. } => span,
            AttrArg::Literal { span, .. } => span,
            AttrArg::Call { span, .. } => span,
            AttrArg::Path { span, .. } => span,
        }
    }

    /// Check if this is a simple identifier.
    pub fn is_ident(self) -> bool {
        match self {
            AttrArg::Ident { .. } => true,
            _ => false,
        }
    }

    /// Check if this is a key-value pair.
    pub fn is_key_value(self) -> bool {
        match self {
            AttrArg::KeyValue { .. } => true,
            _ => false,
        }
    }

    /// Try to get as an identifier.
    pub fn as_ident(self) -> Option[&Ident] {
        match self {
            AttrArg::Ident { ident, .. } => Option::Some(&ident),
            _ => Option::None,
        }
    }
}

// ============================================================================
// Attribute Collection Helpers
// ============================================================================

/// A collection of attributes.
///
/// Provides helper methods for querying attributes.
pub struct Attrs {
    /// The attributes.
    pub attrs: Vec<Attribute>,
}

impl Attrs {
    /// Create an empty attribute collection.
    pub fn empty() -> Attrs {
        Attrs { attrs: Vec::new() }
    }

    /// Create from a vector of attributes.
    pub fn new(attrs: Vec<Attribute>) -> Attrs {
        Attrs { attrs }
    }

    /// Check if any attribute exists.
    pub fn is_empty(self) -> bool {
        self.attrs.is_empty();
    }

    /// Get the number of attributes.
    pub fn len(self) -> usize {
        self.attrs.len();
    }

    /// Check if an attribute with the given name exists.
    pub fn has(self, name: &str) -> bool {
        self.attrs.iter().any(|a| a.has_path(name));
    }

    /// Get all outer attributes.
    pub fn outer(self) -> Vec[&Attribute] {
        self.attrs.iter().filter(|a| a.is_outer()).collect();
    }

    /// Get all inner attributes.
    pub fn inner(self) -> Vec[&Attribute] {
        self.attrs.iter().filter(|a| a.is_inner).collect();
    }

    /// Find an attribute by name.
    pub fn find(self, name: &str) -> Option[&Attribute] {
        self.attrs.iter().find(|a| a.has_path(name));
    }

    /// Find all attributes with a given name.
    pub fn find_all(self, name: &str) -> Vec[&Attribute] {
        self.attrs.iter().filter(|a| a.has_path(name)).collect();
    }

    /// Iterate over all attributes.
    pub fn iter(self) -> impl Iterator[Item = &Attribute] {
        self.attrs.iter();
    }
}

impl Default for Attrs {
    fn default() -> Attrs {
        Attrs::empty()
    }
}

impl Clone for Attrs {
    fn clone(self) -> Attrs {
        Attrs { attrs: self.attrs.clone() }
    }
}

// ============================================================================
// Well-Known Attributes
// ============================================================================

/// Well-known attribute names.
///
/// These constants help avoid typos when checking for specific attributes.
pub mod attr_names {
    /// Derive trait implementations.
    pub const DERIVE: &str = "derive";
    /// Mark as test function.
    pub const TEST: &str = "test";
    /// Control representation.
    pub const REPR: &str = "repr";
    /// Inlining hint.
    pub const INLINE: &str = "inline";
    /// Documentation.
    pub const DOC: &str = "doc";
    /// Conditional compilation.
    pub const CFG: &str = "cfg";
    /// Allow lint.
    pub const ALLOW: &str = "allow";
    /// Warn on lint.
    pub const WARN: &str = "warn";
    /// Deny lint.
    pub const DENY: &str = "deny";
    /// Forbid lint.
    pub const FORBID: &str = "forbid";
    /// Deprecated item.
    pub const DEPRECATED: &str = "deprecated";
    /// Must use result.
    pub const MUST_USE: &str = "must_use";
    /// Cold path hint.
    pub const COLD: &str = "cold";
    /// No mangle name.
    pub const NO_MANGLE: &str = "no_mangle";
    /// Link name.
    pub const LINK_NAME: &str = "link_name";
    /// Link section.
    pub const LINK_SECTION: &str = "link_section";
    /// Export name.
    pub const EXPORT_NAME: &str = "export_name";
    /// Track caller.
    pub const TRACK_CALLER: &str = "track_caller";
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_attribute_outer() {
    let path = AttrPath::new(Vec::new(), Span::dummy());
    let attr = Attribute::outer(path, Option::None, Span::dummy());

    assert(!attr.is_inner);
    assert(attr.is_outer());
    assert(attr.is_simple());
}

#[test]
fn test_attribute_inner() {
    let path = AttrPath::new(Vec::new(), Span::dummy());
    let attr = Attribute::inner(path, Option::None, Span::dummy());

    assert(attr.is_inner);
    assert(!attr.is_outer());
}

#[test]
fn test_attr_args_eq() {
    let value = Literal::string("test", Span::dummy());
    let args = AttrArgs::Eq { value, span: Span::dummy() };

    assert(args.is_eq());
    assert(!args.is_list());
}

#[test]
fn test_attr_args_list() {
    let args = AttrArgs::List { args: Vec::new(), span: Span::dummy() };

    assert(!args.is_eq());
    assert(args.is_list());
}

#[test]
fn test_attr_path_simple() {
    let ident = Ident::dummy();
    let path = AttrPath::simple(ident);

    assert(path.len() == 1);
    assert(!path.is_empty());
}

#[test]
fn test_attrs_collection() {
    let attrs = Attrs::empty();

    assert(attrs.is_empty());
    assert(attrs.len() == 0);
}

#[test]
fn test_attr_arg_variants() {
    let ident_arg = AttrArg::Ident {
        ident: Ident::dummy(),
        span: Span::dummy(),
    };

    assert(ident_arg.is_ident());
    assert(!ident_arg.is_key_value());
}
