//! # AST Declaration Types
//!
//! Top-level declarations in the Blood AST.
//!
//! ## Overview
//!
//! Declarations are the top-level items that can appear in a Blood program:
//! - Functions: `fn foo() { ... }`
//! - Types: `type Alias = Int`
//! - Structs: `struct Point { x: Int, y: Int }`
//! - Enums: `enum Option[T] { Some(T), None }`
//! - Effects: `effect IO { fn read() -> String }`
//! - Handlers: `handler ConsoleIO for IO { ... }`
//! - Traits: `trait Clone { fn clone(self) -> Self }`
//! - Implementations: `impl Clone for Point { ... }`
//! - Constants: `const PI: F64 = 3.14159`
//! - Statics: `static mut COUNTER: Int = 0`
//! - Modules: `mod foo { ... }`
//! - Macros: `macro vec!(...) { ... }`
//!
//! ## Declaration Structure
//!
//! | Declaration | Keywords | Example |
//! |-------------|----------|---------|
//! | Function | `fn` | `fn add(a: Int, b: Int) -> Int` |
//! | Type Alias | `type` | `type Id = Int` |
//! | Struct | `struct` | `struct User { name: String }` |
//! | Enum | `enum` | `enum Result[T, E] { Ok(T), Err(E) }` |
//! | Effect | `effect` | `effect Log { fn log(msg: String) }` |
//! | Handler | `handler` | `handler FileLog for Log { ... }` |
//! | Trait | `trait` | `trait Iterator { type Item; fn next() }` |
//! | Impl | `impl` | `impl Iterator for Range { ... }` |
//! | Const | `const` | `const MAX: Int = 100` |
//! | Static | `static` | `static mut COUNT: Int = 0` |
//! | Module | `mod` | `mod utils { ... }` |
//! | Macro | `macro` | `macro dbg!($e:expr) { ... }` |

module std.compiler.ast.decl

use std.option.Option
use std.collections.Vec
use std.compiler.ast.node.Span
use std.compiler.ast.node.Ident
use std.compiler.ast.node.NodeId
use std.compiler.ast.node.Visibility
use std.compiler.ast.attr.Attribute
use std.compiler.ast.ty.Type
use std.compiler.ast.ty.TypePath
use std.compiler.ast.ty.TypeParams
use std.compiler.ast.ty.TypeArgs
use std.compiler.ast.ty.WhereClause
use std.compiler.ast.ty.EffectRow
use std.compiler.ast.pattern.Pattern
use std.compiler.ast.stmt.Block

// ============================================================================
// Declaration
// ============================================================================

/// A top-level declaration in a Blood program.
///
/// Declarations form the structure of a program, defining functions, types,
/// traits, effects, and other items.
#[derive(Clone, PartialEq, Eq)]
pub enum Declaration {
    /// Function declaration: `fn foo() { ... }`
    Function(FnDecl),
    /// Type alias: `type Id = Int`
    Type(TypeDecl),
    /// Struct: `struct Point { x: Int, y: Int }`
    Struct(StructDecl),
    /// Enum: `enum Option[T] { Some(T), None }`
    Enum(EnumDecl),
    /// Effect: `effect IO { ... }`
    Effect(EffectDecl),
    /// Handler: `handler ConsoleIO for IO { ... }`
    Handler(HandlerDecl),
    /// Constant: `const PI: F64 = 3.14159`
    Const(ConstDecl),
    /// Static: `static mut COUNTER: Int = 0`
    Static(StaticDecl),
    /// Impl block: `impl Clone for Point { ... }`
    Impl(ImplBlock),
    /// Trait: `trait Clone { fn clone(self) -> Self }`
    Trait(TraitDecl),
    /// Module: `mod foo { ... }`
    Module(ModItemDecl),
    /// Macro: `macro vec!(...) { ... }`
    Macro(MacroDecl),
}

impl Declaration {
    /// Get the span of this declaration.
    pub fn span(self) -> Span {
        match self {
            Declaration::Function(d) => d.span,
            Declaration::Type(d) => d.span,
            Declaration::Struct(d) => d.span,
            Declaration::Enum(d) => d.span,
            Declaration::Effect(d) => d.span,
            Declaration::Handler(d) => d.span,
            Declaration::Const(d) => d.span,
            Declaration::Static(d) => d.span,
            Declaration::Impl(d) => d.span,
            Declaration::Trait(d) => d.span,
            Declaration::Module(d) => d.span,
            Declaration::Macro(d) => d.span,
        }
    }

    /// Get the name of this declaration, if it has one.
    pub fn name(self) -> Option[&Ident] {
        match self {
            Declaration::Function(d) => Option::Some(&d.name),
            Declaration::Type(d) => Option::Some(&d.name),
            Declaration::Struct(d) => Option::Some(&d.name),
            Declaration::Enum(d) => Option::Some(&d.name),
            Declaration::Effect(d) => Option::Some(&d.name),
            Declaration::Handler(d) => Option::Some(&d.name),
            Declaration::Const(d) => Option::Some(&d.name),
            Declaration::Static(d) => Option::Some(&d.name),
            Declaration::Impl(_) => Option::None,
            Declaration::Trait(d) => Option::Some(&d.name),
            Declaration::Module(d) => Option::Some(&d.name),
            Declaration::Macro(d) => Option::Some(&d.name),
        }
    }

    /// Check if this declaration is public.
    pub fn is_public(self) -> Bool {
        match self {
            Declaration::Function(d) => d.vis == Visibility::Public,
            Declaration::Type(d) => d.vis == Visibility::Public,
            Declaration::Struct(d) => d.vis == Visibility::Public,
            Declaration::Enum(d) => d.vis == Visibility::Public,
            Declaration::Effect(d) => d.vis == Visibility::Public,
            Declaration::Handler(d) => d.vis == Visibility::Public,
            Declaration::Const(d) => d.vis == Visibility::Public,
            Declaration::Static(d) => d.vis == Visibility::Public,
            Declaration::Impl(_) => false, // impl blocks don't have visibility
            Declaration::Trait(d) => d.vis == Visibility::Public,
            Declaration::Module(d) => d.vis == Visibility::Public,
            Declaration::Macro(d) => d.vis == Visibility::Public,
        }
    }
}

// ============================================================================
// Function Declaration
// ============================================================================

/// A function declaration.
///
/// ## Example
///
/// ```blood
/// #[inline]
/// pub fn add[T: Add](a: T, b: T) -> T / pure
/// where
///     T: Clone,
/// {
///     a + b
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct FnDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes on the function.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Function qualifiers (const, async, unsafe).
    pub qualifiers: FnQualifiers,
    /// Function name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Function parameters.
    pub params: Vec[Param],
    /// Return type (None means unit `()`).
    pub return_type: Option[Type],
    /// Effect row annotation.
    pub effects: Option[EffectRow],
    /// Where clause.
    pub where_clause: Option[WhereClause],
    /// Function body (None for declarations without body, e.g., in traits).
    pub body: Option[Block],
    /// Span of the entire declaration.
    pub span: Span,
}

impl FnDecl {
    /// Check if this function has a body.
    pub fn has_body(self) -> Bool {
        self.body.is_some()
    }

    /// Check if this is a const function.
    pub fn is_const(self) -> Bool {
        self.qualifiers.is_const
    }

    /// Check if this is an async function.
    pub fn is_async(self) -> Bool {
        self.qualifiers.is_async
    }

    /// Check if this is an unsafe function.
    pub fn is_unsafe(self) -> Bool {
        self.qualifiers.is_unsafe
    }

    /// Check if this function has generic parameters.
    pub fn is_generic(self) -> Bool {
        self.type_params.is_some()
    }
}

/// Function qualifiers: `const`, `async`, `unsafe`.
#[derive(Clone, Copy, PartialEq, Eq, Default)]
pub struct FnQualifiers {
    /// Is this a const function?
    pub is_const: Bool,
    /// Is this an async function?
    pub is_async: Bool,
    /// Is this an unsafe function?
    pub is_unsafe: Bool,
}

impl FnQualifiers {
    /// Create default qualifiers (none set).
    pub fn none() -> FnQualifiers {
        FnQualifiers {
            is_const: false,
            is_async: false,
            is_unsafe: false,
        }
    }

    /// Check if any qualifier is set.
    pub fn any(self) -> Bool {
        self.is_const || self.is_async || self.is_unsafe
    }
}

/// A function parameter.
///
/// ## Example
///
/// ```blood
/// fn foo(
///     x: Int,           // Simple parameter
///     mut y: String,    // Mutable parameter
///     linear z: Handle, // Linear ownership
/// ) { ... }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct Param {
    /// Unique node ID.
    pub id: NodeId,
    /// Optional ownership/mutability qualifier.
    pub qualifier: Option[ParamQualifier],
    /// Parameter pattern (usually just an identifier).
    pub pattern: Pattern,
    /// Parameter type.
    pub ty: Type,
    /// Span of the parameter.
    pub span: Span,
}

/// Parameter qualifier for ownership or mutability.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ParamQualifier {
    /// Linear ownership: must be used exactly once.
    Linear,
    /// Affine ownership: must be used at most once.
    Affine,
    /// Mutable binding.
    Mut,
}

impl ParamQualifier {
    /// Get the qualifier as a string.
    pub fn as_str(self) -> &str {
        match self {
            ParamQualifier::Linear => "linear",
            ParamQualifier::Affine => "affine",
            ParamQualifier::Mut => "mut",
        }
    }
}

// ============================================================================
// Type Declaration
// ============================================================================

/// A type alias declaration.
///
/// ## Example
///
/// ```blood
/// pub type Result[T, E] = Either[E, T]
/// type Id = Int
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct TypeDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Type name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// The aliased type.
    pub ty: Type,
    /// Span of the declaration.
    pub span: Span,
}

// ============================================================================
// Struct Declaration
// ============================================================================

/// A struct declaration.
///
/// ## Example
///
/// ```blood
/// #[derive(Clone, Debug)]
/// pub struct Point[T] {
///     pub x: T,
///     pub y: T,
/// }
///
/// struct Unit;
///
/// struct Tuple(Int, Int);
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct StructDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Struct name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Struct body (record, tuple, or unit).
    pub body: StructBody,
    /// Span of the declaration.
    pub span: Span,
}

impl StructDecl {
    /// Check if this is a unit struct.
    pub fn is_unit(self) -> Bool {
        match self.body {
            StructBody::Unit => true,
            _ => false,
        }
    }

    /// Check if this is a tuple struct.
    pub fn is_tuple(self) -> Bool {
        match self.body {
            StructBody::Tuple(_) => true,
            _ => false,
        }
    }

    /// Check if this is a record struct.
    pub fn is_record(self) -> Bool {
        match self.body {
            StructBody::Record(_) => true,
            _ => false,
        }
    }
}

/// The body of a struct declaration.
#[derive(Clone, PartialEq, Eq)]
pub enum StructBody {
    /// Record struct: `struct Foo { x: Int, y: Int }`
    Record(Vec[StructField]),
    /// Tuple struct: `struct Foo(Int, Int);`
    Tuple(Vec[Type]),
    /// Unit struct: `struct Foo;`
    Unit,
}

/// A field in a record struct.
#[derive(Clone, PartialEq, Eq)]
pub struct StructField {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes on the field.
    pub attrs: Vec[Attribute],
    /// Field visibility.
    pub vis: Visibility,
    /// Field name.
    pub name: Ident,
    /// Field type.
    pub ty: Type,
    /// Span of the field.
    pub span: Span,
}

// ============================================================================
// Enum Declaration
// ============================================================================

/// An enum declaration.
///
/// ## Example
///
/// ```blood
/// pub enum Option[T] {
///     Some(T),
///     None,
/// }
///
/// enum Message {
///     Quit,
///     Move { x: Int, y: Int },
///     Write(String),
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct EnumDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Enum name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Enum variants.
    pub variants: Vec[EnumVariant],
    /// Span of the declaration.
    pub span: Span,
}

/// A variant of an enum.
#[derive(Clone, PartialEq, Eq)]
pub struct EnumVariant {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes on the variant.
    pub attrs: Vec[Attribute],
    /// Variant name.
    pub name: Ident,
    /// Variant body (same forms as struct).
    pub body: StructBody,
    /// Optional discriminant expression.
    pub discriminant: Option[Box[crate.compiler.ast.expr.Expr]],
    /// Span of the variant.
    pub span: Span,
}

// ============================================================================
// Effect Declaration
// ============================================================================

/// An effect declaration.
///
/// Effects define a set of operations that can be performed in a
/// computational context.
///
/// ## Example
///
/// ```blood
/// pub effect IO {
///     fn read() -> String
///     fn write(s: String)
/// }
///
/// effect State[S] {
///     fn get() -> S
///     fn set(s: S)
/// }
///
/// effect Exception[E] extends IO {
///     fn throw(e: E) -> !
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct EffectDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Effect name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Extended effects (supereffects).
    pub extends: Vec[Type],
    /// Effect operations.
    pub operations: Vec[OperationDecl],
    /// Span of the declaration.
    pub span: Span,
}

/// An operation within an effect declaration.
#[derive(Clone, PartialEq, Eq)]
pub struct OperationDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Operation name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Operation parameters.
    pub params: Vec[Param],
    /// Return type.
    pub return_type: Type,
    /// Span of the operation.
    pub span: Span,
}

// ============================================================================
// Handler Declaration
// ============================================================================

/// A handler declaration.
///
/// Handlers provide implementations for effects.
///
/// ## Example
///
/// ```blood
/// handler ConsoleIO for IO {
///     fn read() -> String {
///         // Read from stdin
///         stdin.read_line()
///     }
///
///     fn write(s: String) {
///         println(s)
///     }
/// }
///
/// handler StateHandler[S] for State[S] {
///     state mut current: S = default
///
///     fn get() -> S {
///         self.current
///     }
///
///     fn set(s: S) {
///         self.current = s
///     }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct HandlerDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Handler kind (deep or shallow).
    pub kind: HandlerKind,
    /// Handler name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// The effect being handled.
    pub effect: Type,
    /// Where clause.
    pub where_clause: Option[WhereClause],
    /// Handler state fields.
    pub state: Vec[HandlerState],
    /// Optional return clause.
    pub return_clause: Option[ReturnClause],
    /// Operation implementations.
    pub operations: Vec[OperationImpl],
    /// Span of the declaration.
    pub span: Span,
}

/// Handler kind: deep (default) or shallow.
#[derive(Clone, Copy, PartialEq, Eq, Default)]
pub enum HandlerKind {
    /// Deep handler: handles effects recursively in continuations.
    #[default]
    Deep,
    /// Shallow handler: handles only the first occurrence.
    Shallow,
}

impl HandlerKind {
    /// Get the kind as a string.
    pub fn as_str(self) -> &str {
        match self {
            HandlerKind::Deep => "deep",
            HandlerKind::Shallow => "shallow",
        }
    }
}

/// State field in a handler.
#[derive(Clone, PartialEq, Eq)]
pub struct HandlerState {
    /// Unique node ID.
    pub id: NodeId,
    /// Whether the state is mutable.
    pub is_mut: Bool,
    /// State field name.
    pub name: Ident,
    /// State type.
    pub ty: Type,
    /// Default value (optional).
    pub default: Option[Box[crate.compiler.ast.expr.Expr]],
    /// Span of the state field.
    pub span: Span,
}

/// Return clause in a handler.
///
/// ## Example
///
/// ```blood
/// handler Transformer for Effect {
///     return(value) {
///         // Transform the final value
///         wrap(value)
///     }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct ReturnClause {
    /// Parameter name for the returned value.
    pub param: Ident,
    /// Body block.
    pub body: Block,
    /// Span of the clause.
    pub span: Span,
}

/// Implementation of an operation in a handler.
#[derive(Clone, PartialEq, Eq)]
pub struct OperationImpl {
    /// Unique node ID.
    pub id: NodeId,
    /// Operation name.
    pub name: Ident,
    /// Parameter patterns.
    pub params: Vec[Pattern],
    /// Implementation body.
    pub body: Block,
    /// Span of the implementation.
    pub span: Span,
}

/// Handler clause in a try-with expression.
///
/// ## Example
///
/// ```blood
/// try {
///     perform IO.read()
/// } with {
///     IO::read() => { resume("input") }
///     IO::write(s) => { println(s); resume(()) }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct TryWithHandler {
    /// The effect path.
    pub effect: TypePath,
    /// The operation name.
    pub operation: Ident,
    /// Parameter patterns.
    pub params: Vec[Pattern],
    /// Handler body.
    pub body: Block,
    /// Span of the handler.
    pub span: Span,
}

// ============================================================================
// Trait Declaration
// ============================================================================

/// A trait declaration.
///
/// ## Example
///
/// ```blood
/// pub trait Clone {
///     fn clone(self) -> Self
/// }
///
/// pub trait Iterator {
///     type Item
///
///     fn next(mut self) -> Option[Self::Item]
///     fn size_hint(self) -> (USize, Option[USize]) {
///         (0, Option::None)
///     }
/// }
///
/// trait PartialOrd: PartialEq {
///     fn partial_cmp(self, other: &Self) -> Option[Ordering]
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct TraitDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Trait name.
    pub name: Ident,
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Supertraits (traits that must also be implemented).
    pub supertraits: Vec[Type],
    /// Where clause.
    pub where_clause: Option[WhereClause],
    /// Trait items (functions, types, constants).
    pub items: Vec[TraitItem],
    /// Span of the declaration.
    pub span: Span,
}

/// An item within a trait declaration.
#[derive(Clone, PartialEq, Eq)]
pub enum TraitItem {
    /// Function (method) in a trait.
    Function(FnDecl),
    /// Associated type in a trait.
    Type(TypeDecl),
    /// Associated constant in a trait.
    Const(ConstDecl),
}

impl TraitItem {
    /// Get the span of this item.
    pub fn span(self) -> Span {
        match self {
            TraitItem::Function(f) => f.span,
            TraitItem::Type(t) => t.span,
            TraitItem::Const(c) => c.span,
        }
    }
}

// ============================================================================
// Implementation Block
// ============================================================================

/// An implementation block.
///
/// ## Example
///
/// ```blood
/// // Inherent impl
/// impl Point {
///     pub fn new(x: Int, y: Int) -> Point {
///         Point { x, y }
///     }
///
///     pub fn distance(self, other: Point) -> F64 {
///         // ...
///     }
/// }
///
/// // Trait impl
/// impl Clone for Point {
///     fn clone(self) -> Point {
///         Point { x: self.x, y: self.y }
///     }
/// }
///
/// // Generic impl
/// impl[T: Clone] Clone for Option[T] {
///     fn clone(self) -> Option[T] {
///         match self {
///             Option::Some(v) => Option::Some(v.clone()),
///             Option::None => Option::None,
///         }
///     }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct ImplBlock {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Generic type parameters.
    pub type_params: Option[TypeParams],
    /// Trait being implemented (None for inherent impl).
    pub trait_ty: Option[Type],
    /// The type this impl is for.
    pub self_ty: Type,
    /// Where clause.
    pub where_clause: Option[WhereClause],
    /// Implementation items.
    pub items: Vec[ImplItem],
    /// Span of the block.
    pub span: Span,
}

impl ImplBlock {
    /// Check if this is a trait implementation.
    pub fn is_trait_impl(self) -> Bool {
        self.trait_ty.is_some()
    }

    /// Check if this is an inherent implementation.
    pub fn is_inherent(self) -> Bool {
        self.trait_ty.is_none()
    }
}

/// An item within an impl block.
#[derive(Clone, PartialEq, Eq)]
pub enum ImplItem {
    /// Function (method) in an impl.
    Function(FnDecl),
    /// Associated type in an impl.
    Type(TypeDecl),
    /// Associated constant in an impl.
    Const(ConstDecl),
}

impl ImplItem {
    /// Get the span of this item.
    pub fn span(self) -> Span {
        match self {
            ImplItem::Function(f) => f.span,
            ImplItem::Type(t) => t.span,
            ImplItem::Const(c) => c.span,
        }
    }
}

// ============================================================================
// Constant and Static Declarations
// ============================================================================

/// A constant declaration.
///
/// ## Example
///
/// ```blood
/// pub const PI: F64 = 3.14159265358979
/// const MAX_SIZE: USize = 1024
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct ConstDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Constant name.
    pub name: Ident,
    /// Constant type.
    pub ty: Type,
    /// Constant value expression.
    pub value: Box[crate.compiler.ast.expr.Expr],
    /// Span of the declaration.
    pub span: Span,
}

/// A static declaration.
///
/// ## Example
///
/// ```blood
/// static INSTANCE: Singleton = Singleton::new()
/// static mut COUNTER: Int = 0
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct StaticDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Whether this static is mutable.
    pub is_mut: Bool,
    /// Static name.
    pub name: Ident,
    /// Static type.
    pub ty: Type,
    /// Static value expression.
    pub value: Box[crate.compiler.ast.expr.Expr],
    /// Span of the declaration.
    pub span: Span,
}

// ============================================================================
// Module Item Declaration
// ============================================================================

/// A module item declaration.
///
/// This represents inline or external module definitions within a file.
///
/// ## Example
///
/// ```blood
/// // External module (file foo.blood)
/// mod foo;
///
/// // Inline module
/// mod bar {
///     pub fn baz() { ... }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct ModItemDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Module name.
    pub name: Ident,
    /// Module body (None for `mod foo;`, Some for `mod foo { ... }`).
    pub body: Option[Vec[Declaration]],
    /// Span of the declaration.
    pub span: Span,
}

impl ModItemDecl {
    /// Check if this is an external module reference.
    pub fn is_external(self) -> Bool {
        self.body.is_none()
    }

    /// Check if this is an inline module.
    pub fn is_inline(self) -> Bool {
        self.body.is_some()
    }
}

// ============================================================================
// Macro Declaration
// ============================================================================

/// A macro declaration.
///
/// ## Example
///
/// ```blood
/// macro vec!($($elem:expr),*) {
///     {
///         let mut v = Vec::new();
///         $(v.push($elem);)*
///         v
///     }
/// }
/// ```
#[derive(Clone, PartialEq, Eq)]
pub struct MacroDecl {
    /// Unique node ID.
    pub id: NodeId,
    /// Attributes.
    pub attrs: Vec[Attribute],
    /// Visibility.
    pub vis: Visibility,
    /// Macro name (without the `!`).
    pub name: Ident,
    /// Macro rules.
    pub rules: Vec[MacroRule],
    /// Span of the declaration.
    pub span: Span,
}

/// A single macro rule.
#[derive(Clone, PartialEq, Eq)]
pub struct MacroRule {
    /// The pattern to match.
    pub pattern: MacroPattern,
    /// The expansion template.
    pub expansion: MacroExpansion,
    /// Span of the rule.
    pub span: Span,
}

/// A macro pattern.
#[derive(Clone, PartialEq, Eq)]
pub struct MacroPattern {
    /// Pattern parts.
    pub parts: Vec[MacroPatternPart],
    /// Span of the pattern.
    pub span: Span,
}

/// A part of a macro pattern.
#[derive(Clone, PartialEq, Eq)]
pub enum MacroPatternPart {
    /// Literal token to match.
    Token {
        kind: TokenKind,
        span: Span,
    },

    /// Capture: `$name:frag`
    Capture {
        name: Ident,
        fragment: FragmentKind,
        span: Span,
    },

    /// Repetition: `$(...)*`, `$(...)+`, `$(...)?`
    Repetition {
        pattern: Vec[MacroPatternPart],
        separator: Option[TokenKind],
        kind: RepetitionKind,
        span: Span,
    },

    /// Delimited group.
    Group {
        delimiter: MacroDelimiter,
        pattern: Vec[MacroPatternPart],
        span: Span,
    },
}

/// Fragment specifier for macro captures.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum FragmentKind {
    /// Expression: `$x:expr`
    Expr,
    /// Type: `$t:ty`
    Ty,
    /// Pattern: `$p:pat`
    Pat,
    /// Identifier: `$i:ident`
    Ident,
    /// Literal: `$l:literal`
    Literal,
    /// Block: `$b:block`
    Block,
    /// Statement: `$s:stmt`
    Stmt,
    /// Item/Declaration: `$d:item`
    Item,
    /// Single token tree: `$t:tt`
    TokenTree,
}

impl FragmentKind {
    /// Get the fragment kind as a string.
    pub fn as_str(self) -> &str {
        match self {
            FragmentKind::Expr => "expr",
            FragmentKind::Ty => "ty",
            FragmentKind::Pat => "pat",
            FragmentKind::Ident => "ident",
            FragmentKind::Literal => "literal",
            FragmentKind::Block => "block",
            FragmentKind::Stmt => "stmt",
            FragmentKind::Item => "item",
            FragmentKind::TokenTree => "tt",
        }
    }

    /// Parse a fragment kind from a string.
    pub fn from_str(s: &str) -> Option[FragmentKind] {
        match s {
            "expr" => Option::Some(FragmentKind::Expr),
            "ty" => Option::Some(FragmentKind::Ty),
            "pat" => Option::Some(FragmentKind::Pat),
            "ident" => Option::Some(FragmentKind::Ident),
            "literal" => Option::Some(FragmentKind::Literal),
            "block" => Option::Some(FragmentKind::Block),
            "stmt" => Option::Some(FragmentKind::Stmt),
            "item" => Option::Some(FragmentKind::Item),
            "tt" => Option::Some(FragmentKind::TokenTree),
            _ => Option::None,
        }
    }
}

/// Repetition kind in macro patterns.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum RepetitionKind {
    /// Zero or more: `*`
    ZeroOrMore,
    /// One or more: `+`
    OneOrMore,
    /// Zero or one: `?`
    ZeroOrOne,
}

impl RepetitionKind {
    /// Get the repetition kind as a string.
    pub fn as_str(self) -> &str {
        match self {
            RepetitionKind::ZeroOrMore => "*",
            RepetitionKind::OneOrMore => "+",
            RepetitionKind::ZeroOrOne => "?",
        }
    }
}

/// Delimiter for macro invocations.
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum MacroDelimiter {
    /// Parentheses: `()`
    Paren,
    /// Brackets: `[]`
    Bracket,
    /// Braces: `{}`
    Brace,
}

impl MacroDelimiter {
    /// Get the opening delimiter.
    pub fn open(self) -> &str {
        match self {
            MacroDelimiter::Paren => "(",
            MacroDelimiter::Bracket => "[",
            MacroDelimiter::Brace => "{",
        }
    }

    /// Get the closing delimiter.
    pub fn close(self) -> &str {
        match self {
            MacroDelimiter::Paren => ")",
            MacroDelimiter::Bracket => "]",
            MacroDelimiter::Brace => "}",
        }
    }
}

/// A macro expansion template.
#[derive(Clone, PartialEq, Eq)]
pub struct MacroExpansion {
    /// Expansion parts.
    pub parts: Vec[MacroExpansionPart],
    /// Span of the expansion.
    pub span: Span,
}

/// A part of a macro expansion template.
#[derive(Clone, PartialEq, Eq)]
pub enum MacroExpansionPart {
    /// Literal tokens to emit.
    Tokens(Vec[MacroToken]),

    /// Substitution: `$name`
    Substitution {
        name: Ident,
        span: Span,
    },

    /// Repetition: `$(...)*`
    Repetition {
        parts: Vec[MacroExpansionPart],
        separator: Option[MacroToken],
        span: Span,
    },

    /// Delimited group.
    Group {
        delimiter: MacroDelimiter,
        parts: Vec[MacroExpansionPart],
        span: Span,
    },
}

/// A token for macro processing.
#[derive(Clone, PartialEq, Eq)]
pub struct MacroToken {
    /// The token kind.
    pub kind: TokenKind,
    /// Source span.
    pub span: Span,
    /// Hygiene context.
    pub hygiene: HygieneId,
}

/// Token kind placeholder (will reference lexer tokens).
pub type TokenKind = crate.compiler.lexer.TokenKind

/// Hygiene context identifier for macro expansion.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct HygieneId(pub U32)

impl HygieneId {
    /// Create a root hygiene context.
    pub fn root() -> HygieneId {
        HygieneId(0)
    }

    /// Create a new hygiene context.
    pub fn new(id: U32) -> HygieneId {
        HygieneId(id)
    }
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_declaration_span() {
    let fn_decl = FnDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Private,
        qualifiers: FnQualifiers::none(),
        name: Ident::dummy(),
        type_params: Option::None,
        params: Vec::new(),
        return_type: Option::None,
        effects: Option::None,
        where_clause: Option::None,
        body: Option::None,
        span: Span::new(0, 10),
    }

    let decl = Declaration::Function(fn_decl)
    assert(decl.span() == Span::new(0, 10))
}

#[test]
fn test_fn_qualifiers() {
    let none = FnQualifiers::none()
    assert(!none.any())

    let async_fn = FnQualifiers {
        is_const: false,
        is_async: true,
        is_unsafe: false,
    }
    assert(async_fn.any())
    assert(async_fn.is_async)
}

#[test]
fn test_struct_body_variants() {
    let unit = StructBody::Unit
    let tuple = StructBody::Tuple(Vec::new())
    let record = StructBody::Record(Vec::new())

    // Create struct decls to test is_* methods
    let unit_struct = StructDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Private,
        name: Ident::dummy(),
        type_params: Option::None,
        body: unit,
        span: Span::dummy(),
    }
    assert(unit_struct.is_unit())
}

#[test]
fn test_handler_kind() {
    assert(HandlerKind::Deep.as_str() == "deep")
    assert(HandlerKind::Shallow.as_str() == "shallow")
}

#[test]
fn test_impl_block_kind() {
    let inherent = ImplBlock {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        type_params: Option::None,
        trait_ty: Option::None,
        self_ty: Type::unit(Span::dummy()),
        where_clause: Option::None,
        items: Vec::new(),
        span: Span::dummy(),
    }
    assert(inherent.is_inherent())
    assert(!inherent.is_trait_impl())
}

#[test]
fn test_fragment_kind() {
    assert(FragmentKind::Expr.as_str() == "expr")
    assert(FragmentKind::from_str("ty") == Option::Some(FragmentKind::Ty))
    assert(FragmentKind::from_str("invalid").is_none())
}

#[test]
fn test_repetition_kind() {
    assert(RepetitionKind::ZeroOrMore.as_str() == "*")
    assert(RepetitionKind::OneOrMore.as_str() == "+")
    assert(RepetitionKind::ZeroOrOne.as_str() == "?")
}

#[test]
fn test_macro_delimiter() {
    assert(MacroDelimiter::Paren.open() == "(")
    assert(MacroDelimiter::Paren.close() == ")")
    assert(MacroDelimiter::Bracket.open() == "[")
    assert(MacroDelimiter::Bracket.close() == "]")
    assert(MacroDelimiter::Brace.open() == "{")
    assert(MacroDelimiter::Brace.close() == "}")
}

#[test]
fn test_param_qualifier() {
    assert(ParamQualifier::Linear.as_str() == "linear")
    assert(ParamQualifier::Affine.as_str() == "affine")
    assert(ParamQualifier::Mut.as_str() == "mut")
}

#[test]
fn test_mod_item_decl() {
    let external = ModItemDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Private,
        name: Ident::dummy(),
        body: Option::None,
        span: Span::dummy(),
    }
    assert(external.is_external())
    assert(!external.is_inline())

    let inline = ModItemDecl {
        id: NodeId::dummy(),
        attrs: Vec::new(),
        vis: Visibility::Private,
        name: Ident::dummy(),
        body: Option::Some(Vec::new()),
        span: Span::dummy(),
    }
    assert(!inline.is_external())
    assert(inline.is_inline())
}
