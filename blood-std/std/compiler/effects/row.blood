/// Effect Row Types
///
/// Implements row polymorphism for effect types. Effect rows are ordered sets
/// of effects with an optional row variable for polymorphism:
///
/// ```text
/// EffectRow ::= {} | {E, ...Es} | {E, ...Es | ρ}
/// ```
///
/// Where `ρ` is a row variable enabling effect polymorphism.
///
/// # Design References
///
/// - [Type Directed Compilation of Row-Typed Algebraic Effects](https://dl.acm.org/doi/10.1145/3093333.3009872) (POPL'17)
/// - [Generalized Evidence Passing for Effect Handlers](https://dl.acm.org/doi/10.1145/3473576) (ICFP'21)
/// - Koka's row-polymorphic effect system
///
/// # Row Polymorphism
///
/// Row polymorphism allows functions to be generic over unknown additional
/// effects. For example:
///
/// ```blood
/// // This function uses State, but callers may use additional effects
/// fn increment() / {State<i32> | ε} {
///     let x = get();
///     put(x + 1);
/// }
/// ```
///
/// The row variable `ε` represents any additional effects the caller might use.

use crate.compiler.typeck::types::{Type, DefId};

// ============================================================
// Row Variable
// ============================================================

/// A row variable for effect polymorphism.
///
/// Row variables enable functions to be polymorphic over unknown additional
/// effects. Each row variable has a unique ID for unification purposes.
pub struct RowVar {
    /// Unique identifier for this row variable.
    pub id: u32,
}

impl RowVar {
    /// Create a new row variable with the given ID.
    pub fn new(id: u32) -> RowVar {
        RowVar { id }
    }

    /// Get the row variable ID.
    pub fn id(&self) -> u32 {
        self.id
    }
}

impl Clone for RowVar {
    fn clone(&self) -> RowVar {
        RowVar { id: self.id }
    }
}

impl PartialEq for RowVar {
    fn eq(&self, other: &RowVar) -> bool {
        self.id == other.id;
    }
}

// ============================================================
// Effect Reference
// ============================================================

/// An effect reference with optional type arguments.
///
/// Effect references point to effect definitions and may include type
/// arguments for parameterized effects (e.g., `State<i32>`).
///
/// # Examples
///
/// - `State<i32>` - State effect with i32 state type
/// - `Error<String>` - Error effect with String error type
/// - `IO` - IO effect (no type arguments)
pub struct EffectRef {
    /// The effect definition ID.
    pub def_id: DefId,
    /// Type arguments for parameterized effects.
    pub type_args: [Type],
}

impl EffectRef {
    /// Create a new effect reference without type arguments.
    pub fn new(def_id: DefId) -> EffectRef {
        EffectRef {
            def_id,
            type_args: [],
        }
    }

    /// Create an effect reference with type arguments.
    pub fn with_args(def_id: DefId, type_args: [Type]) -> EffectRef {
        EffectRef { def_id, type_args }
    }

    /// Get the effect definition ID.
    pub fn def_id(&self) -> &DefId {
        &self.def_id
    }

    /// Get the type arguments.
    pub fn type_args(&self) -> &[Type] {
        &self.type_args
    }

    /// Check if this effect reference has type arguments.
    pub fn has_type_args(&self) -> bool {
        self.type_args.len() > 0
    }

    /// Check if two effect references are equal (ignoring type arguments).
    ///
    /// This is useful for handler matching where the handler handles all
    /// instantiations of an effect regardless of type arguments.
    pub fn same_effect(&self, other: &EffectRef) -> bool {
        self.def_id.eq(&other.def_id);
    }
}

impl Clone for EffectRef {
    fn clone(&self) -> EffectRef {
        EffectRef {
            def_id: self.def_id.clone(),
            type_args: self.type_args.clone(),
        }
    }
}

impl PartialEq for EffectRef {
    fn eq(&self, other: &EffectRef) -> bool {
        if !self.def_id.eq(&other.def_id) {
            return false;
        };
        if self.type_args.len() != other.type_args.len() {
            return false;
        }
        // For full equality, would need to compare type args
        // For now, just compare def_ids
        true
    }
}

// ============================================================
// Effect Row
// ============================================================

/// An effect row representing a set of effects.
///
/// Effect rows support row polymorphism through an optional row variable,
/// enabling functions to be polymorphic over unknown additional effects.
///
/// # Structure
///
/// An effect row consists of:
/// - A set of concrete effects (EffectRef instances)
/// - An optional row variable for polymorphism
///
/// # Examples
///
/// ```text
/// {}              - Pure (no effects)
/// {State<i32>}    - Only State effect
/// {State<i32> | ε} - State plus unknown effects ε
/// ```
pub struct EffectRow {
    /// The concrete effects in this row.
    effects: [EffectRef],
    /// Optional row variable for polymorphism.
    row_var: Option<RowVar>,
}

impl EffectRow {
    /// Create an empty effect row (pure).
    pub fn pure() -> EffectRow {
        EffectRow {
            effects: [],
            row_var: Option::None,
        }
    }

    /// Create an effect row with a single effect.
    pub fn single(effect: EffectRef) -> EffectRow {
        EffectRow {
            effects: [effect],
            row_var: Option::None,
        }
    }

    /// Create a polymorphic effect row with just a row variable.
    pub fn polymorphic(row_var: RowVar) -> EffectRow {
        EffectRow {
            effects: [],
            row_var: Option::Some(row_var),
        }
    }

    /// Create an effect row from a list of effects.
    pub fn new(effects: [EffectRef], row_var: Option<RowVar>) -> EffectRow {
        EffectRow { effects, row_var }
    }

    /// Add an effect to this row.
    pub fn add_effect(&mut self, effect: EffectRef) {
        // Check if effect already exists
        let mut i: usize = 0;
        while i < self.effects.len() {
            if self.effects[i].same_effect(&effect) {
                return; // Already present
            };
            i = i + 1;
        };
        self.effects.push(effect);
    }

    /// Set the row variable for polymorphism.
    pub fn set_row_var(&mut self, row_var: RowVar) {
        self.row_var = Option::Some(row_var);
    }

    /// Check if this row is pure (no effects and no row variable).
    pub fn is_pure(&self) -> bool {
        self.effects.len() == 0 && self.row_var.is_none();
    }

    /// Check if this row is closed (no row variable).
    pub fn is_closed(&self) -> bool {
        self.row_var.is_none();
    }

    /// Check if this row is polymorphic (has a row variable).
    pub fn is_polymorphic(&self) -> bool {
        self.row_var.is_some();
    }

    /// Get the concrete effects in this row.
    pub fn effects(&self) -> &[EffectRef] {
        &self.effects
    }

    /// Get the row variable if present.
    pub fn row_var(&self) -> Option<&RowVar> {
        self.row_var.as_ref();
    }

    /// Check if this row contains a specific effect (by DefId).
    pub fn contains(&self, effect_id: &DefId) -> bool {
        let mut i: usize = 0;
        while i < self.effects.len() {
            if self.effects[i].def_id.eq(effect_id) {
                return true;
            };
            i = i + 1;
        }
        false
    }

    /// Check if this row contains a specific effect reference.
    pub fn contains_effect(&self, effect: &EffectRef) -> bool {
        let mut i: usize = 0;
        while i < self.effects.len() {
            if self.effects[i].same_effect(effect) {
                return true;
            };
            i = i + 1;
        }
        false
    }

    /// Get the number of effects in this row.
    pub fn len(&self) -> usize {
        self.effects.len();
    }

    /// Extend this row with effects from another row.
    ///
    /// If either row has a row variable, the result will have a row variable.
    pub fn extend(&mut self, other: &EffectRow) {
        let mut i: usize = 0;
        while i < other.effects.len() {
            self.add_effect(other.effects[i].clone());
            i = i + 1;
        };
        // Take row variable from other if we don't have one
        if self.row_var.is_none() && other.row_var.is_some() {
            self.row_var = other.row_var.clone();
        }
    }

    /// Remove an effect from this row.
    ///
    /// Returns true if the effect was removed, false if not found.
    pub fn remove(&mut self, effect_id: &DefId) -> bool {
        let mut i: usize = 0;
        while i < self.effects.len() {
            if self.effects[i].def_id.eq(effect_id) {
                self.effects.remove(i);
                return true;
            };
            i = i + 1;
        }
        false
    }
}

impl Clone for EffectRow {
    fn clone(&self) -> EffectRow {
        EffectRow {
            effects: self.effects.clone(),
            row_var: self.row_var.clone(),
        }
    }
}

impl PartialEq for EffectRow {
    fn eq(&self, other: &EffectRow) -> bool {
        if self.effects.len() != other.effects.len() {
            return false;
        };
        // Check all effects in self are in other
        let mut i: usize = 0;
        while i < self.effects.len() {
            if !other.contains_effect(&self.effects[i]) {
                return false;
            };
            i = i + 1;
        };
        // Check row variables match
        match (&self.row_var, &other.row_var) {
            (Option::None, Option::None) => true,
            (Option::Some(v1), Option::Some(v2)) => v1.eq(v2),
            _ => false,
        }
    }
}

// ============================================================
// Effect Row Operations
// ============================================================

/// Check if two effect rows are compatible for unification.
///
/// Two effect rows are compatible if:
/// - They have the same concrete effects, OR
/// - At least one has a row variable (can extend to match)
pub fn rows_compatible(r1: &EffectRow, r2: &EffectRow) -> bool {
    // If both are closed, they must have the same effects
    if r1.is_closed() && r2.is_closed() {
        return r1.eq(r2);
    }

    // If one has a row variable, it can extend to match the other
    true
}

/// Compute the difference between two effect rows.
///
/// Returns the effects in `source` that are not in `target`.
pub fn row_difference(source: &EffectRow, target: &EffectRow) -> [EffectRef] {
    let mut diff: [EffectRef] = [];
    let mut i: usize = 0;
    while i < source.effects.len() {
        if !target.contains_effect(&source.effects[i]) {
            diff.push(source.effects[i].clone());
        };
        i = i + 1;
    }
    diff
}

/// Merge two effect rows, combining their effects.
///
/// The result has all effects from both rows. If either row has a
/// row variable, the result will be polymorphic.
pub fn merge_rows(r1: &EffectRow, r2: &EffectRow) -> EffectRow {
    let mut result = r1.clone();
    result.extend(r2);
    result
}

/// Check if one effect row is a subset of another.
///
/// A row R1 is a subset of R2 if every effect in R1 is also in R2.
/// Polymorphic rows (with row variables) can contain additional effects.
pub fn is_subset(subset: &EffectRow, superset: &EffectRow) -> bool {
    // If superset is polymorphic, it can contain any effects
    if superset.is_polymorphic() {
        return true;
    };

    // Check that every effect in subset is in superset
    let mut i: usize = 0;
    while i < subset.effects.len() {
        if !superset.contains_effect(&subset.effects[i]) {
            return false;
        };
        i = i + 1;
    }
    true
}

/// Compute the intersection of two effect rows.
///
/// Returns a row containing only effects present in both rows.
pub fn intersect_rows(r1: &EffectRow, r2: &EffectRow) -> EffectRow {
    let mut effects: [EffectRef] = [];
    let mut i: usize = 0;
    while i < r1.effects.len() {
        if r2.contains_effect(&r1.effects[i]) {
            effects.push(r1.effects[i].clone());
        };
        i = i + 1;
    };

    // Result is polymorphic only if both inputs are
    let row_var = match (&r1.row_var, &r2.row_var) {
        (Option::Some(v), _) => Option::Some(v.clone()),
        (_, Option::Some(v)) => Option::Some(v.clone()),
        _ => Option::None,
    };

    EffectRow::new(effects, row_var)
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_row_var() {
    let v1 = RowVar::new(0);
    let v2 = RowVar::new(1);
    let v1_clone = v1.clone();

    assert!(v1.id() == 0);
    assert!(v2.id() == 1);
    assert!(v1.eq(&v1_clone));
    assert!(!v1.eq(&v2));
}

#[test]
fn test_effect_ref() {
    let def1 = DefId::new(1);
    let def2 = DefId::new(2);

    let e1 = EffectRef::new(def1.clone());
    let e2 = EffectRef::new(def1.clone());
    let e3 = EffectRef::new(def2);

    assert!(e1.same_effect(&e2));
    assert!(!e1.same_effect(&e3));
    assert!(!e1.has_type_args());
}

#[test]
fn test_effect_ref_with_args() {
    let def = DefId::new(1);
    let args = [Type::i32()];
    let e = EffectRef::with_args(def, args);

    assert!(e.has_type_args());
    assert!(e.type_args().len() == 1);
}

#[test]
fn test_effect_row_pure() {
    let row = EffectRow::pure();

    assert!(row.is_pure());
    assert!(row.is_closed());
    assert!(!row.is_polymorphic());
    assert!(row.len() == 0);
}

#[test]
fn test_effect_row_single() {
    let effect = EffectRef::new(DefId::new(1));
    let row = EffectRow::single(effect);

    assert!(!row.is_pure());
    assert!(row.is_closed());
    assert!(row.len() == 1);
}

#[test]
fn test_effect_row_polymorphic() {
    let row_var = RowVar::new(0);
    let row = EffectRow::polymorphic(row_var);

    assert!(row.is_pure()); // No concrete effects
    assert!(!row.is_closed());
    assert!(row.is_polymorphic());
}

#[test]
fn test_effect_row_add() {
    let mut row = EffectRow::pure();
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));

    row.add_effect(e1.clone());
    assert!(row.len() == 1);

    row.add_effect(e2);
    assert!(row.len() == 2);

    // Adding duplicate should not increase size
    row.add_effect(e1);
    assert!(row.len() == 2);
}

#[test]
fn test_effect_row_contains() {
    let def1 = DefId::new(1);
    let def2 = DefId::new(2);
    let def3 = DefId::new(3);

    let mut row = EffectRow::pure();
    row.add_effect(EffectRef::new(def1.clone()));
    row.add_effect(EffectRef::new(def2.clone()));

    assert!(row.contains(&def1));
    assert!(row.contains(&def2));
    assert!(!row.contains(&def3));
}

#[test]
fn test_effect_row_extend() {
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));

    let mut row1 = EffectRow::single(e1);
    let row2 = EffectRow::single(e2);

    row1.extend(&row2);

    assert!(row1.len() == 2);
}

#[test]
fn test_effect_row_remove() {
    let def1 = DefId::new(1);
    let def2 = DefId::new(2);

    let mut row = EffectRow::pure();
    row.add_effect(EffectRef::new(def1.clone()));
    row.add_effect(EffectRef::new(def2.clone()));

    assert!(row.len() == 2);
    assert!(row.remove(&def1));
    assert!(row.len() == 1);
    assert!(!row.contains(&def1));
    assert!(row.contains(&def2));
}

#[test]
fn test_rows_compatible() {
    let e1 = EffectRef::new(DefId::new(1));

    let row1 = EffectRow::single(e1.clone());
    let row2 = EffectRow::single(e1.clone());
    let row3 = EffectRow::polymorphic(RowVar::new(0));

    assert!(rows_compatible(&row1, &row2));
    assert!(rows_compatible(&row1, &row3));
    assert!(rows_compatible(&row3, &row1));
}

#[test]
fn test_row_difference() {
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));
    let e3 = EffectRef::new(DefId::new(3));

    let mut source = EffectRow::pure();
    source.add_effect(e1.clone());
    source.add_effect(e2.clone());
    source.add_effect(e3);

    let target = EffectRow::single(e1);

    let diff = row_difference(&source, &target);
    assert!(diff.len() == 2);
}

#[test]
fn test_merge_rows() {
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));

    let row1 = EffectRow::single(e1);
    let row2 = EffectRow::single(e2);

    let merged = merge_rows(&row1, &row2);
    assert!(merged.len() == 2);
}

#[test]
fn test_is_subset() {
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));

    let subset = EffectRow::single(e1.clone());
    let mut superset = EffectRow::pure();
    superset.add_effect(e1);
    superset.add_effect(e2);

    assert!(is_subset(&subset, &superset));
    assert!(!is_subset(&superset, &subset));
}

#[test]
fn test_intersect_rows() {
    let e1 = EffectRef::new(DefId::new(1));
    let e2 = EffectRef::new(DefId::new(2));
    let e3 = EffectRef::new(DefId::new(3));

    let mut row1 = EffectRow::pure();
    row1.add_effect(e1.clone());
    row1.add_effect(e2.clone());

    let mut row2 = EffectRow::pure();
    row2.add_effect(e2.clone());
    row2.add_effect(e3);

    let intersection = intersect_rows(&row1, &row2);
    assert!(intersection.len() == 1);
    assert!(intersection.contains(&DefId::new(2)));
}
