/// Effect Lowering
///
/// Translates effectful HIR to effect-free code via evidence passing.
///
/// # Translation Process
///
/// The effect lowering pass transforms effectful code by:
///
/// 1. Adding evidence parameters to effectful functions
/// 2. Replacing `perform` operations with evidence lookups
/// 3. Transforming `with...handle` blocks into handler invocations
/// 4. Applying tail-resumptive optimizations where applicable
///
/// # Technical Approach
///
/// Based on [Generalized Evidence Passing for Effect Handlers](https://dl.acm.org/doi/10.1145/3473576)
/// (ICFP'21) and [Efficient Compilation of Algebraic Effect Handlers](https://dl.acm.org/doi/10.1145/3485479)
/// (OOPSLA'21).
///
/// # Example Translation
///
/// ```text
/// // Before lowering
/// fn counter() / {State<i32>} -> i32 {
///     let x = get();
///     put(x + 1);
///     get()
/// }
///
/// // After lowering (conceptually)
/// fn counter(ev: Evidence) -> i32 {
///     let x = ev.state.get();
///     ev.state.put(x + 1);
///     ev.state.get()
/// }
/// ```
///
/// # Effect Declaration Lowering
///
/// Effect declarations are lowered to operation tables for evidence lookup:
///
/// ```text
/// // Source
/// effect State<T> {
///     fn get() -> T
///     fn put(value: T) -> ()
/// }
///
/// // Lowered to operation table
/// EffectInfo {
///     def_id: ...,
///     name: "State",
///     type_params: ["T"],
///     operations: [
///         OperationInfo { name: "get", params: [], return_ty: T },
///         OperationInfo { name: "put", params: [T], return_ty: () },
///     ],
/// }
/// ```

use crate.compiler.typeck::types::{Type, DefId, Generics};
use crate.compiler.hir::{Item, ItemKind, Span};
use crate.compiler.effects::row::{EffectRef, EffectRow};
use crate.compiler.effects::evidence::{EvidenceVector, EvidenceContext};
use crate.compiler.effects::handler::{HandlerKind, Handler, analyze_tail_resumptive, count_resumes};
use std.collections::HashMap;

// ============================================================
// Effect Info
// ============================================================

/// Complete information about an effect declaration.
pub struct EffectInfo {
    /// The effect's definition ID.
    pub def_id: DefId,
    /// Effect name.
    pub name: String,
    /// Type parameters (e.g., T in State<T>).
    pub generics: Option<Generics>,
    /// Effects this effect extends (inheritance).
    pub extends: [DefId],
    /// Operations defined by this effect.
    pub operations: [OperationInfo],
    /// Evidence index in the evidence vector.
    pub evidence_index: Option<usize>,
}

impl EffectInfo {
    /// Create a new effect info.
    pub fn new(def_id: DefId, name: String) -> EffectInfo {
        EffectInfo {
            def_id,
            name,
            generics: Option::None,
            extends: [],
            operations: [],
            evidence_index: Option::None,
        }
    }

    /// Set the generics.
    pub fn set_generics(&mut self, generics: Generics) {
        self.generics = Option::Some(generics);
    }

    /// Add an operation.
    pub fn add_operation(&mut self, op: OperationInfo) {
        self.operations.push(op);
    }

    /// Find an operation by name.
    pub fn find_operation(&self, name: &str) -> Option<&OperationInfo> {
        let mut i: usize = 0;
        while i < self.operations.len() {
            if self.operations[i].name == name {
                return Option::Some(&self.operations[i]);
            };
            i = i + 1;
        }
        Option::None
    }

    /// Get the number of operations.
    pub fn operation_count(&self) -> usize {
        self.operations.len();
    }
}

impl Clone for EffectInfo {
    fn clone(&self) -> EffectInfo {
        EffectInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            generics: self.generics.clone(),
            extends: self.extends.clone(),
            operations: self.operations.clone(),
            evidence_index: self.evidence_index,
        }
    }
}

// ============================================================
// Operation Info
// ============================================================

/// Information about an effect operation.
pub struct OperationInfo {
    /// The operation DefId.
    pub def_id: DefId,
    /// Operation name.
    pub name: String,
    /// Parameter types.
    pub params: [Type],
    /// Return type.
    pub return_ty: Type,
    /// Index within the effect's operation table.
    pub op_index: usize,
}

impl OperationInfo {
    /// Create a new operation info.
    pub fn new(def_id: DefId, name: String, params: [Type], return_ty: Type, op_index: usize) -> OperationInfo {
        OperationInfo {
            def_id,
            name,
            params,
            return_ty,
            op_index,
        }
    }
}

impl Clone for OperationInfo {
    fn clone(&self) -> OperationInfo {
        OperationInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            params: self.params.clone(),
            return_ty: self.return_ty.clone(),
            op_index: self.op_index,
        }
    }
}

// ============================================================
// Evidence Requirement
// ============================================================

/// Evidence requirement for a function.
pub struct EvidenceRequirement {
    /// Effects that require evidence.
    pub effects: [DefId],
    /// Whether the function is polymorphic in effects.
    pub polymorphic: bool,
    /// The effect row for this function.
    pub effect_row: Option<EffectRow>,
}

impl EvidenceRequirement {
    /// Create a new evidence requirement.
    pub fn new() -> EvidenceRequirement {
        EvidenceRequirement {
            effects: [],
            polymorphic: false,
            effect_row: Option::None,
        }
    }

    /// Create a requirement from an effect row.
    pub fn from_row(row: &EffectRow) -> EvidenceRequirement {
        let mut effects: [DefId] = [];
        let effect_refs = row.effects();
        let mut i: usize = 0;
        while i < effect_refs.len() {
            effects.push(effect_refs[i].def_id.clone());
            i = i + 1;
        }
        EvidenceRequirement {
            effects,
            polymorphic: row.is_polymorphic(),
            effect_row: Option::Some(row.clone()),
        }
    }

    /// Add an effect requirement.
    pub fn add_effect(&mut self, effect_id: DefId) {
        self.effects.push(effect_id);
    }

    /// Check if this requirement is empty (pure function).
    pub fn is_empty(&self) -> bool {
        self.effects.len() == 0 && !self.polymorphic
    }

    /// Check if evidence is needed.
    pub fn needs_evidence(&self) -> bool {
        !self.is_empty()
    }
}

impl Clone for EvidenceRequirement {
    fn clone(&self) -> EvidenceRequirement {
        EvidenceRequirement {
            effects: self.effects.clone(),
            polymorphic: self.polymorphic,
            effect_row: self.effect_row.clone(),
        }
    }
}

// ============================================================
// Handler Info
// ============================================================

/// Compiled handler information.
pub struct HandlerInfo {
    /// Handler definition ID.
    pub def_id: DefId,
    /// Handler name.
    pub name: String,
    /// The effect being handled.
    pub effect_id: DefId,
    /// Handler kind (deep/shallow).
    pub kind: HandlerKind,
    /// Operation implementations.
    pub op_impls: [OpImplInfo],
    /// Whether all operations are tail-resumptive.
    pub all_tail_resumptive: bool,
}

impl HandlerInfo {
    /// Create a new handler info.
    pub fn new(def_id: DefId, name: String, effect_id: DefId, kind: HandlerKind) -> HandlerInfo {
        HandlerInfo {
            def_id,
            name,
            effect_id,
            kind,
            op_impls: [],
            all_tail_resumptive: true,
        }
    }

    /// Add an operation implementation.
    pub fn add_op_impl(&mut self, op: OpImplInfo) {
        if !op.is_tail_resumptive {
            self.all_tail_resumptive = false;
        };
        self.op_impls.push(op);
    }
}

impl Clone for HandlerInfo {
    fn clone(&self) -> HandlerInfo {
        HandlerInfo {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            effect_id: self.effect_id.clone(),
            kind: self.kind.clone(),
            op_impls: self.op_impls.clone(),
            all_tail_resumptive: self.all_tail_resumptive,
        }
    }
}

/// Information about an operation implementation in a handler.
pub struct OpImplInfo {
    /// The operation being implemented.
    pub operation_id: DefId,
    /// Operation name.
    pub name: String,
    /// Whether this implementation is tail-resumptive.
    pub is_tail_resumptive: bool,
    /// Number of resume calls in the implementation.
    pub resume_count: usize,
}

impl OpImplInfo {
    /// Create a new operation implementation info.
    pub fn new(operation_id: DefId, name: String) -> OpImplInfo {
        OpImplInfo {
            operation_id,
            name,
            is_tail_resumptive: false,
            resume_count: 0,
        }
    }

    /// Create a tail-resumptive implementation.
    pub fn tail_resumptive(operation_id: DefId, name: String) -> OpImplInfo {
        OpImplInfo {
            operation_id,
            name,
            is_tail_resumptive: true,
            resume_count: 1,
        }
    }
}

impl Clone for OpImplInfo {
    fn clone(&self) -> OpImplInfo {
        OpImplInfo {
            operation_id: self.operation_id.clone(),
            name: self.name.clone(),
            is_tail_resumptive: self.is_tail_resumptive,
            resume_count: self.resume_count,
        }
    }
}

// ============================================================
// Lowering Error
// ============================================================

/// Error from effect lowering.
pub struct LoweringError {
    /// Error message.
    pub message: String,
    /// Source location.
    pub span: Span,
    /// Whether this is an internal compiler error.
    pub is_ice: bool,
}

impl LoweringError {
    /// Create a new lowering error.
    pub fn new(message: String, span: Span) -> LoweringError {
        LoweringError {
            message,
            span,
            is_ice: false,
        }
    }

    /// Create an internal compiler error.
    pub fn ice(message: String, span: Span) -> LoweringError {
        LoweringError {
            message,
            span,
            is_ice: true,
        }
    }
}

impl Clone for LoweringError {
    fn clone(&self) -> LoweringError {
        LoweringError {
            message: self.message.clone(),
            span: self.span.clone(),
            is_ice: self.is_ice,
        }
    }
}

// ============================================================
// Effect Lowering
// ============================================================

/// Effect lowering context.
///
/// Manages the translation of effectful HIR to effect-free code.
pub struct EffectLowering {
    /// Registered effect definitions.
    effects: HashMap<u32, EffectInfo>,
    /// Mapping from function DefId to its evidence requirements.
    evidence_reqs: HashMap<u32, EvidenceRequirement>,
    /// Mapping from handler DefId to its compiled form.
    handlers: HashMap<u32, HandlerInfo>,
    /// Counter for generating fresh variable names.
    fresh_counter: u64,
    /// Accumulated errors.
    errors: [LoweringError],
}

impl EffectLowering {
    /// Create a new effect lowering context.
    pub fn new() -> EffectLowering {
        EffectLowering {
            effects: HashMap::new(),
            evidence_reqs: HashMap::new(),
            handlers: HashMap::new(),
            fresh_counter: 0,
            errors: [],
        }
    }

    // ========================================================================
    // Effect Registration
    // ========================================================================

    /// Register an effect.
    pub fn register_effect(&mut self, info: EffectInfo) {
        self.effects.insert(info.def_id.index, info);
    }

    /// Get effect info by DefId.
    pub fn get_effect(&self, effect_id: &DefId) -> Option<&EffectInfo> {
        self.effects.get(&effect_id.index);
    }

    /// Check if an effect is registered.
    pub fn has_effect(&self, effect_id: &DefId) -> bool {
        self.effects.contains_key(&effect_id.index);
    }

    // ========================================================================
    // Handler Registration
    // ========================================================================

    /// Register a handler.
    pub fn register_handler(&mut self, info: HandlerInfo) {
        self.handlers.insert(info.def_id.index, info);
    }

    /// Get handler info by DefId.
    pub fn get_handler(&self, handler_id: &DefId) -> Option<&HandlerInfo> {
        self.handlers.get(&handler_id.index);
    }

    /// Find all handlers for a given effect.
    pub fn handlers_for_effect(&self, effect_id: &DefId) -> [&HandlerInfo] {
        let mut result: [&HandlerInfo] = [];
        for handler in self.handlers.values() {
            if handler.effect_id.eq(effect_id) {
                result.push(handler);
            }
        }
        result
    }

    // ========================================================================
    // Evidence Requirements
    // ========================================================================

    /// Register evidence requirements for a function.
    pub fn register_evidence(&mut self, def_id: &DefId, req: EvidenceRequirement) {
        self.evidence_reqs.insert(def_id.index, req);
    }

    /// Get evidence requirements for a function.
    pub fn get_evidence_req(&self, def_id: &DefId) -> Option<&EvidenceRequirement> {
        self.evidence_reqs.get(&def_id.index);
    }

    /// Check if a function requires evidence.
    pub fn requires_evidence(&self, def_id: &DefId) -> bool {
        match self.evidence_reqs.get(&def_id.index) {
            Option::Some(req) => req.needs_evidence(),
            Option::None => false,
        }
    }

    // ========================================================================
    // Effect Declaration Lowering
    // ========================================================================

    /// Lower an effect declaration item to EffectInfo.
    pub fn lower_effect_decl(&mut self, item: &Item) -> Option<EffectInfo> {
        match &item.kind {
            ItemKind::Effect { generics, operations } => {
                let mut info = EffectInfo::new(item.def_id.clone(), item.name.clone());
                info.set_generics(generics.clone());

                let mut i: usize = 0;
                while i < operations.len() {
                    let op = &operations[i];
                    let op_info = OperationInfo::new(
                        op.def_id.clone(),
                        op.name.clone(),
                        op.inputs.clone(),
                        op.output.clone(),
                        i,
                    );
                    info.add_operation(op_info);
                    i = i + 1;
                };

                self.register_effect(info.clone());
                Option::Some(info)
            }
            _ => Option::None,
        }
    }

    /// Lower a handler declaration item to HandlerInfo.
    pub fn lower_handler_decl(&mut self, item: &Item) -> Result<HandlerInfo, LoweringError> {
        match &item.kind {
            ItemKind::Handler { kind, effect, operations, return_clause: _, generics: _, state: _ } => {
                // Resolve the effect type to its DefId
                let effect_id = match self.resolve_effect_type(effect) {
                    Option::Some(id) => id,
                    Option::None => {
                        return Err(LoweringError::ice(
                            "Handler references unresolved effect type".to_string(),
                            item.span.clone(),
                        ));
                    }
                };

                // Convert handler kind
                let handler_kind = match kind {
                    crate.compiler.hir::HandlerKind::Deep => HandlerKind::Deep,
                    crate.compiler.hir::HandlerKind::Shallow => HandlerKind::Shallow,
                };

                let mut info = HandlerInfo::new(
                    item.def_id.clone(),
                    item.name.clone(),
                    effect_id,
                    handler_kind,
                );

                // Lower operation implementations
                let mut i: usize = 0;
                while i < operations.len() {
                    let op = &operations[i];
                    let op_impl = OpImplInfo::new(
                        op.def_id.clone(),
                        op.name.clone(),
                    );
                    info.add_op_impl(op_impl);
                    i = i + 1;
                };

                self.register_handler(info.clone());
                Ok(info)
            }
            _ => Err(LoweringError::new(
                "Expected handler item".to_string(),
                item.span.clone(),
            )),
        }
    }

    /// Resolve an effect type to its DefId.
    fn resolve_effect_type(&self, ty: &Type) -> Option<DefId> {
        match ty.kind() {
            crate.compiler.hir::TypeKind::Adt { def_id, type_args: _ } => {
                Option::Some(def_id.clone())
            }
            _ => Option::None,
        }
    }

    // ========================================================================
    // Evidence Building
    // ========================================================================

    /// Build evidence vector for a handler block.
    pub fn build_evidence(&self, effects: &[DefId]) -> Result<EvidenceVector, LoweringError> {
        let mut ev = EvidenceVector::new();
        let mut i: usize = 0;
        while i < effects.len() {
            let effect_id = &effects[i];
            let handlers = self.handlers_for_effect(effect_id);

            if handlers.len() == 0 {
                return Err(LoweringError::new(
                    format!("No handler found for effect {:?}", effect_id),
                    Span::dummy(),
                ));
            };

            let handler = handlers[0];
            ev.add(EffectRef::new(effect_id.clone()), handler.def_id.clone());
            i = i + 1;
        };
        Ok(ev)
    }

    /// Build evidence with specific handler assignments.
    pub fn build_evidence_with_handlers(
        &self,
        pairs: &[(DefId, DefId)],
    ) -> EvidenceVector {
        let mut ev = EvidenceVector::new();
        let mut i: usize = 0;
        while i < pairs.len() {
            let (effect_id, handler_id) = &pairs[i];
            ev.add(EffectRef::new(effect_id.clone()), handler_id.clone());
            i = i + 1;
        }
        ev
    }

    // ========================================================================
    // Utilities
    // ========================================================================

    /// Generate a fresh variable name.
    pub fn fresh_name(&mut self, prefix: &str) -> String {
        let id = self.fresh_counter;
        self.fresh_counter = self.fresh_counter + 1;
        format!("{}_{}", prefix, id)
    }

    /// Add an error.
    pub fn add_error(&mut self, error: LoweringError) {
        self.errors.push(error);
    }

    /// Check if there are any errors.
    pub fn has_errors(&self) -> bool {
        self.errors.len() > 0
    }

    /// Get all errors.
    pub fn errors(&self) -> &[LoweringError] {
        &self.errors
    }

    /// Get all registered effects.
    pub fn all_effects(&self) -> &HashMap<u32, EffectInfo> {
        &self.effects
    }

    /// Get all registered handlers.
    pub fn all_handlers(&self) -> &HashMap<u32, HandlerInfo> {
        &self.handlers
    }
}

impl Clone for EffectLowering {
    fn clone(&self) -> EffectLowering {
        EffectLowering {
            effects: self.effects.clone(),
            evidence_reqs: self.evidence_reqs.clone(),
            handlers: self.handlers.clone(),
            fresh_counter: self.fresh_counter,
            errors: self.errors.clone(),
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_effect_info() {
    let mut info = EffectInfo::new(DefId::new(1), "State".to_string());
    assert!(info.name == "State");
    assert!(info.operation_count() == 0);

    let op = OperationInfo::new(
        DefId::new(2),
        "get".to_string(),
        [],
        Type::i32(),
        0,
    );
    info.add_operation(op);
    assert!(info.operation_count() == 1);

    let found = info.find_operation("get");
    assert!(found.is_some());
}

#[test]
fn test_operation_info() {
    let op = OperationInfo::new(
        DefId::new(1),
        "put".to_string(),
        [Type::i32()],
        Type::unit(),
        0,
    );
    assert!(op.name == "put");
    assert!(op.params.len() == 1);
    assert!(op.op_index == 0);
}

#[test]
fn test_evidence_requirement() {
    let mut req = EvidenceRequirement::new();
    assert!(req.is_empty());
    assert!(!req.needs_evidence());

    req.add_effect(DefId::new(1));
    assert!(!req.is_empty());
    assert!(req.needs_evidence());
}

#[test]
fn test_evidence_requirement_from_row() {
    let effect = EffectRef::new(DefId::new(1));
    let row = EffectRow::single(effect);
    let req = EvidenceRequirement::from_row(&row);

    assert!(req.effects.len() == 1);
    assert!(!req.polymorphic);
}

#[test]
fn test_handler_info() {
    let mut info = HandlerInfo::new(
        DefId::new(1),
        "StateHandler".to_string(),
        DefId::new(2),
        HandlerKind::Deep,
    );

    assert!(info.all_tail_resumptive);

    let op = OpImplInfo::new(DefId::new(3), "get".to_string());
    info.add_op_impl(op);

    // Non-tail-resumptive op makes handler non-tail-resumptive
    assert!(!info.all_tail_resumptive);
}

#[test]
fn test_op_impl_info() {
    let op = OpImplInfo::new(DefId::new(1), "get".to_string());
    assert!(!op.is_tail_resumptive);
    assert!(op.resume_count == 0);

    let tail_op = OpImplInfo::tail_resumptive(DefId::new(2), "put".to_string());
    assert!(tail_op.is_tail_resumptive);
    assert!(tail_op.resume_count == 1);
}

#[test]
fn test_effect_lowering() {
    let mut lowering = EffectLowering::new();
    assert!(!lowering.has_errors());

    let info = EffectInfo::new(DefId::new(1), "Test".to_string());
    lowering.register_effect(info);
    assert!(lowering.has_effect(&DefId::new(1)));
    assert!(!lowering.has_effect(&DefId::new(2)));
}

#[test]
fn test_effect_lowering_handlers() {
    let mut lowering = EffectLowering::new();

    let handler = HandlerInfo::new(
        DefId::new(10),
        "TestHandler".to_string(),
        DefId::new(1),
        HandlerKind::Deep,
    );
    lowering.register_handler(handler);

    let handlers = lowering.handlers_for_effect(&DefId::new(1));
    assert!(handlers.len() == 1);

    let handlers2 = lowering.handlers_for_effect(&DefId::new(2));
    assert!(handlers2.len() == 0);
}

#[test]
fn test_effect_lowering_evidence() {
    let mut lowering = EffectLowering::new();

    let effect = EffectInfo::new(DefId::new(1), "State".to_string());
    lowering.register_effect(effect);

    let handler = HandlerInfo::new(
        DefId::new(10),
        "StateHandler".to_string(),
        DefId::new(1),
        HandlerKind::Deep,
    );
    lowering.register_handler(handler);

    let effects = [DefId::new(1)];
    let result = lowering.build_evidence(&effects);
    assert!(result.is_ok());
    match result {
        Ok(ev) => assert!(ev.len() == 1),
        Err(_) => assert!(false),
    }
}

#[test]
fn test_fresh_name() {
    let mut lowering = EffectLowering::new();
    let name1 = lowering.fresh_name("ev");
    let name2 = lowering.fresh_name("ev");

    assert!(name1 != name2);
}

#[test]
fn test_lowering_error() {
    let err = LoweringError::new("test error".to_string(), Span::dummy());
    assert!(!err.is_ice);

    let ice = LoweringError::ice("internal error".to_string(), Span::dummy());
    assert!(ice.is_ice);
}
