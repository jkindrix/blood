//! # Effects System
//!
//! This module implements Blood's algebraic effects system based on evidence passing.
//!
//! ## Design Overview
//!
//! Blood's effect system is based on research from:
//! - [Type Directed Compilation of Row-Typed Algebraic Effects](https://dl.acm.org/doi/10.1145/3093333.3009872) (POPL'17)
//! - [Generalized Evidence Passing for Effect Handlers](https://dl.acm.org/doi/10.1145/3473576) (ICFP'21)
//! - [Lexical Effect Handlers, Directly](https://dl.acm.org/doi/10.1145/3689770) (OOPSLA'24)
//! - [Zero-Overhead Lexical Effect Handlers](https://doi.org/10.1145/3763177) (OOPSLA'25)
//! - [Parallel Algebraic Effect Handlers](https://icfp24.sigplan.org/details/icfp-2024-papers/27/Parallel-Algebraic-Effect-Handlers) (ICFP'24)
//! - [Optimize Effect Handling for Tail-resumption with Stack Unwinding](https://dl.acm.org/doi/10.1145/3732771.3742721) (SLE'25)
//!
//! ## Key Optimizations
//!
//! ### Tail-Resumptive Handlers
//!
//! Most handlers in practice are "tail-resumptive" (resume exactly once in tail position).
//! These are optimized to avoid continuation capture, achieving up to 150M ops/sec
//! (per SLE'25 research). Common examples: State, Reader, Writer effects.
//!
//! ### Lexical Scoping
//!
//! Blood uses lexically scoped handlers (per OOPSLA'24/25) which enable:
//! - Local reasoning about handler behavior
//! - Zero-overhead implementation when no effects raised
//! - Type-directed stack walking for handler lookup
//!
//! ### Static Evidence Optimization
//!
//! When handlers have stateless or constant state, evidence can be pre-allocated
//! at compile time, eliminating runtime allocation and O(1) handler lookup.
//!
//! ## Implementation Strategy
//!
//! Effects are compiled using **evidence passing**:
//!
//! ```text
//! // Source (with effects)
//! fn increment() / {State<i32>} {
//!     let x = get()
//!     put(x + 1)
//! }
//!
//! // After evidence translation
//! fn increment(ev: Evidence<State<i32>>) {
//!     let x = ev.get()
//!     ev.put(x + 1)
//! }
//! ```
//!
//! ## Module Structure
//!
//! - [`row`] - Effect row types and row polymorphism
//! - [`evidence`] - Evidence vectors and evidence passing
//! - [`handler`] - Handler compilation and continuation capture
//! - [`lowering`] - HIR to effect-free translation
//! - [`infer`] - Effect inference for automatic effect signatures
//! - [`std_effects`] - Standard effects (State, Error, IO, Console)
//!
//! ## Implementation Status
//!
//! | Phase | Description | Status |
//! |-------|-------------|--------|
//! | 2.1 | Basic evidence passing | Complete |
//! | 2.2 | Tail-resumptive optimization | Complete |
//! | 2.3 | Segmented stack continuations | Pending |
//! | 2.4 | Evidence fusion optimization | Pending |
//! | 2.5 | Zero-overhead lexical handlers | Future |
//! | 2.6 | Parallel effect handlers | Future |

// ============================================================================
// Submodule Declarations
// ============================================================================

pub mod row;
pub mod evidence;
pub mod handler;
pub mod infer;
pub mod lowering;
pub mod std_effects;

// ============================================================================
// Re-exports: Row Types
// ============================================================================

/// Effect row types for effect polymorphism.
pub use row::{
    // Core types
    RowVar,
    EffectRef,
    EffectRow,

    // Utility functions
    rows_compatible,
    row_difference,
    merge_rows,
    is_subset,
    intersect_rows,
};

// ============================================================================
// Re-exports: Evidence Passing
// ============================================================================

/// Evidence passing infrastructure for effect compilation.
pub use evidence::{
    // Runtime evidence
    EvidenceEntry,
    EvidenceVector,
    Evidence,

    // Translation
    TranslatedOp,
    EvidenceContext,

    // Caching
    HandlerPattern,
    EvidenceCache,
    CacheStats,

    // Static evidence optimization
    StaticEvidenceId,
    HandlerStateKind,
    StaticEvidenceEntry,
    StaticEvidence,
    StaticEvidenceRegistry,
};

// ============================================================================
// Re-exports: Handler Compilation
// ============================================================================

/// Handler compilation and continuation capture.
pub use handler::{
    // Handler types
    HandlerKind,
    ResumeMode,
    HandlerState,
    OperationImpl,
    ReturnClause,
    Handler,

    // Continuation
    Continuation,

    // Analysis functions
    analyze_tail_resumptive,
    count_resumes,
    analyze_resume_mode,
};

// ============================================================================
// Re-exports: Effect Inference
// ============================================================================

/// Effect inference for automatic signatures.
pub use infer::{
    // Context types
    InferenceContext,
    EffectInferencer,
    InferenceResult,

    // Convenience functions
    infer_effects,
    verify_effects_subset,

    // Extended inference
    DetailedEffectInferencer,
};

// ============================================================================
// Re-exports: Effect Lowering
// ============================================================================

/// Effect lowering coordinator.
pub use lowering::{
    // Info types
    EffectInfo,
    OperationInfo,
    EvidenceRequirement,
    HandlerInfo,
    OpImplInfo,

    // Error handling
    LoweringError,

    // Main coordinator
    EffectLowering,
};

// ============================================================================
// Re-exports: Standard Effects
// ============================================================================

/// Standard effects library.
pub use std_effects::{
    // Well-known effect IDs
    STATE_EFFECT_ID,
    ERROR_EFFECT_ID,
    IO_EFFECT_ID,
    CONSOLE_EFFECT_ID,
    STALE_REFERENCE_EFFECT_ID,

    // Operation indices
    state_ops,
    error_ops,
    io_ops,
    console_ops,
    stale_ref_ops,

    // State effect
    StateEffect,
    StateHandler,

    // Error effect
    ExceptionInfo,
    Exception,
    ErrorEffect,
    ErrorHandler,

    // IO effects
    IOEffect,
    ConsoleEffect,
    StaleReferenceEffect,

    // Registry
    StandardEffects,
    EffectTypeBuilder,
    DefaultHandlers,

    // Subsumption
    effect_subsumes,
    common_supereffect,
};

// ============================================================================
// High-Level API
// ============================================================================

use std::collections::HashMap;
use super::hir::{DefId, Body};

/// Effect compilation context that coordinates all effect-related operations.
///
/// This is the main entry point for effect system functionality.
pub struct EffectSystem {
    /// Effect lowering coordinator.
    lowering: EffectLowering,
    /// Standard effects registry.
    std_effects: StandardEffects,
    /// Evidence cache for handler reuse.
    cache: EvidenceCache,
    /// Static evidence registry.
    static_evidence: StaticEvidenceRegistry,
}

impl EffectSystem {
    /// Create a new effect system with standard effects enabled.
    pub fn new() -> EffectSystem {
        EffectSystem {
            lowering: EffectLowering::new(),
            std_effects: StandardEffects::all(),
            cache: EvidenceCache::new(),
            static_evidence: StaticEvidenceRegistry::new(),
        }
    }

    /// Create a pure effect system (no standard effects).
    pub fn pure() -> EffectSystem {
        EffectSystem {
            lowering: EffectLowering::new(),
            std_effects: StandardEffects::pure(),
            cache: EvidenceCache::new(),
            static_evidence: StaticEvidenceRegistry::new(),
        }
    }

    /// Infer effects for a function body.
    pub fn infer_body_effects(&self, body: &Body) -> EffectRow {
        infer_effects(body)
    }

    /// Register an effect definition.
    pub fn register_effect(
        &mut self,
        def_id: DefId,
        name: String,
        operations: [OperationInfo],
    ) {
        self.lowering.register_effect(def_id, name, operations);
    }

    /// Register a handler for an effect.
    pub fn register_handler(
        &mut self,
        handler_id: u64,
        effect_id: DefId,
        kind: HandlerKind,
    ) {
        self.lowering.register_handler(handler_id, effect_id, kind);
    }

    /// Analyze if a handler is tail-resumptive.
    pub fn is_handler_tail_resumptive(&self, handler_id: u64) -> bool {
        self.lowering.is_tail_resumptive(handler_id);
    }

    /// Get the evidence requirement for a function.
    pub fn get_evidence_requirement(&self, fn_id: DefId) -> Option<&EvidenceRequirement> {
        self.lowering.get_evidence_requirement(fn_id);
    }

    /// Check if a DefId is a standard effect.
    pub fn is_standard_effect(&self, def_id: DefId) -> bool {
        StandardEffects::is_standard_effect(def_id)
    }

    /// Get the name of a standard effect.
    pub fn standard_effect_name(&self, def_id: DefId) -> Option<String> {
        StandardEffects::effect_name(def_id)
    }

    /// Get cache statistics.
    pub fn cache_stats(&self) -> CacheStats {
        self.cache.stats();
    }

    /// Clear the evidence cache.
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }

    /// Get any lowering errors.
    pub fn errors(&self) -> &[LoweringError] {
        self.lowering.errors();
    }

    /// Check if there are any lowering errors.
    pub fn has_errors(&self) -> bool {
        !self.lowering.errors().is_empty()
    }

    /// Get a reference to the lowering coordinator.
    pub fn lowering(&self) -> &EffectLowering {
        &self.lowering
    }

    /// Get a mutable reference to the lowering coordinator.
    pub fn lowering_mut(&mut self) -> &mut EffectLowering {
        &mut self.lowering
    }

    /// Get a reference to the static evidence registry.
    pub fn static_evidence(&self) -> &StaticEvidenceRegistry {
        &self.static_evidence
    }

    /// Get a mutable reference to the static evidence registry.
    pub fn static_evidence_mut(&mut self) -> &mut StaticEvidenceRegistry {
        &mut self.static_evidence
    }
}

// ============================================================================
// Prelude for Common Use
// ============================================================================

/// Commonly used types and functions for working with effects.
///
/// Usage:
/// ```
/// use std::compiler::effects::prelude::*;
/// ```
pub mod prelude {
    pub use super::{
        // Row types
        EffectRow,
        EffectRef,
        RowVar,

        // Evidence
        Evidence,
        EvidenceVector,
        EvidenceContext,

        // Handlers
        Handler,
        HandlerKind,
        ResumeMode,

        // Inference
        infer_effects,
        verify_effects_subset,

        // Standard effects
        StateEffect,
        ErrorEffect,
        IOEffect,
        ConsoleEffect,
        StandardEffects,

        // High-level API
        EffectSystem,
    };
}
