/// Effect Inference
///
/// Implements automatic effect signature inference for Blood functions.
///
/// # Overview
///
/// When a function doesn't have an explicit effect annotation, the effect
/// inferencer traverses the function body to determine which effects are
/// actually performed. This enables ergonomic effect usage while maintaining
/// type safety.
///
/// # Algorithm
///
/// 1. Traverse the function body (HIR)
/// 2. Collect all `perform` operations
/// 3. Track handlers that reduce (handle) effects
/// 4. Compute the minimal effect row: performed - handled
///
/// # Effect Polymorphism
///
/// Effect inference also handles row polymorphism by detecting:
/// - Calls to functions with polymorphic effect signatures
/// - Higher-order functions that may propagate caller effects
///
/// # Example
///
/// ```text
/// // No effect annotation - effects inferred
/// fn counter() -> i32 {
///     let x = get();     // Perform State.get
///     put(x + 1);        // Perform State.put
///     get()              // Perform State.get
/// }
///
/// // Inferred effect row: {State<i32>}
/// ```
///
/// # Handler Reduction
///
/// ```text
/// fn safe_divide(x: i32, y: i32) -> Option<i32> {
///     handle {
///         if y == 0 {
///             throw();    // Perform Error.throw
///         } else {
///             x / y
///         }
///     } with ErrorHandler
/// }
///
/// // The handler handles Error, so inferred effects: {} (pure)
/// ```

use crate.compiler.typeck::types::DefId;
use crate.compiler.hir::{Body, Expr, ExprKind, Stmt};
use crate.compiler.effects::row::{EffectRef, EffectRow, RowVar};
use std.collections::HashSet;

// ============================================================
// Inference Context
// ============================================================

/// Context for tracking effect information during inference.
pub struct InferenceContext {
    /// Effects that are performed in the current scope.
    performed: [EffectRef],
    /// Effect DefIds that are handled in the current scope.
    handled: HashSet<u32>,
    /// Whether this function may be row-polymorphic.
    is_polymorphic: bool,
    /// Row variable for polymorphism (if applicable).
    row_var: Option<RowVar>,
}

impl InferenceContext {
    /// Create a new empty inference context.
    pub fn new() -> InferenceContext {
        InferenceContext {
            performed: [],
            handled: HashSet::new(),
            is_polymorphic: false,
            row_var: Option::None,
        }
    }

    /// Add a performed effect.
    pub fn add_performed(&mut self, effect: EffectRef) {
        // Check if already present
        let mut i: usize = 0;
        while i < self.performed.len() {
            if self.performed[i].same_effect(&effect) {
                return;
            };
            i = i + 1;
        };
        self.performed.push(effect);
    }

    /// Mark an effect as handled.
    pub fn add_handled(&mut self, effect_id: &DefId) {
        self.handled.insert(effect_id.index);
    }

    /// Check if an effect is handled.
    pub fn is_handled(&self, effect_id: &DefId) -> bool {
        self.handled.contains(&effect_id.index);
    }

    /// Set this context as polymorphic.
    pub fn set_polymorphic(&mut self) {
        self.is_polymorphic = true;
    }

    /// Check if polymorphic.
    pub fn is_polymorphic(&self) -> bool {
        self.is_polymorphic
    }

    /// Set the row variable.
    pub fn set_row_var(&mut self, row_var: RowVar) {
        self.row_var = Option::Some(row_var);
    }

    /// Get performed effects.
    pub fn performed(&self) -> &[EffectRef] {
        &self.performed
    }

    /// Get handled effect IDs.
    pub fn handled(&self) -> &HashSet<u32> {
        &self.handled
    }

    /// Merge effects from a child context.
    ///
    /// Effects performed in the child that are not handled propagate up.
    pub fn merge_child(&mut self, child: &InferenceContext) {
        let mut i: usize = 0;
        while i < child.performed.len() {
            let effect = &child.performed[i];
            if !child.is_handled(&effect.def_id) && !self.is_handled(&effect.def_id) {
                self.add_performed(effect.clone());
            };
            i = i + 1;
        };

        if child.is_polymorphic {
            self.is_polymorphic = true;
        }
    }
}

impl Clone for InferenceContext {
    fn clone(&self) -> InferenceContext {
        InferenceContext {
            performed: self.performed.clone(),
            handled: self.handled.clone(),
            is_polymorphic: self.is_polymorphic,
            row_var: self.row_var.clone(),
        }
    }
}

// ============================================================
// Effect Inferencer
// ============================================================

/// Effect inferencer that traverses HIR to collect performed effects.
pub struct EffectInferencer {
    /// Counter for generating fresh row variables.
    row_var_counter: u32,
}

impl EffectInferencer {
    /// Create a new effect inferencer.
    pub fn new() -> EffectInferencer {
        EffectInferencer {
            row_var_counter: 0,
        }
    }

    /// Generate a fresh row variable for effect polymorphism.
    pub fn fresh_row_var(&mut self) -> RowVar {
        let var = RowVar::new(self.row_var_counter);
        self.row_var_counter = self.row_var_counter + 1;
        var
    }

    /// Infer the effect row for a function body.
    ///
    /// This is the main entry point for effect inference.
    pub fn infer_effects(&mut self, body: &Body) -> EffectRow {
        let mut ctx = InferenceContext::new();
        self.infer_expr(&body.expr, &mut ctx);
        self.build_effect_row(&ctx);
    }

    /// Infer effects from an expression.
    fn infer_expr(&mut self, expr: &Expr, ctx: &mut InferenceContext) {
        match &expr.kind {
            // Effect operations - the core of effect inference
            ExprKind::Perform { effect_id, op_index: _, args } => {
                let effect_ref = EffectRef::new(effect_id.clone());
                ctx.add_performed(effect_ref);

                // Infer effects in arguments
                let mut i: usize = 0;
                while i < args.len() {
                    self.infer_expr(&args[i], ctx);
                    i = i + 1;
                }
            }

            // Handle expressions reduce (handle) effects
            ExprKind::Handle { body, handler_id, handler_instance } => {
                // Create a child context for the handled body
                let mut child_ctx = InferenceContext::new();
                self.infer_expr(body, &mut child_ctx);

                // Mark the handler's effect as handled
                ctx.add_handled(handler_id);

                // Merge child effects (unhandled ones propagate up)
                ctx.merge_child(&child_ctx);

                // Infer effects in the handler instance
                self.infer_expr(handler_instance, ctx);
            }

            // Inline handle expressions
            ExprKind::InlineHandle { body, handlers } => {
                let mut child_ctx = InferenceContext::new();
                self.infer_expr(body, &mut child_ctx);

                // Mark all handled effects
                let mut i: usize = 0;
                while i < handlers.len() {
                    ctx.add_handled(&handlers[i].effect_id);
                    i = i + 1;
                };

                // Merge child effects
                ctx.merge_child(&child_ctx);

                // Infer effects in handler bodies
                i = 0;
                while i < handlers.len() {
                    self.infer_expr(&handlers[i].body, ctx);
                    i = i + 1;
                }
            }

            // Block expressions
            ExprKind::Block { stmts, expr: tail } => {
                let mut i: usize = 0;
                while i < stmts.len() {
                    self.infer_stmt(&stmts[i], ctx);
                    i = i + 1;
                };
                match tail {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            // Control flow
            ExprKind::If { condition, then_branch, else_branch } => {
                self.infer_expr(condition, ctx);
                self.infer_expr(then_branch, ctx);
                match else_branch {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            ExprKind::Match { scrutinee, arms } => {
                self.infer_expr(scrutinee, ctx);
                let mut i: usize = 0;
                while i < arms.len() {
                    match &arms[i].guard {
                        Option::Some(g) => self.infer_expr(g, ctx),
                        Option::None => {}
                    };
                    self.infer_expr(&arms[i].body, ctx);
                    i = i + 1;
                }
            }

            ExprKind::Loop { body, label: _ } => {
                self.infer_expr(body, ctx);
            }

            ExprKind::While { condition, body, label: _ } => {
                self.infer_expr(condition, ctx);
                self.infer_expr(body, ctx);
            }

            // Function calls may propagate effects
            ExprKind::Call { callee, args } => {
                // If calling a local (higher-order function), we may be polymorphic
                match &callee.kind {
                    ExprKind::Local(_) => ctx.set_polymorphic(),
                    _ => {};
                };
                self.infer_expr(callee, ctx);
                let mut i: usize = 0;
                while i < args.len() {
                    self.infer_expr(&args[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::MethodCall { receiver, method: _, args } => {
                self.infer_expr(receiver, ctx);
                let mut i: usize = 0;
                while i < args.len() {
                    self.infer_expr(&args[i], ctx);
                    i = i + 1;
                }
            }

            // Binary and unary operations
            ExprKind::Binary { left, right, op: _ } => {
                self.infer_expr(left, ctx);
                self.infer_expr(right, ctx);
            }

            ExprKind::Unary { operand, op: _ } => {
                self.infer_expr(operand, ctx);
            }

            // Compound expressions
            ExprKind::Tuple(exprs) => {
                let mut i: usize = 0;
                while i < exprs.len() {
                    self.infer_expr(&exprs[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::Array(exprs) => {
                let mut i: usize = 0;
                while i < exprs.len() {
                    self.infer_expr(&exprs[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::Repeat { value, count: _ } => {
                self.infer_expr(value, ctx);
            }

            ExprKind::Struct { def_id: _, fields, base } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    self.infer_expr(&fields[i].value, ctx);
                    i = i + 1;
                };
                match base {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            ExprKind::Variant { def_id: _, variant: _, fields } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    self.infer_expr(&fields[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::Record { fields } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    self.infer_expr(&fields[i].value, ctx);
                    i = i + 1;
                }
            }

            // Return and control flow
            ExprKind::Return(inner) => {
                match inner {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            ExprKind::Break { label: _, value } => {
                match value {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            ExprKind::Assign { target, value } => {
                self.infer_expr(target, ctx);
                self.infer_expr(value, ctx);
            }

            // Field and index access
            ExprKind::Field { base, field: _ } => {
                self.infer_expr(base, ctx);
            }

            ExprKind::Index { base, index } => {
                self.infer_expr(base, ctx);
                self.infer_expr(index, ctx);
            }

            // Reference operations
            ExprKind::Borrow { expr: inner, mutable: _ } => {
                self.infer_expr(inner, ctx);
            }

            ExprKind::Deref(inner) => {
                self.infer_expr(inner, ctx);
            }

            ExprKind::AddrOf { expr: inner, mutable: _ } => {
                self.infer_expr(inner, ctx);
            }

            ExprKind::Cast { expr: inner, ty: _ } => {
                self.infer_expr(inner, ctx);
            }

            ExprKind::Unsafe(inner) => {
                self.infer_expr(inner, ctx);
            }

            ExprKind::Let { pattern: _, ty: _, init } => {
                self.infer_expr(init, ctx);
            }

            ExprKind::Range { start, end, inclusive: _ } => {
                match start {
                    Option::Some(s) => self.infer_expr(s, ctx),
                    Option::None => {}
                };
                match end {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }

            // Resume may indicate we're in a handler context
            ExprKind::Resume { value } => {
                match value {
                    Option::Some(v) => self.infer_expr(v, ctx),
                    Option::None => {}
                }
            }

            // Closures have their own effect inference
            ExprKind::Closure { params: _, body: _, captures: _, return_ty: _ } => {
                // Closures are analyzed separately
            }

            // Macro expansion expressions
            ExprKind::MacroExpansion { name: _, args } => {
                let mut i: usize = 0;
                while i < args.len() {
                    self.infer_expr(&args[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::VecLiteral(exprs) => {
                let mut i: usize = 0;
                while i < exprs.len() {
                    self.infer_expr(&exprs[i], ctx);
                    i = i + 1;
                }
            }

            ExprKind::VecRepeat { value, count } => {
                self.infer_expr(value, ctx);
                self.infer_expr(count, ctx);
            }

            ExprKind::Assert { condition, message } => {
                self.infer_expr(condition, ctx);
                match message {
                    Option::Some(m) => self.infer_expr(m, ctx),
                    Option::None => {}
                }
            }

            ExprKind::Dbg(inner) => {
                self.infer_expr(inner, ctx);
            }

            // Leaf expressions - no effects
            ExprKind::Literal(_) |
            ExprKind::Local(_) |
            ExprKind::Def(_) |
            ExprKind::MethodFamily { def_id: _, type_args: _ } |
            ExprKind::Continue { label: _ } |
            ExprKind::Default |
            ExprKind::Error => {
                // No effects
            }
        }
    }

    /// Infer effects from a statement.
    fn infer_stmt(&mut self, stmt: &Stmt, ctx: &mut InferenceContext) {
        match stmt {
            Stmt::Expr(expr) => {
                self.infer_expr(expr, ctx);
            }
            Stmt::Let { pattern: _, ty: _, init } => {
                match init {
                    Option::Some(e) => self.infer_expr(e, ctx),
                    Option::None => {}
                }
            }
            Stmt::Item(_) => {
                // Nested items have their own effect inference
            }
        }
    }

    /// Build the final effect row from the inference context.
    fn build_effect_row(&mut self, ctx: &InferenceContext) -> EffectRow {
        // Filter out handled effects
        let mut remaining: [EffectRef] = [];
        let mut i: usize = 0;
        while i < ctx.performed.len() {
            let effect = &ctx.performed[i];
            if !ctx.is_handled(&effect.def_id) {
                remaining.push(effect.clone());
            };
            i = i + 1;
        };

        if remaining.len() == 0 && !ctx.is_polymorphic() {
            // Pure function
            EffectRow::pure()
        } else {
            let row_var = if ctx.is_polymorphic() {
                Option::Some(self.fresh_row_var())
            } else {
                Option::None
            };
            EffectRow::new(remaining, row_var)
        }
    }
}

// ============================================================
// Inference Result
// ============================================================

/// Effect inference result with additional metadata.
pub struct InferenceResult {
    /// The inferred effect row.
    pub effect_row: EffectRow,
    /// Whether the function performs any effects.
    pub has_effects: bool,
    /// Whether the function is row-polymorphic.
    pub is_polymorphic: bool,
    /// Effect DefIds that were handled within the function.
    pub handled_effects: HashSet<u32>,
}

impl InferenceResult {
    /// Create an inference result from an effect row.
    pub fn from_row(row: EffectRow) -> InferenceResult {
        InferenceResult {
            has_effects: !row.is_pure(),
            is_polymorphic: row.is_polymorphic(),
            handled_effects: HashSet::new(),
            effect_row: row,
        }
    }

    /// Create a pure inference result.
    pub fn pure() -> InferenceResult {
        InferenceResult {
            effect_row: EffectRow::pure(),
            has_effects: false,
            is_polymorphic: false,
            handled_effects: HashSet::new(),
        }
    }
}

impl Clone for InferenceResult {
    fn clone(&self) -> InferenceResult {
        InferenceResult {
            effect_row: self.effect_row.clone(),
            has_effects: self.has_effects,
            is_polymorphic: self.is_polymorphic,
            handled_effects: self.handled_effects.clone(),
        }
    }
}

// ============================================================
// Convenience Functions
// ============================================================

/// Infer effects for a function body.
///
/// This is a convenience function that creates an inferencer and runs inference.
pub fn infer_effects(body: &Body) -> EffectRow {
    let mut inferencer = EffectInferencer::new();
    inferencer.infer_effects(body);
}

/// Verify that inferred effects are a subset of declared effects.
///
/// Returns a list of undeclared effects if any.
pub fn verify_effects_subset(
    inferred: &EffectRow,
    declared: &EffectRow,
) -> Option<[EffectRef]> {
    let mut undeclared: [EffectRef] = [];

    let effects = inferred.effects();
    let mut i: usize = 0;
    while i < effects.len() {
        let effect = &effects[i];
        // Check if this effect is declared or if declared is polymorphic
        if !declared.contains(&effect.def_id) && !declared.is_polymorphic() {
            undeclared.push(effect.clone());
        };
        i = i + 1;
    };

    if undeclared.len() == 0 {
        Option::None
    } else {
        Option::Some(undeclared)
    }
}

// ============================================================
// Detailed Effect Inferencer
// ============================================================

/// Extended effect inferencer that tracks more detailed information.
///
/// Used for type checking integration where detailed error reporting is needed.
pub struct DetailedEffectInferencer {
    /// The base inferencer.
    inner: EffectInferencer,
    /// Effects handled in the current function.
    handled: HashSet<u32>,
    /// Mapping from handler DefId to the effect it handles.
    handler_effects: std.collections.HashMap<u32, DefId>,
}

impl DetailedEffectInferencer {
    /// Create a new detailed effect inferencer.
    pub fn new() -> DetailedEffectInferencer {
        DetailedEffectInferencer {
            inner: EffectInferencer::new(),
            handled: HashSet::new(),
            handler_effects: std.collections.HashMap::new(),
        }
    }

    /// Register a handler and the effect it handles.
    pub fn register_handler(&mut self, handler_id: &DefId, effect_id: DefId) {
        self.handler_effects.insert(handler_id.index, effect_id);
    }

    /// Infer effects with detailed tracking.
    pub fn infer_effects_detailed(&mut self, body: &Body) -> InferenceResult {
        let mut ctx = InferenceContext::new();
        self.inner.infer_expr(&body.expr, &mut ctx);

        // Track handled effects
        let handled_iter = ctx.handled();
        for handler_id in handled_iter.iter() {
            match self.handler_effects.get(handler_id) {
                Option::Some(effect_id) => {
                    self.handled.insert(effect_id.index);
                }
                Option::None => {}
            }
        };

        let row = self.inner.build_effect_row(&ctx);

        InferenceResult {
            has_effects: !row.is_pure(),
            is_polymorphic: row.is_polymorphic(),
            handled_effects: self.handled.clone(),
            effect_row: row,
        }
    }

    /// Generate a fresh row variable.
    pub fn fresh_row_var(&mut self) -> RowVar {
        self.inner.fresh_row_var();
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_inference_context() {
    let mut ctx = InferenceContext::new();
    assert!(!ctx.is_polymorphic());
    assert!(ctx.performed().len() == 0);

    let effect = EffectRef::new(DefId::new(1));
    ctx.add_performed(effect);
    assert!(ctx.performed().len() == 1);

    ctx.add_handled(&DefId::new(2));
    assert!(ctx.is_handled(&DefId::new(2)));
    assert!(!ctx.is_handled(&DefId::new(1)));

    ctx.set_polymorphic();
    assert!(ctx.is_polymorphic());
}

#[test]
fn test_inference_context_merge() {
    let mut parent = InferenceContext::new();
    let mut child = InferenceContext::new();

    child.add_performed(EffectRef::new(DefId::new(1)));
    child.add_performed(EffectRef::new(DefId::new(2)));
    child.add_handled(&DefId::new(2)); // Effect 2 is handled

    parent.merge_child(&child);

    // Only effect 1 should propagate (effect 2 was handled)
    assert!(parent.performed().len() == 1);
    let effect_ids: [u32] = parent.performed().iter().map(|e| e.def_id.index).collect();
    assert!(effect_ids.contains(&1));
    assert!(!effect_ids.contains(&2));
}

#[test]
fn test_effect_inferencer() {
    let inferencer = EffectInferencer::new();
    assert!(inferencer.row_var_counter == 0);
}

#[test]
fn test_fresh_row_var() {
    let mut inferencer = EffectInferencer::new();
    let v1 = inferencer.fresh_row_var();
    let v2 = inferencer.fresh_row_var();

    assert!(v1.id() == 0);
    assert!(v2.id() == 1);
    assert!(!v1.eq(&v2));
}

#[test]
fn test_inference_result() {
    let result = InferenceResult::pure();
    assert!(!result.has_effects);
    assert!(!result.is_polymorphic);
    assert!(result.effect_row.is_pure());
}

#[test]
fn test_inference_result_from_row() {
    let effect = EffectRef::new(DefId::new(1));
    let row = EffectRow::single(effect);
    let result = InferenceResult::from_row(row);

    assert!(result.has_effects);
    assert!(!result.is_polymorphic);
}

#[test]
fn test_verify_effects_subset_valid() {
    let effect = EffectRef::new(DefId::new(1));
    let inferred = EffectRow::single(effect.clone());

    let mut declared = EffectRow::pure();
    declared.add_effect(effect);

    let result = verify_effects_subset(&inferred, &declared);
    assert!(result.is_none());
}

#[test]
fn test_verify_effects_subset_invalid() {
    let effect1 = EffectRef::new(DefId::new(1));
    let effect2 = EffectRef::new(DefId::new(2));

    let inferred = EffectRow::single(effect1.clone());
    let declared = EffectRow::single(effect2);

    let result = verify_effects_subset(&inferred, &declared);
    assert!(result.is_some());
    match result {
        Option::Some(undeclared) => {
            assert!(undeclared.len() == 1);
            assert!(undeclared[0].def_id.index == 1);
        }
        Option::None => assert!(false),
    }
}

#[test]
fn test_verify_effects_subset_polymorphic() {
    let effect = EffectRef::new(DefId::new(1));
    let inferred = EffectRow::single(effect);
    let declared = EffectRow::polymorphic(RowVar::new(0));

    // Polymorphic declaration should accept any effects
    let result = verify_effects_subset(&inferred, &declared);
    assert!(result.is_none());
}

#[test]
fn test_detailed_effect_inferencer() {
    let mut inferencer = DetailedEffectInferencer::new();
    inferencer.register_handler(&DefId::new(10), DefId::new(1));

    // Just verify it can be created and configured
    let var = inferencer.fresh_row_var();
    assert!(var.id() == 0);
}
