/// Evidence Passing Infrastructure
///
/// Implements evidence vectors for effect handler compilation. Evidence passing
/// is the compilation strategy for algebraic effects, based on:
///
/// - [Generalized Evidence Passing for Effect Handlers](https://dl.acm.org/doi/10.1145/3473576) (ICFP'21)
/// - [Type Directed Compilation of Row-Typed Algebraic Effects](https://dl.acm.org/doi/10.1145/3093333.3009872) (POPL'17)
///
/// # Overview
///
/// Instead of searching for handlers at runtime, evidence vectors are passed
/// explicitly to effectful functions, providing O(1) handler lookup.
///
/// # Translation Process
///
/// 1. **Function translation**: Add evidence parameter to effectful functions
/// 2. **Operation translation**: Replace `perform op(args)` with `ev[idx].op(args)`
/// 3. **Handler translation**: Create evidence vector from handler block
///
/// # Example
///
/// ```text
/// // Source code
/// fn foo() / {State<i32>, Error} {
///     let x = get();
///     if x < 0 { throw("negative"); }
///     put(x + 1);
/// }
///
/// // After evidence translation
/// fn foo(ev: Evidence) {
///     let x = ev.state.get();
///     if x < 0 { ev.error.throw("negative"); }
///     ev.state.put(x + 1);
/// }
/// ```
///
/// # Tail-Resumptive Optimization
///
/// When a handler operation immediately resumes (tail-resumptive), the
/// continuation doesn't need to be captured. This is common for State,
/// Reader, and Writer effects.

use crate.compiler.typeck::types::DefId;
use crate.compiler.effects::row::EffectRef;
use std.collections::HashMap;

// ============================================================
// Evidence Entry
// ============================================================

/// An evidence entry for a single effect.
///
/// Contains the handler implementation for one effect in the evidence vector.
pub struct EvidenceEntry {
    /// The effect this evidence handles.
    pub effect: EffectRef,
    /// The handler definition ID.
    pub handler_id: DefId,
    /// Index into the evidence vector.
    pub index: usize,
}

impl EvidenceEntry {
    /// Create a new evidence entry.
    pub fn new(effect: EffectRef, handler_id: DefId, index: usize) -> EvidenceEntry {
        EvidenceEntry {
            effect,
            handler_id,
            index,
        }
    }

    /// Get the effect this entry handles.
    pub fn effect(&self) -> &EffectRef {
        &self.effect
    }

    /// Get the handler definition ID.
    pub fn handler_id(&self) -> &DefId {
        &self.handler_id
    }

    /// Get the index in the evidence vector.
    pub fn index(&self) -> usize {
        self.index
    }
}

impl Clone for EvidenceEntry {
    fn clone(&self) -> EvidenceEntry {
        EvidenceEntry {
            effect: self.effect.clone(),
            handler_id: self.handler_id.clone(),
            index: self.index,
        }
    }
}

// ============================================================
// Evidence Vector
// ============================================================

/// An evidence vector mapping effects to their handlers.
///
/// The evidence vector is passed to effectful functions at runtime,
/// enabling O(1) lookup of handler implementations.
pub struct EvidenceVector {
    /// Mapping from effect DefId to evidence entry.
    entries: HashMap<u32, EvidenceEntry>,
    /// Ordered list of effect DefIds for vector representation.
    ordered: [DefId],
}

impl EvidenceVector {
    /// Create an empty evidence vector.
    pub fn new() -> EvidenceVector {
        EvidenceVector {
            entries: HashMap::new(),
            ordered: [],
        }
    }

    /// Add an evidence entry for an effect.
    pub fn add(&mut self, effect: EffectRef, handler_id: DefId) {
        let index = self.ordered.len();
        let effect_id = effect.def_id.index;
        let entry = EvidenceEntry::new(effect.clone(), handler_id.clone(), index);
        self.entries.insert(effect_id, entry);
        self.ordered.push(effect.def_id);
    }

    /// Look up evidence for an effect.
    pub fn lookup(&self, effect_id: &DefId) -> Option<&EvidenceEntry> {
        self.entries.get(&effect_id.index)
    }

    /// Get the number of entries in the vector.
    pub fn len(&self) -> usize {
        self.ordered.len()
    }

    /// Check if the vector is empty.
    pub fn is_empty(&self) -> bool {
        self.ordered.len() == 0
    }

    /// Get all entries in order.
    pub fn entries(&self) -> &HashMap<u32, EvidenceEntry> {
        &self.entries
    }

    /// Get the ordered effect IDs.
    pub fn ordered(&self) -> &[DefId] {
        &self.ordered
    }

    /// Check if this vector contains an entry for an effect.
    pub fn contains(&self, effect_id: &DefId) -> bool {
        self.entries.contains_key(&effect_id.index)
    }

    /// Get the evidence index for an effect.
    pub fn index_of(&self, effect_id: &DefId) -> Option<usize> {
        match self.entries.get(&effect_id.index) {
            Option::Some(entry) => Option::Some(entry.index),
            Option::None => Option::None,
        }
    }
}

impl Clone for EvidenceVector {
    fn clone(&self) -> EvidenceVector {
        EvidenceVector {
            entries: self.entries.clone(),
            ordered: self.ordered.clone(),
        }
    }
}

// ============================================================
// Evidence
// ============================================================

/// Evidence structure passed to effectful functions at runtime.
///
/// This is the runtime representation of handler implementations.
/// It wraps an evidence vector with depth tracking for nested handlers.
pub struct Evidence {
    /// The evidence vector.
    pub vector: EvidenceVector,
    /// The current handler depth (for nested handlers).
    pub depth: usize,
}

impl Evidence {
    /// Create new evidence from a vector.
    pub fn new(vector: EvidenceVector) -> Evidence {
        Evidence { vector, depth: 0 }
    }

    /// Create evidence with a specific depth.
    pub fn with_depth(vector: EvidenceVector, depth: usize) -> Evidence {
        Evidence { vector, depth }
    }

    /// Push a new handler scope, incrementing depth.
    ///
    /// Returns new evidence with combined handlers and incremented depth.
    pub fn push_scope(&self, additional: EvidenceVector) -> Evidence {
        let mut combined = self.vector.clone();
        let mut i: usize = 0;
        while i < additional.ordered.len() {
            let effect_id = &additional.ordered[i];
            match additional.lookup(effect_id) {
                Option::Some(entry) => {
                    combined.add(entry.effect.clone(), entry.handler_id.clone());
                }
                Option::None => {}
            }
            i = i + 1;
        }
        Evidence {
            vector: combined,
            depth: self.depth + 1,
        }
    }

    /// Get the evidence entry for an effect.
    pub fn get(&self, effect_id: &DefId) -> Option<&EvidenceEntry> {
        self.vector.lookup(effect_id)
    }

    /// Get the evidence index for an effect.
    pub fn index_of(&self, effect_id: &DefId) -> Option<usize> {
        self.vector.index_of(effect_id)
    }

    /// Get the handler depth.
    pub fn depth(&self) -> usize {
        self.depth
    }

    /// Check if this evidence handles an effect.
    pub fn handles(&self, effect_id: &DefId) -> bool {
        self.vector.contains(effect_id)
    }
}

impl Clone for Evidence {
    fn clone(&self) -> Evidence {
        Evidence {
            vector: self.vector.clone(),
            depth: self.depth,
        }
    }
}

// ============================================================
// Translated Operation
// ============================================================

/// Represents an evidence-translated operation call.
///
/// After translation, `perform Effect.op(args)` becomes `ev[idx].op(args)`.
pub struct TranslatedOp {
    /// The evidence index for the effect.
    pub evidence_index: usize,
    /// The operation index within the effect.
    pub operation_index: u32,
    /// The handler DefId.
    pub handler_id: DefId,
}

impl TranslatedOp {
    /// Create a new translated operation.
    pub fn new(evidence_index: usize, operation_index: u32, handler_id: DefId) -> TranslatedOp {
        TranslatedOp {
            evidence_index,
            operation_index,
            handler_id,
        }
    }
}

impl Clone for TranslatedOp {
    fn clone(&self) -> TranslatedOp {
        TranslatedOp {
            evidence_index: self.evidence_index,
            operation_index: self.operation_index,
            handler_id: self.handler_id.clone(),
        }
    }
}

// ============================================================
// Evidence Context
// ============================================================

/// Evidence translation context for a function.
///
/// Tracks evidence requirements and provides lookup during translation.
pub struct EvidenceContext {
    /// The evidence parameter name (e.g., "ev").
    pub param_name: String,
    /// Mapping from effect DefId to evidence index.
    effect_indices: HashMap<u32, usize>,
    /// Whether this context has any evidence requirements.
    has_evidence: bool,
}

impl EvidenceContext {
    /// Create a new empty evidence context.
    pub fn new() -> EvidenceContext {
        EvidenceContext {
            param_name: "ev".to_string(),
            effect_indices: HashMap::new(),
            has_evidence: false,
        }
    }

    /// Create an evidence context from an evidence vector.
    pub fn from_evidence(ev: &EvidenceVector) -> EvidenceContext {
        let mut effect_indices: HashMap<u32, usize> = HashMap::new();
        let mut i: usize = 0;
        while i < ev.ordered.len() {
            let effect_id = &ev.ordered[i];
            match ev.lookup(effect_id) {
                Option::Some(entry) => {
                    effect_indices.insert(effect_id.index, entry.index);
                }
                Option::None => {}
            }
            i = i + 1;
        }
        EvidenceContext {
            param_name: "ev".to_string(),
            effect_indices,
            has_evidence: !ev.is_empty(),
        }
    }

    /// Register an effect in the context.
    pub fn register_effect(&mut self, effect_id: &DefId, index: usize) {
        self.effect_indices.insert(effect_id.index, index);
        self.has_evidence = true;
    }

    /// Look up the evidence index for an effect.
    pub fn lookup(&self, effect_id: &DefId) -> Option<usize> {
        match self.effect_indices.get(&effect_id.index) {
            Option::Some(idx) => Option::Some(*idx),
            Option::None => Option::None,
        }
    }

    /// Check if this context has any evidence requirements.
    pub fn has_evidence(&self) -> bool {
        self.has_evidence
    }

    /// Get the number of effects in the context.
    pub fn effect_count(&self) -> usize {
        self.effect_indices.len()
    }
}

impl Clone for EvidenceContext {
    fn clone(&self) -> EvidenceContext {
        EvidenceContext {
            param_name: self.param_name.clone(),
            effect_indices: self.effect_indices.clone(),
            has_evidence: self.has_evidence,
        }
    }
}

// ============================================================
// Handler Pattern
// ============================================================

/// A pattern of handlers that uniquely identifies an evidence vector configuration.
///
/// Two handler patterns are equal if they map the same effects to the same handlers
/// in the same order. This enables caching and reuse of evidence vectors.
pub struct HandlerPattern {
    /// Ordered pairs of (effect_id, handler_id) defining the pattern.
    bindings: [(DefId, DefId)],
}

impl HandlerPattern {
    /// Create a new empty handler pattern.
    pub fn empty() -> HandlerPattern {
        HandlerPattern { bindings: [] }
    }

    /// Create a new handler pattern from an evidence vector.
    pub fn from_evidence(ev: &EvidenceVector) -> HandlerPattern {
        let mut bindings: [(DefId, DefId)] = [];
        let mut i: usize = 0;
        while i < ev.ordered.len() {
            let effect_id = &ev.ordered[i];
            match ev.lookup(effect_id) {
                Option::Some(entry) => {
                    bindings.push((effect_id.clone(), entry.handler_id.clone()));
                }
                Option::None => {}
            }
            i = i + 1;
        }
        HandlerPattern { bindings }
    }

    /// Add a handler binding to the pattern.
    pub fn add(&mut self, effect_id: DefId, handler_id: DefId) {
        self.bindings.push((effect_id, handler_id));
    }

    /// Get the number of bindings in the pattern.
    pub fn len(&self) -> usize {
        self.bindings.len()
    }

    /// Check if the pattern is empty.
    pub fn is_empty(&self) -> bool {
        self.bindings.len() == 0
    }

    /// Get the bindings.
    pub fn bindings(&self) -> &[(DefId, DefId)] {
        &self.bindings
    }

    /// Compute a hash of this pattern for cache lookup.
    pub fn hash_value(&self) -> u64 {
        let mut hash: u64 = 17;
        let mut i: usize = 0;
        while i < self.bindings.len() {
            let (effect_id, handler_id) = &self.bindings[i];
            hash = hash * 31 + (effect_id.index as u64);
            hash = hash * 31 + (handler_id.index as u64);
            i = i + 1;
        }
        hash
    }
}

impl Clone for HandlerPattern {
    fn clone(&self) -> HandlerPattern {
        HandlerPattern {
            bindings: self.bindings.clone(),
        }
    }
}

impl PartialEq for HandlerPattern {
    fn eq(&self, other: &HandlerPattern) -> bool {
        if self.bindings.len() != other.bindings.len() {
            return false;
        }
        let mut i: usize = 0;
        while i < self.bindings.len() {
            let (e1, h1) = &self.bindings[i];
            let (e2, h2) = &other.bindings[i];
            if !e1.eq(e2) || !h1.eq(h2) {
                return false;
            }
            i = i + 1;
        }
        true
    }
}

// ============================================================
// Evidence Cache
// ============================================================

/// Cache statistics for monitoring.
pub struct CacheStats {
    /// Number of cache hits.
    pub hits: u64,
    /// Number of cache misses.
    pub misses: u64,
    /// Number of patterns currently cached.
    pub cached_patterns: usize,
}

impl CacheStats {
    /// Create default stats.
    pub fn new() -> CacheStats {
        CacheStats {
            hits: 0,
            misses: 0,
            cached_patterns: 0,
        }
    }

    /// Calculate the cache hit rate as a percentage.
    pub fn hit_rate(&self) -> f64 {
        let total = self.hits + self.misses;
        if total == 0 {
            0.0
        } else {
            (self.hits as f64 / total as f64) * 100.0
        }
    }

    /// Reset all statistics.
    pub fn reset(&mut self) {
        self.hits = 0;
        self.misses = 0;
    }
}

impl Clone for CacheStats {
    fn clone(&self) -> CacheStats {
        CacheStats {
            hits: self.hits,
            misses: self.misses,
            cached_patterns: self.cached_patterns,
        }
    }
}

/// Cache for evidence vectors, enabling reuse of identical handler patterns.
///
/// This optimization detects when the same set of handlers is used multiple times
/// and reuses the cached evidence vector instead of creating a new one.
///
/// # Benefits
///
/// - Reduced memory allocation in loops with repeated handler installation
/// - Faster evidence lookup when patterns are recognized
/// - Better cache locality from evidence vector reuse
pub struct EvidenceCache {
    /// Map from pattern hash to cached evidence vectors.
    cache: HashMap<u64, EvidenceVector>,
    /// Statistics for cache performance monitoring.
    stats: CacheStats,
}

impl EvidenceCache {
    /// Create a new empty evidence cache.
    pub fn new() -> EvidenceCache {
        EvidenceCache {
            cache: HashMap::new(),
            stats: CacheStats::new(),
        }
    }

    /// Look up or create an evidence vector for a handler pattern.
    ///
    /// If an evidence vector for this pattern exists in the cache, returns it.
    /// Otherwise, returns None (caller should create and insert).
    pub fn get(&mut self, pattern: &HandlerPattern) -> Option<&EvidenceVector> {
        let hash = pattern.hash_value();
        if self.cache.contains_key(&hash) {
            self.stats.hits = self.stats.hits + 1;
            self.cache.get(&hash)
        } else {
            self.stats.misses = self.stats.misses + 1;
            Option::None
        }
    }

    /// Insert an evidence vector for a pattern.
    pub fn insert(&mut self, pattern: &HandlerPattern, evidence: EvidenceVector) {
        let hash = pattern.hash_value();
        self.cache.insert(hash, evidence);
        self.stats.cached_patterns = self.cache.len();
    }

    /// Check if a pattern is already cached.
    pub fn contains(&self, pattern: &HandlerPattern) -> bool {
        let hash = pattern.hash_value();
        self.cache.contains_key(&hash)
    }

    /// Clear all cached evidence vectors.
    pub fn clear(&mut self) {
        self.cache.clear();
        self.stats.cached_patterns = 0;
    }

    /// Get the number of cached patterns.
    pub fn len(&self) -> usize {
        self.cache.len()
    }

    /// Check if the cache is empty.
    pub fn is_empty(&self) -> bool {
        self.cache.len() == 0
    }

    /// Get cache statistics.
    pub fn stats(&self) -> &CacheStats {
        &self.stats
    }
}

impl Clone for EvidenceCache {
    fn clone(&self) -> EvidenceCache {
        EvidenceCache {
            cache: self.cache.clone(),
            stats: self.stats.clone(),
        }
    }
}

// ============================================================
// Static Evidence Optimization
// ============================================================

/// A unique identifier for a static evidence pattern.
///
/// Static evidence patterns are identified at compile time and emitted as
/// global constants, avoiding runtime allocation.
pub struct StaticEvidenceId {
    pub id: u32,
}

impl StaticEvidenceId {
    /// Create a new static evidence ID.
    pub fn new(id: u32) -> StaticEvidenceId {
        StaticEvidenceId { id }
    }

    /// Get the numeric ID value.
    pub fn index(&self) -> u32 {
        self.id
    }
}

impl Clone for StaticEvidenceId {
    fn clone(&self) -> StaticEvidenceId {
        StaticEvidenceId { id: self.id }
    }
}

impl PartialEq for StaticEvidenceId {
    fn eq(&self, other: &StaticEvidenceId) -> bool {
        self.id == other.id
    }
}

/// Classification of handler state for static evidence optimization.
///
/// Determines whether a handler's state can be pre-allocated at compile time.
pub enum HandlerStateKind {
    /// Handler has no state (unit type).
    Stateless,
    /// Handler state is a constant value known at compile time.
    Constant,
    /// Handler state is zero-initialized.
    ZeroInit,
    /// Handler state is computed at runtime.
    Dynamic,
}

impl HandlerStateKind {
    /// Check if this state kind allows static evidence optimization.
    pub fn is_static(&self) -> bool {
        match self {
            HandlerStateKind::Stateless => true,
            HandlerStateKind::Constant => true,
            HandlerStateKind::ZeroInit => true,
            HandlerStateKind::Dynamic => false,
        }
    }
}

impl Clone for HandlerStateKind {
    fn clone(&self) -> HandlerStateKind {
        match self {
            HandlerStateKind::Stateless => HandlerStateKind::Stateless,
            HandlerStateKind::Constant => HandlerStateKind::Constant,
            HandlerStateKind::ZeroInit => HandlerStateKind::ZeroInit,
            HandlerStateKind::Dynamic => HandlerStateKind::Dynamic,
        }
    }
}

/// A single handler entry in static evidence.
pub struct StaticEvidenceEntry {
    /// The effect this handler handles.
    pub effect_id: DefId,
    /// The handler definition ID.
    pub handler_id: DefId,
    /// The kind of handler state.
    pub state_kind: HandlerStateKind,
    /// For constant state, the serialized constant value (if small enough).
    pub constant_state: Option<[u8]>,
}

impl StaticEvidenceEntry {
    /// Create a stateless entry.
    pub fn stateless(effect_id: DefId, handler_id: DefId) -> StaticEvidenceEntry {
        StaticEvidenceEntry {
            effect_id,
            handler_id,
            state_kind: HandlerStateKind::Stateless,
            constant_state: Option::None,
        }
    }

    /// Create an entry with constant state.
    pub fn with_constant(effect_id: DefId, handler_id: DefId, state: [u8]) -> StaticEvidenceEntry {
        StaticEvidenceEntry {
            effect_id,
            handler_id,
            state_kind: HandlerStateKind::Constant,
            constant_state: Option::Some(state),
        }
    }

    /// Create a zero-initialized entry.
    pub fn zero_init(effect_id: DefId, handler_id: DefId) -> StaticEvidenceEntry {
        StaticEvidenceEntry {
            effect_id,
            handler_id,
            state_kind: HandlerStateKind::ZeroInit,
            constant_state: Option::None,
        }
    }

    /// Create a dynamic entry.
    pub fn dynamic(effect_id: DefId, handler_id: DefId) -> StaticEvidenceEntry {
        StaticEvidenceEntry {
            effect_id,
            handler_id,
            state_kind: HandlerStateKind::Dynamic,
            constant_state: Option::None,
        }
    }
}

impl Clone for StaticEvidenceEntry {
    fn clone(&self) -> StaticEvidenceEntry {
        StaticEvidenceEntry {
            effect_id: self.effect_id.clone(),
            handler_id: self.handler_id.clone(),
            state_kind: self.state_kind.clone(),
            constant_state: self.constant_state.clone(),
        }
    }
}

/// A complete static evidence pattern.
pub struct StaticEvidence {
    /// Unique identifier for this static evidence.
    pub id: StaticEvidenceId,
    /// The handler entries in this evidence.
    pub entries: [StaticEvidenceEntry],
    /// Whether all entries are fully static.
    pub fully_static: bool,
}

impl StaticEvidence {
    /// Create new static evidence with the given ID.
    pub fn new(id: StaticEvidenceId) -> StaticEvidence {
        StaticEvidence {
            id,
            entries: [],
            fully_static: true,
        }
    }

    /// Add a handler entry to this static evidence.
    pub fn add_entry(&mut self, entry: StaticEvidenceEntry) {
        if !entry.state_kind.is_static() {
            self.fully_static = false;
        }
        self.entries.push(entry);
    }

    /// Get the number of handlers in this evidence.
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Check if this evidence is empty.
    pub fn is_empty(&self) -> bool {
        self.entries.len() == 0
    }

    /// Check if this evidence can be fully emitted as static data.
    pub fn can_emit_static(&self) -> bool {
        self.fully_static && !self.is_empty()
    }
}

impl Clone for StaticEvidence {
    fn clone(&self) -> StaticEvidence {
        StaticEvidence {
            id: self.id.clone(),
            entries: self.entries.clone(),
            fully_static: self.fully_static,
        }
    }
}

/// Registry of static evidence patterns discovered during MIR analysis.
pub struct StaticEvidenceRegistry {
    /// All registered static evidence patterns.
    patterns: [StaticEvidence],
    /// Lookup from handler pattern hash to static evidence ID.
    pattern_lookup: HashMap<u64, StaticEvidenceId>,
    /// Next available ID.
    next_id: u32,
    /// Statistics about static evidence optimization.
    handlers_analyzed: u64,
    static_eligible: u64,
    unique_patterns: u64,
    pattern_reuses: u64,
}

impl StaticEvidenceRegistry {
    /// Create a new empty registry.
    pub fn new() -> StaticEvidenceRegistry {
        StaticEvidenceRegistry {
            patterns: [],
            pattern_lookup: HashMap::new(),
            next_id: 0,
            handlers_analyzed: 0,
            static_eligible: 0,
            unique_patterns: 0,
            pattern_reuses: 0,
        }
    }

    /// Register a static evidence pattern, returning its ID.
    ///
    /// If an identical pattern already exists, returns the existing ID.
    pub fn register(&mut self, pattern: &HandlerPattern, evidence: StaticEvidence) -> StaticEvidenceId {
        let hash = pattern.hash_value();

        match self.pattern_lookup.get(&hash) {
            Option::Some(id) => {
                self.pattern_reuses = self.pattern_reuses + 1;
                id.clone()
            }
            Option::None => {
                let id = StaticEvidenceId::new(self.next_id);
                self.next_id = self.next_id + 1;

                self.pattern_lookup.insert(hash, id.clone());
                self.patterns.push(evidence);
                self.unique_patterns = self.unique_patterns + 1;

                id
            }
        }
    }

    /// Look up static evidence by ID.
    pub fn get(&self, id: &StaticEvidenceId) -> Option<&StaticEvidence> {
        if (id.index() as usize) < self.patterns.len() {
            Option::Some(&self.patterns[id.index() as usize])
        } else {
            Option::None
        }
    }

    /// Check if a pattern is already registered.
    pub fn contains(&self, pattern: &HandlerPattern) -> bool {
        self.pattern_lookup.contains_key(&pattern.hash_value())
    }

    /// Get the ID for a registered pattern.
    pub fn lookup(&self, pattern: &HandlerPattern) -> Option<&StaticEvidenceId> {
        self.pattern_lookup.get(&pattern.hash_value())
    }

    /// Get the number of registered patterns.
    pub fn len(&self) -> usize {
        self.patterns.len()
    }

    /// Check if the registry is empty.
    pub fn is_empty(&self) -> bool {
        self.patterns.len() == 0
    }

    /// Record that a handler was analyzed.
    pub fn record_analyzed(&mut self) {
        self.handlers_analyzed = self.handlers_analyzed + 1;
    }

    /// Record that a handler is eligible for static evidence.
    pub fn record_static_eligible(&mut self) {
        self.static_eligible = self.static_eligible + 1;
    }

    /// Calculate the eligibility rate.
    pub fn eligibility_rate(&self) -> f64 {
        if self.handlers_analyzed == 0 {
            0.0
        } else {
            (self.static_eligible as f64 / self.handlers_analyzed as f64) * 100.0
        }
    }
}

impl Clone for StaticEvidenceRegistry {
    fn clone(&self) -> StaticEvidenceRegistry {
        StaticEvidenceRegistry {
            patterns: self.patterns.clone(),
            pattern_lookup: self.pattern_lookup.clone(),
            next_id: self.next_id,
            handlers_analyzed: self.handlers_analyzed,
            static_eligible: self.static_eligible,
            unique_patterns: self.unique_patterns,
            pattern_reuses: self.pattern_reuses,
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_evidence_entry() {
    let effect = EffectRef::new(DefId::new(1));
    let handler_id = DefId::new(2);
    let entry = EvidenceEntry::new(effect, handler_id, 0);

    assert!(entry.index() == 0);
    assert!(entry.handler_id().index == 2);
}

#[test]
fn test_evidence_vector_new() {
    let ev = EvidenceVector::new();
    assert!(ev.is_empty());
    assert!(ev.len() == 0);
}

#[test]
fn test_evidence_vector_add() {
    let mut ev = EvidenceVector::new();
    let effect = EffectRef::new(DefId::new(1));
    let handler = DefId::new(2);

    ev.add(effect, handler);

    assert!(ev.len() == 1);
    assert!(ev.lookup(&DefId::new(1)).is_some());
}

#[test]
fn test_evidence_vector_lookup() {
    let mut ev = EvidenceVector::new();
    ev.add(EffectRef::new(DefId::new(1)), DefId::new(10));
    ev.add(EffectRef::new(DefId::new(2)), DefId::new(20));

    let entry1 = ev.lookup(&DefId::new(1));
    assert!(entry1.is_some());
    match entry1 {
        Option::Some(e) => assert!(e.handler_id.index == 10),
        Option::None => assert!(false),
    }

    let entry2 = ev.lookup(&DefId::new(2));
    assert!(entry2.is_some());

    let entry3 = ev.lookup(&DefId::new(99));
    assert!(entry3.is_none());
}

#[test]
fn test_evidence_push_scope() {
    let mut ev1 = EvidenceVector::new();
    ev1.add(EffectRef::new(DefId::new(1)), DefId::new(10));

    let evidence = Evidence::new(ev1);
    assert!(evidence.depth() == 0);

    let mut ev2 = EvidenceVector::new();
    ev2.add(EffectRef::new(DefId::new(2)), DefId::new(20));

    let scoped = evidence.push_scope(ev2);
    assert!(scoped.depth() == 1);
    assert!(scoped.vector.len() == 2);
}

#[test]
fn test_evidence_index_of() {
    let mut ev = EvidenceVector::new();
    ev.add(EffectRef::new(DefId::new(1)), DefId::new(10));
    ev.add(EffectRef::new(DefId::new(2)), DefId::new(20));

    let evidence = Evidence::new(ev);

    match evidence.index_of(&DefId::new(1)) {
        Option::Some(idx) => assert!(idx == 0),
        Option::None => assert!(false),
    }

    match evidence.index_of(&DefId::new(2)) {
        Option::Some(idx) => assert!(idx == 1),
        Option::None => assert!(false),
    }

    assert!(evidence.index_of(&DefId::new(99)).is_none());
}

#[test]
fn test_evidence_context() {
    let mut ctx = EvidenceContext::new();
    assert!(!ctx.has_evidence());
    assert!(ctx.effect_count() == 0);

    ctx.register_effect(&DefId::new(1), 0);
    ctx.register_effect(&DefId::new(2), 1);

    assert!(ctx.has_evidence());
    assert!(ctx.effect_count() == 2);

    match ctx.lookup(&DefId::new(1)) {
        Option::Some(idx) => assert!(idx == 0),
        Option::None => assert!(false),
    }
}

#[test]
fn test_handler_pattern() {
    let mut pattern = HandlerPattern::empty();
    assert!(pattern.is_empty());

    pattern.add(DefId::new(1), DefId::new(10));
    pattern.add(DefId::new(2), DefId::new(20));

    assert!(!pattern.is_empty());
    assert!(pattern.len() == 2);
}

#[test]
fn test_handler_pattern_equality() {
    let mut p1 = HandlerPattern::empty();
    p1.add(DefId::new(1), DefId::new(10));

    let mut p2 = HandlerPattern::empty();
    p2.add(DefId::new(1), DefId::new(10));

    let mut p3 = HandlerPattern::empty();
    p3.add(DefId::new(1), DefId::new(20)); // Different handler

    assert!(p1.eq(&p2));
    assert!(!p1.eq(&p3));
}

#[test]
fn test_evidence_cache() {
    let mut cache = EvidenceCache::new();
    assert!(cache.is_empty());

    let mut pattern = HandlerPattern::empty();
    pattern.add(DefId::new(1), DefId::new(10));

    let mut ev = EvidenceVector::new();
    ev.add(EffectRef::new(DefId::new(1)), DefId::new(10));

    assert!(cache.get(&pattern).is_none());

    cache.insert(&pattern, ev);
    assert!(!cache.is_empty());
    assert!(cache.len() == 1);
    assert!(cache.contains(&pattern));
}

#[test]
fn test_cache_stats() {
    let stats = CacheStats::new();
    assert!(stats.hits == 0);
    assert!(stats.misses == 0);
    assert!(stats.hit_rate() == 0.0);
}

#[test]
fn test_static_evidence_id() {
    let id = StaticEvidenceId::new(42);
    assert!(id.index() == 42);
}

#[test]
fn test_handler_state_kind() {
    assert!(HandlerStateKind::Stateless.is_static());
    assert!(HandlerStateKind::Constant.is_static());
    assert!(HandlerStateKind::ZeroInit.is_static());
    assert!(!HandlerStateKind::Dynamic.is_static());
}

#[test]
fn test_static_evidence() {
    let mut ev = StaticEvidence::new(StaticEvidenceId::new(0));
    assert!(ev.is_empty());
    assert!(ev.fully_static);

    ev.add_entry(StaticEvidenceEntry::stateless(DefId::new(1), DefId::new(10)));
    assert!(!ev.is_empty());
    assert!(ev.fully_static);
    assert!(ev.can_emit_static());

    ev.add_entry(StaticEvidenceEntry::dynamic(DefId::new(2), DefId::new(20)));
    assert!(!ev.fully_static);
    assert!(!ev.can_emit_static());
}

#[test]
fn test_static_evidence_registry() {
    let mut registry = StaticEvidenceRegistry::new();
    assert!(registry.is_empty());

    let mut pattern = HandlerPattern::empty();
    pattern.add(DefId::new(1), DefId::new(10));

    let mut evidence = StaticEvidence::new(StaticEvidenceId::new(0));
    evidence.add_entry(StaticEvidenceEntry::stateless(DefId::new(1), DefId::new(10)));

    let id = registry.register(&pattern, evidence);
    assert!(id.index() == 0);
    assert!(registry.len() == 1);
    assert!(registry.contains(&pattern));

    // Registering same pattern should return same ID
    let evidence2 = StaticEvidence::new(StaticEvidenceId::new(0));
    let id2 = registry.register(&pattern, evidence2);
    assert!(id.eq(&id2));
    assert!(registry.len() == 1); // Still only one pattern
}
