// Blood Self-Hosted Compiler - Codegen Terminators
//
// This module handles generating LLVM IR for MIR terminators.

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod codegen_ctx;
mod codegen_expr;

// ============================================================
// Terminator Codegen
// ============================================================

/// Generates LLVM IR for a terminator.
pub fn emit_terminator(
    ctx: &mut codegen_ctx::CodegenCtx,
    term: &mir_term::Terminator,
) {
    match &term.kind {
        &mir_term::TerminatorKind::Goto { target } => {
            let label = ctx.block_label(target);
            ctx.emit_br(label.as_str());
        }
        &mir_term::TerminatorKind::SwitchInt { ref discr, ref targets } => {
            emit_switch_int(ctx, discr, targets);
        }
        &mir_term::TerminatorKind::Return => {
            emit_return(ctx);
        }
        &mir_term::TerminatorKind::Call { ref func, ref args, ref destination, ref target, unwind: _ } => {
            emit_call(ctx, func, args, destination, target);
        }
        &mir_term::TerminatorKind::Assert { ref cond, expected, ref msg, target, unwind: _ } => {
            emit_assert(ctx, cond, expected, msg, target);
        }
        &mir_term::TerminatorKind::Perform { effect_id, op_index, ref args, ref destination, ref target, is_tail_resumptive: _ } => {
            // Effect perform - call runtime to look up and dispatch to handler
            let effect_id_val = codegen_types::format_u64(effect_id.index as u64);
            let op_index_val = codegen_types::format_u64(op_index as u64);
            let dest = codegen_expr::emit_place_addr(ctx, destination);

            // Pack arguments into array for runtime
            let args_vals: Vec<String> = emit_operand_list(ctx, args);
            let num_args_val = codegen_types::format_u64(args_vals.len() as u64);

            // Call @blood_perform(effect_id, op_index, num_args, args_ptr, result_ptr)
            // For now, simplified: store result directly
            let result = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&result);
            ctx.write(" = call i64 @blood_perform(i64 ");
            ctx.write_string(&effect_id_val);
            ctx.write(", i64 ");
            ctx.write_string(&op_index_val);
            ctx.write(", i64 ");
            ctx.write_string(&num_args_val);
            ctx.write(")\n");

            // Store result
            ctx.emit_store("i64", result.as_str(), dest.as_str());

            match target {
                &Option::Some(t) => {
                    let label = ctx.block_label(t);
                    ctx.emit_br(label.as_str());
                }
                &Option::None => {
                    ctx.emit_unreachable();
                }
            }
        }
        &mir_term::TerminatorKind::Resume { ref value } => {
            // Resume from handler - call runtime to transfer control back
            match value {
                &Option::Some(ref v) => {
                    let val = codegen_expr::emit_operand(ctx, v);
                    ctx.write_indent();
                    ctx.write("call void @blood_resume(i64 ");
                    ctx.write_string(&val);
                    ctx.write(")\n");
                }
                &Option::None => {
                    // Unit-resume: pass 0
                    ctx.write_indent();
                    ctx.write("call void @blood_resume(i64 0)\n");
                }
            }

            // Resume doesn't return, emit unreachable (runtime handles control transfer)
            ctx.emit_unreachable();
        }
        &mir_term::TerminatorKind::Unreachable => {
            ctx.emit_unreachable();
        }
        &mir_term::TerminatorKind::Drop { ref place, target, unwind: _ } => {
            // Drop - call destructor if needed, then continue
            let _ptr = codegen_expr::emit_place_addr(ctx, place);
            // For now, just continue to target
            let label = ctx.block_label(target);
            ctx.emit_br(label.as_str());
        }
    }
}

/// Emits a switch on an integer value.
fn emit_switch_int(
    ctx: &mut codegen_ctx::CodegenCtx,
    discr: &mir_types::Operand,
    switch_targets: &mir_types::SwitchTargets,
) {
    let (discr_val, discr_ty) = codegen_expr::emit_operand_typed(ctx, discr);

    // Check if this is a simple boolean switch
    if switch_targets.targets.len() == 1 {
        // Binary switch - use conditional branch
        let default_label = ctx.block_label(switch_targets.otherwise);
        let case_target = &switch_targets.targets[0];
        let case_label = ctx.block_label(case_target.target);
        let case_val = codegen_types::format_u128(case_target.value);

        // Compare discriminant with case value using actual type
        let cmp_result = ctx.fresh_temp();
        ctx.emit_icmp(cmp_result.as_str(), "eq", discr_ty.as_str(), discr_val.as_str(), case_val.as_str());
        ctx.emit_cond_br(cmp_result.as_str(), case_label.as_str(), default_label.as_str());
    } else {
        // Multi-way switch
        let default_label = ctx.block_label(switch_targets.otherwise);

        // Build cases vector
        let mut cases: Vec<(String, String)> = Vec::new();
        let mut i: usize = 0;
        while i < switch_targets.targets.len() {
            let switch_target = &switch_targets.targets[i];
            let val_str = codegen_types::format_u128(switch_target.value);
            let label = ctx.block_label(switch_target.target);
            cases.push((val_str, label));
            i = i + 1;
        }

        ctx.emit_switch(discr_ty.as_str(), discr_val.as_str(), default_label.as_str(), &cases);
    }
}

/// Emits a return from the function.
fn emit_return(ctx: &mut codegen_ctx::CodegenCtx) {
    // Load return value from _0
    let ret_local = mir_def::MirLocalId::new(0);
    let ret_name = ctx.local_name(ret_local);
    let ret_ty = ctx.get_local_type(ret_local);

    // Check if return type is void (unit type)
    let is_void = is_void_type(ret_ty.as_str());

    if is_void {
        ctx.emit_ret("void", Option::None);
    } else {
        let ret_val = ctx.fresh_temp();
        ctx.emit_load(ret_val.as_str(), ret_ty.as_str(), ret_name.as_str());
        ctx.emit_ret(ret_ty.as_str(), Option::Some(ret_val.as_str()));
    }
}

/// Emits a function call.
fn emit_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    func: &mir_types::Operand,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Try to extract a direct function name from the operand to avoid
    // unnecessary store/load indirection for known function references.
    let func_val = match extract_direct_fn_name(ctx, func) {
        Option::Some(name) => name,
        Option::None => {
            // Fallback: emit the operand normally (may produce %tmp from a local load)
            let func_typed = codegen_expr::emit_operand_typed(ctx, func);
            let raw_func = func_typed.0;
            let func_ty = func_typed.1;
            // LLVM requires call targets to be ptr type.
            // SSA values loaded as i64 need inttoptr conversion.
            // Fat pointers (struct { ptr, i64 }) need extractvalue instead.
            if starts_with_percent(&raw_func) && !string_eq_str(func_ty.as_str(), "ptr") {
                let func_ty_bytes = func_ty.as_bytes();
                let is_fat_ptr = func_ty_bytes.len() > 0 && func_ty_bytes[0] == 123; // '{'
                if is_fat_ptr {
                    // Fat pointer: extract the data pointer (field 0)
                    let extracted = ctx.fresh_temp();
                    ctx.write_indent();
                    ctx.write_string(&extracted);
                    ctx.write(" = extractvalue ");
                    ctx.write_string(&func_ty);
                    ctx.write(" ");
                    ctx.write_string(&raw_func);
                    ctx.write(", 0\n");
                    extracted
                } else {
                    // Integer type: use inttoptr
                    let cast = ctx.fresh_temp();
                    ctx.emit_cast(cast.as_str(), "inttoptr", func_ty.as_str(), raw_func.as_str(), "ptr");
                    cast
                }
            } else {
                raw_func
            }
        }
    };

    // Check for Vec builtin functions which have special calling conventions
    if is_vec_new(&func_val) {
        emit_vec_new_call(ctx, destination, target);
        return;
    }
    if is_vec_push(&func_val) {
        emit_vec_push_call(ctx, args, target);
        return;
    }
    if is_vec_len(&func_val) {
        emit_vec_len_call(ctx, args, destination, target);
        return;
    }
    if is_vec_pop(&func_val) {
        emit_vec_pop_call(ctx, args, destination, target);
        return;
    }
    if is_vec_clear(&func_val) {
        emit_vec_clear_call(ctx, args, target);
        return;
    }

    // Check for String builtin functions which have special calling conventions
    if is_string_new(&func_val) {
        emit_string_new_call(ctx, destination, target);
        return;
    }
    if is_string_push_str(&func_val) {
        emit_string_push_str_call(ctx, args, target);
        return;
    }
    if is_string_len(&func_val) {
        emit_string_len_call(ctx, args, destination, target);
        return;
    }
    if is_string_push(&func_val) {
        emit_string_push_call(ctx, args, target);
        return;
    }
    if is_string_as_str(&func_val) {
        emit_string_as_str_call(ctx, args, destination, target);
        return;
    }
    if is_string_as_bytes(&func_val) {
        emit_string_as_bytes_call(ctx, args, destination, target);
        return;
    }

    // Check for Option builtin functions which have special calling conventions
    if is_option_is_some(&func_val) {
        emit_option_is_some_call(ctx, args, destination, target);
        return;
    }
    if is_option_is_none(&func_val) {
        emit_option_is_none_call(ctx, args, destination, target);
        return;
    }
    if is_option_unwrap(&func_val) {
        emit_option_unwrap_call(ctx, args, destination, target);
        return;
    }
    if is_option_as_ref(&func_val) {
        emit_option_as_ref_call(ctx, args, destination, target);
        return;
    }

    // Emit arguments with their types
    let mut llvm_args: Vec<(String, String)> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, &args[i]);
        llvm_args.push((arg_ty, arg_val));
        i = i + 1;
    }

    // Get return type from destination
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    let return_ty = ctx.get_local_type(destination.local);

    // Check if return type is void (unit type)
    let is_void = is_void_type(return_ty.as_str());

    if is_void {
        // Void function - no return value
        ctx.emit_call(
            Option::None,
            "void",
            func_val.as_str(),
            &llvm_args,
        );
    } else {
        // Non-void function - capture return value
        let result = ctx.fresh_temp();
        ctx.emit_call(
            Option::Some(result.as_str()),
            return_ty.as_str(),
            func_val.as_str(),
            &llvm_args,
        );
        // Store result
        ctx.emit_store(return_ty.as_str(), result.as_str(), dest_ptr.as_str());
    }

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Extracts a direct function name from a MIR operand.
/// Returns Some("@fn_name") if the operand is a Constant(FnDef(...)),
/// None otherwise (for Copy/Move of locals, which need the load path).
fn extract_direct_fn_name(
    ctx: &mut codegen_ctx::CodegenCtx,
    operand: &mir_types::Operand,
) -> Option<String> {
    match operand {
        &mir_types::Operand::Constant(ref constant) => {
            match &constant.kind {
                &mir_types::ConstantKind::FnDef(ref def_id) => {
                    match ctx.lookup_def_name(def_id.index) {
                        Option::Some(name) => {
                            let mut result = common::make_string("@");
                            result.push_str(name.as_str());
                            Option::Some(result)
                        }
                        Option::None => {
                            let mut result = common::make_string("@fn_");
                            result.push_str(codegen_types::format_u64(def_id.index as u64).as_str());
                            Option::Some(result)
                        }
                    }
                }
                _ => Option::None,
            }
        }
        _ => Option::None,
    }
}

/// Checks if an LLVM type is void/unit.
fn is_void_type(llvm_ty: &str) -> bool {
    let bytes = llvm_ty.as_bytes();
    if bytes.len() == 4 {
        // Check for "void"
        if bytes[0] == 118 && bytes[1] == 111 && bytes[2] == 105 && bytes[3] == 100 {
            return true;
        }
    }
    if bytes.len() == 2 {
        // Check for "{}"
        if bytes[0] == 123 && bytes[1] == 125 {
            return true;
        }
    }
    false
}

/// Emits an assertion.
/// On failure, prints the assertion message and traps.
fn emit_assert(
    ctx: &mut codegen_ctx::CodegenCtx,
    cond: &mir_types::Operand,
    expected: bool,
    msg: &String,
    target: mir_def::BasicBlockId,
) {
    let cond_val = codegen_expr::emit_operand(ctx, cond);

    // Create labels
    let success_label = ctx.block_label(target);
    let fail_label = ctx.fresh_label();

    // Compare condition with expected
    if expected {
        // Expect true: if cond, goto success, else fail
        ctx.emit_cond_br(cond_val.as_str(), success_label.as_str(), fail_label.as_str());
    } else {
        // Expect false: if cond, goto fail, else success
        ctx.emit_cond_br(cond_val.as_str(), fail_label.as_str(), success_label.as_str());
    }

    // Fail block
    ctx.emit_label(fail_label.as_str());
    ctx.indent();

    // Build the full assertion message: "Assertion failed: <msg>\n"
    let mut full_msg = common::make_string("Assertion failed: ");
    full_msg.push_str(msg.as_str());

    // Add the message as a string constant and get its label
    let msg_label = ctx.add_string_constant(&full_msg);

    // Call puts() to print the message to stderr before trapping
    // puts takes a pointer and returns i32
    ctx.write("    call i32 @puts(ptr ");
    ctx.write_string(&msg_label);
    ctx.write(")\n");

    // Call panic or trap
    ctx.writeln("call void @llvm.trap()");
    ctx.emit_unreachable();
    ctx.dedent();
}

/// Emits a list of operands and returns their values.
fn emit_operand_list(
    ctx: &mut codegen_ctx::CodegenCtx,
    operands: &Vec<mir_types::Operand>,
) -> Vec<String> {
    let mut result: Vec<String> = Vec::new();
    let mut i: usize = 0;
    while i < operands.len() {
        result.push(codegen_expr::emit_operand(ctx, &operands[i]));
        i = i + 1;
    }
    result
}

/// Compares a &str against a &str for equality.
fn string_eq_str(a: &str, b: &str) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Checks if a string starts with '%' (SSA register name).
fn starts_with_percent(s: &String) -> bool {
    let bytes = s.as_bytes();
    if bytes.len() > 0 {
        bytes[0] == 37 // '%'
    } else {
        false
    }
}

// ============================================================
// Vec Builtin Handling
// ============================================================
// Vec runtime functions have special calling conventions:
//   vec_new(i64 elem_size, ptr out_ptr) -> void
//   vec_push(ptr vec, ptr elem_ptr, i64 elem_size) -> void
//   vec_len(ptr vec) -> i64

/// Checks if the function name is @vec_new.
fn is_vec_new(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_new")
}

/// Checks if the function name is @vec_push.
fn is_vec_push(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_push")
}

/// Checks if the function name is @vec_len.
fn is_vec_len(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_len")
}

/// Checks if the function name is @vec_pop.
fn is_vec_pop(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_pop")
}

/// Checks if the function name is @vec_clear.
fn is_vec_clear(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_clear")
}

/// Extracts element type from Vec<T> HIR type.
/// Returns the element type T if the type is Vec<T>, None otherwise.
fn extract_vec_element_type(ty: &hir_ty::Type) -> Option<hir_ty::Type> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            // Vec<T> has one type argument
            if args.len() > 0 {
                // Clone the element type
                Option::Some(clone_type(&args[0]))
            } else {
                Option::None
            }
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            // Handle &Vec<T> or &mut Vec<T>
            extract_vec_element_type(inner.as_ref())
        }
        _ => Option::None,
    }
}

/// Clones a HIR type (needed because we can't move out of borrowed content).
fn clone_type(ty: &hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type::new(clone_type_kind(&ty.kind))
}

/// Clones a HIR type kind.
fn clone_type_kind(kind: &hir_ty::TypeKind) -> hir_ty::TypeKind {
    match kind {
        &hir_ty::TypeKind::Primitive(ref p) => hir_ty::TypeKind::Primitive(clone_primitive(p)),
        &hir_ty::TypeKind::Tuple(ref elems) => {
            let mut cloned: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < elems.len() {
                cloned.push(clone_type(&elems[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Tuple(cloned)
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::TypeKind::Ref {
                inner: Box::new(clone_type(inner.as_ref())),
                mutable,
            }
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::TypeKind::Ptr {
                inner: Box::new(clone_type(inner.as_ref())),
                mutable,
            }
        }
        &hir_ty::TypeKind::Adt { ref def_id, ref args } => {
            let mut cloned_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                cloned_args.push(clone_type(&args[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Adt {
                def_id: hir_def::DefId { index: def_id.index },
                args: cloned_args,
            }
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::TypeKind::Array {
                element: Box::new(clone_type(element.as_ref())),
                size,
            }
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::TypeKind::Slice {
                element: Box::new(clone_type(element.as_ref())),
            }
        }
        &hir_ty::TypeKind::Infer(ref var_id) => {
            hir_ty::TypeKind::Infer(hir_def::TyVarId { index: var_id.index })
        }
        &hir_ty::TypeKind::Param(ref var_id) => {
            hir_ty::TypeKind::Param(hir_def::TyVarId { index: var_id.index })
        }
        &hir_ty::TypeKind::Error => hir_ty::TypeKind::Error,
        &hir_ty::TypeKind::Never => hir_ty::TypeKind::Never,
        _ => {
            // For other complex types, fall back to Error
            // This is safe because we're only using this for Vec element extraction
            hir_ty::TypeKind::Error
        }
    }
}

/// Clones a primitive type.
fn clone_primitive(p: &hir_ty::PrimitiveTy) -> hir_ty::PrimitiveTy {
    match p {
        &hir_ty::PrimitiveTy::Bool => hir_ty::PrimitiveTy::Bool,
        &hir_ty::PrimitiveTy::Char => hir_ty::PrimitiveTy::Char,
        &hir_ty::PrimitiveTy::I8 => hir_ty::PrimitiveTy::I8,
        &hir_ty::PrimitiveTy::I16 => hir_ty::PrimitiveTy::I16,
        &hir_ty::PrimitiveTy::I32 => hir_ty::PrimitiveTy::I32,
        &hir_ty::PrimitiveTy::I64 => hir_ty::PrimitiveTy::I64,
        &hir_ty::PrimitiveTy::I128 => hir_ty::PrimitiveTy::I128,
        &hir_ty::PrimitiveTy::Isize => hir_ty::PrimitiveTy::Isize,
        &hir_ty::PrimitiveTy::U8 => hir_ty::PrimitiveTy::U8,
        &hir_ty::PrimitiveTy::U16 => hir_ty::PrimitiveTy::U16,
        &hir_ty::PrimitiveTy::U32 => hir_ty::PrimitiveTy::U32,
        &hir_ty::PrimitiveTy::U64 => hir_ty::PrimitiveTy::U64,
        &hir_ty::PrimitiveTy::U128 => hir_ty::PrimitiveTy::U128,
        &hir_ty::PrimitiveTy::Usize => hir_ty::PrimitiveTy::Usize,
        &hir_ty::PrimitiveTy::F32 => hir_ty::PrimitiveTy::F32,
        &hir_ty::PrimitiveTy::F64 => hir_ty::PrimitiveTy::F64,
        &hir_ty::PrimitiveTy::Str => hir_ty::PrimitiveTy::Str,
    }
}

/// Emits a vec_new call with correct calling convention.
/// Runtime signature: void @vec_new(i64 elem_size, ptr out_ptr)
///
/// The runtime expects out_ptr to point to 24 bytes of space where the Vec
/// struct { ptr data, i64 len, i64 capacity } will be written. However, the
/// self-hosted compiler represents ADTs as pointers, so the destination local
/// only has 8 bytes. We allocate a separate 24-byte space for the Vec struct
/// and store a pointer to it in the destination.
fn emit_vec_new_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Get destination pointer (where the Vec ptr will be stored)
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);

    // Get element size from the destination's HIR type (Vec<T>)
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            match extract_vec_element_type(hir_ty) {
                Option::Some(elem_ty) => codegen_types::type_size_bytes(&elem_ty),
                Option::None => 8, // Fallback to pointer size
            }
        }
        Option::None => 8, // Fallback to pointer size
    };

    // Allocate space for the Vec struct (24 bytes: ptr + len + capacity)
    let vec_struct = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&vec_struct);
    ctx.write(" = alloca { ptr, i64, i64 }, align 8\n");

    // Emit: call void @vec_new(i64 elem_size, ptr vec_struct)
    let mut args: Vec<(String, String)> = Vec::new();
    args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    // Copy vec_struct string for use in args (Blood has no .clone())
    let mut vec_struct_copy = common::make_string("");
    vec_struct_copy.push_str(vec_struct.as_str());
    args.push((common::make_string("ptr"), vec_struct_copy));

    ctx.emit_call(Option::None, "void", "@vec_new", &args);

    // Store pointer to Vec struct in destination
    let vec_struct_str = vec_struct.as_str();
    ctx.emit_store("ptr", vec_struct_str, dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_push call with correct calling convention.
/// Runtime signature: void @vec_push(ptr vec, ptr elem_ptr, i64 elem_size)
fn emit_vec_push_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    // args[1] is the element (T)
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec pointer - this is a pointer to the Vec struct pointer (double indirection)
    // because the self-hosted compiler represents ADTs as pointers and passes &mut Vec
    let vec_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get the actual Vec struct pointer
    let vec_ptr = ctx.fresh_temp();
    ctx.emit_load(vec_ptr.as_str(), "ptr", vec_ref.as_str());

    // Get element value and type
    let (elem_val, elem_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // Allocate temporary storage for the element
    let elem_alloca = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&elem_alloca);
    ctx.write(" = alloca ");
    ctx.write_string(&elem_ty);
    ctx.write(", align 8\n");

    // Store element value to alloca
    ctx.emit_store(elem_ty.as_str(), elem_val.as_str(), elem_alloca.as_str());

    // Get element size from the element's HIR type
    let elem_size: u64 = match &args[1] {
        &mir_types::Operand::Copy(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_types::type_size_bytes(hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Move(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_types::type_size_bytes(hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Constant(ref c) => {
            codegen_types::type_size_bytes(&c.ty)
        }
    };

    // Emit: call void @vec_push(ptr vec, ptr elem_ptr, i64 elem_size)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));
    call_args.push((common::make_string("ptr"), elem_alloca));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));

    ctx.emit_call(Option::None, "void", "@vec_push", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_len call with correct calling convention.
/// Runtime signature: i64 @vec_len(ptr vec)
fn emit_vec_len_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec reference - this is a pointer to the Vec struct pointer (double indirection)
    let vec_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get the actual Vec struct pointer
    let vec_ptr = ctx.fresh_temp();
    ctx.emit_load(vec_ptr.as_str(), "ptr", vec_ref.as_str());

    // Emit: %result = call i64 @vec_len(ptr vec)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut vec_ptr_copy = common::make_string("");
    vec_ptr_copy.push_str(vec_ptr.as_str());
    call_args.push((common::make_string("ptr"), vec_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i64", "@vec_len", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("i64", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_pop call with correct calling convention.
/// Runtime signature: i32 @vec_pop(ptr vec, i64 elem_size, ptr out_ptr)
/// Returns 1 on success (element popped), 0 if vec was empty.
fn emit_vec_pop_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec reference - this is a pointer to the Vec struct pointer (double indirection)
    let vec_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get the actual Vec struct pointer
    let vec_ptr = ctx.fresh_temp();
    ctx.emit_load(vec_ptr.as_str(), "ptr", vec_ref.as_str());

    // Get element size from destination's HIR type (Option<T>)
    // pop returns Option<T>, so we need to extract T's size
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            // Destination is Option<T>, extract T's size
            match extract_vec_element_type(hir_ty) {
                Option::Some(elem_ty) => codegen_types::type_size_bytes(&elem_ty),
                Option::None => 8,
            }
        }
        Option::None => 8,
    };

    // Allocate output pointer for the popped element
    let out_alloca = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&out_alloca);
    ctx.write(" = alloca [");
    ctx.write_string(&codegen_types::format_u64(elem_size));
    ctx.write(" x i8], align 8\n");

    // Emit: %result = call i32 @vec_pop(ptr vec, i64 elem_size, ptr out_ptr)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    // Save out_alloca string for use in call args and later memcpy
    let out_alloca_str = out_alloca.as_str();
    let mut out_alloca_copy = common::make_string("");
    out_alloca_copy.push_str(out_alloca_str);
    call_args.push((common::make_string("ptr"), out_alloca_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i32", "@vec_pop", &call_args);

    // Build Option<T> in destination
    // Option is typically { i8 tag, T value }
    // tag = 0 for None, tag = 1 for Some
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);

    // Store the tag (result from vec_pop: 0=empty/None, 1=success/Some)
    let tag_i8 = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&tag_i8);
    ctx.write(" = trunc i32 ");
    ctx.write_string(&result);
    ctx.write(" to i8\n");
    ctx.emit_store("i8", tag_i8.as_str(), dest_ptr.as_str());

    // If result was 1 (Some), copy the element data
    // Calculate offset for the value field (after tag, with alignment)
    let value_offset = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&value_offset);
    ctx.write(" = getelementptr i8, ptr ");
    ctx.write_string(&dest_ptr);
    ctx.write(", i64 8\n"); // Assuming 8-byte alignment for Option payload

    // Copy element data from out_alloca to Option's value field
    ctx.write_indent();
    ctx.write("call void @llvm.memcpy.p0.p0.i64(ptr ");
    ctx.write_string(&value_offset);
    ctx.write(", ptr ");
    ctx.write_string(&out_alloca);
    ctx.write(", i64 ");
    ctx.write_string(&codegen_types::format_u64(elem_size));
    ctx.write(", i1 false)\n");

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_clear call with correct calling convention.
/// Runtime signature: void @vec_clear(ptr vec)
fn emit_vec_clear_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec reference - this is a pointer to the Vec struct pointer (double indirection)
    let vec_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get the actual Vec struct pointer
    let vec_ptr = ctx.fresh_temp();
    ctx.emit_load(vec_ptr.as_str(), "ptr", vec_ref.as_str());

    // Emit: call void @vec_clear(ptr vec)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));

    ctx.emit_call(Option::None, "void", "@vec_clear", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// String Builtin Handling
// ============================================================
// String runtime functions have special calling conventions:
//   string_new(ptr out_ptr) -> void
//   string_len(ptr self) -> i64
//   string_push(ptr self, i32 char) -> void
//   string_push_str(ptr self, {ptr, i64} str) -> void
//   string_as_str(ptr self) -> ptr
//   string_as_bytes(ptr self) -> ptr

/// Checks if the function name is @string_new.
fn is_string_new(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_new")
}

/// Checks if the function name is @string_push_str.
fn is_string_push_str(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_push_str")
}

/// Checks if the function name is @string_len.
fn is_string_len(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_len")
}

/// Checks if the function name is @string_push.
fn is_string_push(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_push")
}

/// Checks if the function name is @string_as_str.
fn is_string_as_str(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_as_str")
}

/// Checks if the function name is @string_as_bytes.
fn is_string_as_bytes(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_as_bytes")
}

/// Emits a string_new call with correct calling convention.
/// Runtime signature: void @string_new(ptr out_ptr)
fn emit_string_new_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Get destination pointer
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);

    // Allocate space for String struct (similar to Vec: ptr + len + capacity = 24 bytes)
    let str_struct = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&str_struct);
    ctx.write(" = alloca { ptr, i64, i64 }, align 8\n");

    // Emit: call void @string_new(ptr str_struct)
    let mut args: Vec<(String, String)> = Vec::new();
    let mut str_struct_copy = common::make_string("");
    str_struct_copy.push_str(str_struct.as_str());
    args.push((common::make_string("ptr"), str_struct_copy));

    ctx.emit_call(Option::None, "void", "@string_new", &args);

    // Store pointer to String struct in destination
    ctx.emit_store("ptr", str_struct.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_push_str call with correct calling convention.
/// Runtime signature: void @string_push_str(ptr self, {ptr, i64} str)
fn emit_string_push_str_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get string reference (double indirect)
    let str_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual String struct pointer
    let str_ptr = ctx.fresh_temp();
    ctx.emit_load(str_ptr.as_str(), "ptr", str_ref.as_str());

    // Get the &str argument (fat pointer)
    let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // Emit: call void @string_push_str(ptr self, {ptr, i64} str)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), str_ptr));
    call_args.push((arg_ty, arg_val));

    ctx.emit_call(Option::None, "void", "@string_push_str", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_len call with correct calling convention.
/// Runtime signature: i64 @string_len(ptr self)
fn emit_string_len_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string reference (double indirect)
    let str_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual String struct pointer
    let str_ptr = ctx.fresh_temp();
    ctx.emit_load(str_ptr.as_str(), "ptr", str_ref.as_str());

    // Emit: %result = call i64 @string_len(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i64", "@string_len", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("i64", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_push call with correct calling convention.
/// Runtime signature: void @string_push(ptr self, i32 char)
fn emit_string_push_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get string reference (double indirect)
    let str_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual String struct pointer
    let str_ptr = ctx.fresh_temp();
    ctx.emit_load(str_ptr.as_str(), "ptr", str_ref.as_str());

    // Get char argument - it may be { i32 } struct, need to extract i32
    let (char_val, char_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // If char type is a struct { i32 }, extract the i32
    let char_i32 = if string_eq_str(char_ty.as_str(), "{ i32 }") {
        let extracted = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&extracted);
        ctx.write(" = extractvalue { i32 } ");
        ctx.write_string(&char_val);
        ctx.write(", 0\n");
        extracted
    } else {
        char_val
    };

    // Emit: call void @string_push(ptr self, i32 char)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), str_ptr));
    call_args.push((common::make_string("i32"), char_i32));

    ctx.emit_call(Option::None, "void", "@string_push", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_as_str call with correct calling convention.
/// Runtime signature: ptr @string_as_str(ptr self)
fn emit_string_as_str_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string reference (double indirect)
    let str_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual String struct pointer
    let str_ptr = ctx.fresh_temp();
    ctx.emit_load(str_ptr.as_str(), "ptr", str_ref.as_str());

    // Emit: %result = call ptr @string_as_str(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "ptr", "@string_as_str", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("ptr", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_as_bytes call with correct calling convention.
/// Runtime signature: ptr @string_as_bytes(ptr self)
fn emit_string_as_bytes_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string reference (double indirect)
    let str_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual String struct pointer
    let str_ptr = ctx.fresh_temp();
    ctx.emit_load(str_ptr.as_str(), "ptr", str_ref.as_str());

    // Emit: %result = call ptr @string_as_bytes(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "ptr", "@string_as_bytes", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("ptr", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// Option Builtin Handling
// ============================================================
// Option runtime functions have special calling conventions:
//   option_is_some(ptr self) -> i32
//   option_is_none(ptr self) -> i32
//   option_unwrap(ptr self, i64 elem_size, ptr out_ptr) -> void
//   option_as_ref(ptr self, i64 elem_size, ptr out_ptr) -> void

/// Checks if the function name is @option_is_some.
fn is_option_is_some(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_is_some")
}

/// Checks if the function name is @option_is_none.
fn is_option_is_none(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_is_none")
}

/// Checks if the function name is @option_unwrap.
fn is_option_unwrap(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_unwrap")
}

/// Checks if the function name is @option_as_ref.
fn is_option_as_ref(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_as_ref")
}

/// Emits an option_is_some call with correct calling convention.
/// Runtime signature: i32 @option_is_some(ptr self)
fn emit_option_is_some_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option reference (double indirect)
    let opt_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual Option struct pointer
    let opt_ptr = ctx.fresh_temp();
    ctx.emit_load(opt_ptr.as_str(), "ptr", opt_ref.as_str());

    // Emit: %result = call i32 @option_is_some(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i32", "@option_is_some", &call_args);

    // Convert i32 result to i1 for bool and store
    let bool_result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&bool_result);
    ctx.write(" = trunc i32 ");
    ctx.write_string(&result);
    ctx.write(" to i1\n");

    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("i1", bool_result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an option_is_none call with correct calling convention.
/// Runtime signature: i32 @option_is_none(ptr self)
fn emit_option_is_none_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option reference (double indirect)
    let opt_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual Option struct pointer
    let opt_ptr = ctx.fresh_temp();
    ctx.emit_load(opt_ptr.as_str(), "ptr", opt_ref.as_str());

    // Emit: %result = call i32 @option_is_none(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i32", "@option_is_none", &call_args);

    // Convert i32 result to i1 for bool and store
    let bool_result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&bool_result);
    ctx.write(" = trunc i32 ");
    ctx.write_string(&result);
    ctx.write(" to i1\n");

    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    ctx.emit_store("i1", bool_result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an option_unwrap call with correct calling convention.
/// Runtime signature: void @option_unwrap(ptr self, i64 elem_size, ptr out_ptr)
fn emit_option_unwrap_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option reference (double indirect)
    let opt_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual Option struct pointer
    let opt_ptr = ctx.fresh_temp();
    ctx.emit_load(opt_ptr.as_str(), "ptr", opt_ref.as_str());

    // Get destination pointer and its size
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);
    let dest_ty = ctx.get_local_type(destination.local);

    // Get element size from destination type
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => codegen_types::type_size_bytes(hir_ty),
        Option::None => 8,
    };

    // Emit: call void @option_unwrap(ptr self, i64 elem_size, ptr out_ptr)
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    call_args.push((common::make_string("ptr"), dest_ptr));

    ctx.emit_call(Option::None, "void", "@option_unwrap", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an option_as_ref call with correct calling convention.
/// Runtime signature: void @option_as_ref(ptr self, i64 elem_size, ptr out_ptr)
fn emit_option_as_ref_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option reference (double indirect)
    let opt_ref = codegen_expr::emit_operand(ctx, &args[0]);

    // Dereference to get actual Option struct pointer
    let opt_ptr = ctx.fresh_temp();
    ctx.emit_load(opt_ptr.as_str(), "ptr", opt_ref.as_str());

    // Get destination pointer
    let dest_ptr = codegen_expr::emit_place_addr(ctx, destination);

    // Get element size from destination type (Option<&T>)
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            match extract_vec_element_type(hir_ty) {
                Option::Some(inner) => codegen_types::type_size_bytes(&inner),
                Option::None => 8,
            }
        }
        Option::None => 8,
    };

    // Emit: call void @option_as_ref(ptr self, i64 elem_size, ptr out_ptr)
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    call_args.push((common::make_string("ptr"), dest_ptr));

    ctx.emit_call(Option::None, "void", "@option_as_ref", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// Basic Block Codegen
// ============================================================

/// Emits a complete basic block.
pub fn emit_basic_block(
    ctx: &mut codegen_ctx::CodegenCtx,
    block_id: mir_def::BasicBlockId,
    block: &mir_body::BasicBlockData,
) {
    // Emit label
    let label = ctx.block_label(block_id);
    ctx.emit_label(label.as_str());

    // Emit statements
    ctx.indent();
    let mut i: usize = 0;
    while i < block.statements.len() {
        codegen_stmt::emit_statement(ctx, &block.statements[i]);
        i = i + 1;
    }
    ctx.dedent();

    // Emit terminator
    ctx.indent();
    match &block.terminator {
        &Option::Some(ref term) => {
            emit_terminator(ctx, term);
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
    ctx.dedent();
}

// Forward declaration for codegen_stmt
mod codegen_stmt;
