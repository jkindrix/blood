// Blood Self-Hosted Compiler - Codegen Terminators
//
// This module handles generating LLVM IR for MIR terminators.

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod codegen_ctx;
mod codegen_expr;
mod dump_mir;

// ============================================================
// Terminator Codegen
// ============================================================

/// Generates LLVM IR for a terminator.
pub fn emit_terminator(
    ctx: &mut codegen_ctx::CodegenCtx,
    term: &mir_term::Terminator,
) {
    if ctx.trace_codegen {
        let trace = dump_mir::format_terminator(term);
        ctx.write("    ; MIR: ");
        ctx.write_string(&trace);
        ctx.newline();
    }
    match &term.kind {
        &mir_term::TerminatorKind::Goto { target } => {
            let label = ctx.block_label(target);
            ctx.emit_br(label.as_str());
        }
        &mir_term::TerminatorKind::SwitchInt { ref discr, ref targets } => {
            emit_switch_int(ctx, discr, targets);
        }
        &mir_term::TerminatorKind::Return => {
            emit_return(ctx);
        }
        &mir_term::TerminatorKind::Call { ref func, ref args, ref destination, ref target, unwind: _ } => {
            emit_call(ctx, func, args, destination, target);
        }
        &mir_term::TerminatorKind::Assert { ref cond, expected, ref msg, target, unwind: _ } => {
            emit_assert(ctx, cond, expected, msg, target);
        }
        &mir_term::TerminatorKind::Perform { effect_id, op_index, ref args, ref destination, ref target, is_tail_resumptive: _ } => {
            // Effect perform via evidence API 5-arg call:
            //   blood_perform(i64 effect_id, i32 op_index, ptr args, i64 arg_count, i64 continuation)
            let effect_id_val = codegen_types::format_u64(effect_id.index as u64);
            // op_index in MIR is the op_name symbol index; resolve to positional index
            let resolved_op_index = ctx.resolve_op_index(effect_id.index, op_index);
            let op_index_val = codegen_types::format_u64(resolved_op_index as u64);
            let dest = codegen_expr::emit_place_data_ptr(ctx, destination);

            // Pack arguments into [N x i64] stack array, widening each arg to i64
            let num_args = args.len();
            let num_args_val = codegen_types::format_u64(num_args as u64);

            // Allocate args array on stack
            let args_alloca = ctx.fresh_temp();
            if num_args > 0 {
                let arr_ty_str = make_array_type(num_args);
                ctx.write_indent();
                ctx.write_string(&args_alloca);
                ctx.write(" = alloca ");
                ctx.write_string(&arr_ty_str);
                ctx.write("\n");

                // Store each argument widened to i64 into the array
                let mut ai: usize = 0;
                while ai < num_args {
                    let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, &args[ai]);

                    // Widen arg to i64
                    let widened_val = widen_operand_to_i64(ctx, arg_val.as_str(), arg_ty.as_str());

                    // Get store target
                    let store_ptr = if ai == 0 {
                        // First element: alloca is already the pointer
                        clone_string(&args_alloca)
                    } else {
                        // Subsequent elements: GEP to index
                        let idx_str = codegen_types::format_u64(ai as u64);
                        let elem_ptr = ctx.fresh_temp();
                        ctx.write_indent();
                        ctx.write_string(&elem_ptr);
                        ctx.write(" = getelementptr ");
                        ctx.write_string(&arr_ty_str);
                        ctx.write(", ptr ");
                        ctx.write_string(&args_alloca);
                        ctx.write(", i64 0, i64 ");
                        ctx.write_string(&idx_str);
                        ctx.write("\n");
                        elem_ptr
                    };

                    ctx.write_indent();
                    ctx.write("store i64 ");
                    ctx.write_string(&widened_val);
                    ctx.write(", ptr ");
                    ctx.write_string(&store_ptr);
                    ctx.write("\n");

                    ai = ai + 1;
                }
            }

            // Create continuation (identity for tail-resumptive)
            let continuation = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&continuation);
            ctx.write(" = call i64 @blood_continuation_create_multishot(ptr @__blood_identity_continuation, ptr null)\n");

            // Call blood_perform(i64 effect_id, i32 op_index, ptr args, i64 arg_count, i64 continuation)
            let result = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&result);
            ctx.write(" = call i64 @blood_perform(i64 ");
            ctx.write_string(&effect_id_val);
            ctx.write(", i32 ");
            ctx.write_string(&op_index_val);
            ctx.write(", ptr ");
            if num_args > 0 {
                ctx.write_string(&args_alloca);
            } else {
                ctx.write("null");
            }
            ctx.write(", i64 ");
            ctx.write_string(&num_args_val);
            ctx.write(", i64 ");
            ctx.write_string(&continuation);
            ctx.write(")\n");

            // Store result
            ctx.emit_store("i64", result.as_str(), dest.as_str());

            match target {
                &Option::Some(t) => {
                    let label = ctx.block_label(t);
                    ctx.emit_br(label.as_str());
                }
                &Option::None => {
                    ctx.emit_unreachable();
                }
            }
        }
        &mir_term::TerminatorKind::Resume { ref value } => {
            // Resume from handler op body.
            // The inner body returns the resume value in its natural return type.
            // The wrapper function handles widening to i64 and continuation resume.
            match value {
                &Option::Some(ref v) => {
                    let (val, ty) = codegen_expr::emit_operand_typed(ctx, v);
                    if str_eq(ty.as_str(), "{}") || is_void_type(ty.as_str()) {
                        // Unit-typed resume value â†’ ret void
                        ctx.emit_ret("void", Option::None);
                    } else {
                        ctx.emit_ret(ty.as_str(), Option::Some(val.as_str()));
                    }
                }
                &Option::None => {
                    // Unit-resume: ret void
                    ctx.emit_ret("void", Option::None);
                }
            }
        }
        &mir_term::TerminatorKind::Unreachable => {
            ctx.emit_unreachable();
        }
        &mir_term::TerminatorKind::Drop { ref place, target, unwind: _ } => {
            // Drop - call destructor if needed, then continue
            let _ptr = codegen_expr::emit_place_addr(ctx, place);
            // For now, just continue to target
            let label = ctx.block_label(target);
            ctx.emit_br(label.as_str());
        }
    }
}

/// Emits a switch on an integer value.
fn emit_switch_int(
    ctx: &mut codegen_ctx::CodegenCtx,
    discr: &mir_types::Operand,
    switch_targets: &mir_types::SwitchTargets,
) {
    let (discr_val, discr_ty) = codegen_expr::emit_operand_typed(ctx, discr);

    // Check if this is a simple boolean switch
    if switch_targets.targets.len() == 1 {
        // Binary switch - use conditional branch
        let default_label = ctx.block_label(switch_targets.otherwise);
        let case_target = &switch_targets.targets[0];
        let case_label = ctx.block_label(case_target.target);
        let case_val = codegen_types::format_u128(case_target.value);

        // Compare discriminant with case value using actual type
        let cmp_result = ctx.fresh_temp();
        ctx.emit_icmp(cmp_result.as_str(), "eq", discr_ty.as_str(), discr_val.as_str(), case_val.as_str());
        ctx.emit_cond_br(cmp_result.as_str(), case_label.as_str(), default_label.as_str());
    } else {
        // Multi-way switch
        let default_label = ctx.block_label(switch_targets.otherwise);

        // Build cases vector
        let mut cases: Vec<(String, String)> = Vec::new();
        let mut i: usize = 0;
        while i < switch_targets.targets.len() {
            let switch_target = &switch_targets.targets[i];
            let val_str = codegen_types::format_u128(switch_target.value);
            let label = ctx.block_label(switch_target.target);
            cases.push((val_str, label));
            i = i + 1;
        }

        ctx.emit_switch(discr_ty.as_str(), discr_val.as_str(), default_label.as_str(), &cases);
    }
}

/// Emits a return from the function.
fn emit_return(ctx: &mut codegen_ctx::CodegenCtx) {
    // Load return value from _0
    let ret_local = mir_def::MirLocalId::new(0);
    let ret_name = ctx.local_name(ret_local);
    let ret_ty = ctx.get_local_type(ret_local);

    // Check if return type is void (unit type)
    let is_void = is_void_type(ret_ty.as_str());

    if is_void {
        ctx.emit_ret("void", Option::None);
    } else {
        let ret_val = ctx.fresh_temp();
        ctx.emit_load(ret_val.as_str(), ret_ty.as_str(), ret_name.as_str());
        ctx.emit_ret(ret_ty.as_str(), Option::Some(ret_val.as_str()));
    }
}

/// Emits a function call.
fn emit_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    func: &mir_types::Operand,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Try to extract a direct function name from the operand to avoid
    // unnecessary store/load indirection for known function references.
    let func_val = match extract_direct_fn_name(ctx, func) {
        Option::Some(name) => name,
        Option::None => {
            // Fallback: emit the operand normally (may produce %tmp from a local load)
            let func_typed = codegen_expr::emit_operand_typed(ctx, func);
            let raw_func = func_typed.0;
            let func_ty = func_typed.1;
            // LLVM requires call targets to be ptr type.
            // SSA values loaded as i64 need inttoptr conversion.
            // Fat pointers (struct { ptr, i64 }) need extractvalue instead.
            if starts_with_percent(&raw_func) && !string_eq_str(func_ty.as_str(), "ptr") {
                let func_ty_bytes = func_ty.as_bytes();
                let is_fat_ptr = func_ty_bytes.len() > 0 && func_ty_bytes[0] == 123; // '{'
                if is_fat_ptr {
                    // Fat pointer: extract the data pointer (field 0)
                    let extracted = ctx.fresh_temp();
                    ctx.write_indent();
                    ctx.write_string(&extracted);
                    ctx.write(" = extractvalue ");
                    ctx.write_string(&func_ty);
                    ctx.write(" ");
                    ctx.write_string(&raw_func);
                    ctx.write(", 0\n");
                    extracted
                } else {
                    // Integer type: use inttoptr
                    let cast = ctx.fresh_temp();
                    ctx.emit_cast(cast.as_str(), "inttoptr", func_ty.as_str(), raw_func.as_str(), "ptr");
                    cast
                }
            } else {
                raw_func
            }
        }
    };

    // Check for Vec builtin functions which have special calling conventions
    if is_vec_new(&func_val) {
        emit_vec_new_call(ctx, destination, target);
        return;
    }
    if is_vec_push(&func_val) {
        emit_vec_push_call(ctx, args, target);
        return;
    }
    if is_vec_len(&func_val) {
        emit_vec_len_call(ctx, args, destination, target);
        return;
    }
    if is_vec_pop(&func_val) {
        emit_vec_pop_call(ctx, args, destination, target);
        return;
    }
    if is_vec_clear(&func_val) {
        emit_vec_clear_call(ctx, args, target);
        return;
    }

    // Check for String builtin functions which have special calling conventions
    if is_string_new(&func_val) {
        emit_string_new_call(ctx, destination, target);
        return;
    }
    if is_string_push_str(&func_val) {
        emit_string_push_str_call(ctx, args, target);
        return;
    }
    if is_string_len(&func_val) {
        emit_string_len_call(ctx, args, destination, target);
        return;
    }
    if is_string_push(&func_val) {
        emit_string_push_call(ctx, args, target);
        return;
    }
    if is_string_as_str(&func_val) {
        emit_string_as_str_call(ctx, args, destination, target);
        return;
    }
    if is_string_as_bytes(&func_val) {
        emit_string_as_bytes_call(ctx, args, destination, target);
        return;
    }

    // Check for &str builtin functions which have special calling conventions.
    // The generic path passes &str by pointer (&&str), but the runtime expects
    // { ptr, i64 } by value. These handlers load the fat pointer before calling.
    if is_str_len(&func_val) {
        emit_str_len_call(ctx, args, destination, target);
        return;
    }
    if is_str_eq(&func_val) {
        emit_str_eq_call(ctx, args, destination, target);
        return;
    }
    if is_str_concat(&func_val) {
        emit_str_concat_call(ctx, args, destination, target);
        return;
    }

    // Check for Option builtin functions which have special calling conventions
    if is_option_is_some(&func_val) {
        emit_option_is_some_call(ctx, args, destination, target);
        return;
    }
    if is_option_is_none(&func_val) {
        emit_option_is_none_call(ctx, args, destination, target);
        return;
    }
    if is_option_unwrap(&func_val) {
        emit_option_unwrap_call(ctx, args, destination, target);
        return;
    }
    if is_option_as_ref(&func_val) {
        emit_option_as_ref_call(ctx, args, destination, target);
        return;
    }

    // Check for Box builtin function which has special calling convention
    if is_box_new(&func_val) {
        emit_box_new_call(ctx, args, destination, target);
        return;
    }

    // Extract the target DefId (if this is a direct call to a known function)
    let target_def_id: Option<u32> = extract_call_def_id(func);

    // Emit arguments with their types, applying generic call fixup if needed
    let mut llvm_args: Vec<(String, String)> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, &args[i]);

        // Check if this parameter needs widening for a generic function
        let mut final_val: String;
        let mut final_ty: String;
        match target_def_id {
            Option::Some(did) => {
                match ctx.lookup_fn_param_type(did, i) {
                    Option::Some(expected_ty) => {
                        if !string_eq_str(expected_ty.as_str(), arg_ty.as_str()) && needs_int_cast(arg_ty.as_str(), expected_ty.as_str()) {
                            // Type mismatch: widen the argument to match the definition
                            let widened = ctx.fresh_temp();
                            ctx.write_indent();
                            ctx.write_string(&widened);
                            if is_smaller_int(arg_ty.as_str(), expected_ty.as_str()) {
                                ctx.write(" = sext ");
                            } else {
                                ctx.write(" = zext ");
                            }
                            ctx.write_string(&arg_ty);
                            ctx.write(" ");
                            ctx.write_string(&arg_val);
                            ctx.write(" to ");
                            ctx.write_string(&expected_ty);
                            ctx.write("\n");
                            final_val = widened;
                            final_ty = expected_ty;
                        } else if !string_eq_str(expected_ty.as_str(), arg_ty.as_str()) && is_struct_type(arg_ty.as_str()) && is_struct_type(expected_ty.as_str()) {
                            // Struct type mismatch (generic struct with different field sizes)
                            // Widen field-by-field: { i1, i32 } -> { i64, i64 }
                            let widened = emit_struct_widening(ctx, &arg_val, arg_ty.as_str(), expected_ty.as_str());
                            final_val = widened;
                            final_ty = expected_ty;
                        } else if !string_eq_str(expected_ty.as_str(), arg_ty.as_str()) {
                            // General type mismatch (e.g., struct { i32, i32 } vs scalar i64)
                            // Use memory-based bitcast
                            let cast_alloca = ctx.fresh_temp();
                            ctx.emit_alloca(cast_alloca.as_str(), expected_ty.as_str());
                            ctx.emit_store(arg_ty.as_str(), arg_val.as_str(), cast_alloca.as_str());
                            let cast_result = ctx.fresh_temp();
                            ctx.write_indent();
                            ctx.write_string(&cast_result);
                            ctx.write(" = load ");
                            ctx.write_string(&expected_ty);
                            ctx.write(", ptr ");
                            ctx.write_string(&cast_alloca);
                            ctx.write("\n");
                            final_val = cast_result;
                            final_ty = expected_ty;
                        } else {
                            final_val = arg_val;
                            final_ty = arg_ty;
                        }
                    }
                    Option::None => {
                        final_val = arg_val;
                        final_ty = arg_ty;
                    }
                }
            }
            Option::None => {
                final_val = arg_val;
                final_ty = arg_ty;
            }
        }
        llvm_args.push((final_ty, final_val));
        i = i + 1;
    }

    // Get return type from destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    let call_site_ret_ty = ctx.get_local_type(destination.local);

    // Determine the actual return type to use for the call instruction
    // If the function definition has a different return type (generic), use the definition's type
    let def_ret_ty: String = match target_def_id {
        Option::Some(did) => {
            match ctx.lookup_fn_ret_type(did) {
                Option::Some(drt) => drt,
                Option::None => clone_string(&call_site_ret_ty),
            }
        }
        Option::None => clone_string(&call_site_ret_ty),
    };

    // Check if return type is void (unit type)
    let is_void = is_void_type(def_ret_ty.as_str());

    if is_void {
        // Void function - no return value
        ctx.emit_call(
            Option::None,
            "void",
            func_val.as_str(),
            &llvm_args,
        );
    } else {
        // Non-void function - capture return value
        let result = ctx.fresh_temp();
        ctx.emit_call(
            Option::Some(result.as_str()),
            def_ret_ty.as_str(),
            func_val.as_str(),
            &llvm_args,
        );

        // If the definition return type differs from the call site's expected type, narrow
        if !string_eq_str(def_ret_ty.as_str(), call_site_ret_ty.as_str()) && needs_int_cast(def_ret_ty.as_str(), call_site_ret_ty.as_str()) {
            let truncated = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&truncated);
            ctx.write(" = trunc ");
            ctx.write_string(&def_ret_ty);
            ctx.write(" ");
            ctx.write_string(&result);
            ctx.write(" to ");
            ctx.write_string(&call_site_ret_ty);
            ctx.write("\n");
            ctx.emit_store(call_site_ret_ty.as_str(), truncated.as_str(), dest_ptr.as_str());
        } else if !string_eq_str(def_ret_ty.as_str(), call_site_ret_ty.as_str()) && is_struct_type(def_ret_ty.as_str()) && is_struct_type(call_site_ret_ty.as_str()) {
            // Struct return type mismatch: narrow field-by-field
            let narrowed = emit_struct_narrowing(ctx, &result, def_ret_ty.as_str(), call_site_ret_ty.as_str());
            ctx.emit_store(call_site_ret_ty.as_str(), narrowed.as_str(), dest_ptr.as_str());
        } else if !string_eq_str(def_ret_ty.as_str(), call_site_ret_ty.as_str()) {
            // General type mismatch: use memory bitcast
            let cast_alloca = ctx.fresh_temp();
            ctx.emit_alloca(cast_alloca.as_str(), def_ret_ty.as_str());
            ctx.emit_store(def_ret_ty.as_str(), result.as_str(), cast_alloca.as_str());
            let cast_result = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&cast_result);
            ctx.write(" = load ");
            ctx.write_string(&call_site_ret_ty);
            ctx.write(", ptr ");
            ctx.write_string(&cast_alloca);
            ctx.write("\n");
            ctx.emit_store(call_site_ret_ty.as_str(), cast_result.as_str(), dest_ptr.as_str());
        } else {
            // Store result
            ctx.emit_store(def_ret_ty.as_str(), result.as_str(), dest_ptr.as_str());
        }
    }

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Extracts a direct function name from a MIR operand.
/// Returns Some("@fn_name") if the operand is a Constant(FnDef(...)),
/// None otherwise (for Copy/Move of locals, which need the load path).
fn extract_direct_fn_name(
    ctx: &mut codegen_ctx::CodegenCtx,
    operand: &mir_types::Operand,
) -> Option<String> {
    match operand {
        &mir_types::Operand::Constant(ref constant) => {
            match &constant.kind {
                &mir_types::ConstantKind::FnDef(ref def_id) => {
                    // Apply call remapping for trait default methods.
                    // If this call targets an abstract trait method DefId,
                    // redirect to the concrete impl method DefId.
                    let remapped_id = ctx.remap_def_id(def_id.index);
                    match ctx.lookup_def_name(remapped_id) {
                        Option::Some(name) => {
                            let mut result = common::make_string("@");
                            result.push_str(name.as_str());
                            Option::Some(result)
                        }
                        Option::None => {
                            let mut fallback_name = common::make_string("fn_");
                            fallback_name.push_str(codegen_types::format_u64(remapped_id as u64).as_str());
                            // Register the fallback name so stub generation can create a declaration
                            ctx.register_def_name(remapped_id, clone_string(&fallback_name));
                            let mut result = common::make_string("@");
                            result.push_str(fallback_name.as_str());
                            Option::Some(result)
                        }
                    }
                }
                _ => Option::None,
            }
        }
        _ => Option::None,
    }
}

/// Extracts the DefId from a MIR call operand (for signature lookup).
fn extract_call_def_id(operand: &mir_types::Operand) -> Option<u32> {
    match operand {
        &mir_types::Operand::Constant(ref constant) => {
            match &constant.kind {
                &mir_types::ConstantKind::FnDef(ref def_id) => {
                    Option::Some(def_id.index)
                }
                _ => Option::None,
            }
        }
        _ => Option::None,
    }
}

/// Checks if two LLVM integer types need a cast between them.
/// Returns true if both are integer types (iN) and they differ.
fn needs_int_cast(from_ty: &str, to_ty: &str) -> bool {
    let from_bytes = from_ty.as_bytes();
    let to_bytes = to_ty.as_bytes();
    // Both must start with 'i' and be integer types
    if from_bytes.len() < 2 || to_bytes.len() < 2 {
        return false;
    }
    if from_bytes[0] != 105 || to_bytes[0] != 105 {
        // 105 = 'i'
        return false;
    }
    // Check that rest is digits (not "iN" vs "internal" or something)
    let mut fi: usize = 1;
    while fi < from_bytes.len() {
        if from_bytes[fi] < 48 || from_bytes[fi] > 57 {
            return false;
        }
        fi = fi + 1;
    }
    let mut ti: usize = 1;
    while ti < to_bytes.len() {
        if to_bytes[ti] < 48 || to_bytes[ti] > 57 {
            return false;
        }
        ti = ti + 1;
    }
    true
}

/// Checks if from_ty is a smaller integer type than to_ty (for sext).
fn is_smaller_int(from_ty: &str, to_ty: &str) -> bool {
    let from_bits = parse_int_bits(from_ty);
    let to_bits = parse_int_bits(to_ty);
    from_bits < to_bits
}

/// Parses the bit width from an LLVM integer type string (e.g., "i32" -> 32).
fn parse_int_bits(ty: &str) -> u32 {
    let bytes = ty.as_bytes();
    if bytes.len() < 2 || bytes[0] != 105 {
        return 0;
    }
    let mut result: u32 = 0;
    let mut i: usize = 1;
    while i < bytes.len() {
        if bytes[i] >= 48 && bytes[i] <= 57 {
            result = result * 10 + ((bytes[i] - 48) as u32);
        }
        i = i + 1;
    }
    result
}

/// Clone a string.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    result.push_str(s.as_str());
    result
}

/// Checks if an LLVM type is void/unit.
fn is_void_type(llvm_ty: &str) -> bool {
    let bytes = llvm_ty.as_bytes();
    if bytes.len() == 4 {
        // Check for "void"
        if bytes[0] == 118 && bytes[1] == 111 && bytes[2] == 105 && bytes[3] == 100 {
            return true;
        }
    }
    if bytes.len() == 2 {
        // Check for "{}"
        if bytes[0] == 123 && bytes[1] == 125 {
            return true;
        }
    }
    false
}

/// Checks if an LLVM type is a struct type (starts with '{').
fn is_struct_type(ty: &str) -> bool {
    let bytes = ty.as_bytes();
    if bytes.len() < 2 {
        return false;
    }
    // Check for '{ ... }'
    bytes[0] == 123 && bytes[bytes.len() - 1] == 125
}

/// Parses the field types from a struct type string like "{ i64, i32 }".
/// Returns a Vec of field type strings.
fn parse_struct_fields(ty: &str) -> Vec<String> {
    let mut fields: Vec<String> = Vec::new();
    let bytes = ty.as_bytes();
    if bytes.len() < 4 {
        return fields;
    }
    // Skip "{ " prefix
    let mut pos: usize = 2;
    let end = bytes.len() - 2; // skip " }"
    while pos < end {
        // Skip whitespace
        while pos < end && bytes[pos] == 32 {
            pos = pos + 1;
        }
        if pos >= end {
            break;
        }
        // Read a field type (until ',' or end)
        let start = pos;
        let mut depth: i32 = 0;
        while pos < end {
            if bytes[pos] == 123 {
                depth = depth + 1;
            } else if bytes[pos] == 125 {
                depth = depth - 1;
            } else if bytes[pos] == 44 && depth == 0 {
                // comma at top level
                break;
            }
            pos = pos + 1;
        }
        // Trim trailing whitespace
        let mut field_end = pos;
        while field_end > start && bytes[field_end - 1] == 32 {
            field_end = field_end - 1;
        }
        if field_end > start {
            let mut field = String::new();
            let mut fi: usize = start;
            while fi < field_end {
                field.push(bytes[fi] as char);
                fi = fi + 1;
            }
            fields.push(field);
        }
        // Skip comma
        if pos < end && bytes[pos] == 44 {
            pos = pos + 1;
        }
    }
    fields
}

/// Emits struct widening: converts a struct with smaller fields to one with larger fields.
/// E.g., { i1, i32 } -> { i64, i64 } by extracting each field and sign-extending.
fn emit_struct_widening(
    ctx: &mut codegen_ctx::CodegenCtx,
    src_val: &String,
    src_ty: &str,
    dst_ty: &str,
) -> String {
    let src_fields = parse_struct_fields(src_ty);
    let dst_fields = parse_struct_fields(dst_ty);

    // Alloca for the destination struct
    let dst_alloca = ctx.fresh_temp();
    ctx.emit_alloca(dst_alloca.as_str(), dst_ty);

    // For each field, extract from source, cast if needed, store into destination
    let mut fi: usize = 0;
    let field_count = if src_fields.len() < dst_fields.len() { src_fields.len() } else { dst_fields.len() };
    while fi < field_count {
        let extracted = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&extracted);
        ctx.write(" = extractvalue ");
        ctx.write(src_ty);
        ctx.write(" ");
        ctx.write_string(src_val);
        ctx.write(", ");
        ctx.write(codegen_types::format_u64(fi as u64).as_str());
        ctx.write("\n");

        let mut field_val: String;
        if string_eq_str(src_fields[fi].as_str(), dst_fields[fi].as_str()) {
            // Same type, no conversion needed
            field_val = extracted;
        } else if needs_int_cast(src_fields[fi].as_str(), dst_fields[fi].as_str()) {
            // Scalar to scalar: use sext/zext
            let extended = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&extended);
            if is_smaller_int(src_fields[fi].as_str(), dst_fields[fi].as_str()) {
                ctx.write(" = sext ");
            } else {
                ctx.write(" = zext ");
            }
            ctx.write(src_fields[fi].as_str());
            ctx.write(" ");
            ctx.write_string(&extracted);
            ctx.write(" to ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write("\n");
            field_val = extended;
        } else {
            // Type mismatch (e.g., struct field { i32 } vs scalar i64):
            // Use memory-based bitcast: alloca dst, zero it, store src, load as dst
            let cast_alloca = ctx.fresh_temp();
            ctx.emit_alloca(cast_alloca.as_str(), dst_fields[fi].as_str());
            // Zero-initialize the destination alloca
            let zero_val = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&zero_val);
            ctx.write(" = bitcast ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write(" zeroinitializer to ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write("\n");
            ctx.emit_store(dst_fields[fi].as_str(), zero_val.as_str(), cast_alloca.as_str());
            // Store source value (smaller) into the alloca
            ctx.emit_store(src_fields[fi].as_str(), extracted.as_str(), cast_alloca.as_str());
            // Load as destination type
            let cast_result = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&cast_result);
            ctx.write(" = load ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write(", ptr ");
            ctx.write_string(&cast_alloca);
            ctx.write("\n");
            field_val = cast_result;
        }

        // Store into destination struct via GEP
        let gep = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&gep);
        ctx.write(" = getelementptr ");
        ctx.write(dst_ty);
        ctx.write(", ptr ");
        ctx.write_string(&dst_alloca);
        ctx.write(", i64 0, i32 ");
        ctx.write(codegen_types::format_u64(fi as u64).as_str());
        ctx.write("\n");
        ctx.emit_store(dst_fields[fi].as_str(), field_val.as_str(), gep.as_str());

        fi = fi + 1;
    }

    // Load the complete destination struct
    let result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&result);
    ctx.write(" = load ");
    ctx.write(dst_ty);
    ctx.write(", ptr ");
    ctx.write_string(&dst_alloca);
    ctx.write("\n");
    result
}

/// Emits struct narrowing: converts a struct with larger fields to one with smaller fields.
/// E.g., { i64, i64 } -> { i32, i1 } by extracting each field and truncating.
fn emit_struct_narrowing(
    ctx: &mut codegen_ctx::CodegenCtx,
    src_val: &String,
    src_ty: &str,
    dst_ty: &str,
) -> String {
    let src_fields = parse_struct_fields(src_ty);
    let dst_fields = parse_struct_fields(dst_ty);

    // Alloca for the destination struct
    let dst_alloca = ctx.fresh_temp();
    ctx.emit_alloca(dst_alloca.as_str(), dst_ty);

    let mut fi: usize = 0;
    let field_count = if src_fields.len() < dst_fields.len() { src_fields.len() } else { dst_fields.len() };
    while fi < field_count {
        let extracted = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&extracted);
        ctx.write(" = extractvalue ");
        ctx.write(src_ty);
        ctx.write(" ");
        ctx.write_string(src_val);
        ctx.write(", ");
        ctx.write(codegen_types::format_u64(fi as u64).as_str());
        ctx.write("\n");

        let mut field_val: String;
        if string_eq_str(src_fields[fi].as_str(), dst_fields[fi].as_str()) {
            // Same type, no conversion needed
            field_val = extracted;
        } else if needs_int_cast(src_fields[fi].as_str(), dst_fields[fi].as_str()) {
            // Scalar to scalar: use trunc
            let truncated = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&truncated);
            ctx.write(" = trunc ");
            ctx.write(src_fields[fi].as_str());
            ctx.write(" ");
            ctx.write_string(&extracted);
            ctx.write(" to ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write("\n");
            field_val = truncated;
        } else {
            // Type mismatch (e.g., scalar i64 vs struct { i32 }):
            // Use memory-based bitcast: alloca src type, store src, load as dst
            let cast_alloca = ctx.fresh_temp();
            ctx.emit_alloca(cast_alloca.as_str(), src_fields[fi].as_str());
            ctx.emit_store(src_fields[fi].as_str(), extracted.as_str(), cast_alloca.as_str());
            let cast_result = ctx.fresh_temp();
            ctx.write_indent();
            ctx.write_string(&cast_result);
            ctx.write(" = load ");
            ctx.write(dst_fields[fi].as_str());
            ctx.write(", ptr ");
            ctx.write_string(&cast_alloca);
            ctx.write("\n");
            field_val = cast_result;
        }

        let gep = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&gep);
        ctx.write(" = getelementptr ");
        ctx.write(dst_ty);
        ctx.write(", ptr ");
        ctx.write_string(&dst_alloca);
        ctx.write(", i64 0, i32 ");
        ctx.write(codegen_types::format_u64(fi as u64).as_str());
        ctx.write("\n");
        ctx.emit_store(dst_fields[fi].as_str(), field_val.as_str(), gep.as_str());

        fi = fi + 1;
    }

    let result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&result);
    ctx.write(" = load ");
    ctx.write(dst_ty);
    ctx.write(", ptr ");
    ctx.write_string(&dst_alloca);
    ctx.write("\n");
    result
}

/// Emits an assertion.
/// On failure, prints the assertion message and traps.
fn emit_assert(
    ctx: &mut codegen_ctx::CodegenCtx,
    cond: &mir_types::Operand,
    expected: bool,
    msg: &String,
    target: mir_def::BasicBlockId,
) {
    let cond_val = codegen_expr::emit_operand(ctx, cond);

    // Create labels
    let success_label = ctx.block_label(target);
    let fail_label = ctx.fresh_label();

    // Compare condition with expected
    if expected {
        // Expect true: if cond, goto success, else fail
        ctx.emit_cond_br(cond_val.as_str(), success_label.as_str(), fail_label.as_str());
    } else {
        // Expect false: if cond, goto fail, else success
        ctx.emit_cond_br(cond_val.as_str(), fail_label.as_str(), success_label.as_str());
    }

    // Fail block
    ctx.emit_label(fail_label.as_str());
    ctx.indent();

    // Build the full assertion message: "Assertion failed: <msg>\n"
    let mut full_msg = common::make_string("Assertion failed: ");
    full_msg.push_str(msg.as_str());

    // Add the message as a string constant and get its label
    let msg_label = ctx.add_string_constant(&full_msg);

    // Call puts() to print the message to stderr before trapping
    // puts takes a pointer and returns i32
    ctx.write("    call i32 @puts(ptr ");
    ctx.write_string(&msg_label);
    ctx.write(")\n");

    // Call panic or trap
    ctx.writeln("call void @llvm.trap()");
    ctx.emit_unreachable();
    ctx.dedent();
}

/// Emits a list of operands and returns their values.
fn emit_operand_list(
    ctx: &mut codegen_ctx::CodegenCtx,
    operands: &Vec<mir_types::Operand>,
) -> Vec<String> {
    let mut result: Vec<String> = Vec::new();
    let mut i: usize = 0;
    while i < operands.len() {
        result.push(codegen_expr::emit_operand(ctx, &operands[i]));
        i = i + 1;
    }
    result
}

/// Widens an operand value to i64 if needed.
/// Returns the SSA name of the widened value (already i64-typed).
fn widen_operand_to_i64(ctx: &mut codegen_ctx::CodegenCtx, val: &str, ty: &str) -> String {
    if str_eq(ty, "i64") {
        return common::make_string(val);
    }
    if str_eq(ty, "i32") || str_eq(ty, "i16") || str_eq(ty, "i8") || str_eq(ty, "i1") {
        let widened = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&widened);
        ctx.write(" = zext ");
        ctx.write(ty);
        ctx.write(" ");
        ctx.write(val);
        ctx.write(" to i64\n");
        return widened;
    }
    if str_eq(ty, "ptr") {
        let widened = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&widened);
        ctx.write(" = ptrtoint ptr ");
        ctx.write(val);
        ctx.write(" to i64\n");
        return widened;
    }
    if str_eq(ty, "double") {
        let widened = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&widened);
        ctx.write(" = bitcast double ");
        ctx.write(val);
        ctx.write(" to i64\n");
        return widened;
    }
    // For other types (unit {}, etc.), return 0
    common::make_string("0")
}

/// Makes an LLVM array type string like "[3 x i64]".
fn make_array_type(count: usize) -> String {
    let mut s = common::make_string("[");
    let count_str = codegen_types::format_u64(count as u64);
    s.push_str(count_str.as_str());
    s.push_str(" x i64]");
    s
}

/// Compares a &str against a &str for equality.
fn string_eq_str(a: &str, b: &str) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Checks if a string starts with '%' (SSA register name).
fn starts_with_percent(s: &String) -> bool {
    let bytes = s.as_bytes();
    if bytes.len() > 0 {
        bytes[0] == 37 // '%'
    } else {
        false
    }
}

// ============================================================
// Vec Builtin Handling
// ============================================================
// Vec runtime functions have special calling conventions:
//   vec_new(i64 elem_size, ptr out_ptr) -> void
//   vec_push(ptr vec, ptr elem_ptr, i64 elem_size) -> void
//   vec_len(ptr vec) -> i64

/// Checks if the function name is @vec_new.
fn is_vec_new(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_new")
}

/// Checks if the function name is @vec_push.
fn is_vec_push(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_push")
}

/// Checks if the function name is @vec_len.
fn is_vec_len(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_len")
}

/// Checks if the function name is @vec_pop.
fn is_vec_pop(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_pop")
}

/// Checks if the function name is @vec_clear.
fn is_vec_clear(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@vec_clear")
}

/// Extracts element type from Vec<T> HIR type.
/// Returns the element type T if the type is Vec<T>, None otherwise.
fn extract_vec_element_type(ty: &hir_ty::Type) -> Option<hir_ty::Type> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id: _, ref args } => {
            // Vec<T> has one type argument
            if args.len() > 0 {
                // Clone the element type
                Option::Some(clone_type(&args[0]))
            } else {
                Option::None
            }
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable: _ } => {
            // Handle &Vec<T> or &mut Vec<T>
            extract_vec_element_type(inner.as_ref())
        }
        _ => Option::None,
    }
}

/// Clones a HIR type (needed because we can't move out of borrowed content).
fn clone_type(ty: &hir_ty::Type) -> hir_ty::Type {
    hir_ty::Type::new(clone_type_kind(&ty.kind))
}

/// Clones a HIR type kind.
fn clone_type_kind(kind: &hir_ty::TypeKind) -> hir_ty::TypeKind {
    match kind {
        &hir_ty::TypeKind::Primitive(ref p) => hir_ty::TypeKind::Primitive(clone_primitive(p)),
        &hir_ty::TypeKind::Tuple(ref elems) => {
            let mut cloned: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < elems.len() {
                cloned.push(clone_type(&elems[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Tuple(cloned)
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            hir_ty::TypeKind::Ref {
                inner: Box::new(clone_type(inner.as_ref())),
                mutable,
            }
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            hir_ty::TypeKind::Ptr {
                inner: Box::new(clone_type(inner.as_ref())),
                mutable,
            }
        }
        &hir_ty::TypeKind::Adt { ref def_id, ref args } => {
            let mut cloned_args: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                cloned_args.push(clone_type(&args[i]));
                i = i + 1;
            }
            hir_ty::TypeKind::Adt {
                def_id: hir_def::DefId { index: def_id.index },
                args: cloned_args,
            }
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            hir_ty::TypeKind::Array {
                element: Box::new(clone_type(element.as_ref())),
                size,
            }
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            hir_ty::TypeKind::Slice {
                element: Box::new(clone_type(element.as_ref())),
            }
        }
        &hir_ty::TypeKind::Infer(ref var_id) => {
            hir_ty::TypeKind::Infer(hir_def::TyVarId { index: var_id.index })
        }
        &hir_ty::TypeKind::Param(ref var_id) => {
            hir_ty::TypeKind::Param(hir_def::TyVarId { index: var_id.index })
        }
        &hir_ty::TypeKind::Error => hir_ty::TypeKind::Error,
        &hir_ty::TypeKind::Never => hir_ty::TypeKind::Never,
        _ => {
            // For other complex types, fall back to Error
            // This is safe because we're only using this for Vec element extraction
            hir_ty::TypeKind::Error
        }
    }
}

/// Clones a primitive type.
fn clone_primitive(p: &hir_ty::PrimitiveTy) -> hir_ty::PrimitiveTy {
    match p {
        &hir_ty::PrimitiveTy::Bool => hir_ty::PrimitiveTy::Bool,
        &hir_ty::PrimitiveTy::Char => hir_ty::PrimitiveTy::Char,
        &hir_ty::PrimitiveTy::I8 => hir_ty::PrimitiveTy::I8,
        &hir_ty::PrimitiveTy::I16 => hir_ty::PrimitiveTy::I16,
        &hir_ty::PrimitiveTy::I32 => hir_ty::PrimitiveTy::I32,
        &hir_ty::PrimitiveTy::I64 => hir_ty::PrimitiveTy::I64,
        &hir_ty::PrimitiveTy::I128 => hir_ty::PrimitiveTy::I128,
        &hir_ty::PrimitiveTy::Isize => hir_ty::PrimitiveTy::Isize,
        &hir_ty::PrimitiveTy::U8 => hir_ty::PrimitiveTy::U8,
        &hir_ty::PrimitiveTy::U16 => hir_ty::PrimitiveTy::U16,
        &hir_ty::PrimitiveTy::U32 => hir_ty::PrimitiveTy::U32,
        &hir_ty::PrimitiveTy::U64 => hir_ty::PrimitiveTy::U64,
        &hir_ty::PrimitiveTy::U128 => hir_ty::PrimitiveTy::U128,
        &hir_ty::PrimitiveTy::Usize => hir_ty::PrimitiveTy::Usize,
        &hir_ty::PrimitiveTy::F32 => hir_ty::PrimitiveTy::F32,
        &hir_ty::PrimitiveTy::F64 => hir_ty::PrimitiveTy::F64,
        &hir_ty::PrimitiveTy::Str => hir_ty::PrimitiveTy::Str,
    }
}

/// Emits a vec_new call with correct calling convention.
/// Runtime signature: void @vec_new(i64 elem_size, ptr out_ptr)
///
/// Uses emit_place_data_ptr to handle region/persistent indirection.
fn emit_vec_new_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Get data pointer (handles region/persistent heap indirection)
    let out_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);

    // Get element size from the destination's HIR type (Vec<T>)
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            match extract_vec_element_type(hir_ty) {
                Option::Some(elem_ty) => codegen_stmt::type_size_with_ctx(ctx, &elem_ty),
                Option::None => 8,
            }
        }
        Option::None => 8,
    };

    // Emit: call void @vec_new(i64 elem_size, ptr out_ptr)
    let mut args: Vec<(String, String)> = Vec::new();
    args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    args.push((common::make_string("ptr"), out_ptr));

    ctx.emit_call(Option::None, "void", "@vec_new", &args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_push call with correct calling convention.
/// Runtime signature: void @vec_push(ptr vec, ptr elem_ptr, i64 elem_size)
fn emit_vec_push_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    // args[1] is the element (T)
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec pointer - emit_operand loads the &mut Vec reference value,
    // which is already a pointer to the Vec struct (no extra deref needed).
    let vec_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get element value and type
    let (elem_val, elem_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // Allocate temporary storage for the element
    let elem_alloca = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&elem_alloca);
    ctx.write(" = alloca ");
    ctx.write_string(&elem_ty);
    ctx.write(", align 8\n");

    // Store element value to alloca
    ctx.emit_store(elem_ty.as_str(), elem_val.as_str(), elem_alloca.as_str());

    // Get element size from the element's HIR type
    let elem_size: u64 = match &args[1] {
        &mir_types::Operand::Copy(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_stmt::type_size_with_ctx(ctx, hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Move(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_stmt::type_size_with_ctx(ctx, hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Constant(ref c) => {
            codegen_stmt::type_size_with_ctx(ctx, &c.ty)
        }
    };

    // Emit: call void @vec_push(ptr vec, ptr elem_ptr, i64 elem_size)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));
    call_args.push((common::make_string("ptr"), elem_alloca));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));

    ctx.emit_call(Option::None, "void", "@vec_push", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_len call with correct calling convention.
/// Runtime signature: i64 @vec_len(ptr vec)
fn emit_vec_len_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec pointer - emit_operand loads the reference value,
    // which is already a pointer to the Vec struct.
    let vec_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Emit: %result = call i64 @vec_len(ptr vec)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut vec_ptr_copy = common::make_string("");
    vec_ptr_copy.push_str(vec_ptr.as_str());
    call_args.push((common::make_string("ptr"), vec_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i64", "@vec_len", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i64", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_pop call with correct calling convention.
/// Runtime signature: i32 @vec_pop(ptr vec, i64 elem_size, ptr out_ptr)
/// Returns 1 on success (element popped), 0 if vec was empty.
fn emit_vec_pop_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec pointer - emit_operand loads the reference value,
    // which is already a pointer to the Vec struct.
    let vec_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get element size from destination's HIR type (Option<T>)
    // pop returns Option<T>, so we need to extract T's size
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            // Destination is Option<T>, extract T's size
            match extract_vec_element_type(hir_ty) {
                Option::Some(elem_ty) => codegen_stmt::type_size_with_ctx(ctx, &elem_ty),
                Option::None => 8,
            }
        }
        Option::None => 8,
    };

    // Allocate output pointer for the popped element
    let out_alloca = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&out_alloca);
    ctx.write(" = alloca [");
    ctx.write_string(&codegen_types::format_u64(elem_size));
    ctx.write(" x i8], align 8\n");

    // Emit: %result = call i32 @vec_pop(ptr vec, i64 elem_size, ptr out_ptr)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    // Save out_alloca string for use in call args and later memcpy
    let out_alloca_str = out_alloca.as_str();
    let mut out_alloca_copy = common::make_string("");
    out_alloca_copy.push_str(out_alloca_str);
    call_args.push((common::make_string("ptr"), out_alloca_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i32", "@vec_pop", &call_args);

    // Build Option<T> in destination
    // Option is typically { i8 tag, T value }
    // tag = 0 for None, tag = 1 for Some
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);

    // Store the tag (result from vec_pop: 0=empty/None, 1=success/Some)
    let tag_i8 = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&tag_i8);
    ctx.write(" = trunc i32 ");
    ctx.write_string(&result);
    ctx.write(" to i8\n");
    ctx.emit_store("i8", tag_i8.as_str(), dest_ptr.as_str());

    // If result was 1 (Some), copy the element data
    // Calculate offset for the value field (after tag, with alignment)
    let value_offset = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&value_offset);
    ctx.write(" = getelementptr i8, ptr ");
    ctx.write_string(&dest_ptr);
    ctx.write(", i64 8\n"); // Assuming 8-byte alignment for Option payload

    // Copy element data from out_alloca to Option's value field
    ctx.write_indent();
    ctx.write("call void @llvm.memcpy.p0.p0.i64(ptr ");
    ctx.write_string(&value_offset);
    ctx.write(", ptr ");
    ctx.write_string(&out_alloca);
    ctx.write(", i64 ");
    ctx.write_string(&codegen_types::format_u64(elem_size));
    ctx.write(", i1 false)\n");

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a vec_clear call with correct calling convention.
/// Runtime signature: void @vec_clear(ptr vec)
fn emit_vec_clear_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the vec (&mut Vec<T>)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get vec pointer - emit_operand loads the reference value,
    // which is already a pointer to the Vec struct.
    let vec_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Emit: call void @vec_clear(ptr vec)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), vec_ptr));

    ctx.emit_call(Option::None, "void", "@vec_clear", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// String Builtin Handling
// ============================================================
// String runtime functions have special calling conventions:
//   string_new(ptr out_ptr) -> void
//   string_len(ptr self) -> i64
//   string_push(ptr self, i32 char) -> void
//   string_push_str(ptr self, ptr str_ref) -> void     (str_ref = ptr to {ptr, i64})
//   string_as_str(ptr self) -> {ptr, i64}
//   string_as_bytes(ptr self) -> {ptr, i64}

/// Checks if the function name is @string_new.
fn is_string_new(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_new")
}

/// Checks if the function name is @string_push_str.
fn is_string_push_str(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_push_str")
}

/// Checks if the function name is @string_len.
fn is_string_len(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_len")
}

/// Checks if the function name is @string_push.
fn is_string_push(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_push")
}

/// Checks if the function name is @string_as_str.
fn is_string_as_str(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_as_str")
}

/// Checks if the function name is @string_as_bytes.
fn is_string_as_bytes(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@string_as_bytes")
}

/// Emits a string_new call with correct calling convention.
/// Runtime signature: void @string_new(ptr out_ptr)
///
/// Emits a string_new call. Uses emit_place_data_ptr for region/persistent indirection.
fn emit_string_new_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // Get data pointer (handles region/persistent heap indirection)
    let out_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);

    // Emit: call void @string_new(ptr out_ptr)
    let mut args: Vec<(String, String)> = Vec::new();
    args.push((common::make_string("ptr"), out_ptr));

    ctx.emit_call(Option::None, "void", "@string_new", &args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_push_str call with correct calling convention.
/// Runtime signature: void @string_push_str(ptr self, ptr str_ref)
fn emit_string_push_str_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get string pointer - emit_operand loads the reference value,
    // which is already a pointer to the String struct.
    let str_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get the &str argument (fat pointer)
    let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // Alloca temp for the &str fat pointer (runtime expects ptr to BloodStr)
    let str_tmp = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&str_tmp);
    ctx.write(" = alloca { ptr, i64 }\n");

    // Store the &str value into the temp
    ctx.emit_store("{ ptr, i64 }", arg_val.as_str(), str_tmp.as_str());

    // Emit: call void @string_push_str(ptr self, ptr str_ptr)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), str_ptr));
    call_args.push((common::make_string("ptr"), str_tmp));

    ctx.emit_call(Option::None, "void", "@string_push_str", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_len call with correct calling convention.
/// Runtime signature: i64 @string_len(ptr self)
fn emit_string_len_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string pointer - emit_operand loads the reference value,
    // which is already a pointer to the String struct.
    let str_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Emit: %result = call i64 @string_len(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "i64", "@string_len", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i64", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_push call with correct calling convention.
/// Runtime signature: void @string_push(ptr self, i32 char)
fn emit_string_push_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Get string pointer - emit_operand loads the reference value,
    // which is already a pointer to the String struct.
    let str_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get char argument - it may be { i32 } struct, need to extract i32
    let (char_val, char_ty) = codegen_expr::emit_operand_typed(ctx, &args[1]);

    // If char type is a struct { i32 }, extract the i32
    let char_i32 = if string_eq_str(char_ty.as_str(), "{ i32 }") {
        let extracted = ctx.fresh_temp();
        ctx.write_indent();
        ctx.write_string(&extracted);
        ctx.write(" = extractvalue { i32 } ");
        ctx.write_string(&char_val);
        ctx.write(", 0\n");
        extracted
    } else {
        char_val
    };

    // Emit: call void @string_push(ptr self, i32 char)
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), str_ptr));
    call_args.push((common::make_string("i32"), char_i32));

    ctx.emit_call(Option::None, "void", "@string_push", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_as_str call with correct calling convention.
/// Runtime signature: { ptr, i64 } @string_as_str(ptr self)
fn emit_string_as_str_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string pointer - emit_operand loads the reference value,
    // which is already a pointer to the String struct.
    let str_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Emit: %result = call { ptr, i64 } @string_as_str(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "{ ptr, i64 }", "@string_as_str", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("{ ptr, i64 }", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a string_as_bytes call with correct calling convention.
/// Runtime signature: { ptr, i64 } @string_as_bytes(ptr self)
fn emit_string_as_bytes_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get string pointer - emit_operand loads the reference value,
    // which is already a pointer to the String struct.
    let str_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Emit: %result = call { ptr, i64 } @string_as_bytes(ptr self)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut str_ptr_copy = common::make_string("");
    str_ptr_copy.push_str(str_ptr.as_str());
    call_args.push((common::make_string("ptr"), str_ptr_copy));

    ctx.emit_call(Option::Some(result.as_str()), "{ ptr, i64 }", "@string_as_bytes", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("{ ptr, i64 }", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// Option Builtin Handling
// ============================================================
// Option runtime functions have special calling conventions:
//   option_is_some(ptr self) -> i32
//   option_is_none(ptr self) -> i32
//   option_unwrap(ptr self, i64 elem_size, ptr out_ptr) -> void
//   option_as_ref(ptr self, i64 elem_size, ptr out_ptr) -> void

// ============================================================
// &str runtime functions have special calling conventions:
//   str_len({ ptr, i64 }) -> i64
//   str_eq({ ptr, i64 }, { ptr, i64 }) -> i1
//   str_concat({ ptr, i64 }, { ptr, i64 }) -> { ptr, i64 }
//
// The generic call path passes &str by pointer (creating &&str),
// but the runtime expects { ptr, i64 } by value. These handlers
// load the fat pointer from the pointer before calling.

fn is_str_len(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@str_len")
}

fn is_str_eq(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@str_eq")
}

fn is_str_concat(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@str_concat")
}

/// Helper: load a { ptr, i64 } fat pointer from a pointer operand.
/// The generic call path for &str methods produces a pointer to the
/// fat pointer alloca. This loads the actual { ptr, i64 } value.
fn load_str_fat_ptr(ctx: &mut codegen_ctx::CodegenCtx, operand: &mir_types::Operand) -> String {
    let (arg_val, arg_ty) = codegen_expr::emit_operand_typed(ctx, operand);
    // If it's already a { ptr, i64 }, return as-is
    if string_eq_str(arg_ty.as_str(), "{ ptr, i64 }") {
        return arg_val;
    }
    // Otherwise it's a ptr â€” load the { ptr, i64 } from it
    let loaded = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&loaded);
    ctx.write(" = load { ptr, i64 }, ptr ");
    ctx.write_string(&arg_val);
    ctx.write("\n");
    loaded
}

/// Emits a str_len call with correct calling convention.
/// Runtime signature: i64 @str_len({ ptr, i64 })
fn emit_str_len_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Load the &str fat pointer from the operand
    let str_val = load_str_fat_ptr(ctx, &args[0]);

    // Emit: %result = call i64 @str_len({ ptr, i64 } %str_val)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("{ ptr, i64 }"), str_val));
    ctx.emit_call(Option::Some(result.as_str()), "i64", "@str_len", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i64", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a str_eq call with correct calling convention.
/// Runtime signature: i1 @str_eq({ ptr, i64 }, { ptr, i64 })
fn emit_str_eq_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Load both &str fat pointers
    let str_a = load_str_fat_ptr(ctx, &args[0]);
    let str_b = load_str_fat_ptr(ctx, &args[1]);

    // Emit: %result = call i1 @str_eq({ ptr, i64 } %a, { ptr, i64 } %b)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("{ ptr, i64 }"), str_a));
    call_args.push((common::make_string("{ ptr, i64 }"), str_b));
    ctx.emit_call(Option::Some(result.as_str()), "i1", "@str_eq", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i1", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits a str_concat call with correct calling convention.
/// Runtime signature: { ptr, i64 } @str_concat({ ptr, i64 }, { ptr, i64 })
fn emit_str_concat_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 2 {
        ctx.emit_unreachable();
        return;
    }

    // Load both &str fat pointers
    let str_a = load_str_fat_ptr(ctx, &args[0]);
    let str_b = load_str_fat_ptr(ctx, &args[1]);

    // Emit: %result = call { ptr, i64 } @str_concat({ ptr, i64 } %a, { ptr, i64 } %b)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("{ ptr, i64 }"), str_a));
    call_args.push((common::make_string("{ ptr, i64 }"), str_b));
    ctx.emit_call(Option::Some(result.as_str()), "{ ptr, i64 }", "@str_concat", &call_args);

    // Store result to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("{ ptr, i64 }", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Checks if the function name is @option_is_some.
fn is_option_is_some(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_is_some")
}

/// Checks if the function name is @option_is_none.
fn is_option_is_none(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_is_none")
}

/// Checks if the function name is @option_unwrap.
fn is_option_unwrap(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_unwrap")
}

/// Checks if the function name is @option_as_ref.
fn is_option_as_ref(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@option_as_ref")
}

// ============================================================
// Box runtime functions have special calling conventions:
//   box_new(ptr value_ptr, i64 value_size) -> ptr

/// Checks if the function name is @box_new.
fn is_box_new(func_val: &String) -> bool {
    string_eq_str(func_val.as_str(), "@box_new")
}

/// Emits a box_new call with correct calling convention.
/// Runtime signature: ptr @box_new(ptr value_ptr, i64 value_size)
///
/// The generic call path passes the value by-value (as an LLVM aggregate),
/// which LLVM decomposes into register-sized chunks per ABI. box_new expects
/// a pointer to the value and its size. This handler stores the value to a
/// temp alloca and passes (ptr, i64) correctly.
fn emit_box_new_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    // args[0] is the value to box (type T)
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get value and its LLVM type
    let (val, val_ty) = codegen_expr::emit_operand_typed(ctx, &args[0]);

    // Allocate temporary storage for the value
    let val_alloca = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&val_alloca);
    ctx.write(" = alloca ");
    ctx.write_string(&val_ty);
    ctx.write(", align 8\n");

    // Store value to alloca
    ctx.emit_store(val_ty.as_str(), val.as_str(), val_alloca.as_str());

    // Get value size from HIR type
    let val_size: u64 = match &args[0] {
        &mir_types::Operand::Copy(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_stmt::type_size_with_ctx(ctx, hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Move(ref place) => {
            match ctx.get_local_hir_type(place.local) {
                Option::Some(hir_ty) => codegen_stmt::type_size_with_ctx(ctx, hir_ty),
                Option::None => 8,
            }
        }
        &mir_types::Operand::Constant(ref c) => {
            codegen_stmt::type_size_with_ctx(ctx, &c.ty)
        }
    };

    // Emit: %result = call ptr @box_new(ptr val_alloca, i64 val_size)
    let result = ctx.fresh_temp();
    let mut call_args: Vec<(String, String)> = Vec::new();
    call_args.push((common::make_string("ptr"), val_alloca));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(val_size)));

    ctx.emit_call(Option::Some(result.as_str()), "ptr", "@box_new", &call_args);

    // Store result pointer to destination
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("ptr", result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an inline is_some check using i8 discriminant.
/// Standard enum convention: None = discriminant 0, Some = discriminant 1.
/// Inlined to avoid ABI mismatch with runtime (which uses i32 discriminant).
fn emit_option_is_some_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option pointer - emit_operand loads the reference value,
    // which is already a pointer to the Option struct.
    let opt_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Load i8 discriminant from byte 0
    let disc = ctx.fresh_temp();
    ctx.emit_load(disc.as_str(), "i8", opt_ptr.as_str());

    // is_some = (discriminant == 1), since Some is variant index 1
    let cmp_result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&cmp_result);
    ctx.write(" = icmp eq i8 ");
    ctx.write_string(&disc);
    ctx.write(", 1\n");

    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i1", cmp_result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an inline is_none check using i8 discriminant.
/// Standard enum convention: None = discriminant 0, Some = discriminant 1.
/// Inlined to avoid ABI mismatch with runtime (which uses i32 discriminant).
fn emit_option_is_none_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option pointer - emit_operand loads the reference value,
    // which is already a pointer to the Option struct.
    let opt_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Load i8 discriminant from byte 0
    let disc = ctx.fresh_temp();
    ctx.emit_load(disc.as_str(), "i8", opt_ptr.as_str());

    // is_none = (discriminant == 0), since None is variant index 0
    let cmp_result = ctx.fresh_temp();
    ctx.write_indent();
    ctx.write_string(&cmp_result);
    ctx.write(" = icmp eq i8 ");
    ctx.write_string(&disc);
    ctx.write(", 0\n");

    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    ctx.emit_store("i1", cmp_result.as_str(), dest_ptr.as_str());

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an option_unwrap call with correct calling convention.
/// Runtime signature: void @option_unwrap(ptr self, i64 elem_size, ptr out_ptr)
fn emit_option_unwrap_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option pointer - emit_operand loads the reference value,
    // which is already a pointer to the Option struct.
    let opt_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get destination pointer and its size
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);
    let dest_ty = ctx.get_local_type(destination.local);

    // Get element size from destination type
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => codegen_stmt::type_size_with_ctx(ctx, hir_ty),
        Option::None => 8,
    };

    // Emit: call void @option_unwrap(ptr self, i64 elem_size, ptr out_ptr)
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    call_args.push((common::make_string("ptr"), dest_ptr));

    ctx.emit_call(Option::None, "void", "@option_unwrap", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

/// Emits an option_as_ref call with correct calling convention.
/// Runtime signature: void @option_as_ref(ptr self, i64 elem_size, ptr out_ptr)
fn emit_option_as_ref_call(
    ctx: &mut codegen_ctx::CodegenCtx,
    args: &Vec<mir_types::Operand>,
    destination: &mir_types::Place,
    target: &Option<mir_def::BasicBlockId>,
) {
    if args.len() < 1 {
        ctx.emit_unreachable();
        return;
    }

    // Get option pointer - emit_operand loads the reference value,
    // which is already a pointer to the Option struct.
    let opt_ptr = codegen_expr::emit_operand(ctx, &args[0]);

    // Get destination pointer
    let dest_ptr = codegen_expr::emit_place_data_ptr(ctx, destination);

    // Get element size from destination type (Option<&T>)
    let elem_size: u64 = match ctx.get_local_hir_type(destination.local) {
        Option::Some(hir_ty) => {
            match extract_vec_element_type(hir_ty) {
                Option::Some(inner) => codegen_stmt::type_size_with_ctx(ctx, &inner),
                Option::None => 8,
            }
        }
        Option::None => 8,
    };

    // Emit: call void @option_as_ref(ptr self, i64 elem_size, ptr out_ptr)
    let mut call_args: Vec<(String, String)> = Vec::new();
    let mut opt_ptr_copy = common::make_string("");
    opt_ptr_copy.push_str(opt_ptr.as_str());
    call_args.push((common::make_string("ptr"), opt_ptr_copy));
    call_args.push((common::make_string("i64"), codegen_types::format_u64(elem_size)));
    call_args.push((common::make_string("ptr"), dest_ptr));

    ctx.emit_call(Option::None, "void", "@option_as_ref", &call_args);

    // Jump to continuation
    match target {
        &Option::Some(t) => {
            let label = ctx.block_label(t);
            ctx.emit_br(label.as_str());
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
}

// ============================================================
// Basic Block Codegen
// ============================================================

/// Emits a complete basic block.
pub fn emit_basic_block(
    ctx: &mut codegen_ctx::CodegenCtx,
    block_id: mir_def::BasicBlockId,
    block: &mir_body::BasicBlockData,
) {
    // Emit label
    let label = ctx.block_label(block_id);
    ctx.emit_label(label.as_str());

    // Emit statements
    ctx.indent();
    let mut i: usize = 0;
    while i < block.statements.len() {
        codegen_stmt::emit_statement(ctx, &block.statements[i]);
        i = i + 1;
    }
    ctx.dedent();

    // Emit terminator
    ctx.indent();
    match &block.terminator {
        &Option::Some(ref term) => {
            emit_terminator(ctx, term);
        }
        &Option::None => {
            ctx.emit_unreachable();
        }
    }
    ctx.dedent();
}

// Forward declaration for codegen_stmt
mod codegen_stmt;
