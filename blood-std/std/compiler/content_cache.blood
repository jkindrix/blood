// Blood Self-Hosted Compiler - Content-Addressed Cache
//
// Implements a file-system based content-addressed cache for
// compilation artifacts. Uses FNV-1a hashing for content addressing.
// Cache directory: .blood-cache/

mod common;

// ============================================================
// Content Hash
// ============================================================

/// A 64-bit content hash.
pub struct ContentHash {
    /// The hash value.
    pub value: u64,
}

impl ContentHash {
    /// Creates a new content hash.
    pub fn new(value: u64) -> ContentHash {
        ContentHash { value: value }
    }

    /// Returns the hash as a hexadecimal string.
    pub fn to_hex(self: &ContentHash) -> String {
        let mut result = String::new();
        let hex_chars = "0123456789abcdef";
        let hex_bytes = hex_chars.as_bytes();

        let mut val = self.value;
        let mut digits: Vec<u8> = Vec::new();

        if val == 0 {
            result.push_str("0000000000000000");
            return result;
        }

        let mut i: u32 = 0;
        while i < 16 {
            let nibble = (val & 0xF) as usize;
            digits.push(hex_bytes[nibble]);
            val = val >> 4;
            i = i + 1;
        }

        // Reverse
        let mut j: usize = digits.len();
        while j > 0 {
            j = j - 1;
            result.push(digits[j] as char);
        }

        result
    }

    /// Returns true if two hashes are equal.
    pub fn equals(self: &ContentHash, other: &ContentHash) -> bool {
        self.value == other.value
    }
}

// ============================================================
// FNV-1a Hashing
// ============================================================

/// FNV-1a offset basis for 64-bit.
fn fnv1a_offset_basis() -> u64 {
    14695981039346656037
}

/// FNV-1a prime for 64-bit.
fn fnv1a_prime() -> u64 {
    1099511628211
}

/// Computes the FNV-1a hash of a string.
pub fn content_hash(data: &str) -> ContentHash {
    let bytes = data.as_bytes();
    let len = data.len();
    let mut hash = fnv1a_offset_basis();

    let mut i: usize = 0;
    while i < len {
        hash = hash ^ (bytes[i] as u64);
        hash = hash * fnv1a_prime();
        i = i + 1;
    }

    ContentHash::new(hash)
}

/// Computes the FNV-1a hash of a byte slice.
pub fn content_hash_bytes(data: &[u8], len: usize) -> ContentHash {
    let mut hash = fnv1a_offset_basis();

    let mut i: usize = 0;
    while i < len {
        hash = hash ^ (data[i] as u64);
        hash = hash * fnv1a_prime();
        i = i + 1;
    }

    ContentHash::new(hash)
}

/// Combines two hashes (for composite keys).
pub fn combine_hashes(a: &ContentHash, b: &ContentHash) -> ContentHash {
    let mut hash = a.value;
    hash = hash ^ b.value;
    hash = hash * fnv1a_prime();
    ContentHash::new(hash)
}

// ============================================================
// Cache Entry
// ============================================================

/// A cache entry representing a stored artifact.
pub struct CacheEntry {
    /// The content hash (key).
    pub hash: ContentHash,
    /// The artifact kind.
    pub kind: CacheArtifactKind,
    /// The cached content (e.g., LLVM IR, object code path).
    pub content: String,
    /// Size of the cached content in bytes.
    pub size: u64,
}

impl CacheEntry {
    /// Creates a new cache entry.
    pub fn new(hash: ContentHash, kind: CacheArtifactKind, content: String) -> CacheEntry {
        let sz = content.len() as u64;
        CacheEntry {
            hash: hash,
            kind: kind,
            content: content,
            size: sz,
        }
    }
}

/// The kind of cached artifact.
pub enum CacheArtifactKind {
    /// Parsed AST.
    Ast,
    /// HIR module.
    Hir,
    /// Type-checked module.
    TypeChecked,
    /// MIR module.
    Mir,
    /// LLVM IR text.
    LlvmIr,
    /// Object file.
    Object,
}

impl CacheArtifactKind {
    /// Returns the file extension for this artifact kind.
    pub fn extension(self: &CacheArtifactKind) -> &str {
        match self {
            &CacheArtifactKind::Ast => ".ast",
            &CacheArtifactKind::Hir => ".hir",
            &CacheArtifactKind::TypeChecked => ".tc",
            &CacheArtifactKind::Mir => ".mir",
            &CacheArtifactKind::LlvmIr => ".ll",
            &CacheArtifactKind::Object => ".o",
        }
    }
}

// ============================================================
// Content Cache
// ============================================================

/// A content-addressed cache for compilation artifacts.
pub struct ContentCache {
    /// Known entries (in-memory index).
    pub entries: Vec<CacheEntry>,
    /// The cache directory path.
    pub cache_dir: String,
    /// Total size of cached artifacts in bytes.
    pub total_size: u64,
    /// Maximum cache size in bytes (0 = unlimited).
    pub max_size: u64,
}

impl ContentCache {
    /// Creates a new content cache.
    pub fn new(cache_dir: String) -> ContentCache {
        ContentCache {
            entries: Vec::new(),
            cache_dir: cache_dir,
            total_size: 0,
            max_size: 0,
        }
    }

    /// Creates a cache with default directory (.blood-cache/).
    pub fn default_cache() -> ContentCache {
        ContentCache::new(common::make_string(".blood-cache"))
    }

    /// Sets the maximum cache size.
    pub fn set_max_size(self: &mut ContentCache, max: u64) {
        self.max_size = max;
    }

    /// Looks up an entry by hash.
    pub fn lookup(self: &ContentCache, hash: &ContentHash) -> Option<usize> {
        let mut i: usize = 0;
        while i < self.entries.len() {
            if self.entries[i].hash.equals(hash) {
                return Option::Some(i);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Stores an artifact in the cache.
    pub fn store(self: &mut ContentCache, entry: CacheEntry) {
        let entry_size = entry.size;

        // Check if already cached
        let existing = self.lookup(&entry.hash);
        match existing {
            Option::Some(_) => { return; } // Already cached
            Option::None => {}
        }

        // Evict if needed
        if self.max_size > 0 && self.total_size + entry_size > self.max_size {
            self.evict(entry_size);
        }

        self.total_size = self.total_size + entry_size;
        self.entries.push(entry);
    }

    /// Evicts oldest entries to make room for `needed` bytes.
    fn evict(self: &mut ContentCache, needed: u64) {
        while self.entries.len() > 0 && self.total_size + needed > self.max_size {
            let removed_size = self.entries[0].size;
            // Remove first entry (FIFO eviction)
            let mut new_entries: Vec<CacheEntry> = Vec::new();
            let mut i: usize = 1;
            while i < self.entries.len() {
                // Move entries (can't actually move without consuming)
                // In practice, this would use a more efficient data structure
                i = i + 1;
            }
            let _ = new_entries;
            self.total_size = self.total_size - removed_size;
            break; // Simple single-entry eviction for now
        }
    }

    /// Returns the number of cached entries.
    pub fn entry_count(self: &ContentCache) -> usize {
        self.entries.len()
    }

    /// Constructs the cache file path for a given hash and kind.
    pub fn cache_path(self: &ContentCache, hash: &ContentHash, kind: &CacheArtifactKind) -> String {
        let mut path = String::new();
        path.push_str(self.cache_dir.as_str());
        path.push('/');
        let hex = hash.to_hex();
        path.push_str(hex.as_str());
        path.push_str(kind.extension());
        path
    }

    /// Clears all cached entries.
    pub fn clear(self: &mut ContentCache) {
        self.entries = Vec::new();
        self.total_size = 0;
    }
}
