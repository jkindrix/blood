// Blood Self-Hosted Compiler - HIR Item Lowering
//
// This module handles lowering AST declarations to HIR items:
// - Function parameter lowering
// - Struct body and field lowering
// - Enum variant lowering
// - Declaration lowering (function, struct, enum, etc.)
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_expr;
mod hir_lower_body;
mod resolve;

// ============================================================
// Function Parameter Lowering
// ============================================================

/// Lower function parameters.
pub fn lower_fn_params(ctx: &mut hir_lower_ctx::LoweringCtx, params: &Vec<ast::Param>) -> Vec<hir_item::FnParam> {
    let mut result: Vec<hir_item::FnParam> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() {
        let param = lower_fn_param(ctx, &params[i], i as u32);
        result.push(param);
        i = i + 1;
    }
    result
}

/// Lower a single function parameter.
/// param_index is used for generating synthetic names for complex patterns.
fn lower_fn_param(ctx: &mut hir_lower_ctx::LoweringCtx, param: &ast::Param, param_index: u32) -> hir_item::FnParam {
    let ty = hir_lower_type::lower_type(ctx, &param.ty);

    // Extract the parameter name from the pattern
    // For complex patterns, this generates a synthetic name
    let (name, is_mut, _needs_destructure) = extract_param_name(&param.pattern, param_index);

    // Allocate a DefId for the parameter
    let def_id = ctx.alloc_def_id();

    // Check for qualifier-based mutability
    let mutable = is_mut || match &param.qualifier {
        &Some(ast::ParamQualifier::Mut) => true,
        _ => false,
    };

    // Check if this is a self parameter by checking the name
    let is_self = is_self_param_name(name.symbol);

    let result = hir_item::FnParam::new(def_id, name, ty, mutable, is_self, param.span);

    result
}

/// Checks if a parameter name symbol represents "self".
/// "self" is pre-interned at index 19 in the interner.
fn is_self_param_name(symbol: common::Symbol) -> bool {
    // "self" is pre-interned at index 19 (see interner.blood)
    symbol.index == 19
}

/// Extract the parameter name and mutability from a pattern.
/// Returns (name, is_mut, needs_destructuring) for all patterns.
/// For complex patterns, generates a synthetic name and signals that destructuring is needed.
fn extract_param_name(pattern: &ast::Pattern, param_index: u32) -> (common::SpannedSymbol, bool, bool) {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut, ref name, ref subpattern } => {
            // Simple ident without subpattern is trivial
            let needs_destructure = subpattern.is_some();
            (*name, is_mut, needs_destructure)
        }
        &ast::PatternKind::Wildcard => {
            // Create a synthetic name for wildcard parameters
            // Using symbol index 0 as a placeholder
            let span = pattern.span;
            let sym = common::Symbol::new(0);
            let spanned = common::SpannedSymbol { symbol: sym, span };
            (spanned, false, false)
        }
        &ast::PatternKind::Ref { is_mut: _, ref inner } => {
            // Look through reference patterns
            extract_param_name(inner.as_ref(), param_index)
        }
        _ => {
            // Complex pattern: generate synthetic name __param_N
            // The actual destructuring happens at the start of the function body
            let span = pattern.span;
            // Use a synthetic symbol. Symbol index encodes __param_N where N is param_index.
            // We'll use a high symbol index range (10000 + param_index) to avoid conflicts.
            let synthetic_index = 10000u32 + param_index;
            let sym = common::Symbol::new(synthetic_index);
            let spanned = common::SpannedSymbol { symbol: sym, span };
            (spanned, false, true)
        }
    }
}

/// Lower the return type, defaulting to unit if not specified.
pub fn lower_return_type(ctx: &mut hir_lower_ctx::LoweringCtx, return_type: &Option<ast::Type>) -> hir_ty::Type {
    match return_type {
        &Some(ref ty) => hir_lower_type::lower_type(ctx, ty),
        &None => hir_ty::Type::unit(),
    }
}

/// Lower the effect row, defaulting to empty (pure) if not specified.
pub fn lower_effects(ctx: &mut hir_lower_ctx::LoweringCtx, effects: &Option<ast::EffectRow>) -> hir_ty::EffectRow {
    match effects {
        &Some(ref eff) => hir_lower_type::lower_effect_row(ctx, eff),
        &None => hir_ty::EffectRow::empty(),
    }
}

// ============================================================
// Struct Body Lowering
// ============================================================

/// Lower a struct body to HIR.
pub fn lower_struct_body(ctx: &mut hir_lower_ctx::LoweringCtx, body: &ast::StructBody) -> hir_item::StructBody {
    match body {
        &ast::StructBody::Unit => hir_item::StructBody::Unit,
        &ast::StructBody::Tuple(ref types) => {
            let mut lowered: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let ty = hir_lower_type::lower_type(ctx, &types[i]);
                lowered.push(ty);
                i = i + 1;
            }
            hir_item::StructBody::Tuple(lowered)
        }
        &ast::StructBody::Record(ref fields) => {
            let mut lowered: Vec<hir_item::StructField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let field = lower_struct_field(ctx, &fields[i]);
                lowered.push(field);
                i = i + 1;
            }
            hir_item::StructBody::Record(lowered)
        }
    }
}

/// Lower a struct field to HIR.
pub fn lower_struct_field(ctx: &mut hir_lower_ctx::LoweringCtx, field: &ast::StructField) -> hir_item::StructField {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type(ctx, &field.ty);
    hir_item::StructField::new(def_id, field.name, ty, field.vis, field.span)
}

// ============================================================
// Enum Variant Lowering
// ============================================================

/// Lower enum variants to HIR.
pub fn lower_enum_variants(ctx: &mut hir_lower_ctx::LoweringCtx, parent_def_id: hir_def::DefId, variants: &Vec<ast::EnumVariant>) -> Vec<hir_item::Variant> {
    let mut result: Vec<hir_item::Variant> = Vec::new();
    let mut i: usize = 0;
    while i < variants.len() {
        let variant = lower_enum_variant(ctx, parent_def_id, &variants[i], i as u32);
        result.push(variant);
        i = i + 1;
    }
    result
}

/// Lower a single enum variant to HIR.
fn lower_enum_variant(ctx: &mut hir_lower_ctx::LoweringCtx, parent_def_id: hir_def::DefId, variant: &ast::EnumVariant, discriminant: u32) -> hir_item::Variant {
    let def_id = ctx.alloc_def_id();

    // Re-intern the variant name from span for consistent symbol indices
    let name_str = ctx.span_to_string(variant.name.span);
    let name_symbol = ctx.intern(name_str.as_str());

    // Register the variant def_info with the enum as its parent
    ctx.resolver.register_def_info(
        def_id,
        hir_def::DefKind::Variant,
        name_symbol,
        variant.name.span,
        Option::Some(parent_def_id),
    );

    // Create re-interned SpannedSymbol for the HIR variant
    let hir_name = common::SpannedSymbol {
        symbol: name_symbol,
        span: variant.name.span,
    };

    let kind = lower_variant_kind(ctx, &variant.body);
    hir_item::Variant::new(def_id, hir_name, discriminant, kind, variant.span)
}

/// Lower a variant body to a VariantKind.
fn lower_variant_kind(ctx: &mut hir_lower_ctx::LoweringCtx, body: &ast::StructBody) -> hir_item::VariantKind {
    match body {
        &ast::StructBody::Unit => {
            hir_item::VariantKind::Unit
        }
        &ast::StructBody::Tuple(ref types) => {
            let mut lowered: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let ty = hir_lower_type::lower_type(ctx, &types[i]);
                lowered.push(ty);
                i = i + 1;
            }
            hir_item::VariantKind::Tuple(lowered)
        }
        &ast::StructBody::Record(ref fields) => {
            let mut lowered: Vec<hir_item::StructField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let field = lower_struct_field(ctx, &fields[i]);
                lowered.push(field);
                i = i + 1;
            }
            hir_item::VariantKind::Record(lowered)
        }
    }
}

// ============================================================
// Declaration Lowering
// ============================================================

/// Lower all declarations to HIR items.
pub fn lower_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    // Two-pass lowering: first non-impl declarations (enums, structs, traits,
    // functions, etc.) to ensure all enum variants and type information is
    // registered, then impl blocks whose method bodies may reference them.
    // Without this, an `impl Type` block appearing before `enum TypeKind` in the
    // source would fail to resolve `TypeKind::Error` in method bodies.
    let mut i: usize = 0;
    while i < decls.len() {
        match &decls[i] {
            &ast::Declaration::Impl(_) => {}
            _ => {
                lower_declaration(ctx, &decls[i]);
            }
        }
        i = i + 1;
    }
    // Pass 2: lower impl blocks (method bodies can now reference all enum variants)
    i = 0;
    while i < decls.len() {
        match &decls[i] {
            &ast::Declaration::Impl(ref imp) => {
                lower_impl_decl(ctx, imp);
            }
            _ => {}
        }
        i = i + 1;
    }
}

/// Lower a single declaration to an HIR item.
pub fn lower_declaration(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            lower_function_decl(ctx, f);
        }
        &ast::Declaration::Struct(ref s) => {
            lower_struct_decl(ctx, s);
        }
        &ast::Declaration::Enum(ref e) => {
            lower_enum_decl(ctx, e);
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            lower_type_alias_decl(ctx, ta);
        }
        &ast::Declaration::Const(ref c) => {
            lower_const_decl(ctx, c);
        }
        &ast::Declaration::Static(ref s) => {
            lower_static_decl(ctx, s);
        }
        &ast::Declaration::Trait(ref t) => {
            lower_trait_decl(ctx, t);
        }
        &ast::Declaration::Effect(ref e) => {
            lower_effect_decl(ctx, e);
        }
        &ast::Declaration::Handler(ref h) => {
            lower_handler_decl(ctx, h);
        }
        &ast::Declaration::Impl(ref i) => {
            lower_impl_decl(ctx, i);
        }
        &ast::Declaration::Bridge(ref _b) => {
            // Bridge declarations and use-placeholder declarations are silently skipped.
        }
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    lower_module_decl(ctx, m, declarations);
                }
                &Option::None => {} // External module - lowered in Phase 3b
            }
        }
        &ast::Declaration::Macro(ref m) => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("macro declarations not yet supported"),
                m.span,
            );
        }
        &ast::Declaration::Use(_) => {} // Already handled in Phase 1
    }
}

/// Lower a function declaration.
fn lower_function_decl(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl) {
    // Look up the DefId we registered (re-intern from span for consistent indices)
    let name_str = ctx.span_to_string(f.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics
    let generics = hir_lower_type::lower_generics(ctx, &f.type_params, &f.where_clause);

    // Lower parameters
    let params = lower_fn_params(ctx, &f.params);

    // Lower return type
    let return_ty = lower_return_type(ctx, &f.return_type);

    // Lower effects
    let effects = lower_effects(ctx, &f.effects);

    // Create function signature
    let sig = hir_item::FnSig::new(
        generics,
        params,
        return_ty,
        effects,
        f.qualifiers,
        f.span,
    );

    // Pre-allocate body_id if function has a body (actual lowering in Phase 4)
    let body_id = if f.body.is_some() {
        let bid = ctx.alloc_body_id();
        Option::Some(bid)
    } else {
        Option::None
    };

    // Create function definition with pre-allocated body_id
    let fn_def = hir_item::FnDef::new(sig, body_id);
    let item_kind = hir_item::ItemKind::Fn(fn_def);

    // Create HIR name with re-interned symbol (not AST symbol) so it resolves correctly
    let hir_name = common::SpannedSymbol {
        symbol: lookup_symbol,
        span: f.name.span,
    };

    let item = hir_item::Item::new(
        def_id,
        hir_name,
        item_kind,
        f.vis,
        f.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a struct declaration.
fn lower_struct_decl(ctx: &mut hir_lower_ctx::LoweringCtx, s: &ast::StructDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(s.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (structs don't have where_clause in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &s.type_params, &no_where);

    // Lower struct body
    let struct_body = lower_struct_body(ctx, &s.body);

    let struct_def = hir_item::StructDef::new(generics, struct_body);
    let item_kind = hir_item::ItemKind::Struct(struct_def);
    let item = hir_item::Item::new(
        def_id,
        s.name,
        item_kind,
        s.vis,
        s.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an enum declaration.
fn lower_enum_decl(ctx: &mut hir_lower_ctx::LoweringCtx, e: &ast::EnumDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(e.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (enums don't have where_clause in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &e.type_params, &no_where);

    // Lower variants, passing the enum's DefId as parent
    let variants = lower_enum_variants(ctx, def_id, &e.variants);

    let enum_def = hir_item::EnumDef::new(generics, variants);
    let item_kind = hir_item::ItemKind::Enum(enum_def);
    let item = hir_item::Item::new(
        def_id,
        e.name,
        item_kind,
        e.vis,
        e.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a type alias declaration.
fn lower_type_alias_decl(ctx: &mut hir_lower_ctx::LoweringCtx, ta: &ast::TypeAliasDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(ta.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &ta.type_params, &no_where);

    // Lower the aliased type
    let ty = hir_lower_type::lower_type(ctx, &ta.ty);

    let alias_def = hir_item::TypeAliasDef::new(generics, ty);
    let item_kind = hir_item::ItemKind::TypeAlias(alias_def);
    let item = hir_item::Item::new(
        def_id,
        ta.name,
        item_kind,
        ta.vis,
        ta.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a const declaration.
fn lower_const_decl(ctx: &mut hir_lower_ctx::LoweringCtx, c: &ast::ConstDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(c.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower the type
    let ty = hir_lower_type::lower_type(ctx, &c.ty);

    // Allocate a body for the initializer
    let body_id = ctx.alloc_body_id();

    // Lower the initializer expression to HIR
    let init_expr = hir_lower_expr::lower_expr(ctx, &c.init_value);

    // Create the body (consts have no parameters or locals)
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    let const_def = hir_item::ConstDef::new(ty, body_id);
    let item_kind = hir_item::ItemKind::Const(const_def);
    let item = hir_item::Item::new(
        def_id,
        c.name,
        item_kind,
        c.vis,
        c.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a static declaration.
fn lower_static_decl(ctx: &mut hir_lower_ctx::LoweringCtx, s: &ast::StaticDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(s.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower the type
    let ty = hir_lower_type::lower_type(ctx, &s.ty);

    // Allocate a body for the initializer
    let body_id = ctx.alloc_body_id();

    // Lower the initializer expression to HIR
    let init_expr = hir_lower_expr::lower_expr(ctx, &s.init_value);

    // Create the body (statics have no parameters or locals)
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    let static_def = hir_item::StaticDef::new(ty, s.is_mut, body_id);
    let item_kind = hir_item::ItemKind::Static(static_def);
    let item = hir_item::Item::new(
        def_id,
        s.name,
        item_kind,
        s.vis,
        s.span,
    );
    ctx.add_item(def_id, item);
}

// ============================================================
// Trait Declaration Lowering
// ============================================================

/// Lower a trait declaration.
fn lower_trait_decl(ctx: &mut hir_lower_ctx::LoweringCtx, t: &ast::TraitDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(t.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics
    let generics = hir_lower_type::lower_generics(ctx, &t.type_params, &t.where_clause);

    // Lower supertraits
    let mut supertraits: Vec<hir_ty::TraitRef> = Vec::new();
    let mut i: usize = 0;
    while i < t.supertraits.len() {
        let supertrait_ty = hir_lower_type::lower_type(ctx, &t.supertraits[i]);
        let trait_ref = type_to_trait_ref(&supertrait_ty, t.supertraits[i].span);
        if trait_ref.is_some() {
            supertraits.push(trait_ref.unwrap());
        }
        i = i + 1;
    }

    // Lower associated items
    let mut items: Vec<hir_item::AssocItem> = Vec::new();
    let mut i: usize = 0;
    while i < t.items.len() {
        let assoc_item = lower_trait_item(ctx, &t.items[i]);
        if assoc_item.is_some() {
            items.push(assoc_item.unwrap());
        }
        i = i + 1;
    }

    let trait_def = hir_item::TraitDef::new(generics, supertraits, items);
    let item_kind = hir_item::ItemKind::Trait(trait_def);
    let item = hir_item::Item::new(
        def_id,
        t.name,
        item_kind,
        t.vis,
        t.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a trait item to an AssocItem.
fn lower_trait_item(ctx: &mut hir_lower_ctx::LoweringCtx, item: &ast::TraitItem) -> Option<hir_item::AssocItem> {
    match item {
        &ast::TraitItem::Function(ref f) => {
            let assoc_fn = lower_assoc_fn(ctx, f, true);
            Option::Some(hir_item::AssocItem::Fn(assoc_fn))
        }
        &ast::TraitItem::TypeAlias(ref ta) => {
            let assoc_ty = lower_assoc_type(ctx, ta);
            Option::Some(hir_item::AssocItem::Type(assoc_ty))
        }
        &ast::TraitItem::Const(ref c) => {
            let assoc_const = lower_assoc_const(ctx, c);
            Option::Some(hir_item::AssocItem::Const(assoc_const))
        }
    }
}

/// Lower an associated function.
fn lower_assoc_fn(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl, is_trait_item: bool) -> hir_item::AssocFn {
    let def_id = ctx.alloc_def_id();
    let generics = hir_lower_type::lower_generics(ctx, &f.type_params, &f.where_clause);
    let sig = hir_item::FnSig::new(
        generics,
        lower_fn_params(ctx, &f.params),
        lower_return_type(ctx, &f.return_type),
        lower_effects(ctx, &f.effects),
        f.qualifiers,
        f.span,
    );

    // Lower body if present
    let body_id = if f.body.is_some() {
        let bid = ctx.alloc_body_id();
        let params = lower_fn_params(ctx, &f.params);
        let body = hir_lower_body::lower_fn_body(
            ctx,
            bid,
            &params,
            &f.params,      // AST params for complex pattern destructuring
            &Option::None,
            &f.body,
        );
        ctx.add_body(bid, body);
        Option::Some(bid)
    } else {
        Option::None
    };

    let has_default = body_id.is_some();
    hir_item::AssocFn::new(def_id, f.name, sig, body_id, has_default)
}

/// Lower an associated type.
fn lower_assoc_type(ctx: &mut hir_lower_ctx::LoweringCtx, ta: &ast::TypeAliasDecl) -> hir_item::AssocType {
    let def_id = ctx.alloc_def_id();
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &ta.type_params, &no_where);
    let ty = hir_lower_type::lower_type(ctx, &ta.ty);
    let bounds: Vec<hir_ty::TraitRef> = Vec::new();
    hir_item::AssocType::new(def_id, ta.name, generics, bounds, Option::Some(ty))
}

/// Lower an associated constant.
fn lower_assoc_const(ctx: &mut hir_lower_ctx::LoweringCtx, c: &ast::ConstDecl) -> hir_item::AssocConst {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type(ctx, &c.ty);

    // Lower the initializer body
    let body_id = ctx.alloc_body_id();
    let init_expr = hir_lower_expr::lower_expr(ctx, &c.init_value);
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    hir_item::AssocConst::new(def_id, c.name, ty, Option::Some(body_id))
}

/// Convert a type to a TraitRef.
fn type_to_trait_ref(ty: &hir_ty::Type, span: common::Span) -> Option<hir_ty::TraitRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Copy the args vector
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Option::Some(hir_ty::TraitRef::new(def_id, args_copy, span))
        }
        _ => Option::None
    }
}

// ============================================================
// Effect Declaration Lowering
// ============================================================

/// Lower an effect declaration.
fn lower_effect_decl(ctx: &mut hir_lower_ctx::LoweringCtx, e: &ast::EffectDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(e.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (effects don't have where clauses in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &e.type_params, &no_where);

    // Lower parent effects
    let mut parents: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < e.parent_effects.len() {
        let parent_ty = hir_lower_type::lower_type(ctx, &e.parent_effects[i]);
        let effect_ref = type_to_effect_ref(&parent_ty);
        if effect_ref.is_some() {
            parents.push(effect_ref.unwrap());
        }
        i = i + 1;
    }

    // Lower operations
    let mut operations: Vec<hir_item::EffectOp> = Vec::new();
    let mut i: usize = 0;
    while i < e.operations.len() {
        let eff_op = lower_effect_op(ctx, &e.operations[i]);
        operations.push(eff_op);
        i = i + 1;
    }

    let effect_def = hir_item::EffectDef::new(generics, parents, operations);
    let item_kind = hir_item::ItemKind::Effect(effect_def);
    // Effects don't have visibility in the AST, use public
    let item = hir_item::Item::new(
        def_id,
        e.name,
        item_kind,
        common::Visibility::Public,
        e.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an effect operation.
fn lower_effect_op(ctx: &mut hir_lower_ctx::LoweringCtx, oper: &ast::OperationDecl) -> hir_item::EffectOp {
    let def_id = ctx.alloc_def_id();
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &oper.type_params, &no_where);

    // Lower parameter types
    let mut param_tys: Vec<hir_ty::Type> = Vec::new();
    let mut i: usize = 0;
    while i < oper.params.len() {
        let ty = hir_lower_type::lower_type(ctx, &oper.params[i].ty);
        param_tys.push(ty);
        i = i + 1;
    }

    let return_ty = hir_lower_type::lower_type(ctx, &oper.return_type);

    hir_item::EffectOp::new(def_id, oper.name, generics, param_tys, return_ty, oper.span)
}

/// Convert a type to an EffectRef.
fn type_to_effect_ref(ty: &hir_ty::Type) -> Option<hir_ty::EffectRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Option::Some(hir_ty::EffectRef::new(def_id, args_copy))
        }
        _ => Option::None
    }
}

// ============================================================
// Handler Declaration Lowering
// ============================================================

/// Lower a handler declaration.
fn lower_handler_decl(ctx: &mut hir_lower_ctx::LoweringCtx, h: &ast::HandlerDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(h.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics
    let generics = hir_lower_type::lower_generics(ctx, &h.type_params, &h.where_clause);

    // Lower the handled effect
    let effect_ty = hir_lower_type::lower_type(ctx, &h.effect);
    let handled_effect = type_to_effect_ref(&effect_ty);
    if handled_effect.is_none() {
        ctx.error(
            hir::DiagnosticCode::E0104,
            common::make_string("invalid effect type in handler"),
            h.span,
        );
        return;
    }

    // Lower state fields
    let mut state: Vec<hir_item::HandlerState> = Vec::new();
    let mut i: usize = 0;
    while i < h.state.len() {
        let hs = lower_handler_state(ctx, &h.state[i]);
        state.push(hs);
        i = i + 1;
    }

    // Lower return clause
    let return_clause = match &h.return_clause {
        &Some(ref rc) => {
            let hs = lower_handler_return(ctx, rc);
            Option::Some(hs)
        }
        &None => Option::None,
    };

    // Lower operation implementations
    let mut op_impls: Vec<hir_item::OpImpl> = Vec::new();
    let mut i: usize = 0;
    while i < h.operations.len() {
        let oper_impl = lower_op_impl(ctx, &h.operations[i]);
        op_impls.push(oper_impl);
        i = i + 1;
    }

    let handler_def = hir_item::HandlerDef::new(
        generics,
        handled_effect.unwrap(),
        h.kind,
        state,
        return_clause,
        op_impls,
    );
    let item_kind = hir_item::ItemKind::Handler(handler_def);
    // Handlers don't have visibility in AST, use public
    let item = hir_item::Item::new(
        def_id,
        h.name,
        item_kind,
        common::Visibility::Public,
        h.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower handler state field.
fn lower_handler_state(ctx: &mut hir_lower_ctx::LoweringCtx, hs: &ast::HandlerState) -> hir_item::HandlerState {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type(ctx, &hs.ty);

    let default_body = match &hs.default_val {
        &Some(ref expr) => {
            let body_id = ctx.alloc_body_id();
            let init_expr = hir_lower_expr::lower_expr(ctx, expr);
            let locals: Vec<hir_expr::Local> = Vec::new();
            let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
            ctx.add_body(body_id, body);
            Option::Some(body_id)
        }
        &None => Option::None,
    };

    hir_item::HandlerState::new(def_id, hs.name, ty, hs.is_mut, default_body)
}

/// Lower handler return clause.
fn lower_handler_return(ctx: &mut hir_lower_ctx::LoweringCtx, rc: &ast::ReturnClause) -> hir_item::HandlerReturn {
    // Lower the body
    let body_id = ctx.alloc_body_id();
    let body_expr = hir_lower_expr::lower_block_to_expr(ctx, &rc.body);
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, body_expr);
    ctx.add_body(body_id, body);

    hir_item::HandlerReturn::new(rc.param, body_id)
}

/// Lower operation implementation.
fn lower_op_impl(ctx: &mut hir_lower_ctx::LoweringCtx, oper: &ast::OperationImpl) -> hir_item::OpImpl {
    let def_id = ctx.alloc_def_id();

    // Lower parameter patterns to extract names
    let mut param_names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < oper.params.len() {
        let name = extract_pattern_name(&oper.params[i]);
        if name.is_some() {
            param_names.push(name.unwrap());
        }
        i = i + 1;
    }

    // Lower the body
    let body_id = ctx.alloc_body_id();
    let body_expr = hir_lower_expr::lower_block_to_expr(ctx, &oper.body);
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, body_expr);
    ctx.add_body(body_id, body);

    hir_item::OpImpl::new(def_id, oper.name, param_names, body_id, oper.span)
}

/// Extract a name from a pattern (for parameter names).
fn extract_pattern_name(pattern: &ast::Pattern) -> Option<common::SpannedSymbol> {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut: _, ref name, subpattern: _ } => {
            Option::Some(*name)
        }
        &ast::PatternKind::Wildcard => {
            // Create a placeholder name for wildcard
            let sym = common::Symbol::new(0);
            let spanned = common::SpannedSymbol { symbol: sym, span: pattern.span };
            Option::Some(spanned)
        }
        _ => Option::None
    }
}

// ============================================================
// Impl Declaration Lowering
// ============================================================

/// Lower an impl block.
fn lower_impl_decl(ctx: &mut hir_lower_ctx::LoweringCtx, imp: &ast::ImplBlock) {
    // Impl blocks don't have names, so we allocate a fresh DefId
    let def_id = ctx.alloc_def_id();

    // Lower generics
    let generics = hir_lower_type::lower_generics(ctx, &imp.type_params, &imp.where_clause);

    // Lower trait ref if this is a trait impl
    let trait_ref = match &imp.trait_ty {
        &Some(ref trait_ty) => {
            let lowered_ty = hir_lower_type::lower_type(ctx, trait_ty);
            type_to_trait_ref(&lowered_ty, trait_ty.span)
        }
        &None => Option::None,
    };

    // Lower self type
    let self_ty = hir_lower_type::lower_type(ctx, &imp.self_ty);

    // Set the current Self type so that `Self` references resolve correctly
    ctx.current_self_type = Option::Some(hir_ty::copy_type(&self_ty));

    // Lower associated items
    let mut items: Vec<hir_item::AssocItem> = Vec::new();
    let mut i: usize = 0;
    while i < imp.items.len() {
        let assoc_item = lower_impl_item(ctx, &imp.items[i]);
        if assoc_item.is_some() {
            items.push(assoc_item.unwrap());
        }
        i = i + 1;
    }

    // Clear the Self type after processing the impl block
    ctx.current_self_type = Option::None;

    let impl_def = hir_item::ImplDef::new(generics, trait_ref, self_ty, items);
    let item_kind = hir_item::ItemKind::Impl(impl_def);

    // Impl blocks don't have names - create a placeholder
    let placeholder_name = common::SpannedSymbol {
        symbol: common::Symbol::new(0),
        span: imp.span,
    };

    let item = hir_item::Item::new(
        def_id,
        placeholder_name,
        item_kind,
        common::Visibility::Private,
        imp.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an impl item to an AssocItem.
fn lower_impl_item(ctx: &mut hir_lower_ctx::LoweringCtx, item: &ast::ImplItem) -> Option<hir_item::AssocItem> {
    match item {
        &ast::ImplItem::Function(ref f) => {
            let assoc_fn = lower_assoc_fn(ctx, f, false);
            Option::Some(hir_item::AssocItem::Fn(assoc_fn))
        }
        &ast::ImplItem::TypeAlias(ref ta) => {
            let assoc_ty = lower_assoc_type(ctx, ta);
            Option::Some(hir_item::AssocItem::Type(assoc_ty))
        }
        &ast::ImplItem::Const(ref c) => {
            let assoc_const = lower_assoc_const(ctx, c);
            Option::Some(hir_item::AssocItem::Const(assoc_const))
        }
    }
}

// ============================================================
// Module Declaration Lowering
// ============================================================

/// Lower a module declaration.
fn lower_module_decl(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    m: &ast::ModItemDecl,
    declarations: &Vec<ast::Declaration>,
) {
    // Look up the module's DefId from registration
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(m.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = hir_def::DefId::new(binding.def_id.index);

    // Push a Module scope for lowering nested items
    // This allows unqualified name resolution within the module
    ctx.resolver.push_scope(resolve::ScopeKind::Module);

    // Add all module items to the new scope for unqualified access within the module
    add_module_items_to_scope(ctx, def_id, declarations);

    // Lower all nested declarations
    lower_declarations(ctx, declarations);

    // Collect DefIds of the items we lowered
    let item_def_ids = collect_item_def_ids(ctx, def_id);

    // Pop the module scope
    ctx.resolver.pop_scope();

    // Create the ModuleDef
    let mod_def = hir_item::ModuleDef::new(item_def_ids);
    let item_kind = hir_item::ItemKind::Module(mod_def);

    // Create the Item
    let item = hir_item::Item::new(
        def_id,
        m.name,
        item_kind,
        m.vis,
        m.span,
    );
    ctx.add_item(def_id, item);
}

/// Add module items to the current scope for unqualified access.
pub fn add_module_items_to_scope(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    declarations: &Vec<ast::Declaration>,
) {
    let mut i: usize = 0;
    while i < declarations.len() {
        add_decl_to_scope(ctx, parent_def_id, &declarations[i]);
        i = i + 1;
    }
}

/// Add a single declaration to the current scope.
/// NOTE: We must re-intern names from spans because the AST comes from a
/// re-parsed external module whose parser has a different interner than
/// the lowering context. Using parser-originated symbols directly would
/// cause lookup_in_parent to fail due to mismatched symbol indices.
fn add_decl_to_scope(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let name_str = ctx.span_to_string(s.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Enum(ref e) => {
            let name_str = ctx.span_to_string(e.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Function(ref f) => {
            let name_str = ctx.span_to_string(f.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Const(ref c) => {
            let name_str = ctx.span_to_string(c.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Static(ref s) => {
            let name_str = ctx.span_to_string(s.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Trait(ref t) => {
            let name_str = ctx.span_to_string(t.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Effect(ref e) => {
            let name_str = ctx.span_to_string(e.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let name_str = ctx.span_to_string(ta.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Handler(ref h) => {
            let name_str = ctx.span_to_string(h.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Module(ref m) => {
            // Nested modules are also added to scope
            match &m.body {
                &Option::Some(_) => {
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_sym = ctx.intern(name_str.as_str());
                    let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
                    if def_id.is_some() {
                        let binding = resolve::Binding::mod_binding(def_id.unwrap());
                        ctx.resolver.define(name_sym, binding);
                    }
                }
                &Option::None => {
                    // External module — needs to be added to scope for unqualified access
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_sym = ctx.intern(name_str.as_str());
                    // External modules are registered as globals; look up there
                    let lookup = ctx.resolver.lookup(name_sym);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let existing = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let binding = resolve::Binding::mod_binding(existing.def_id);
                        ctx.resolver.define(name_sym, binding);
                    }
                }
            }
        }
        // Impl blocks don't have names - skip
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(ref u) => {
            // pub use module::Item — add the re-exported name to the current scope
            let item_name_str = ctx.span_to_string(u.item_name.span);
            let item_sym = ctx.intern(item_name_str.as_str());
            let item_def = ctx.resolver.lookup_in_parent(parent_def_id, item_sym);
            if item_def.is_some() {
                let binding = resolve::Binding::def(item_def.unwrap());
                ctx.resolver.define(item_sym, binding);
            }
        }
    }
}

/// Collect DefIds of items that belong to a module.
fn collect_item_def_ids(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
) -> Vec<hir_def::DefId> {
    let mut result: Vec<hir_def::DefId> = Vec::new();

    // Search through def_info for items with this parent
    let mut i: usize = 0;
    while i < ctx.resolver.def_info.len() {
        let entry = &ctx.resolver.def_info[i];
        match &entry.info.parent {
            &Option::Some(p) => {
                if p.index == parent_def_id.index {
                    result.push(hir_def::DefId::new(entry.def_id.index));
                }
            }
            &Option::None => {}
        }
        i = i + 1;
    }

    result
}

/// Lower the contents of an external module.
/// Called during Phase 3b for external modules that were loaded in Phase 1.
/// This creates a Module item and lowers all declarations within the module scope.
pub fn lower_module_contents(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    module_def_id: hir_def::DefId,
    declarations: &Vec<ast::Declaration>,
) {
    // Get the module's name from def_info
    let def_info = ctx.resolver.get_def_info(module_def_id);
    if def_info.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let info = def_info.unwrap();
    let name_symbol = info.name;
    let name_span = info.span;

    // Create a SpannedSymbol for the module name
    let name = common::SpannedSymbol {
        symbol: name_symbol,
        span: name_span,
    };

    // Push a Module scope for lowering nested items
    ctx.resolver.push_scope(resolve::ScopeKind::Module);

    // Add all module items to the new scope for unqualified access within the module
    add_module_items_to_scope(ctx, module_def_id, declarations);

    // Lower all nested declarations
    lower_declarations(ctx, declarations);

    // Collect DefIds of the items we lowered
    let item_def_ids = collect_item_def_ids(ctx, module_def_id);

    // Pop the module scope
    ctx.resolver.pop_scope();

    // Create the ModuleDef
    let mod_def = hir_item::ModuleDef::new(item_def_ids);
    let item_kind = hir_item::ItemKind::Module(mod_def);

    // Create the Item (use Public visibility for external modules)
    let item = hir_item::Item::new(
        module_def_id,
        name,
        item_kind,
        common::Visibility::Public,
        name_span,
    );
    ctx.add_item(module_def_id, item);
}
