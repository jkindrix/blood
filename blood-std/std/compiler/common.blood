// Blood Self-Hosted Compiler - Common Types
//
// Shared types used across all compiler modules (lexer, parser, ast, etc.)
//
// NOTE: blood-rust (as of 1148f02) does not yet support multi-file compilation.
// Each compiler module must currently define these types inline. This file
// serves as the canonical reference - once blood-rust gains multi-file support,
// modules will import from here using Blood's dot-separated syntax:
//
//     use std.compiler.common.Span;
//     use std.compiler.common::{Symbol, SpannedSymbol};
//
// Until then, copy these type definitions into each compiler module as needed.

// ============================================================
// Source Location Types
// ============================================================

/// Span in source code with byte offsets and line/column info.
///
/// Used to track the location of tokens and AST nodes for error reporting.
pub struct Span {
    /// Start byte offset (inclusive)
    pub start: usize,
    /// End byte offset (exclusive)
    pub end: usize,
    /// Line number (1-based)
    pub line: u32,
    /// Column number (1-based)
    pub column: u32,
}

impl Span {
    /// Creates a new span.
    pub fn new(start: usize, end: usize, line: u32, column: u32) -> Span {
        Span { start, end, line, column }
    }

    /// Creates a dummy span for synthetic tokens or nodes.
    pub fn dummy() -> Span {
        Span { start: 0, end: 0, line: 0, column: 0 }
    }

    /// Returns the length of this span in bytes.
    pub fn len(self: &Span) -> usize {
        self.end - self.start
    }

    /// Merges two spans into one that covers both.
    pub fn merge(self: &Span, other: &Span) -> Span {
        let new_start = if self.start < other.start { self.start } else { other.start };
        let new_end = if self.end > other.end { self.end } else { other.end };
        // Use the line/column of whichever span starts first
        let line = if self.start <= other.start { self.line } else { other.line };
        let column = if self.start <= other.start { self.column } else { other.column };
        Span { start: new_start, end: new_end, line, column }
    }
}

// ============================================================
// Symbol - Interned String Identifier
// ============================================================

/// A symbol representing an interned string identifier.
///
/// Symbols are used instead of raw strings for identifiers to enable
/// fast comparison (just compare indices) and efficient memory usage
/// (each unique string is stored only once in the interner).
pub struct Symbol {
    /// Index into the string interner.
    pub index: u32,
}

impl Symbol {
    /// Creates a new symbol with the given index.
    pub fn new(index: u32) -> Symbol {
        Symbol { index }
    }
}

// ============================================================
// Spanned Wrappers
// ============================================================

/// A symbol with its source span.
///
/// Used for identifiers, type names, and other symbolic values that need
/// location information for error reporting.
pub struct SpannedSymbol {
    pub symbol: Symbol,
    pub span: Span,
}

impl SpannedSymbol {
    /// Creates a new spanned symbol.
    pub fn new(symbol: Symbol, span: Span) -> SpannedSymbol {
        SpannedSymbol { symbol, span }
    }
}

/// A string with its source span.
///
/// Used for string literals and other string values that need location
/// information for error reporting.
pub struct SpannedString {
    pub value: String,
    pub span: Span,
}

impl SpannedString {
    /// Creates a new spanned string.
    pub fn new(value: String, span: Span) -> SpannedString {
        SpannedString { value, span }
    }
}

// ============================================================
// Numeric Wrappers
// ============================================================

/// Wrapper for f64 that stores the bits directly.
///
/// This allows floats to be used in AST nodes without dealing with
/// NaN comparison issues.
pub struct OrderedFloat {
    pub bits: u64,
}

impl OrderedFloat {
    /// Creates an OrderedFloat from a u64 bit representation.
    pub fn from_bits(bits: u64) -> OrderedFloat {
        OrderedFloat { bits }
    }
}

// ============================================================
// Visibility
// ============================================================

/// The visibility of an item or field.
pub enum Visibility {
    /// Private to the current module.
    Private,
    /// Public to all.
    Public,
    /// Public to the current crate.
    PublicCrate,
    /// Public to the parent module.
    PublicSuper,
    /// Public to the current module (explicit self).
    PublicSelf,
}

impl Visibility {
    /// Returns true if this is public to all.
    pub fn is_public(self: &Self) -> bool {
        match self {
            Visibility::Private => false,
            Visibility::Public => true,
            Visibility::PublicCrate => false,
            Visibility::PublicSuper => false,
            Visibility::PublicSelf => false,
        }
    }
}

// ============================================================
// Function Qualifiers
// ============================================================

/// Qualifiers on a function (const, async, unsafe).
pub struct FnQualifiers {
    /// Whether the function is const.
    pub is_const: bool,
    /// Whether the function is async.
    pub is_async: bool,
    /// Whether the function is unsafe.
    pub is_unsafe: bool,
}

impl FnQualifiers {
    /// Creates default (none) qualifiers.
    pub fn none() -> FnQualifiers {
        FnQualifiers { is_const: false, is_async: false, is_unsafe: false }
    }

    /// Creates const qualifiers.
    pub fn const_fn() -> FnQualifiers {
        FnQualifiers { is_const: true, is_async: false, is_unsafe: false }
    }

    /// Creates async qualifiers.
    pub fn async_fn() -> FnQualifiers {
        FnQualifiers { is_const: false, is_async: true, is_unsafe: false }
    }

    /// Creates unsafe qualifiers.
    pub fn unsafe_fn() -> FnQualifiers {
        FnQualifiers { is_const: false, is_async: false, is_unsafe: true }
    }
}

// ============================================================
// Handler Kind
// ============================================================

/// The kind of effect handler.
pub enum HandlerKind {
    /// A deep handler (resumes always return to handler).
    Deep,
    /// A shallow handler (resumes return to call site).
    Shallow,
}

// ============================================================
// Operators
// ============================================================

/// A binary operator.
pub enum BinOp {
    /// Addition (+)
    Add,
    /// Subtraction (-)
    Sub,
    /// Multiplication (*)
    Mul,
    /// Division (/)
    Div,
    /// Remainder (%)
    Rem,
    /// Equality (==)
    Eq,
    /// Inequality (!=)
    Ne,
    /// Less than (<)
    Lt,
    /// Less than or equal (<=)
    Le,
    /// Greater than (>)
    Gt,
    /// Greater than or equal (>=)
    Ge,
    /// Logical and (&&)
    And,
    /// Logical or (||)
    Or,
    /// Bitwise and (&)
    BitAnd,
    /// Bitwise or (|)
    BitOr,
    /// Bitwise xor (^)
    BitXor,
    /// Left shift (<<)
    Shl,
    /// Right shift (>>)
    Shr,
    /// Pipe operator (|>)
    Pipe,
}

/// A unary operator.
pub enum UnaryOp {
    /// Negation (-)
    Neg,
    /// Logical not (!)
    Not,
    /// Dereference (*)
    Deref,
    /// Reference (&)
    Ref,
    /// Mutable reference (&mut)
    RefMut,
}

// ============================================================
// String Utilities
// ============================================================

/// Creates a new String from a string slice.
/// This is a workaround since Blood doesn't have String::from().
pub fn make_string(s: &str) -> String {
    let mut result = String::new();
    result.push_str(s);
    result
}

// ============================================================
// Copy Utilities
// ============================================================

// ============================================================
// Method Resolution Entry
// ============================================================

/// Entry mapping an expression span to its resolved method DefId.
///
/// The type checker records these during method resolution so that
/// MIR lowering can look up the resolved method for each call site.
/// Uses u32 for def_id_index to avoid pulling hir_def into common.
pub struct MethodResEntry {
    /// The start byte offset of the method call expression's span.
    pub span_start: usize,
    /// The DefId.index of the resolved method.
    pub def_id_index: u32,
}

impl MethodResEntry {
    /// Creates a new method resolution entry.
    pub fn new(span_start: usize, def_id_index: u32) -> MethodResEntry {
        MethodResEntry { span_start, def_id_index }
    }
}

/// A deferred method call whose receiver was an unresolved Infer type
/// during initial type checking. After all bodies are checked, Infer
/// variables may be resolved, allowing the method to be looked up.
pub struct PendingMethodCall {
    /// The byte offset of the method call expression span.
    pub span_start: usize,
    /// The TyVarId.index of the receiver's Infer variable.
    pub receiver_var: u32,
    /// The interned symbol of the method name.
    pub method_symbol: Symbol,
    /// The TyVarId.index of the return type's Infer variable.
    pub return_ty_var: u32,
}

impl PendingMethodCall {
    /// Creates a new pending method call entry.
    pub fn new(span_start: usize, receiver_var: u32, method_symbol: Symbol, return_ty_var: u32) -> PendingMethodCall {
        PendingMethodCall { span_start, receiver_var, method_symbol, return_ty_var }
    }
}

// ============================================================
// Copy Utilities
// ============================================================

/// Creates a copy of a SpannedSymbol.
pub fn copy_spanned_symbol(ss: &SpannedSymbol) -> SpannedSymbol {
    SpannedSymbol {
        symbol: ss.symbol,
        span: ss.span,
    }
}
