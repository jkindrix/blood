/// Core Type Definitions for Multiple Dispatch Resolution
///
/// This module defines the fundamental data structures used in Blood's
/// multiple dispatch system. Multiple dispatch selects the method to call
/// based on the runtime types of all arguments, not just the receiver.
///
/// # Design Principles
///
/// 1. **Explicit patterns**: Every type variant is explicitly handled
/// 2. **No shortcuts**: All cases enumerated, no catch-all patterns
/// 3. **Type stability**: Return types must be determined by input types
/// 4. **Effect awareness**: Dispatch considers effect annotations
///
/// # Algorithm Overview
///
/// Multiple dispatch resolution follows the Dylan/Julia approach:
///
/// 1. **Collect candidates**: Find all methods with matching name and arity
/// 2. **Filter applicable**: Keep methods where each argument is a subtype of parameter
/// 3. **Order by specificity**: More specific parameters = more specific method
/// 4. **Select best**: Choose unique most specific, or error on ambiguity
///
/// # References
///
/// - Dylan Reference Manual: Method Dispatch
/// - Julia Documentation: Methods
/// - "A Polyglot's Guide to Multiple Dispatch" - Eli Bendersky

use std.collections::{HashMap};
use super.super.types::{Type, TypeKind, TyVarId, DefId, PrimitiveTy, EffectRow};

// ============================================================================
// Method Candidate
// ============================================================================

/// A method candidate for dispatch resolution.
///
/// Represents a potential method that could be called at a particular call site.
/// During dispatch, candidates are filtered by applicability and then ordered
/// by specificity to find the unique best match.
///
/// # Example
///
/// For a call `foo(x, y)` where `x: i32` and `y: String`, candidates might include:
/// - `fn foo(a: i32, b: String) -> i32`
/// - `fn foo<T>(a: T, b: String) -> T`
/// - `fn foo(a: i32, b: &str) -> i32` (not applicable - String is not &str)
pub struct MethodCandidate {
    /// The definition ID of this method.
    ///
    /// Used to uniquely identify the method in the codebase and to
    /// generate calls to it in the codegen phase.
    pub def_id: DefId,

    /// The method's name.
    ///
    /// All candidates for a given dispatch must share the same name.
    pub name: String,

    /// Parameter types for this method.
    ///
    /// These are the types declared in the method signature. For generic
    /// methods, these may contain type parameters (TypeKind::Param).
    pub param_types: [Type],

    /// Return type of this method.
    ///
    /// For type stability, methods with overlapping input types should
    /// have compatible return types.
    pub return_type: Type,

    /// Type parameters for generic methods.
    ///
    /// Empty for monomorphic methods. For generic methods, these define
    /// the type variables that can be substituted during instantiation.
    pub type_params: [TypeParam],

    /// The effect row for this method, if any.
    ///
    /// None means the method is pure (no effects).
    /// Some(row) specifies which effects the method may perform.
    /// Effect specificity is used as a tiebreaker: pure > closed row > open row.
    pub effects: Option<EffectRow>,

    /// The trait this method belongs to, if any.
    ///
    /// None for inherent methods or free functions.
    /// Some(trait_id) for trait methods, used for diamond conflict detection
    /// when a type implements multiple traits with the same method name.
    pub trait_id: Option<DefId>,
}

impl MethodCandidate {
    /// Create a new method candidate.
    pub fn new(
        def_id: DefId,
        name: String,
        param_types: [Type],
        return_type: Type,
    ) -> MethodCandidate {
        MethodCandidate {
            def_id,
            name,
            param_types,
            return_type,
            type_params: vec![],
            effects: None,
            trait_id: None,
        }
    }

    /// Create a method candidate with type parameters (generic method).
    pub fn generic(
        def_id: DefId,
        name: String,
        param_types: [Type],
        return_type: Type,
        type_params: [TypeParam],
    ) -> MethodCandidate {
        MethodCandidate {
            def_id,
            name,
            param_types,
            return_type,
            type_params,
            effects: None,
            trait_id: None,
        }
    }

    /// Create a method candidate with effects.
    pub fn with_effects(
        def_id: DefId,
        name: String,
        param_types: [Type],
        return_type: Type,
        effects: EffectRow,
    ) -> MethodCandidate {
        MethodCandidate {
            def_id,
            name,
            param_types,
            return_type,
            type_params: vec![],
            effects: Some(effects),
            trait_id: None,
        }
    }

    /// Set the trait ID for this method.
    pub fn set_trait_id(&mut self, trait_id: DefId) {
        self.trait_id = Some(trait_id);
    }

    /// Check if this is a generic method.
    pub fn is_generic(&self) -> bool {
        self.type_params.len() > 0
    }

    /// Check if this method is pure (no effects).
    pub fn is_pure(&self) -> bool {
        match &self.effects {
            None => true,
            Some(row) => row.is_pure(),
        }
    }

    /// Check if this is a trait method.
    pub fn is_trait_method(&self) -> bool {
        self.trait_id.is_some();
    }

    /// Get the arity (number of parameters) of this method.
    pub fn arity(&self) -> usize {
        self.param_types.len();
    }
}

impl Clone for MethodCandidate {
    fn clone(&self) -> MethodCandidate {
        MethodCandidate {
            def_id: self.def_id.clone(),
            name: self.name.clone(),
            param_types: self.param_types.clone(),
            return_type: self.return_type.clone(),
            type_params: self.type_params.clone(),
            effects: self.effects.clone(),
            trait_id: self.trait_id.clone(),
        }
    }
}

// ============================================================================
// Type Parameter
// ============================================================================

/// A type parameter with optional constraints.
///
/// Type parameters represent universally quantified type variables in generic
/// methods. They may have constraints that restrict which types can be
/// substituted for them.
///
/// # Example
///
/// ```blood
/// fn sort<T: Ord>(list: [T]) -> [T]
/// ```
///
/// Here `T` is a type parameter with the constraint `Ord`.
pub struct TypeParam {
    /// The name of this type parameter (e.g., "T", "U").
    pub name: String,

    /// The unique ID for this type parameter.
    ///
    /// This ID is used during substitution to identify which type
    /// variable to replace.
    pub id: TyVarId,

    /// Constraints on this type parameter.
    ///
    /// Empty if the type parameter is unconstrained.
    /// Each constraint specifies a trait that the concrete type must implement.
    pub constraints: [Constraint],
}

impl TypeParam {
    /// Create a new unconstrained type parameter.
    pub fn new(name: String, id: TyVarId) -> TypeParam {
        TypeParam {
            name,
            id,
            constraints: vec![],
        }
    }

    /// Create a type parameter with constraints.
    pub fn with_constraints(name: String, id: TyVarId, constraints: [Constraint]) -> TypeParam {
        TypeParam {
            name,
            id,
            constraints,
        }
    }

    /// Check if this type parameter has any constraints.
    pub fn has_constraints(&self) -> bool {
        self.constraints.len() > 0
    }
}

impl Clone for TypeParam {
    fn clone(&self) -> TypeParam {
        TypeParam {
            name: self.name.clone(),
            id: self.id.clone(),
            constraints: self.constraints.clone(),
        }
    }
}

// ============================================================================
// Constraint
// ============================================================================

/// A constraint on a type parameter.
///
/// Constraints specify that a type must implement a particular trait.
/// During generic instantiation, the constraint checker verifies that
/// the concrete type satisfies all constraints.
///
/// # Example
///
/// For `T: Ord + Clone`, there would be two constraints:
/// - `Constraint { trait_name: "Ord" }`
/// - `Constraint { trait_name: "Clone" }`
pub struct Constraint {
    /// The name of the trait that must be implemented.
    pub trait_name: String,

    /// The DefId of the trait (for full trait resolution).
    ///
    /// This is optional - if None, constraint checking uses
    /// built-in heuristics for well-known traits.
    pub trait_id: Option<DefId>,
}

impl Constraint {
    /// Create a constraint from a trait name.
    pub fn from_name(trait_name: String) -> Constraint {
        Constraint {
            trait_name,
            trait_id: None,
        }
    }

    /// Create a constraint with a trait ID.
    pub fn from_trait(trait_name: String, trait_id: DefId) -> Constraint {
        Constraint {
            trait_name,
            trait_id: Some(trait_id),
        }
    }
}

impl Clone for Constraint {
    fn clone(&self) -> Constraint {
        Constraint {
            trait_name: self.trait_name.clone(),
            trait_id: self.trait_id.clone(),
        }
    }
}

// ============================================================================
// Instantiation Result
// ============================================================================

/// The result of attempting to instantiate a generic method.
///
/// When a generic method is called with concrete argument types, we attempt
/// to infer substitutions for its type parameters. This result captures
/// whether that succeeded and, if so, what substitutions were inferred.
///
/// # Algorithm
///
/// 1. For each parameter type, match against the corresponding argument type
/// 2. Extract type parameter substitutions from the matching
/// 3. Verify consistency (same type parameter gets same concrete type)
/// 4. Check that all constraints are satisfied
/// 5. Apply substitutions to create the instantiated method
pub enum InstantiationResult {
    /// Successfully instantiated the generic method.
    Success {
        /// The type substitutions that were inferred.
        ///
        /// Maps type parameter IDs to their concrete types.
        substitutions: HashMap<u32, Type>,

        /// The instantiated method candidate with concrete types.
        ///
        /// All type parameters have been replaced with their concrete types.
        candidate: MethodCandidate,
    },

    /// Failed to instantiate due to a type mismatch.
    ///
    /// This occurs when the same type parameter would need to be
    /// bound to two different concrete types.
    TypeMismatch {
        /// The type parameter that couldn't be matched.
        param_id: TyVarId,

        /// The first type inferred for this parameter.
        expected: Type,

        /// The conflicting type that was found.
        found: Type,
    },

    /// The argument count doesn't match the parameter count.
    ArityMismatch {
        /// Expected number of arguments.
        expected: usize,

        /// Found number of arguments.
        found: usize,
    },

    /// A type parameter constraint was not satisfied.
    ConstraintNotSatisfied {
        /// Details about which constraint failed.
        error: ConstraintError,
    },
}

impl InstantiationResult {
    /// Check if instantiation succeeded.
    pub fn is_success(&self) -> bool {
        match self {
            InstantiationResult::Success { substitutions: _, candidate: _ } => true,
            InstantiationResult::TypeMismatch { param_id: _, expected: _, found: _ } => false,
            InstantiationResult::ArityMismatch { expected: _, found: _ } => false,
            InstantiationResult::ConstraintNotSatisfied { error: _ } => false,
        }
    }

    /// Get the instantiated candidate if successful.
    pub fn candidate(&self) -> Option<&MethodCandidate> {
        match self {
            InstantiationResult::Success { substitutions: _, candidate } => Some(candidate),
            InstantiationResult::TypeMismatch { param_id: _, expected: _, found: _ } => None,
            InstantiationResult::ArityMismatch { expected: _, found: _ } => None,
            InstantiationResult::ConstraintNotSatisfied { error: _ } => None,
        }
    }
}

impl Clone for InstantiationResult {
    fn clone(&self) -> InstantiationResult {
        match self {
            InstantiationResult::Success { substitutions, candidate } => {
                InstantiationResult::Success {
                    substitutions: substitutions.clone(),
                    candidate: candidate.clone(),
                }
            }
            InstantiationResult::TypeMismatch { param_id, expected, found } => {
                InstantiationResult::TypeMismatch {
                    param_id: param_id.clone(),
                    expected: expected.clone(),
                    found: found.clone(),
                }
            }
            InstantiationResult::ArityMismatch { expected, found } => {
                InstantiationResult::ArityMismatch {
                    expected: *expected,
                    found: *found,
                }
            }
            InstantiationResult::ConstraintNotSatisfied { error } => {
                InstantiationResult::ConstraintNotSatisfied {
                    error: error.clone(),
                }
            }
        }
    }
}

// ============================================================================
// Constraint Error
// ============================================================================

/// Error indicating a constraint was not satisfied during generic instantiation.
///
/// When a generic method has constraints on its type parameters, we must
/// verify that the concrete types inferred satisfy those constraints.
/// This error captures details about which constraint failed.
pub struct ConstraintError {
    /// The name of the type parameter whose constraint was violated.
    pub param_name: String,

    /// The type parameter's ID.
    pub param_id: TyVarId,

    /// The concrete type that was inferred for this parameter.
    pub concrete_type: Type,

    /// The constraint that was not satisfied.
    pub constraint: Constraint,
}

impl ConstraintError {
    /// Create a new constraint error.
    pub fn new(
        param_name: String,
        param_id: TyVarId,
        concrete_type: Type,
        constraint: Constraint,
    ) -> ConstraintError {
        ConstraintError {
            param_name,
            param_id,
            concrete_type,
            constraint,
        }
    }

    /// Get a human-readable error message.
    pub fn message(&self) -> String {
        format!(
            "the trait bound `{}: {}` is not satisfied",
            self.param_name,
            self.constraint.trait_name
        )
    }

    /// Get a detailed error message including the concrete type.
    pub fn detailed_message(&self) -> String {
        format!(
            "type parameter `{}` was inferred as `{:?}`, which does not implement `{}`",
            self.param_name,
            self.concrete_type.kind(),
            self.constraint.trait_name
        )
    }
}

impl Clone for ConstraintError {
    fn clone(&self) -> ConstraintError {
        ConstraintError {
            param_name: self.param_name.clone(),
            param_id: self.param_id.clone(),
            concrete_type: self.concrete_type.clone(),
            constraint: self.constraint.clone(),
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_method_candidate_creation() {
        let def_id = DefId::new(1);
        let candidate = MethodCandidate::new(
            def_id,
            "foo".to_string(),
            vec![Type::i32(), Type::bool()],
            Type::unit(),
        );

        assert_eq!(candidate.name, "foo");
        assert_eq!(candidate.arity(), 2);
        assert!(candidate.is_pure());
        assert!(!candidate.is_generic());
        assert!(!candidate.is_trait_method());
    }

    #[test]
    fn test_generic_method_candidate() {
        let def_id = DefId::new(2);
        let type_param = TypeParam::new("T".to_string(), TyVarId::new(0));
        let candidate = MethodCandidate::generic(
            def_id,
            "identity".to_string(),
            vec![Type::param(TyVarId::new(0))],
            Type::param(TyVarId::new(0)),
            vec![type_param],
        );

        assert!(candidate.is_generic());
        assert_eq!(candidate.type_params.len(), 1);
    }

    #[test]
    fn test_type_param_with_constraints() {
        let constraint = Constraint::from_name("Ord".to_string());
        let type_param = TypeParam::with_constraints(
            "T".to_string(),
            TyVarId::new(0),
            vec![constraint],
        );

        assert!(type_param.has_constraints());
        assert_eq!(type_param.constraints.len(), 1);
        assert_eq!(type_param.constraints[0].trait_name, "Ord");
    }

    #[test]
    fn test_constraint_error_message() {
        let error = ConstraintError::new(
            "T".to_string(),
            TyVarId::new(0),
            Type::f64(),
            Constraint::from_name("Ord".to_string()),
        );

        let msg = error.message();
        assert!(msg.contains("T"));
        assert!(msg.contains("Ord"));
    }

    #[test]
    fn test_instantiation_result_success() {
        let def_id = DefId::new(3);
        let candidate = MethodCandidate::new(
            def_id,
            "test".to_string(),
            vec![Type::i32()],
            Type::i32(),
        );

        let result = InstantiationResult::Success {
            substitutions: HashMap::new(),
            candidate,
        };

        assert!(result.is_success());
        assert!(result.candidate().is_some());
    }

    #[test]
    fn test_instantiation_result_type_mismatch() {
        let result = InstantiationResult::TypeMismatch {
            param_id: TyVarId::new(0),
            expected: Type::i32(),
            found: Type::bool(),
        };

        assert!(!result.is_success());
        assert!(result.candidate().is_none());
    }

    #[test]
    fn test_instantiation_result_arity_mismatch() {
        let result = InstantiationResult::ArityMismatch {
            expected: 2,
            found: 3,
        };

        assert!(!result.is_success());
    }
}
