/// Main Dispatch Resolution Algorithm
///
/// This module implements Blood's multiple dispatch resolution algorithm,
/// following the Dylan/Julia approach to method selection based on runtime
/// types of all arguments.
///
/// # Algorithm Overview
///
/// Multiple dispatch resolution proceeds in phases:
///
/// 1. **Collect candidates**: All methods with matching name and arity
/// 2. **Filter applicable**: Methods where each argument is subtype of parameter
/// 3. **Instantiate generics**: Infer type parameter substitutions
/// 4. **Order by specificity**: More specific parameters = more specific method
/// 5. **Find maximal**: Methods not dominated by any other
/// 6. **Select unique**: If exactly one maximal, success; else ambiguity
///
/// # Specificity Rules
///
/// Method A is more specific than method B if:
/// - For each position i: A[i] <: B[i] (at least as specific)
/// - For at least one position j: A[j] <: B[j] but not B[j] <: A[j] (strictly more specific)
/// - If parameter types are equal, use effect specificity as tiebreaker
///
/// # Effect-Aware Dispatch
///
/// Effects participate in dispatch as a secondary criterion:
/// - pure > closed row > open row
/// - fewer effects > more effects
///
/// # References
///
/// - Dylan Reference Manual: Method Dispatch
/// - Julia Documentation: Methods and Dispatch
/// - "A Polyglot's Guide to Multiple Dispatch" - Eli Bendersky

use std.collections::{HashMap, HashSet};
use std.compiler.typeck.types::{Type, TypeKind, TyVarId, DefId, PrimitiveTy, EffectRow};
use std.compiler.typeck.types::{MethodCandidate, TypeParam, InstantiationResult, ConstraintError};
use std.compiler.typeck.dispatch.effect_row::{DispatchEffectRow, Ordering};
use std.compiler.typeck.dispatch.result::{DispatchResult, NoMatchError, AmbiguityError};
use std.compiler.typeck.dispatch.constraints::ConstraintChecker;

// ============================================================================
// Dispatch Resolver
// ============================================================================

/// The main dispatch resolution engine.
///
/// The resolver holds references to type context needed for subtype checking
/// and trait implementation verification. It provides methods for complete
/// dispatch resolution as well as lower-level utilities.
///
/// # Usage
///
/// ```blood
/// let resolver = DispatchResolver::new();
///
/// let result = resolver.resolve(
///     "foo",
///     &[Type::i32(), Type::bool()],
///     &candidates,
/// );
///
/// match result {
///     DispatchResult::Resolved { candidate } => {
///         // Use candidate.def_id to generate call
///     }
///     DispatchResult::NoMatch { error } => {
///         // Report error to user
///     }
///     DispatchResult::Ambiguous { error } => {
///         // Report ambiguity, suggest qualified syntax
///     }
/// }
/// ```
pub struct DispatchResolver {
    /// Optional constraint checker for generic method instantiation.
    constraint_checker: Option<ConstraintChecker>,
}

impl DispatchResolver {
    /// Create a new dispatch resolver.
    pub fn new() -> DispatchResolver {
        DispatchResolver {
            constraint_checker: None,
        }
    }

    /// Create a resolver with a custom constraint checker.
    ///
    /// The constraint checker is used to verify trait bounds on generic
    /// type parameters during instantiation.
    pub fn with_constraint_checker(checker: ConstraintChecker) -> DispatchResolver {
        DispatchResolver {
            constraint_checker: Some(checker),
        }
    }

    // ========================================================================
    // Main Dispatch Entry Point
    // ========================================================================

    /// Resolve dispatch for a method call.
    ///
    /// Given a method name, argument types, and candidate methods, finds the
    /// unique most specific applicable method or returns an appropriate error.
    ///
    /// # Arguments
    ///
    /// * `method_name` - The name of the method being called
    /// * `arg_types` - The types of the arguments at the call site
    /// * `candidates` - All method candidates with the given name
    ///
    /// # Returns
    ///
    /// * `Resolved` - A unique most specific method was found
    /// * `NoMatch` - No methods are applicable to the given arguments
    /// * `Ambiguous` - Multiple methods are equally applicable
    pub fn resolve(
        &self,
        method_name: &str,
        arg_types: &[Type],
        candidates: &[MethodCandidate],
    ) -> DispatchResult {
        // Step 1: Filter to applicable methods
        let applicable = self.filter_applicable(candidates, arg_types);

        // Step 2: Handle no matches
        if applicable.is_empty() {
            return DispatchResult::no_match(NoMatchError::new(
                method_name.to_string(),
                arg_types.to_vec(),
                candidates.to_vec(),
            ));
        };

        // Step 3: Find maximally specific methods
        let maximal = self.find_maximal(&applicable);

        // Step 4: Check for unique winner
        if maximal.len() == 1 {
            return DispatchResult::resolved(maximal[0].clone());
        }

        // Step 5: Ambiguity error (multiple maximal candidates)
        DispatchResult::ambiguous(AmbiguityError::new(
            method_name.to_string(),
            arg_types.to_vec(),
            maximal,
        ))
    }

    /// Resolve dispatch with effect context.
    ///
    /// This is an extended version that also considers effect compatibility
    /// when filtering applicable methods.
    ///
    /// # Arguments
    ///
    /// * `method_name` - The name of the method being called
    /// * `arg_types` - The types of the arguments at the call site
    /// * `candidates` - All method candidates with the given name
    /// * `context_effects` - The effects the calling context can handle
    ///
    /// # Returns
    ///
    /// Same as `resolve`, but methods with incompatible effects are filtered out.
    pub fn resolve_with_effects(
        &self,
        method_name: &str,
        arg_types: &[Type],
        candidates: &[MethodCandidate],
        context_effects: Option<&EffectRow>,
    ) -> DispatchResult {
        // Step 1: Filter to applicable methods (including effect check);
        let applicable = self.filter_applicable_with_effects(
            candidates,
            arg_types,
            context_effects,
        );

        // Step 2: Handle no matches
        if applicable.is_empty() {
            return DispatchResult::no_match(NoMatchError::new(
                method_name.to_string(),
                arg_types.to_vec(),
                candidates.to_vec(),
            ));
        };

        // Step 3: Find maximally specific methods
        let maximal = self.find_maximal(&applicable);

        // Step 4: Check for unique winner
        if maximal.len() == 1 {
            return DispatchResult::resolved(maximal[0].clone());
        }

        // Step 5: Ambiguity error
        DispatchResult::ambiguous(AmbiguityError::new(
            method_name.to_string(),
            arg_types.to_vec(),
            maximal,
        ))
    }

    // ========================================================================
    // Applicability Checking
    // ========================================================================

    /// Filter candidates to only those applicable to the given arguments.
    fn filter_applicable(
        &self,
        candidates: &[MethodCandidate],
        arg_types: &[Type],
    ) -> [MethodCandidate] {
        let mut applicable: [MethodCandidate] = vec![];

        for candidate in candidates.iter() {
            if self.is_applicable(candidate, arg_types) {
                applicable.push(candidate.clone());
            }
        }

        applicable
    }

    /// Filter candidates with effect compatibility checking.
    fn filter_applicable_with_effects(
        &self,
        candidates: &[MethodCandidate],
        arg_types: &[Type],
        context_effects: Option<&EffectRow>,
    ) -> [MethodCandidate] {
        let mut applicable: [MethodCandidate] = vec![];

        for candidate in candidates.iter() {
            if self.is_applicable_with_effects(candidate, arg_types, context_effects) {
                applicable.push(candidate.clone());
            }
        }

        applicable
    }

    /// Check if a method is applicable to the given argument types.
    ///
    /// A method is applicable if:
    /// 1. It has the same arity as the arguments
    /// 2. Each argument type is a subtype of the corresponding parameter type
    /// 3. For generic methods, type parameters can be successfully instantiated
    ///
    /// # Arguments
    ///
    /// * `method` - The method candidate to check
    /// * `arg_types` - The argument types at the call site
    ///
    /// # Returns
    ///
    /// `true` if the method can be called with the given arguments.
    pub fn is_applicable(&self, method: &MethodCandidate, arg_types: &[Type]) -> bool {
        // Check arity
        if method.param_types.len() != arg_types.len() {
            return false;
        };

        // For generic methods, try to instantiate
        if method.is_generic() {
            match self.instantiate_generic(method, arg_types) {
                InstantiationResult::Success { substitutions: _, candidate } => {
                    // Verify the instantiated types are subtypes
                    let mut i: usize = 0;
                    while i < arg_types.len() {
                        if !self.is_subtype(&arg_types[i], &candidate.param_types[i]) {
                            return false;
                        };
                        i = i + 1;
                    };
                    return true;
                }
                InstantiationResult::TypeMismatch { param_id: _, expected: _, found: _ } => {
                    return false;
                }
                InstantiationResult::ArityMismatch { expected: _, found: _ } => {
                    return false;
                }
                InstantiationResult::ConstraintNotSatisfied { error: _ } => {
                    return false;
                }
            }
        };

        // Check each argument against parameter (non-generic case);
        let mut i: usize = 0;
        while i < arg_types.len() {
            if !self.is_subtype(&arg_types[i], &method.param_types[i]) {
                return false;
            };
            i = i + 1;
        }

        true
    }

    /// Check if a method is applicable with effect context.
    ///
    /// This is an extended version of `is_applicable` that also checks
    /// if the method's effects are compatible with the calling context.
    pub fn is_applicable_with_effects(
        &self,
        method: &MethodCandidate,
        arg_types: &[Type],
        context_effects: Option<&EffectRow>,
    ) -> bool {
        // First check basic type applicability
        if !self.is_applicable(method, arg_types) {
            return false;
        };

        // Then check effect compatibility
        self.effects_compatible(&method.effects, context_effects);
    }

    /// Check if method effects are compatible with a context.
    ///
    /// A method's effects are compatible if:
    /// - The method is pure (no effects) - always compatible
    /// - The method has no effect annotation - always compatible
    /// - The context can handle all the method's effects
    pub fn effects_compatible(
        &self,
        method_effects: &Option<EffectRow>,
        context_effects: Option<&EffectRow>,
    ) -> bool {
        match (method_effects, context_effects) {
            // No method effects means pure - always compatible
            (None, _) => true,

            // Method has effects but no context provided - assume compatible
            (Some(_), None) => true,

            // Both have effect rows - check subset relationship
            (Some(method_row), Some(context_row)) => {
                let method_dispatch_row = DispatchEffectRow::from_row(method_row.clone());
                let context_dispatch_row = DispatchEffectRow::from_row(context_row.clone());
                method_dispatch_row.is_subset_of(&context_dispatch_row);
            }
        }
    }

    // ========================================================================
    // Generic Instantiation
    // ========================================================================

    /// Attempt to instantiate a generic method with concrete argument types.
    ///
    /// This method infers type parameter substitutions from the argument types
    /// and returns an instantiated candidate with all type parameters replaced
    /// by their concrete types.
    ///
    /// # Algorithm
    ///
    /// 1. For each parameter type, recursively match against the corresponding
    ///    argument type, accumulating type parameter substitutions.
    /// 2. If a type parameter is encountered multiple times, verify that all
    ///    inferred types are consistent (equal).
    /// 3. Check that all type parameter constraints are satisfied.
    /// 4. Apply substitutions to create the instantiated method candidate.
    pub fn instantiate_generic(
        &self,
        method: &MethodCandidate,
        arg_types: &[Type],
    ) -> InstantiationResult {
        // Check arity first
        if method.param_types.len() != arg_types.len() {
            return InstantiationResult::ArityMismatch {
                expected: method.param_types.len(),
                found: arg_types.len(),
            };
        };

        // Build a set of valid type parameter IDs for this method
        let mut valid_params: HashSet<u32> = HashSet::new();
        for param in method.type_params.iter() {
            valid_params.insert(param.id.id());
        };

        // Accumulate substitutions
        let mut substitutions: HashMap<u32, Type> = HashMap::new();

        // Match each parameter against its argument
        let mut i: usize = 0;
        while i < method.param_types.len() {
            match self.try_match_type_param(
                &method.param_types[i],
                &arg_types[i],
                &valid_params,
                &mut substitutions,
            ) {
                Some(mismatch) => return mismatch,
                None => { /* continue */ };
            };
            i = i + 1;
        };

        // Check type parameter constraints
        let has_constraints = self.any_param_has_constraints(&method.type_params);
        if has_constraints {
            match &self.constraint_checker {
                Some(checker) => {
                    match checker.check_constraints(&method.type_params, &substitutions) {
                        Ok(()) => { /* constraints satisfied */ }
                        Err(error) => {
                            return InstantiationResult::ConstraintNotSatisfied { error };
                        }
                    }
                };
                None => {
                    // No constraint checker - create a default one
                    let default_checker = ConstraintChecker::new();
                    match default_checker.check_constraints(&method.type_params, &substitutions) {
                        Ok(()) => { /* constraints satisfied */ }
                        Err(error) => {
                            return InstantiationResult::ConstraintNotSatisfied { error };
                        }
                    }
                }
            }
        };

        // Apply substitutions to create instantiated candidate
        let mut instantiated_params: [Type] = vec![];
        for param_type in method.param_types.iter() {
            instantiated_params.push(self.apply_substitutions(param_type, &substitutions));
        };

        let instantiated_return = self.apply_substitutions(&method.return_type, &substitutions);

        let instantiated_candidate = MethodCandidate {
            def_id: method.def_id.clone(),
            name: method.name.clone(),
            param_types: instantiated_params,
            return_type: instantiated_return,
            type_params: vec![], // No longer generic after instantiation
            effects: method.effects.clone(),
            trait_id: method.trait_id.clone(),
        };

        InstantiationResult::Success {
            substitutions,
            candidate: instantiated_candidate,
        }
    }

    /// Check if any type parameter has constraints.
    fn any_param_has_constraints(&self, params: &[TypeParam]) -> bool {
        for param in params.iter() {
            if param.has_constraints() {
                return true;
            }
        }
        false
    }

    /// Try to match a parameter type against an argument type, extracting
    /// type parameter substitutions.
    ///
    /// Returns `Some(InstantiationResult)` if there's a conflict,
    /// `None` if matching succeeded (substitution extracted or deferred to subtyping).
    fn try_match_type_param(
        &self,
        param_type: &Type,
        arg_type: &Type,
        valid_params: &HashSet<u32>,
        substitutions: &mut HashMap<u32, Type>,
    ) -> Option<InstantiationResult> {
        match param_type.kind() {
            // Type parameter: record or verify substitution
            TypeKind::Param(param_id) => {
                if valid_params.contains(&param_id.id()) {
                    match substitutions.get(&param_id.id()) {
                        Some(existing) => {
                            // Already have a substitution - verify consistency
                            if !self.types_equal(existing, arg_type) {
                                return Some(InstantiationResult::TypeMismatch {
                                    param_id: param_id.clone(),
                                    expected: existing.clone(),
                                    found: arg_type.clone(),
                                });
                            }
                        };
                        None => {
                            // First occurrence - record substitution
                            substitutions.insert(param_id.id(), arg_type.clone());
                        }
                    }
                }
                None
            }

            // Reference types: match inner types
            TypeKind::Ref { inner: param_inner, mutable: param_mut } => {
                match arg_type.kind() {
                    TypeKind::Ref { inner: arg_inner, mutable: arg_mut } => {
                        // Check mutability compatibility
                        if *param_mut && !arg_mut {
                            // Mutable param requires mutable arg
                            return None; // Let subtype checking handle this
                        };
                        self.try_match_type_param(param_inner, arg_inner, valid_params, substitutions);
                    }
                    _ => None, // Structure mismatch - defer to subtyping
                }
            }

            // Pointer types: match inner types
            TypeKind::Ptr { inner: param_inner, mutable: param_mut } => {
                match arg_type.kind() {
                    TypeKind::Ptr { inner: arg_inner, mutable: arg_mut } => {
                        if param_mut == arg_mut {
                            self.try_match_type_param(param_inner, arg_inner, valid_params, substitutions);
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // Array types: match element types
            TypeKind::Array { element: param_elem, size: param_size } => {
                match arg_type.kind() {
                    TypeKind::Array { element: arg_elem, size: arg_size } => {
                        if param_size == arg_size {
                            self.try_match_type_param(param_elem, arg_elem, valid_params, substitutions);
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // Slice types: match element types
            TypeKind::Slice { element: param_elem } => {
                match arg_type.kind() {
                    TypeKind::Slice { element: arg_elem } => {
                        self.try_match_type_param(param_elem, arg_elem, valid_params, substitutions);
                    }
                    _ => None,
                }
            }

            // Tuple types: match each element
            TypeKind::Tuple(param_elems) => {
                match arg_type.kind() {
                    TypeKind::Tuple(arg_elems) => {
                        if param_elems.len() == arg_elems.len() {
                            let mut i: usize = 0;
                            while i < param_elems.len() {
                                if let Some(mismatch) = self.try_match_type_param(
                                    &param_elems[i],
                                    &arg_elems[i],
                                    valid_params,
                                    substitutions,
                                ) {
                                    return Some(mismatch);
                                };
                                i = i + 1;
                            }
                            None
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // Function types: match params and return
            TypeKind::Fn { params: param_params, ret: param_ret } => {
                match arg_type.kind() {
                    TypeKind::Fn { params: arg_params, ret: arg_ret } => {
                        if param_params.len() == arg_params.len() {
                            let mut i: usize = 0;
                            while i < param_params.len() {
                                if let Some(mismatch) = self.try_match_type_param(
                                    &param_params[i],
                                    &arg_params[i],
                                    valid_params,
                                    substitutions,
                                ) {
                                    return Some(mismatch);
                                };
                                i = i + 1;
                            };
                            self.try_match_type_param(param_ret, arg_ret, valid_params, substitutions);
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // ADT types: match type arguments
            TypeKind::Adt { def_id: param_def, args: param_args } => {
                match arg_type.kind() {
                    TypeKind::Adt { def_id: arg_def, args: arg_args } => {
                        if param_def.eq(arg_def) && param_args.len() == arg_args.len() {
                            let mut i: usize = 0;
                            while i < param_args.len() {
                                if let Some(mismatch) = self.try_match_type_param(
                                    &param_args[i],
                                    &arg_args[i],
                                    valid_params,
                                    substitutions,
                                ) {
                                    return Some(mismatch);
                                };
                                i = i + 1;
                            }
                            None
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // Range types: match element types
            TypeKind::Range { element: param_elem, inclusive: param_incl } => {
                match arg_type.kind() {
                    TypeKind::Range { element: arg_elem, inclusive: arg_incl } => {
                        if param_incl == arg_incl {
                            self.try_match_type_param(param_elem, arg_elem, valid_params, substitutions);
                        } else {
                            None
                        }
                    }
                    _ => None,
                }
            }

            // Ground types and non-extractable types: no substitutions possible
            TypeKind::Primitive(_) => None,
            TypeKind::Never => None,
            TypeKind::Error => None,
            TypeKind::Infer(_) => None,
            TypeKind::Closure { def_id: _, params: _, ret: _ } => None,
            TypeKind::DynTrait { trait_id: _, auto_traits: _ } => None,
            TypeKind::Forall { params: _, body: _ } => None,
            TypeKind::Record { fields: _, row_var: _ } => None,
            TypeKind::Ownership { qualifier: _, inner: _ } => None,
        }
    }

    /// Apply type parameter substitutions to a type.
    fn apply_substitutions(
        &self,
        ty: &Type,
        substitutions: &HashMap<u32, Type>,
    ) -> Type {
        match ty.kind() {
            TypeKind::Param(id) => {
                match substitutions.get(&id.id()) {
                    Some(concrete) => concrete.clone(),
                    None => ty.clone(),
                }
            }

            TypeKind::Ref { inner, mutable } => {
                let new_inner = self.apply_substitutions(inner, substitutions);
                Type::reference(new_inner, *mutable)
            }

            TypeKind::Ptr { inner, mutable } => {
                let new_inner = self.apply_substitutions(inner, substitutions);
                Type::ptr(new_inner, *mutable)
            }

            TypeKind::Array { element, size } => {
                let new_elem = self.apply_substitutions(element, substitutions);
                Type::array(new_elem, *size)
            }

            TypeKind::Slice { element } => {
                let new_elem = self.apply_substitutions(element, substitutions);
                Type::slice(new_elem)
            }

            TypeKind::Tuple(elements) => {
                let mut new_elems: [Type] = vec![];
                for elem in elements.iter() {
                    new_elems.push(self.apply_substitutions(elem, substitutions));
                }
                Type::tuple(new_elems)
            }

            TypeKind::Fn { params, ret } => {
                let mut new_params: [Type] = vec![];
                for param in params.iter() {
                    new_params.push(self.apply_substitutions(param, substitutions));
                };
                let new_ret = self.apply_substitutions(ret, substitutions);
                Type::function(new_params, new_ret)
            }

            TypeKind::Adt { def_id, args } => {
                let mut new_args: [Type] = vec![];
                for arg in args.iter() {
                    new_args.push(self.apply_substitutions(arg, substitutions));
                }
                Type::adt(def_id.clone(), new_args)
            }

            TypeKind::Range { element, inclusive } => {
                let new_elem = self.apply_substitutions(element, substitutions);
                Type::range(new_elem, *inclusive)
            }

            TypeKind::Closure { def_id, params, ret } => {
                let mut new_params: [Type] = vec![];
                for param in params.iter() {
                    new_params.push(self.apply_substitutions(param, substitutions));
                };
                let new_ret = self.apply_substitutions(ret, substitutions);
                Type::closure(def_id.clone(), new_params, new_ret)
            }

            // Types that don't contain type parameters
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Error => ty.clone(),
            TypeKind::Infer(_) => ty.clone(),
            TypeKind::DynTrait { trait_id: _, auto_traits: _ } => ty.clone(),
            TypeKind::Forall { params: _, body: _ } => ty.clone(),
            TypeKind::Record { fields: _, row_var: _ } => ty.clone(),
            TypeKind::Ownership { qualifier: _, inner: _ } => ty.clone(),
        }
    }

    // ========================================================================
    // Subtype Checking
    // ========================================================================

    /// Check if type a is a subtype of type b.
    ///
    /// Implements structural subtyping with variance:
    /// - Covariant positions: &T, [T], arrays - T can be a subtype
    /// - Invariant positions: &mut T - T must be exactly equal
    /// - Contravariant positions: function parameters - reversed subtyping
    pub fn is_subtype(&self, a: &Type, b: &Type) -> bool {
        // Any type is a subtype of itself
        if self.types_equal(a, b) {
            return true;
        };

        // Never is a subtype of everything (bottom type)
        match b.kind() {
            TypeKind::Never => return false, // Nothing is subtype of never except never
            _ => {}
        };
        match a.kind() {
            TypeKind::Never => return true, // never is subtype of everything
            _ => {}
        };

        // Integer promotion: narrower integers are subtypes of wider
        match (a.kind(), b.kind()) {
            (TypeKind::Primitive(pa), TypeKind::Primitive(pb)) => {
                if self.primitive_subtype(pa, pb) {
                    return true;
                }
            }
            _ => {}
        };

        // Type parameter check: if b is a type variable, need to check constraints
        match b.kind() {
            TypeKind::Infer(_) => return true,
            TypeKind::Param(_) => return true,
            _ => {}
        };

        // Variance rules for compound types
        match (a.kind(), b.kind()) {
            // Immutable references are covariant
            (
                TypeKind::Ref { inner: a_inner, mutable: false },
                TypeKind::Ref { inner: b_inner, mutable: false },
            ) => {
                return self.is_subtype(a_inner, b_inner);
            }

            // Mutable references are invariant
            (
                TypeKind::Ref { inner: a_inner, mutable: true },
                TypeKind::Ref { inner: b_inner, mutable: true },
            ) => {
                return self.types_equal(a_inner, b_inner);
            }

            // Immutable ref is not subtype of mutable ref
            (
                TypeKind::Ref { inner: _, mutable: false },
                TypeKind::Ref { inner: _, mutable: true },
            ) => {
                return false;
            }

            // Mutable ref can be used where immutable ref is expected
            (
                TypeKind::Ref { inner: a_inner, mutable: true },
                TypeKind::Ref { inner: b_inner, mutable: false },
            ) => {
                return self.is_subtype(a_inner, b_inner);
            }

            // Slices are covariant
            (
                TypeKind::Slice { element: a_elem },
                TypeKind::Slice { element: b_elem },
            ) => {
                return self.is_subtype(a_elem, b_elem);
            }

            // Arrays are covariant in element type (same size required)
            (
                TypeKind::Array { element: a_elem, size: a_size },
                TypeKind::Array { element: b_elem, size: b_size },
            ) => {
                return a_size == b_size && self.is_subtype(a_elem, b_elem);
            }

            // Tuples are covariant in each position
            (TypeKind::Tuple(a_elems), TypeKind::Tuple(b_elems)) => {
                if a_elems.len() != b_elems.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_elems.len() {
                    if !self.is_subtype(&a_elems[i], &b_elems[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                return true;
            }

            // Function types: contravariant in params, covariant in return
            (
                TypeKind::Fn { params: a_params, ret: a_ret },
                TypeKind::Fn { params: b_params, ret: b_ret },
            ) => {
                // Same arity required
                if a_params.len() != b_params.len() {
                    return false;
                };
                // Contravariant in parameters: b_param <: a_param
                let mut i: usize = 0;
                while i < a_params.len() {
                    if !self.is_subtype(&b_params[i], &a_params[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                // Covariant in return type: a_ret <: b_ret
                return self.is_subtype(a_ret, b_ret);
            }

            // Pointers follow same variance as references
            (
                TypeKind::Ptr { inner: a_inner, mutable: false },
                TypeKind::Ptr { inner: b_inner, mutable: false },
            ) => {
                return self.is_subtype(a_inner, b_inner);
            }
            (
                TypeKind::Ptr { inner: a_inner, mutable: true },
                TypeKind::Ptr { inner: b_inner, mutable: true },
            ) => {
                return self.types_equal(a_inner, b_inner);
            }

            // Trait object subtyping
            (
                TypeKind::DynTrait { trait_id: a_trait, auto_traits: a_auto },
                TypeKind::DynTrait { trait_id: b_trait, auto_traits: b_auto },
            ) => {
                // Same primary trait required
                if !a_trait.eq(b_trait) {
                    return false;
                }
                // a must have all auto traits that b has (superset)
                for b_at in b_auto.iter() {
                    let mut found = false;
                    for a_at in a_auto.iter() {
                        if a_at.eq(b_at) {
                            found = true;
                            break;
                        }
                    };
                    if !found {
                        return false;
                    }
                };
                return true;
            }

            _ => {}
        }

        false
    }

    /// Check if primitive type a is a subtype of primitive type b.
    fn primitive_subtype(&self, _a: &PrimitiveTy, _b: &PrimitiveTy) -> bool {
        // For now, no implicit numeric conversions
        // i32 is not a subtype of i64, etc.
        false
    }

    /// Check if two types are structurally equal.
    pub fn types_equal(&self, a: &Type, b: &Type) -> bool {
        match (a.kind(), b.kind()) {
            (TypeKind::Primitive(pa), TypeKind::Primitive(pb)) => pa == pb,

            (TypeKind::Tuple(as_), TypeKind::Tuple(bs)) => {
                if as_.len() != bs.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < as_.len() {
                    if !self.types_equal(&as_[i], &bs[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            (
                TypeKind::Array { element: a_elem, size: a_len },
                TypeKind::Array { element: b_elem, size: b_len },
            ) => a_len == b_len && self.types_equal(a_elem, b_elem),

            (
                TypeKind::Slice { element: a_elem },
                TypeKind::Slice { element: b_elem },
            ) => self.types_equal(a_elem, b_elem),

            (
                TypeKind::Ref { inner: a_inner, mutable: a_mut },
                TypeKind::Ref { inner: b_inner, mutable: b_mut },
            ) => a_mut == b_mut && self.types_equal(a_inner, b_inner),

            (
                TypeKind::Ptr { inner: a_inner, mutable: a_mut },
                TypeKind::Ptr { inner: b_inner, mutable: b_mut },
            ) => a_mut == b_mut && self.types_equal(a_inner, b_inner),

            (
                TypeKind::Fn { params: a_params, ret: a_ret },
                TypeKind::Fn { params: b_params, ret: b_ret },
            ) => {
                if a_params.len() != b_params.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_params.len() {
                    if !self.types_equal(&a_params[i], &b_params[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                self.types_equal(a_ret, b_ret);
            }

            (
                TypeKind::Adt { def_id: a_def, args: a_args },
                TypeKind::Adt { def_id: b_def, args: b_args },
            ) => {
                if !a_def.eq(b_def) {
                    return false;
                };
                if a_args.len() != b_args.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_args.len() {
                    if !self.types_equal(&a_args[i], &b_args[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            (TypeKind::Infer(a_var), TypeKind::Infer(b_var)) => a_var.eq(b_var),
            (TypeKind::Param(a_var), TypeKind::Param(b_var)) => a_var.eq(b_var),
            (TypeKind::Never, TypeKind::Never) => true,
            (TypeKind::Error, TypeKind::Error) => true,

            (
                TypeKind::Closure { def_id: a_def, params: a_params, ret: a_ret },
                TypeKind::Closure { def_id: b_def, params: b_params, ret: b_ret },
            ) => {
                if !a_def.eq(b_def) {
                    return false;
                };
                if a_params.len() != b_params.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_params.len() {
                    if !self.types_equal(&a_params[i], &b_params[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                self.types_equal(a_ret, b_ret);
            }

            (
                TypeKind::Range { element: a_elem, inclusive: a_incl },
                TypeKind::Range { element: b_elem, inclusive: b_incl },
            ) => a_incl == b_incl && self.types_equal(a_elem, b_elem),

            (
                TypeKind::DynTrait { trait_id: a_trait, auto_traits: a_auto },
                TypeKind::DynTrait { trait_id: b_trait, auto_traits: b_auto },
            ) => {
                if !a_trait.eq(b_trait) {
                    return false;
                };
                if a_auto.len() != b_auto.len() {
                    return false;
                };
                // Check all a_auto are in b_auto (order independent)
                for a_at in a_auto.iter() {
                    let mut found = false;
                    for b_at in b_auto.iter() {
                        if a_at.eq(b_at) {
                            found = true;
                            break;
                        }
                    };
                    if !found {
                        return false;
                    }
                }
                true
            }

            _ => false,
        }
    }

    // ========================================================================
    // Specificity Comparison
    // ========================================================================

    /// Find the maximally specific methods from the applicable set.
    ///
    /// A method is maximal if no other method is strictly more specific.
    pub fn find_maximal(&self, applicable: &[MethodCandidate]) -> [MethodCandidate] {
        let mut maximal: [MethodCandidate] = vec![];

        let mut i: usize = 0;
        while i < applicable.len() {
            let m = &applicable[i];
            let mut is_maximal = true;

            // Check if any other method is more specific than this one
            let mut j: usize = 0;
            while j < applicable.len() {
                if i != j {
                    if self.is_more_specific(&applicable[j], m) {
                        is_maximal = false;
                        break;
                    }
                };
                j = j + 1;
            };

            if is_maximal {
                maximal.push(m.clone());
            };
            i = i + 1;
        }

        maximal
    }

    /// Check if method m1 is more specific than method m2.
    ///
    /// m1 is more specific than m2 if:
    /// - Every parameter of m1 is at least as specific as m2
    /// - At least one parameter of m1 is strictly more specific
    /// - OR if parameter types are equally specific, m1 has more restrictive effects
    pub fn is_more_specific(&self, m1: &MethodCandidate, m2: &MethodCandidate) -> bool {
        // Must have same arity
        if m1.param_types.len() != m2.param_types.len() {
            return false;
        };

        let mut all_at_least = true;
        let mut some_strictly = false;

        let mut i: usize = 0;
        while i < m1.param_types.len() {
            let p1 = &m1.param_types[i];
            let p2 = &m2.param_types[i];

            // p1 must be a subtype of p2 (at least as specific)
            if !self.is_subtype(p1, p2) {
                all_at_least = false;
                break;
            };

            // Check if p1 is strictly more specific (p1 <: p2 but not p2 <: p1)
            if self.is_subtype(p1, p2) && !self.is_subtype(p2, p1) {
                some_strictly = true;
            };

            i = i + 1;
        };

        // If parameter types make m1 strictly more specific, we're done
        if all_at_least && some_strictly {
            return true;
        };

        // If parameter types are at least as specific but not strictly more specific,
        // use effect specificity as a tiebreaker
        if all_at_least && !some_strictly {
            let effect_cmp = self.effect_specificity(&m1.effects, &m2.effects);
            if effect_cmp.is_less() {
                // m1 has more restrictive effects - use as tiebreaker
                return true;
            }
        }

        false
    }

    /// Compare effect specificity between two methods.
    ///
    /// Returns:
    /// - `Ordering::Less` if m1's effects are more specific (more restrictive)
    /// - `Ordering::Greater` if m2's effects are more specific
    /// - `Ordering::Equal` if they have equally specific effects
    pub fn effect_specificity(
        &self,
        m1_effects: &Option<EffectRow>,
        m2_effects: &Option<EffectRow>,
    ) -> Ordering {
        match (m1_effects, m2_effects) {
            // Both None (pure) - equal specificity
            (None, None) => Ordering::Equal,

            // None (pure) is more specific than Some (effectful)
            (None, Some(_)) => Ordering::Less,
            (Some(_), None) => Ordering::Greater,

            // Both have effects - compare the rows
            (Some(row1), Some(row2)) => {
                let dispatch_row1 = DispatchEffectRow::from_row(row1.clone());
                let dispatch_row2 = DispatchEffectRow::from_row(row2.clone());
                dispatch_row1.compare_specificity(&dispatch_row2);
            }
        }
    }

    /// Compare the specificity of two methods.
    ///
    /// Returns:
    /// - `Ordering::Less` if m1 is more specific
    /// - `Ordering::Greater` if m2 is more specific
    /// - `Ordering::Equal` if they are equally specific (potential ambiguity)
    pub fn compare_specificity(
        &self,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> Ordering {
        let m1_more = self.is_more_specific(m1, m2);
        let m2_more = self.is_more_specific(m2, m1);

        match (m1_more, m2_more) {
            (true, false) => Ordering::Less,
            (false, true) => Ordering::Greater,
            (true, true) => Ordering::Equal,   // Both more specific than each other (shouldn't happen)
            (false, false) => Ordering::Equal, // Neither more specific (ambiguity)
        }
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Compare type parameter specificity.
///
/// Returns ordering based on:
/// 1. Concrete types are more specific than type parameters
/// 2. More constraints = more specific
/// 3. Instantiated generic is more specific than open generic
pub fn compare_type_param_specificity(t1: &Type, t2: &Type) -> Ordering {
    let t1_concrete = match t1.kind() {
        TypeKind::Infer(_) => false,
        TypeKind::Param(_) => false,
        _ => true,
    };
    let t2_concrete = match t2.kind() {
        TypeKind::Infer(_) => false,
        TypeKind::Param(_) => false,
        _ => true,
    };

    match (t1_concrete, t2_concrete) {
        (true, false) => Ordering::Less,   // Concrete more specific
        (false, true) => Ordering::Greater,
        (true, true) => Ordering::Equal,
        (false, false) => Ordering::Equal,
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn make_candidate(def_id: u32, name: &str, param_types: [Type]) -> MethodCandidate {
        MethodCandidate::new(
            DefId::new(def_id),
            name.to_string(),
            param_types,
            Type::unit(),
        )
    }

    #[test]
    fn test_resolve_no_candidates() {
        let resolver = DispatchResolver::new();
        let result = resolver.resolve("foo", &[Type::i32()], &[]);

        assert!(result.is_no_match());
    }

    #[test]
    fn test_resolve_single_match() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::i32()]);

        let result = resolver.resolve("foo", &[Type::i32()], &[candidate]);

        assert!(result.is_resolved());
    }

    #[test]
    fn test_resolve_no_applicable() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::bool()]);

        let result = resolver.resolve("foo", &[Type::i32()], &[candidate]);

        assert!(result.is_no_match());
    }

    #[test]
    fn test_is_applicable_arity_mismatch() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::i32(), Type::bool()]);

        assert!(!resolver.is_applicable(&candidate, &[Type::i32()]));
    }

    #[test]
    fn test_is_applicable_type_match() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::i32()]);

        assert!(resolver.is_applicable(&candidate, &[Type::i32()]));
    }

    #[test]
    fn test_is_applicable_type_mismatch() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::i32()]);

        assert!(!resolver.is_applicable(&candidate, &[Type::bool()]));
    }

    #[test]
    fn test_types_equal() {
        let resolver = DispatchResolver::new();

        assert!(resolver.types_equal(&Type::i32(), &Type::i32()));
        assert!(resolver.types_equal(&Type::bool(), &Type::bool()));
        assert!(!resolver.types_equal(&Type::i32(), &Type::bool()));
    }

    #[test]
    fn test_is_subtype_reflexive() {
        let resolver = DispatchResolver::new();

        assert!(resolver.is_subtype(&Type::i32(), &Type::i32()));
        assert!(resolver.is_subtype(&Type::bool(), &Type::bool()));
    }

    #[test]
    fn test_is_subtype_never() {
        let resolver = DispatchResolver::new();

        // never is subtype of everything
        assert!(resolver.is_subtype(&Type::never(), &Type::i32()));
        assert!(resolver.is_subtype(&Type::never(), &Type::bool()));

        // nothing is subtype of never (except never itself);
        assert!(!resolver.is_subtype(&Type::i32(), &Type::never()));
    }

    #[test]
    fn test_more_specific_same_types() {
        let resolver = DispatchResolver::new();
        let m1 = make_candidate(1, "foo", vec![Type::i32()]);
        let m2 = make_candidate(2, "foo", vec![Type::i32()]);

        // Same parameter types - neither is more specific
        assert!(!resolver.is_more_specific(&m1, &m2));
        assert!(!resolver.is_more_specific(&m2, &m1));
    }

    #[test]
    fn test_find_maximal_single() {
        let resolver = DispatchResolver::new();
        let candidate = make_candidate(1, "foo", vec![Type::i32()]);

        let maximal = resolver.find_maximal(&[candidate.clone()]);

        assert_eq!(maximal.len(), 1);
    }

    #[test]
    fn test_find_maximal_ambiguous() {
        let resolver = DispatchResolver::new();
        let m1 = make_candidate(1, "foo", vec![Type::i32()]);
        let m2 = make_candidate(2, "foo", vec![Type::i32()]);

        let maximal = resolver.find_maximal(&[m1, m2]);

        // Both are maximal (neither more specific than the other);
        assert_eq!(maximal.len(), 2);
    }

    #[test]
    fn test_effect_specificity_pure_vs_effectful() {
        let resolver = DispatchResolver::new();

        // None (pure) is more specific than Some (effectful);
        let pure_effects: Option<EffectRow> = None;
        let effectful = Some(EffectRow::pure());

        let cmp = resolver.effect_specificity(&pure_effects, &effectful);
        assert!(cmp.is_less()); // pure is more specific
    }

    #[test]
    fn test_compare_type_param_specificity() {
        // Concrete is more specific than param
        let concrete = Type::i32();
        let param = Type::param(TyVarId::new(0));

        let cmp = compare_type_param_specificity(&concrete, &param);
        assert!(cmp.is_less()); // concrete is more specific
    }
}
