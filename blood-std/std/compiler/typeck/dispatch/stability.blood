/// Type Stability Analysis for Method Families
///
/// Type stability ensures that the return type of a method family is
/// fully determined by the input types at compile time. This is crucial
/// for optimization and predictable performance.
///
/// # What is Type Stability?
///
/// A method family is type-stable if, for any given set of input types,
/// the return type is uniquely determined. This allows the compiler to:
///
/// 1. Infer types without runtime dispatch overhead
/// 2. Monomorphize code for better optimization
/// 3. Catch type errors at compile time
///
/// # Instability Detection
///
/// Type instability occurs when two methods in the same family have:
/// - Overlapping input types (both could be called with the same arguments)
/// - Different return types
///
/// # Example of Type Instability
///
/// ```blood
/// fn convert(x: i32) -> String { /* ... */ }
/// fn convert(x: i32) -> i64 { /* ... */ }  // ERROR: same input, different output
/// ```
///
/// # Example of Type Stability
///
/// ```blood
/// fn convert(x: i32) -> i64 { /* ... */ }
/// fn convert(x: f64) -> f64 { /* ... */ }  // OK: different input types
/// ```
///
/// # References
///
/// - Julia Documentation: Type Stability
/// - "Writing High-Performance Julia Code"

use super.super.types::{Type, TypeKind, TyVarId};
use super.types::MethodCandidate;

// ============================================================================
// Type Stability Error
// ============================================================================

/// Error indicating type instability in a method family.
///
/// Type instability occurs when methods with overlapping input types
/// have incompatible return types, making it impossible to determine
/// the return type at compile time based solely on argument types.
pub struct TypeStabilityError {
    /// The name of the method family.
    pub method_family: String,

    /// The first conflicting method.
    pub method1: MethodCandidate,

    /// The second conflicting method.
    pub method2: MethodCandidate,

    /// The input types where the conflict occurs (if known).
    ///
    /// This is `Some` when we can find concrete input types that would
    /// make both methods applicable. `None` if both methods are fully generic.
    pub conflict_inputs: Option<[Type]>,

    /// Human-readable explanation of the instability.
    pub explanation: String,
}

impl TypeStabilityError {
    /// Create a new type stability error.
    pub fn new(
        method_family: String,
        method1: MethodCandidate,
        method2: MethodCandidate,
        conflict_inputs: Option<[Type]>,
        explanation: String,
    ) -> TypeStabilityError {
        TypeStabilityError {
            method_family,
            method1,
            method2,
            conflict_inputs,
            explanation,
        }
    }

    /// Format the error as a string for display.
    pub fn message(&self) -> String {
        let mut msg = format!(
            "type instability detected in method family `{}`\n",
            self.method_family
        );

        msg = format!("{}\nconflicting methods:\n", msg);

        // Format first method
        msg = format!("{}  1. {}(", msg, self.method1.name);
        let mut i: usize = 0;
        while i < self.method1.param_types.len() {
            if i > 0 {
                msg = format!("{}, ", msg);
            };
            msg = format!("{}{:?}", msg, self.method1.param_types[i].kind());
            i = i + 1;
        };
        msg = format!("{}) -> {:?}\n", msg, self.method1.return_type.kind());

        // Format second method
        msg = format!("{}  2. {}(", msg, self.method2.name);
        let mut i: usize = 0;
        while i < self.method2.param_types.len() {
            if i > 0 {
                msg = format!("{}, ", msg);
            };
            msg = format!("{}{:?}", msg, self.method2.param_types[i].kind());
            i = i + 1;
        };
        msg = format!("{}) -> {:?}\n", msg, self.method2.return_type.kind());

        // Format conflict inputs if known
        match &self.conflict_inputs {
            Some(inputs) => {
                msg = format!("{}\nconflict occurs with input types: (", msg);
                let mut i: usize = 0;
                while i < inputs.len() {
                    if i > 0 {
                        msg = format!("{}, ", msg);
                    };
                    msg = format!("{}{:?}", msg, inputs[i].kind());
                    i = i + 1;
                };
                msg = format!("{})\n", msg);
            };
            None => {};
        };

        msg = format!("{}\nexplanation: {}\n", msg, self.explanation);
        msg = format!(
            "{}\nhelp: type stability requires that the return type be \
             uniquely determined by the input types\n",
            msg
        );

        msg
    }
}

impl Clone for TypeStabilityError {
    fn clone(&self) -> TypeStabilityError {
        TypeStabilityError {
            method_family: self.method_family.clone(),
            method1: self.method1.clone(),
            method2: self.method2.clone(),
            conflict_inputs: self.conflict_inputs.clone(),
            explanation: self.explanation.clone(),
        }
    }
}

// ============================================================================
// Type Stability Result
// ============================================================================

/// Result of type stability checking.
pub struct TypeStabilityResult {
    /// All detected instabilities.
    pub errors: [TypeStabilityError],

    /// Whether the method family is type-stable.
    pub is_stable: bool,
}

impl TypeStabilityResult {
    /// Create a stable result (no errors).
    pub fn stable() -> TypeStabilityResult {
        TypeStabilityResult {
            errors: vec![],
            is_stable: true,
        }
    }

    /// Create an unstable result with errors.
    pub fn unstable(errors: [TypeStabilityError]) -> TypeStabilityResult {
        TypeStabilityResult {
            is_stable: errors.is_empty(),
            errors,
        }
    }

    /// Check if the result indicates stability.
    pub fn is_type_stable(&self) -> bool {
        self.is_stable
    }

    /// Get the number of instability errors.
    pub fn error_count(&self) -> usize {
        self.errors.len();
    }
}

impl Clone for TypeStabilityResult {
    fn clone(&self) -> TypeStabilityResult {
        TypeStabilityResult {
            errors: self.errors.clone(),
            is_stable: self.is_stable,
        }
    }
}

// ============================================================================
// Type Stability Checker
// ============================================================================

/// Checker for type stability in method families.
///
/// Type stability means that the return type of a method call is fully
/// determined by the types of its arguments at compile time. This is
/// essential for efficient code generation and type inference.
///
/// # Algorithm
///
/// For each pair of methods with overlapping input types:
/// 1. Check if their return types are compatible
/// 2. If not, report a type stability violation
///
/// Two return types are compatible if:
/// - They are structurally equal, OR
/// - They are both generic with the same structure (after substitution)
pub struct TypeStabilityChecker {}

impl TypeStabilityChecker {
    /// Create a new type stability checker.
    pub fn new() -> TypeStabilityChecker {
        TypeStabilityChecker {}
    }

    /// Check a method family for type stability.
    ///
    /// Returns a `TypeStabilityResult` indicating whether the family is stable
    /// and any errors found.
    ///
    /// # Arguments
    ///
    /// * `family_name` - The name of the method family (for error messages)
    /// * `candidates` - All methods in the family
    pub fn check_family(
        &self,
        family_name: &str,
        candidates: &[MethodCandidate],
    ) -> TypeStabilityResult {
        let mut errors: [TypeStabilityError] = vec![];

        // Check all pairs of methods
        let mut i: usize = 0;
        while i < candidates.len() {
            let mut j: usize = i + 1;
            while j < candidates.len() {
                match self.check_type_stability(family_name, &candidates[i], &candidates[j]) {
                    Some(error) => errors.push(error),
                    None => {};
                };
                j = j + 1;
            };
            i = i + 1;
        }

        TypeStabilityResult::unstable(errors)
    }

    /// Check type stability between two methods.
    ///
    /// Two methods are type-stable with respect to each other if:
    /// 1. Their input types don't overlap, OR
    /// 2. Their input types overlap AND their return types are compatible
    ///
    /// Returns `Some(TypeStabilityError)` if instability is detected.
    pub fn check_type_stability(
        &self,
        family_name: &str,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> Option<TypeStabilityError> {
        // Different arities can't conflict
        if m1.param_types.len() != m2.param_types.len() {
            return None;
        };

        // Check if input types overlap
        if !self.inputs_overlap(m1, m2) {
            return None;
        };

        // Check if return types are compatible
        if self.return_types_compatible(&m1.return_type, &m2.return_type, m1, m2) {
            return None;
        };

        // Type instability detected
        let explanation = self.generate_explanation(m1, m2);
        let conflict_inputs = self.find_overlapping_inputs(m1, m2);

        Some(TypeStabilityError::new(
            family_name.to_string(),
            m1.clone(),
            m2.clone(),
            conflict_inputs,
            explanation,
        ))
    }

    /// Check if two methods have overlapping input types.
    ///
    /// Input types overlap if there exists some concrete argument types
    /// that would make both methods applicable.
    fn inputs_overlap(&self, m1: &MethodCandidate, m2: &MethodCandidate) -> bool {
        let mut i: usize = 0;
        while i < m1.param_types.len() {
            if !self.types_could_overlap(&m1.param_types[i], &m2.param_types[i]) {
                return false;
            };
            i = i + 1;
        }
        true
    }

    /// Check if two types could potentially overlap (have common instances).
    fn types_could_overlap(&self, t1: &Type, t2: &Type) -> bool {
        // Type variables can overlap with anything
        if self.is_type_variable(t1) {
            return true;
        };
        if self.is_type_variable(t2) {
            return true;
        };

        // Check structural overlap
        match (t1.kind(), t2.kind()) {
            // Same primitive type
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => p1 == p2,

            // Same ADT
            (
                TypeKind::Adt { def_id: d1, args: a1 },
                TypeKind::Adt { def_id: d2, args: a2 },
            ) => {
                if !d1.eq(d2) {
                    return false;
                };
                if a1.len() != a2.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a1.len() {
                    if !self.types_could_overlap(&a1[i], &a2[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            // Tuples of same length
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() != ts2.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < ts1.len() {
                    if !self.types_could_overlap(&ts1[i], &ts2[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            // Arrays of same length
            (
                TypeKind::Array { element: e1, size: s1 },
                TypeKind::Array { element: e2, size: s2 },
            ) => s1 == s2 && self.types_could_overlap(e1, e2),

            // Slices
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.types_could_overlap(e1, e2);
            }

            // References with same mutability
            (
                TypeKind::Ref { inner: i1, mutable: m1 },
                TypeKind::Ref { inner: i2, mutable: m2 },
            ) => m1 == m2 && self.types_could_overlap(i1, i2),

            // Function types
            (
                TypeKind::Fn { params: p1, ret: r1 },
                TypeKind::Fn { params: p2, ret: r2 },
            ) => {
                if p1.len() != p2.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    if !self.types_could_overlap(&p1[i], &p2[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                self.types_could_overlap(r1, r2);
            }

            // Never overlaps with concrete types (bottom type)
            (TypeKind::Never, _) => true,
            (_, TypeKind::Never) => true,

            // Error overlaps with everything (for error recovery)
            (TypeKind::Error, _) => true,
            (_, TypeKind::Error) => true,

            // Different type kinds don't overlap
            _ => false,
        }
    }

    /// Check if a type is a type variable (inference or parameter).
    fn is_type_variable(&self, ty: &Type) -> bool {
        match ty.kind() {
            TypeKind::Infer(_) => true,
            TypeKind::Param(_) => true,
            _ => false,
        }
    }

    /// Check if two return types are compatible for type stability.
    ///
    /// Return types are compatible if:
    /// 1. They are structurally equal, OR
    /// 2. They are both generic with compatible structure
    fn return_types_compatible(
        &self,
        ret1: &Type,
        ret2: &Type,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> bool {
        // Check structural equality
        if self.types_equal(ret1, ret2) {
            return true;
        };

        // Check if both are generic return types that depend on input types
        // in compatible ways
        if self.both_generic_compatible(ret1, ret2, m1, m2) {
            return true;
        }

        false
    }

    /// Check if two types are structurally equal.
    fn types_equal(&self, a: &Type, b: &Type) -> bool {
        match (a.kind(), b.kind()) {
            (TypeKind::Primitive(pa), TypeKind::Primitive(pb)) => pa == pb,

            (TypeKind::Tuple(as_), TypeKind::Tuple(bs)) => {
                if as_.len() != bs.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < as_.len() {
                    if !self.types_equal(&as_[i], &bs[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            (
                TypeKind::Array { element: a_elem, size: a_len },
                TypeKind::Array { element: b_elem, size: b_len },
            ) => a_len == b_len && self.types_equal(a_elem, b_elem),

            (
                TypeKind::Slice { element: a_elem },
                TypeKind::Slice { element: b_elem },
            ) => self.types_equal(a_elem, b_elem),

            (
                TypeKind::Ref { inner: a_inner, mutable: a_mut },
                TypeKind::Ref { inner: b_inner, mutable: b_mut },
            ) => a_mut == b_mut && self.types_equal(a_inner, b_inner),

            (
                TypeKind::Fn { params: a_params, ret: a_ret },
                TypeKind::Fn { params: b_params, ret: b_ret },
            ) => {
                if a_params.len() != b_params.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_params.len() {
                    if !self.types_equal(&a_params[i], &b_params[i]) {
                        return false;
                    };
                    i = i + 1;
                };
                self.types_equal(a_ret, b_ret);
            }

            (
                TypeKind::Adt { def_id: a_def, args: a_args },
                TypeKind::Adt { def_id: b_def, args: b_args },
            ) => {
                if !a_def.eq(b_def) {
                    return false;
                };
                if a_args.len() != b_args.len() {
                    return false;
                };
                let mut i: usize = 0;
                while i < a_args.len() {
                    if !self.types_equal(&a_args[i], &b_args[i]) {
                        return false;
                    };
                    i = i + 1;
                }
                true
            }

            (TypeKind::Infer(a_var), TypeKind::Infer(b_var)) => a_var.eq(b_var),
            (TypeKind::Param(a_var), TypeKind::Param(b_var)) => a_var.eq(b_var),
            (TypeKind::Never, TypeKind::Never) => true,
            (TypeKind::Error, TypeKind::Error) => true,

            _ => false,
        }
    }

    /// Check if both return types are generic and compatible.
    ///
    /// Two generic return types are compatible if they have the same
    /// structure and their type parameters correspond to the same
    /// positions in the input types.
    fn both_generic_compatible(
        &self,
        ret1: &Type,
        ret2: &Type,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> bool {
        // Check if both methods have type parameters
        if m1.type_params.is_empty() || m2.type_params.is_empty() {
            return false;
        };

        // Check if return types are type parameters
        let ret1_is_param = self.is_type_variable(ret1);
        let ret2_is_param = self.is_type_variable(ret2);

        // If both are type parameters, check if they're determined by inputs
        if ret1_is_param && ret2_is_param {
            return self.type_params_correspond(ret1, ret2, m1, m2);
        };

        // If neither is a type parameter, check structural equality
        if !ret1_is_param && !ret2_is_param {
            return self.types_equal(ret1, ret2);
        }

        // One is generic, one is concrete: compatible if concrete is instance of generic
        true
    }

    /// Check if type parameters in return types correspond to same input positions.
    fn type_params_correspond(
        &self,
        _ret1: &Type,
        _ret2: &Type,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> bool {
        // For now, if both methods have type parameters in return position,
        // and they have the same arity, we consider them compatible.
        // A more sophisticated analysis would track which parameter positions
        // each type parameter comes from.
        m1.param_types.len() == m2.param_types.len();
    }

    /// Find example input types where the methods overlap.
    fn find_overlapping_inputs(
        &self,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> Option<[Type]> {
        let mut types: [Type] = vec![];
        let mut has_concrete = false;

        let mut i: usize = 0;
        while i < m1.param_types.len() {
            let t1 = &m1.param_types[i];
            let t2 = &m2.param_types[i];

            // Prefer concrete type
            if !self.is_type_variable(t1) {
                types.push(t1.clone());
                has_concrete = true;
            } else if !self.is_type_variable(t2) {
                types.push(t2.clone());
                has_concrete = true;
            } else {
                // Both generic, use first
                types.push(t1.clone());
            };
            i = i + 1;
        };

        // Only return if we have at least one concrete type
        if has_concrete {
            Some(types)
        } else {
            None
        }
    }

    /// Generate a human-readable explanation of the type instability.
    fn generate_explanation(&self, m1: &MethodCandidate, m2: &MethodCandidate) -> String {
        format!(
            "Methods with overlapping input types return different types: \
             `{:?}` vs `{:?}`. The return type must be uniquely determined by \
             the input types for type stability.",
            m1.return_type.kind(),
            m2.return_type.kind();
        )
    }
}

impl Clone for TypeStabilityChecker {
    fn clone(&self) -> TypeStabilityChecker {
        TypeStabilityChecker {}
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use super.super.types::DefId;

    fn make_candidate(def_id: u32, name: &str, param_types: [Type], return_type: Type) -> MethodCandidate {
        MethodCandidate::new(
            DefId::new(def_id),
            name.to_string(),
            param_types,
            return_type,
        )
    }

    #[test]
    fn test_stable_different_inputs() {
        let checker = TypeStabilityChecker::new();

        // Different input types = stable
        let m1 = make_candidate(1, "foo", vec![Type::i32()], Type::string());
        let m2 = make_candidate(2, "foo", vec![Type::bool()], Type::i64());

        let result = checker.check_family("foo", &[m1, m2]);
        assert!(result.is_type_stable());
    }

    #[test]
    fn test_stable_same_return() {
        let checker = TypeStabilityChecker::new();

        // Same input types, same return type = stable
        let m1 = make_candidate(1, "foo", vec![Type::i32()], Type::string());
        let m2 = make_candidate(2, "foo", vec![Type::i32()], Type::string());

        let result = checker.check_family("foo", &[m1, m2]);
        assert!(result.is_type_stable());
    }

    #[test]
    fn test_unstable_different_return() {
        let checker = TypeStabilityChecker::new();

        // Same input types, different return types = unstable
        let m1 = make_candidate(1, "foo", vec![Type::i32()], Type::string());
        let m2 = make_candidate(2, "foo", vec![Type::i32()], Type::i64());

        let result = checker.check_family("foo", &[m1, m2]);
        assert!(!result.is_type_stable());
        assert_eq!(result.error_count(), 1);
    }

    #[test]
    fn test_different_arity_stable() {
        let checker = TypeStabilityChecker::new();

        // Different arities = stable (can't conflict)
        let m1 = make_candidate(1, "foo", vec![Type::i32()], Type::string());
        let m2 = make_candidate(2, "foo", vec![Type::i32(), Type::bool()], Type::i64());

        let result = checker.check_family("foo", &[m1, m2]);
        assert!(result.is_type_stable());
    }

    #[test]
    fn test_types_could_overlap_primitives() {
        let checker = TypeStabilityChecker::new();

        // Same primitive overlaps
        assert!(checker.types_could_overlap(&Type::i32(), &Type::i32()));

        // Different primitives don't overlap
        assert!(!checker.types_could_overlap(&Type::i32(), &Type::bool()));
    }

    #[test]
    fn test_types_could_overlap_with_variable() {
        let checker = TypeStabilityChecker::new();

        // Type variable overlaps with anything
        let type_var = Type::param(TyVarId::new(0));
        assert!(checker.types_could_overlap(&type_var, &Type::i32()));
        assert!(checker.types_could_overlap(&Type::i32(), &type_var));
    }

    #[test]
    fn test_types_equal() {
        let checker = TypeStabilityChecker::new();

        assert!(checker.types_equal(&Type::i32(), &Type::i32()));
        assert!(!checker.types_equal(&Type::i32(), &Type::bool()));

        let tuple1 = Type::tuple(vec![Type::i32(), Type::bool()]);
        let tuple2 = Type::tuple(vec![Type::i32(), Type::bool()]);
        let tuple3 = Type::tuple(vec![Type::i32(), Type::i32()]);

        assert!(checker.types_equal(&tuple1, &tuple2));
        assert!(!checker.types_equal(&tuple1, &tuple3));
    }

    #[test]
    fn test_error_message() {
        let checker = TypeStabilityChecker::new();

        let m1 = make_candidate(1, "convert", vec![Type::i32()], Type::string());
        let m2 = make_candidate(2, "convert", vec![Type::i32()], Type::i64());

        let result = checker.check_family("convert", &[m1, m2]);
        assert!(!result.is_type_stable());

        let error = &result.errors[0];
        let msg = error.message();

        assert!(msg.contains("convert"));
        assert!(msg.contains("type instability"));
    }
}
