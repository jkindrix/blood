/// Compile-time constant evaluation.
///
/// This module implements constant evaluation for expressions that must
/// be known at compile time, such as array sizes.
///
/// # Supported Expressions
///
/// - Integer and boolean literals
/// - Simple binary operations (+, -, *, /, %, comparisons)
/// - Unary operations (-, !)
/// - Parenthesized expressions
/// - Block expressions (with final expression, no statements)
/// - If expressions (condition must be const)
///
/// # Future Work
///
/// - Const items and const functions
/// - More complex const generics

use std.option.Option;
use std.result.Result;
use std.compiler.ast.expr::{Expr, ExprKind, BinOp, UnaryOp, ElseBranch};
use std.compiler.ast.lit::{Literal, LiteralKind, IntSuffix};
use std.compiler.ast.stmt::Block;
use std.compiler.parser::Span;
use super.errors::{TypeError, TypeErrorKind};

// ============================================================
// Const Result
// ============================================================

/// Result of const evaluation - a compile-time known value.
pub enum ConstResult {
    /// A signed integer value.
    Int(i128),
    /// An unsigned integer value.
    Uint(u128),
    /// A boolean value.
    Bool(bool),
}

impl ConstResult {
    /// Try to get as u64 for array sizes.
    pub fn as_u64(&self) -> Option<u64> {
        match self {
            ConstResult::Int(v) => {
                if *v >= 0 && *v <= 18446744073709551615i128 {
                    Option::Some(*v as u64)
                } else {
                    Option::None
                }
            }
            ConstResult::Uint(v) => {
                if *v <= 18446744073709551615u128 {
                    Option::Some(*v as u64)
                } else {
                    Option::None
                }
            }
            ConstResult::Bool(_) => Option::None,
        }
    }

    /// Get the signed integer value.
    pub fn as_i128(&self) -> Option<i128> {
        match self {
            ConstResult::Int(v) => Option::Some(*v),
            ConstResult::Uint(v) => {
                // Check if value fits in i128 (max i128 = 2^127 - 1)
                if *v <= 170141183460469231731687303715884105727u128 {
                    Option::Some(*v as i128)
                } else {
                    Option::None
                }
            }
            ConstResult::Bool(_) => Option::None,
        }
    }

    /// Get the boolean value.
    pub fn as_bool(&self) -> Option<bool> {
        match self {
            ConstResult::Bool(b) => Option::Some(*b),
            ConstResult::Int(_) => Option::None,
            ConstResult::Uint(_) => Option::None,
        }
    }
}

impl Clone for ConstResult {
    fn clone(&self) -> ConstResult {
        match self {
            ConstResult::Int(v) => ConstResult::Int(*v),
            ConstResult::Uint(v) => ConstResult::Uint(*v),
            ConstResult::Bool(b) => ConstResult::Bool(*b),
        }
    }
}

// ============================================================
// Const Evaluation Entry Point
// ============================================================

/// Evaluate an AST expression as a compile-time constant.
///
/// Returns `Ok(value)` if the expression can be evaluated at compile time,
/// or an error if it cannot.
pub fn eval_const_expr(expr: &Expr) -> Result<ConstResult, TypeError> {
    match &expr.kind {
        ExprKind::Literal(lit) => eval_literal(lit, expr.span),

        ExprKind::Binary { left, bin_op, right } => {
            let left_val = eval_const_expr(left)?;
            let right_val = eval_const_expr(right)?;
            eval_binary_op(*bin_op, left_val, right_val, expr.span)
        }

        ExprKind::Unary { op: unary_op, operand } => {
            let val = eval_const_expr(operand)?;
            eval_unary_op(*unary_op, val, expr.span)
        }

        ExprKind::Paren(inner) => eval_const_expr(inner),

        ExprKind::If { condition, then_branch, else_branch } => {
            let cond = eval_const_expr(condition)?;
            match cond {
                ConstResult::Bool(true) => eval_block(then_branch),
                ConstResult::Bool(false) => {
                    match else_branch {
                        Option::Some(else_expr) => eval_else_branch(else_expr),
                        Option::None => {
                            Result::Err(TypeError::new(
                                TypeErrorKind::ConstEvalError {
                                    reason: "if expression without else branch in const context".to_string(),
                                },
                                expr.span,
                            ))
                        }
                    }
                }
                ConstResult::Int(_) => {
                    Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "condition must be a boolean".to_string(),
                        },
                        condition.span,
                    ))
                }
                ConstResult::Uint(_) => {
                    Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "condition must be a boolean".to_string(),
                        },
                        condition.span,
                    ))
                }
            }
        }

        ExprKind::Block(block) => eval_block(block),

        ExprKind::Path(_) => {
            // TODO: Support const items and variables
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "variable references are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Call { .. } => {
            // TODO: Support const functions
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "function calls are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::MethodCall { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "method calls are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Field { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "field access is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Index { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "indexing is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Tuple(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "tuple literals are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Array(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "array literals are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Record { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "struct literals are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Range { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "range expressions are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Cast { .. } => {
            // TODO: Support const casts
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "casts are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Assign { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "assignments are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::AssignOp { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "compound assignments are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::IfLet { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "if-let is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Match { .. } => {
            // TODO: Could potentially support match on const values
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "match expressions are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Loop { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "loops are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::While { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "while loops are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::WhileLet { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "while-let loops are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::For { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "for loops are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Return(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "return is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Break { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "break is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Continue { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "continue is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Closure { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "closures are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::WithHandle { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "effect handlers are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Perform { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "effect operations are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Resume(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "resume is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::TryWith { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "try-with is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Unsafe(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "unsafe blocks are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Region { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "regions are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Default => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "default is not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::MacroCall { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "macro calls are not supported in const contexts".to_string(),
                },
                expr.span,
            ))
        }

        ExprKind::Error => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "cannot evaluate error expression".to_string(),
                },
                expr.span,
            ))
        }
    }
}

// ============================================================
// Block Evaluation
// ============================================================

/// Evaluate a block expression.
fn eval_block(block: &Block) -> Result<ConstResult, TypeError> {
    if block.statements.is_empty() {
        match &block.expr {
            Option::Some(final_expr) => eval_const_expr(final_expr),
            Option::None => {
                Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "empty block in const context".to_string(),
                    },
                    block.span,
                ))
            }
        }
    } else {
        Result::Err(TypeError::new(
            TypeErrorKind::ConstEvalError {
                reason: "const expressions cannot contain statements".to_string(),
            },
            block.span,
        ))
    }
}

/// Evaluate an else branch.
fn eval_else_branch(branch: &ElseBranch) -> Result<ConstResult, TypeError> {
    match branch {
        ElseBranch::Block(block) => eval_block(block),
        ElseBranch::If(if_expr) => eval_const_expr(if_expr),
    }
}

// ============================================================
// Literal Evaluation
// ============================================================

/// Evaluate a literal.
fn eval_literal(lit: &Literal, span: Span) -> Result<ConstResult, TypeError> {
    match &lit.kind {
        LiteralKind::Int { value, suffix } => {
            // Determine if unsigned based on suffix
            let is_unsigned = match suffix {
                Option::Some(IntSuffix::U8) => true,
                Option::Some(IntSuffix::U16) => true,
                Option::Some(IntSuffix::U32) => true,
                Option::Some(IntSuffix::U64) => true,
                Option::Some(IntSuffix::U128) => true,
                Option::Some(IntSuffix::USize) => true,
                _ => false,
            };

            if is_unsigned {
                Result::Ok(ConstResult::Uint(*value as u128))
            } else {
                Result::Ok(ConstResult::Int(*value as i128))
            }
        }
        LiteralKind::Bool(b) => Result::Ok(ConstResult::Bool(*b)),
        LiteralKind::Float { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "floating-point literals are not supported in const contexts".to_string(),
                },
                span,
            ))
        }
        LiteralKind::String { .. } => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "string literals are not supported in const contexts".to_string(),
                },
                span,
            ))
        }
        LiteralKind::Char(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "character literals are not supported in const contexts".to_string(),
                },
                span,
            ))
        }
        LiteralKind::Byte(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "byte literals are not supported in const contexts".to_string(),
                },
                span,
            ))
        }
        LiteralKind::ByteString(_) => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "byte string literals are not supported in const contexts".to_string(),
                },
                span,
            ))
        }
    }
}

// ============================================================
// Binary Operation Evaluation
// ============================================================

/// Evaluate a binary operation.
fn eval_binary_op(
    bin_op: BinOp,
    left: ConstResult,
    right: ConstResult,
    span: Span,
) -> Result<ConstResult, TypeError> {
    // For logical operators, handle separately since they work on bools
    match bin_op {
        BinOp::And => {
            return eval_logical_and(left, right, span);
        }
        BinOp::Or => {
            return eval_logical_or(left, right, span);
        }
        _ => {};
    };

    // Convert both to i128 for arithmetic/comparison operations
    let l = match left.as_i128() {
        Option::Some(v) => v,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "cannot perform operation on these values".to_string(),
                },
                span,
            ));
        }
    };

    let r = match right.as_i128() {
        Option::Some(v) => v,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "cannot perform operation on these values".to_string(),
                },
                span,
            ));
        }
    };

    match bin_op {
        BinOp::Add => {
            match checked_add_i128(l, r) {
                Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                Option::None => Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "arithmetic overflow in const expression".to_string(),
                    },
                    span,
                )),
            }
        }
        BinOp::Sub => {
            match checked_sub_i128(l, r) {
                Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                Option::None => Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "arithmetic overflow in const expression".to_string(),
                    },
                    span,
                )),
            }
        }
        BinOp::Mul => {
            match checked_mul_i128(l, r) {
                Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                Option::None => Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "arithmetic overflow in const expression".to_string(),
                    },
                    span,
                )),
            }
        }
        BinOp::Div => {
            if r == 0 {
                Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "division by zero in const expression".to_string(),
                    },
                    span,
                ))
            } else {
                match checked_div_i128(l, r) {
                    Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                    Option::None => Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "arithmetic overflow in const expression".to_string(),
                        },
                        span,
                    )),
                }
            }
        }
        BinOp::Rem => {
            if r == 0 {
                Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "remainder by zero in const expression".to_string(),
                    },
                    span,
                ))
            } else {
                match checked_rem_i128(l, r) {
                    Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                    Option::None => Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "arithmetic overflow in const expression".to_string(),
                        },
                        span,
                    )),
                }
            }
        }
        BinOp::BitAnd => Result::Ok(ConstResult::Int(l & r)),
        BinOp::BitOr => Result::Ok(ConstResult::Int(l | r)),
        BinOp::BitXor => Result::Ok(ConstResult::Int(l ^ r)),
        BinOp::Shl => {
            if r < 0 || r > 127 {
                Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "shift amount out of range".to_string(),
                    },
                    span,
                ))
            } else {
                match checked_shl_i128(l, r as u32) {
                    Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                    Option::None => Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "shift overflow in const expression".to_string(),
                        },
                        span,
                    )),
                }
            }
        }
        BinOp::Shr => {
            if r < 0 || r > 127 {
                Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "shift amount out of range".to_string(),
                    },
                    span,
                ))
            } else {
                match checked_shr_i128(l, r as u32) {
                    Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                    Option::None => Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "shift overflow in const expression".to_string(),
                        },
                        span,
                    )),
                }
            }
        }
        // Comparison operators return bool
        BinOp::Eq => Result::Ok(ConstResult::Bool(l == r)),
        BinOp::Ne => Result::Ok(ConstResult::Bool(l != r)),
        BinOp::Lt => Result::Ok(ConstResult::Bool(l < r)),
        BinOp::Le => Result::Ok(ConstResult::Bool(l <= r)),
        BinOp::Gt => Result::Ok(ConstResult::Bool(l > r)),
        BinOp::Ge => Result::Ok(ConstResult::Bool(l >= r)),
        BinOp::Pipe => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "pipe operator not supported in const expressions".to_string(),
                },
                span,
            ))
        }
        // And/Or handled above
        BinOp::And => unreachable!(),
        BinOp::Or => unreachable!(),
    }
}

/// Evaluate logical AND.
fn eval_logical_and(left: ConstResult, right: ConstResult, span: Span) -> Result<ConstResult, TypeError> {
    let lb = match left.as_bool() {
        Option::Some(b) => b,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "logical operators require boolean operands".to_string(),
                },
                span,
            ));
        }
    };

    let rb = match right.as_bool() {
        Option::Some(b) => b,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "logical operators require boolean operands".to_string(),
                },
                span,
            ));
        }
    };

    Result::Ok(ConstResult::Bool(lb && rb))
}

/// Evaluate logical OR.
fn eval_logical_or(left: ConstResult, right: ConstResult, span: Span) -> Result<ConstResult, TypeError> {
    let lb = match left.as_bool() {
        Option::Some(b) => b,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "logical operators require boolean operands".to_string(),
                },
                span,
            ));
        }
    };

    let rb = match right.as_bool() {
        Option::Some(b) => b,
        Option::None => {
            return Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "logical operators require boolean operands".to_string(),
                },
                span,
            ));
        }
    };

    Result::Ok(ConstResult::Bool(lb || rb))
}

// ============================================================
// Unary Operation Evaluation
// ============================================================

/// Evaluate a unary operation.
fn eval_unary_op(unary_op: UnaryOp, val: ConstResult, span: Span) -> Result<ConstResult, TypeError> {
    match unary_op {
        UnaryOp::Neg => {
            let v = match val.as_i128() {
                Option::Some(v) => v,
                Option::None => {
                    return Result::Err(TypeError::new(
                        TypeErrorKind::ConstEvalError {
                            reason: "cannot negate this value".to_string(),
                        },
                        span,
                    ));
                }
            };

            match checked_neg_i128(v) {
                Option::Some(result) => Result::Ok(ConstResult::Int(result)),
                Option::None => Result::Err(TypeError::new(
                    TypeErrorKind::ConstEvalError {
                        reason: "arithmetic overflow in const expression".to_string(),
                    },
                    span,
                )),
            }
        }
        UnaryOp::Not => {
            match val {
                ConstResult::Bool(b) => Result::Ok(ConstResult::Bool(!b)),
                ConstResult::Int(v) => Result::Ok(ConstResult::Int(!v)),
                ConstResult::Uint(v) => Result::Ok(ConstResult::Uint(!v)),
            }
        }
        UnaryOp::Deref => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "dereference not supported in const expressions".to_string(),
                },
                span,
            ))
        }
        UnaryOp::Ref => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "references not supported in const expressions".to_string(),
                },
                span,
            ))
        }
        UnaryOp::RefMut => {
            Result::Err(TypeError::new(
                TypeErrorKind::ConstEvalError {
                    reason: "mutable references not supported in const expressions".to_string(),
                },
                span,
            ))
        }
    }
}

// ============================================================
// Checked Arithmetic Helpers
// ============================================================

/// Checked addition for I128.
fn checked_add_i128(a: I128, b: I128) -> Option<i128> {
    // Check for overflow
    // For signed addition: overflow if signs are same and result has different sign
    let result = a + b;
    if (b > 0 && result < a) || (b < 0 && result > a) {
        Option::None
    } else {
        Option::Some(result)
    }
}

/// Checked subtraction for I128.
fn checked_sub_i128(a: I128, b: I128) -> Option<i128> {
    let result = a - b;
    if (b > 0 && result > a) || (b < 0 && result < a) {
        Option::None
    } else {
        Option::Some(result)
    }
}

/// Checked multiplication for I128.
fn checked_mul_i128(a: I128, b: I128) -> Option<i128> {
    if a == 0 || b == 0 {
        return Option::Some(0);
    };

    let result = a * b;

    // Check for overflow: result / b should equal a
    if result / b != a {
        Option::None
    } else {
        Option::Some(result)
    }
}

/// Checked division for I128.
fn checked_div_i128(a: I128, b: I128) -> Option<i128> {
    // Division overflow only occurs for MIN / -1
    if a == -170141183460469231731687303715884105728i128 && b == -1 {
        Option::None
    } else {
        Option::Some(a / b)
    }
}

/// Checked remainder for I128.
fn checked_rem_i128(a: I128, b: I128) -> Option<i128> {
    // Remainder overflow only occurs for MIN % -1
    if a == -170141183460469231731687303715884105728i128 && b == -1 {
        Option::None
    } else {
        Option::Some(a % b)
    }
}

/// Checked left shift for I128.
fn checked_shl_i128(a: I128, shift: U32) -> Option<i128> {
    if shift >= 128 {
        Option::None
    } else {
        Option::Some(a << shift)
    }
}

/// Checked right shift for I128.
fn checked_shr_i128(a: I128, shift: U32) -> Option<i128> {
    if shift >= 128 {
        Option::None
    } else {
        Option::Some(a >> shift)
    }
}

/// Checked negation for I128.
fn checked_neg_i128(a: I128) -> Option<i128> {
    // Negation overflow only occurs for MIN
    if a == -170141183460469231731687303715884105728i128 {
        Option::None
    } else {
        Option::Some(-a)
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_const_result_as_u64() {
    let int_val = ConstResult::Int(42);
    assert(int_val.as_u64() == Option::Some(42u64));

    let uint_val = ConstResult::Uint(100u128);
    assert(uint_val.as_u64() == Option::Some(100u64));

    let negative = ConstResult::Int(-5);
    assert(negative.as_u64() == Option::None);

    let bool_val = ConstResult::Bool(true);
    assert(bool_val.as_u64() == Option::None);
}

#[test]
fn test_const_result_as_i128() {
    let int_val = ConstResult::Int(42);
    assert(int_val.as_i128() == Option::Some(42i128));

    let uint_val = ConstResult::Uint(100u128);
    assert(uint_val.as_i128() == Option::Some(100i128));

    let negative = ConstResult::Int(-5);
    assert(negative.as_i128() == Option::Some(-5i128));
}

#[test]
fn test_const_result_as_bool() {
    let bool_val = ConstResult::Bool(true);
    assert(bool_val.as_bool() == Option::Some(true));

    let int_val = ConstResult::Int(1);
    assert(int_val.as_bool() == Option::None);
}

#[test]
fn test_checked_add() {
    assert(checked_add_i128(1, 2) == Option::Some(3));
    assert(checked_add_i128(-1, -2) == Option::Some(-3));
    assert(checked_add_i128(1, -1) == Option::Some(0));
}

#[test]
fn test_checked_sub() {
    assert(checked_sub_i128(5, 3) == Option::Some(2));
    assert(checked_sub_i128(3, 5) == Option::Some(-2));
}

#[test]
fn test_checked_mul() {
    assert(checked_mul_i128(3, 4) == Option::Some(12));
    assert(checked_mul_i128(-3, 4) == Option::Some(-12));
    assert(checked_mul_i128(0, 100) == Option::Some(0));
}

#[test]
fn test_checked_div() {
    assert(checked_div_i128(10, 2) == Option::Some(5));
    assert(checked_div_i128(-10, 2) == Option::Some(-5));
    assert(checked_div_i128(10, -2) == Option::Some(-5));
}

#[test]
fn test_checked_neg() {
    assert(checked_neg_i128(5) == Option::Some(-5));
    assert(checked_neg_i128(-5) == Option::Some(5));
    assert(checked_neg_i128(0) == Option::Some(0));
}
