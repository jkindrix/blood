/// Type Checker Module for Blood Compiler
///
/// This module provides comprehensive type checking for Blood programs, including:
/// - Type inference using Hindley-Milner with bidirectional checking
/// - Effect type checking with row polymorphism
/// - Pattern exhaustiveness checking
/// - Trait resolution and method lookup
/// - **Multiple dispatch resolution** (Dylan/Julia style)
///
/// # Module Structure
///
/// The type checker is organized into focused sub-modules:
///
/// - `types`: Core type representations (Type, TypeKind, PrimitiveTy, etc.)
/// - `errors`: Type error definitions and reporting
/// - `unify`: Type unification and substitution
/// - `resolve`: Name resolution and scoping
/// - `effects`: Effect tracking and handler resolution
/// - `patterns`: Pattern type checking
/// - `exhaustiveness`: Pattern exhaustiveness analysis
/// - `traits`: Trait definitions and method resolution
/// - `expr`: Expression type checking utilities
/// - `dispatch`: **Multiple dispatch resolution with type stability**
///
/// # Design Principles
///
/// 1. **No shortcuts**: Every case is explicitly handled
/// 2. **Proper errors**: All errors use specific TypeErrorKind variants
/// 3. **Separation of concerns**: Each module has a focused responsibility
/// 4. **Immutability**: Types are immutable once created
/// 5. **Explicit patterns**: No catch-all `_ =>` patterns

// Re-export sub-modules
pub mod types;
pub mod errors;
pub mod unify;
pub mod resolve;
pub mod effects;
pub mod patterns;
pub mod exhaustiveness;
pub mod traits;
pub mod expr;
pub mod dispatch;
pub mod context;
pub mod const_eval;

// Re-export commonly used types for convenience
pub use types::{
    Type, TypeKind, PrimitiveTy, TyVarId, DefId, Mutability, Ownership,
    EffectRow, EffectInstance, EffectRowVarId, RecordField, RecordRowVarId,
};
pub use errors::{TypeError, TypeErrorKind, TypeErrors, Span};
pub use unify::Unifier;
pub use resolve::{Scope, TypeDef, TypeDefKind, FnDef, EffectDef, EffectOpDef, StructFieldDef, EnumVariantDef, DefRegistry};
pub use effects::{EffectContext, HandlerStack};
pub use patterns::{PatternChecker, PatternCheckResult};
pub use exhaustiveness::ExhaustivenessChecker;
pub use traits::{TraitResolver, TraitDef, TraitMethodDef, ImplDef, ImplMethodDef, TraitBound};
pub use expr::{BinOp, UnaryOp, LiteralKind, ExprContext};
pub use dispatch::{
    DispatchResolver, DispatchResult, MethodCandidate, TypeParam,
    TypeStabilityChecker, TypeStabilityResult, ConstraintChecker,
    resolve_dispatch, check_type_stability,
};
pub use context::{
    check_program, ProgramContext, ModuleRegistry, ModuleInfo,
};
pub use const_eval::{ConstResult, eval_const_expr};

// ============================================================
// Type Checker Entry Point
// ============================================================

/// The main type checker for Blood programs.
///
/// This struct orchestrates all type checking operations, using the
/// sub-modules to perform specific tasks.
pub struct TypeChecker {
    /// Type unification engine
    pub unifier: Unifier,
    /// Current scope for name resolution
    pub scope: Scope,
    /// Definition registry
    pub registry: DefRegistry,
    /// Trait resolver for method lookup
    pub trait_resolver: TraitResolver,
    /// Pattern checker
    pub pattern_checker: PatternChecker,
    /// Exhaustiveness checker
    pub exhaustiveness_checker: ExhaustivenessChecker,
    /// Effect context stack
    pub effect_stack: HandlerStack,
    /// Expression checking context
    pub expr_context: ExprContext,
    /// Multiple dispatch resolver
    pub dispatch_resolver: DispatchResolver,
    /// Type stability checker
    pub stability_checker: TypeStabilityChecker,
    /// Accumulated errors
    errors: TypeErrors,
    /// Next definition ID to allocate
    next_def_id: u32,
}

impl TypeChecker {
    /// Create a new type checker.
    pub fn new() -> TypeChecker {
        TypeChecker {
            unifier: Unifier::new(),
            scope: Scope::new(),
            registry: DefRegistry::new(),
            trait_resolver: TraitResolver::new(),
            pattern_checker: PatternChecker::new(),
            exhaustiveness_checker: ExhaustivenessChecker::new(),
            effect_stack: HandlerStack::new(),
            expr_context: ExprContext::new(),
            dispatch_resolver: DispatchResolver::new(),
            stability_checker: TypeStabilityChecker::new(),
            errors: TypeErrors::new(),
            next_def_id: 0,
        }
    }

    /// Allocate a fresh definition ID.
    pub fn fresh_def_id(&mut self) -> DefId {
        let id = DefId::new(self.next_def_id);
        self.next_def_id = self.next_def_id + 1;
        id
    }

    /// Allocate a fresh type variable.
    pub fn fresh_var(&mut self) -> Type {
        self.unifier.fresh_var();
    }

    /// Record a type error.
    pub fn error(&mut self, err: TypeError) {
        self.errors.add(err);
    }

    /// Check if there are any errors.
    pub fn has_errors(&self) -> bool {
        self.errors.has_errors();
    }

    /// Get all accumulated errors.
    pub fn errors(&self) -> &[TypeError] {
        self.errors.errors();
    }

    /// Clear all errors.
    pub fn clear_errors(&mut self) {
        self.errors.clear();
    }

    // ---- Scope Management ----

    /// Enter a new child scope.
    pub fn enter_scope(&mut self) {
        self.scope = self.scope.child();
    }

    /// Exit the current scope.
    pub fn exit_scope(&mut self) {
        match self.scope.parent() {
            Some(parent) => self.scope = parent.clone(),
            None => {
                // Already at root scope - this is a programming error
            }
        }
    }

    /// Define a variable in the current scope.
    pub fn define_var(&mut self, name: String, ty: Type) {
        self.scope.define_var(name, ty);
    }

    /// Look up a variable.
    pub fn lookup_var(&self, name: &str) -> Option<Type> {
        self.scope.lookup_var(name);
    }

    /// Look up a type definition.
    pub fn lookup_type(&self, name: &str) -> Option<DefId> {
        self.scope.lookup_type(name);
    }

    // ---- Type Resolution ----

    /// Resolve a type, applying all known substitutions.
    pub fn resolve_type(&self, ty: &Type) -> Type {
        self.unifier.resolve(ty);
    }

    /// Unify two types.
    pub fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        self.unifier.unify(t1, t2, span);
    }

    /// Unify and record any error.
    pub fn unify_or_error(&mut self, t1: &Type, t2: &Type, span: Span) {
        match self.unifier.unify(t1, t2, span) {
            Ok(()) => {}
            Err(e) => self.error(e),
        }
    }

    // ---- Effect Tracking ----

    /// Record that an effect was used.
    pub fn use_effect(&mut self, effect: EffectInstance) {
        self.expr_context.effect_context_mut().use_effect(effect);
    }

    /// Push a handler onto the effect stack.
    pub fn push_handler(&mut self, row: EffectRow) {
        self.effect_stack.push(row);
    }

    /// Pop a handler from the effect stack.
    pub fn pop_handler(&mut self) -> Option<EffectRow> {
        self.effect_stack.pop();
    }

    /// Check if an effect is handled.
    pub fn is_effect_handled(&self, effect_id: &DefId) -> bool {
        self.effect_stack.handles(effect_id);
    }

    // ---- Pattern Checking ----

    /// Check a pattern against an expected type.
    pub fn check_pattern(&mut self, pattern: &patterns::Pattern, expected: &Type, span: Span) -> PatternCheckResult {
        self.pattern_checker.check(pattern, expected, span);
    }

    // ---- Trait Resolution ----

    /// Look up a method on a type.
    pub fn lookup_method(&self, ty: &Type, method: &str) -> Option<(ImplDef, ImplMethodDef)> {
        self.trait_resolver.lookup_method(ty, method, &self.unifier);
    }

    /// Check if a type satisfies a trait bound.
    pub fn satisfies_bound(&self, ty: &Type, bound: &TraitBound) -> bool {
        self.trait_resolver.satisfies_bound(ty, bound, &self.unifier);
    }

    /// Register a trait definition.
    pub fn register_trait(&mut self, trait_def: TraitDef) {
        self.trait_resolver.register_trait(trait_def);
    }

    /// Register an implementation.
    pub fn register_impl(&mut self, impl_def: ImplDef) {
        self.trait_resolver.register_impl(impl_def);
    }

    // ---- Multiple Dispatch ----

    /// Resolve dispatch for a method call.
    ///
    /// Given a method name, argument types, and candidate methods, finds the
    /// unique most specific applicable method.
    ///
    /// # Arguments
    ///
    /// * `method_name` - The name of the method being called
    /// * `arg_types` - The types of the arguments at the call site
    /// * `candidates` - All method candidates with the given name
    ///
    /// # Returns
    ///
    /// A `DispatchResult` indicating success or failure.
    pub fn resolve_method_dispatch(
        &self,
        method_name: &str,
        arg_types: &[Type],
        candidates: &[MethodCandidate],
    ) -> DispatchResult {
        self.dispatch_resolver.resolve(method_name, arg_types, candidates);
    }

    /// Resolve dispatch with effect context.
    ///
    /// Like `resolve_method_dispatch`, but also considers effect compatibility.
    pub fn resolve_method_dispatch_with_effects(
        &self,
        method_name: &str,
        arg_types: &[Type],
        candidates: &[MethodCandidate],
        context_effects: Option<&EffectRow>,
    ) -> DispatchResult {
        self.dispatch_resolver.resolve_with_effects(
            method_name,
            arg_types,
            candidates,
            context_effects,
        )
    }

    /// Check type stability for a method family.
    ///
    /// Verifies that all methods in the family have compatible return types
    /// for overlapping input types.
    pub fn check_method_stability(
        &self,
        family_name: &str,
        candidates: &[MethodCandidate],
    ) -> TypeStabilityResult {
        self.stability_checker.check_family(family_name, candidates);
    }

    /// Check if one method is more specific than another.
    pub fn method_is_more_specific(
        &self,
        m1: &MethodCandidate,
        m2: &MethodCandidate,
    ) -> bool {
        self.dispatch_resolver.is_more_specific(m1, m2);
    }
}

impl Clone for TypeChecker {
    fn clone(&self) -> TypeChecker {
        TypeChecker {
            unifier: self.unifier.clone(),
            scope: self.scope.clone(),
            registry: self.registry.clone(),
            trait_resolver: self.trait_resolver.clone(),
            pattern_checker: self.pattern_checker.clone(),
            exhaustiveness_checker: self.exhaustiveness_checker.clone(),
            effect_stack: self.effect_stack.clone(),
            expr_context: self.expr_context.clone(),
            dispatch_resolver: self.dispatch_resolver.clone(),
            stability_checker: self.stability_checker.clone(),
            errors: self.errors.clone(),
            next_def_id: self.next_def_id,
        }
    }
}

// ============================================================
// Type Checking Result
// ============================================================

/// The result of type checking a program.
pub struct TypeCheckResult {
    /// The resolved types for all definitions
    pub types: HashMap<DefId, Type>,
    /// All type errors encountered
    pub errors: TypeErrors,
    /// Whether type checking succeeded (no errors)
    pub success: bool,
}

impl TypeCheckResult {
    /// Create a successful result.
    pub fn success(types: HashMap<DefId, Type>) -> TypeCheckResult {
        TypeCheckResult {
            types,
            errors: TypeErrors::new(),
            success: true,
        }
    }

    /// Create a failed result.
    pub fn failure(types: HashMap<DefId, Type>, errors: TypeErrors) -> TypeCheckResult {
        TypeCheckResult {
            types,
            errors,
            success: false,
        }
    }

    /// Check if type checking succeeded.
    pub fn is_success(&self) -> bool {
        self.success
    }

    /// Get the type of a definition.
    pub fn get_type(&self, def_id: &DefId) -> Option<&Type> {
        self.types.get(def_id);
    }

    /// Get all errors.
    pub fn get_errors(&self) -> &[TypeError] {
        self.errors.errors();
    }
}

impl Clone for TypeCheckResult {
    fn clone(&self) -> TypeCheckResult {
        TypeCheckResult {
            types: self.types.clone(),
            errors: self.errors.clone(),
            success: self.success,
        }
    }
}

// ============================================================
// Entry Point Functions
// ============================================================

/// Create a new type checker with standard configuration.
pub fn new_checker() -> TypeChecker {
    TypeChecker::new()
}

/// Convenience function to check a type match.
///
/// Returns true if the types can be unified without error.
pub fn types_match(t1: &Type, t2: &Type) -> bool {
    let mut unifier = Unifier::new();
    match unifier.unify(t1, t2, Span::dummy()) {
        Ok(()) => true,
        Err(_) => false,
    }
}

/// Check if a type is complete (no unresolved inference variables).
pub fn is_complete(ty: &Type) -> bool {
    match ty.kind() {
        TypeKind::Infer(_) => false,
        TypeKind::Primitive(_) => true,
        TypeKind::Never => true,
        TypeKind::Tuple(tys) => {
            let mut i: usize = 0;
            while i < tys.len() {
                if !is_complete(&tys[i]) {
                    return false;
                };
                i = i + 1;
            }
            true
        }
        TypeKind::Array { element, size: _ } => is_complete(element),
        TypeKind::Slice { element } => is_complete(element),
        TypeKind::Ref { inner, mutability: _ } => is_complete(inner),
        TypeKind::Ptr { inner, mutability: _ } => is_complete(inner),
        TypeKind::Fn { params, ret, effect: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                if !is_complete(&params[i]) {
                    return false;
                };
                i = i + 1;
            };
            is_complete(ret)
        }
        TypeKind::Closure { params, ret, effect: _, captures } => {
            let mut i: usize = 0;
            while i < params.len() {
                if !is_complete(&params[i]) {
                    return false;
                };
                i = i + 1;
            };
            if !is_complete(ret) {
                return false;
            };
            i = 0;
            while i < captures.len() {
                if !is_complete(&captures[i]) {
                    return false;
                };
                i = i + 1;
            }
            true
        }
        TypeKind::Adt { def_id: _, type_args } => {
            let mut i: usize = 0;
            while i < type_args.len() {
                if !is_complete(&type_args[i]) {
                    return false;
                };
                i = i + 1;
            }
            true
        }
        TypeKind::Range { element, inclusive: _ } => is_complete(element),
        TypeKind::DynTrait { trait_id: _ } => true,
        TypeKind::Record { fields, row_var } => {
            if row_var.is_some() {
                return false; // Open record type is not complete
            };
            let mut i: usize = 0;
            while i < fields.len() {
                if !is_complete(&fields[i].ty) {
                    return false;
                };
                i = i + 1;
            }
            true
        }
        TypeKind::Forall { params: _, body } => is_complete(body),
        TypeKind::Param(_) => true, // Type parameters are considered complete
        TypeKind::Ownership { inner, ownership: _ } => is_complete(inner),
        TypeKind::Error => true, // Error is complete (for error recovery)
    }
}

/// Get all free type variables in a type.
pub fn free_vars(ty: &Type) -> [TyVarId] {
    let mut result: [TyVarId] = vec![];
    collect_free_vars(ty, &mut result);
    result
}

/// Helper to collect free type variables.
fn collect_free_vars(ty: &Type, result: &mut [TyVarId]) {
    match ty.kind() {
        TypeKind::Infer(id) => {
            // Check if already in result
            let mut found = false;
            let mut i: usize = 0;
            while i < result.len() {
                if result[i].id() == id.id() {
                    found = true;
                };
                i = i + 1;
            };
            if !found {
                result.push(id.clone());
            }
        }
        TypeKind::Primitive(_) => {}
        TypeKind::Never => {}
        TypeKind::Tuple(tys) => {
            let mut i: usize = 0;
            while i < tys.len() {
                collect_free_vars(&tys[i], result);
                i = i + 1;
            }
        }
        TypeKind::Array { element, size: _ } => collect_free_vars(element, result),
        TypeKind::Slice { element } => collect_free_vars(element, result),
        TypeKind::Ref { inner, mutability: _ } => collect_free_vars(inner, result),
        TypeKind::Ptr { inner, mutability: _ } => collect_free_vars(inner, result),
        TypeKind::Fn { params, ret, effect: _ } => {
            let mut i: usize = 0;
            while i < params.len() {
                collect_free_vars(&params[i], result);
                i = i + 1;
            };
            collect_free_vars(ret, result);
        }
        TypeKind::Closure { params, ret, effect: _, captures } => {
            let mut i: usize = 0;
            while i < params.len() {
                collect_free_vars(&params[i], result);
                i = i + 1;
            };
            collect_free_vars(ret, result);
            i = 0;
            while i < captures.len() {
                collect_free_vars(&captures[i], result);
                i = i + 1;
            }
        }
        TypeKind::Adt { def_id: _, type_args } => {
            let mut i: usize = 0;
            while i < type_args.len() {
                collect_free_vars(&type_args[i], result);
                i = i + 1;
            }
        }
        TypeKind::Range { element, inclusive: _ } => collect_free_vars(element, result),
        TypeKind::DynTrait { trait_id: _ } => {}
        TypeKind::Record { fields, row_var: _ } => {
            let mut i: usize = 0;
            while i < fields.len() {
                collect_free_vars(&fields[i].ty, result);
                i = i + 1;
            }
        }
        TypeKind::Forall { params: _, body } => {
            // Bound variables are not free
            collect_free_vars(body, result);
        }
        TypeKind::Param(_) => {}
        TypeKind::Ownership { inner, ownership: _ } => collect_free_vars(inner, result),
        TypeKind::Error => {}
    }
}

// ============================================================
// Type Printing (for diagnostics)
// ============================================================

/// Format a type for display in error messages.
pub fn format_type(ty: &Type) -> String {
    ty.display();
}

/// Format a list of types.
pub fn format_types(types: &[Type]) -> String {
    let mut result = "[".to_string();
    let mut i: usize = 0;
    while i < types.len() {
        if i > 0 {
            result = result + ", ";
        };
        result = result + &format_type(&types[i]);
        i = i + 1;
    }
    result + "]"
}
