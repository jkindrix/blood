/// Type Representations for Blood Type Checker
///
/// This module defines the semantic type system used during type checking.
/// These types are distinct from the AST types in the parser - they represent
/// resolved, canonical type information.
///
/// # Design Principles
///
/// 1. **Immutability**: Types are immutable once created
/// 2. **Structural equality**: Types are compared by structure, not identity
/// 3. **Explicit variants**: All type kinds are explicitly enumerated
/// 4. **No shortcuts**: Every case is handled, no catch-all patterns

// ============================================================
// Type Variable and Definition IDs
// ============================================================

/// Unique identifier for type variables used in inference.
///
/// Type variables represent unknown types that will be resolved
/// through unification. Each variable has a unique ID within
/// a type checking session.
pub struct TyVarId {
    id: u32,
}

impl TyVarId {
    pub fn new(id: u32) -> TyVarId {
        TyVarId { id }
    }

    pub fn id(&self) -> u32 {
        self.id
    }
}

impl Clone for TyVarId {
    fn clone(&self) -> TyVarId {
        TyVarId { id: self.id }
    }
}

impl PartialEq for TyVarId {
    fn eq(&self, other: &TyVarId) -> bool {
        self.id == other.id;
    }
}

/// Unique identifier for definitions (functions, structs, enums, etc.)
///
/// DefIds are assigned during name resolution and remain stable
/// throughout compilation. They provide a way to reference
/// definitions without using string names.
pub struct DefId {
    id: u32,
}

impl DefId {
    pub fn new(id: u32) -> DefId {
        DefId { id }
    }

    pub fn id(&self) -> u32 {
        self.id
    }
}

impl Clone for DefId {
    fn clone(&self) -> DefId {
        DefId { id: self.id }
    }
}

impl PartialEq for DefId {
    fn eq(&self, other: &DefId) -> bool {
        self.id == other.id
    }
}

/// Unique identifier for record row variables (for row polymorphism).
///
/// Row variables allow records to be polymorphic over additional fields,
/// enabling extensible record types.
pub struct RecordRowVarId {
    id: u32,
}

impl RecordRowVarId {
    pub fn new(id: u32) -> RecordRowVarId {
        RecordRowVarId { id }
    }

    pub fn id(&self) -> u32 {
        self.id
    }
}

impl Clone for RecordRowVarId {
    fn clone(&self) -> RecordRowVarId {
        RecordRowVarId { id: self.id }
    }
}

/// Unique identifier for effect row variables.
///
/// Effect row variables enable polymorphism over effect sets,
/// allowing functions to be generic over which effects they may perform.
pub struct EffectRowVarId {
    id: u32,
}

impl EffectRowVarId {
    pub fn new(id: u32) -> EffectRowVarId {
        EffectRowVarId { id }
    }

    pub fn id(&self) -> u32 {
        self.id
    }
}

impl Clone for EffectRowVarId {
    fn clone(&self) -> EffectRowVarId {
        EffectRowVarId { id: self.id }
    }
}

// ============================================================
// Primitive Types
// ============================================================

/// Primitive types built into the language.
///
/// These are the fundamental types that exist without any user definition.
/// They map directly to machine representations or runtime primitives.
pub enum PrimitiveTy {
    // Signed integers
    I8,
    I16,
    I32,
    I64,
    I128,
    Isize,
    // Unsigned integers
    U8,
    U16,
    U32,
    U64,
    U128,
    Usize,
    // Floating point
    F32,
    F64,
    // Other primitives
    Bool,
    Char,
    Str,    // String slice type
    Unit,
}

impl PrimitiveTy {
    /// Get the canonical name of this primitive type.
    pub fn name(&self) -> &str {
        match self {
            PrimitiveTy::I8 => "i8",
            PrimitiveTy::I16 => "i16",
            PrimitiveTy::I32 => "i32",
            PrimitiveTy::I64 => "i64",
            PrimitiveTy::I128 => "i128",
            PrimitiveTy::Isize => "isize",
            PrimitiveTy::U8 => "u8",
            PrimitiveTy::U16 => "u16",
            PrimitiveTy::U32 => "u32",
            PrimitiveTy::U64 => "u64",
            PrimitiveTy::U128 => "u128",
            PrimitiveTy::Usize => "usize",
            PrimitiveTy::F32 => "f32",
            PrimitiveTy::F64 => "f64",
            PrimitiveTy::Bool => "bool",
            PrimitiveTy::Char => "char",
            PrimitiveTy::Str => "str",
            PrimitiveTy::Unit => "()",
        }
    }

    /// Check if this is a signed integer type.
    pub fn is_signed_int(&self) -> bool {
        match self {
            PrimitiveTy::I8 => true,
            PrimitiveTy::I16 => true,
            PrimitiveTy::I32 => true,
            PrimitiveTy::I64 => true,
            PrimitiveTy::I128 => true,
            PrimitiveTy::Isize => true,
            PrimitiveTy::U8 => false,
            PrimitiveTy::U16 => false,
            PrimitiveTy::U32 => false,
            PrimitiveTy::U64 => false,
            PrimitiveTy::U128 => false,
            PrimitiveTy::Usize => false,
            PrimitiveTy::F32 => false,
            PrimitiveTy::F64 => false,
            PrimitiveTy::Bool => false,
            PrimitiveTy::Char => false,
            PrimitiveTy::Str => false,
            PrimitiveTy::Unit => false,
        }
    }

    /// Check if this is an unsigned integer type.
    pub fn is_unsigned_int(&self) -> bool {
        match self {
            PrimitiveTy::I8 => false,
            PrimitiveTy::I16 => false,
            PrimitiveTy::I32 => false,
            PrimitiveTy::I64 => false,
            PrimitiveTy::I128 => false,
            PrimitiveTy::Isize => false,
            PrimitiveTy::U8 => true,
            PrimitiveTy::U16 => true,
            PrimitiveTy::U32 => true,
            PrimitiveTy::U64 => true,
            PrimitiveTy::U128 => true,
            PrimitiveTy::Usize => true,
            PrimitiveTy::F32 => false,
            PrimitiveTy::F64 => false,
            PrimitiveTy::Bool => false,
            PrimitiveTy::Char => false,
            PrimitiveTy::Str => false,
            PrimitiveTy::Unit => false,
        }
    }

    /// Check if this is any integer type (signed or unsigned).
    pub fn is_integer(&self) -> bool {
        self.is_signed_int() || self.is_unsigned_int();
    }

    /// Check if this is a floating point type.
    pub fn is_float(&self) -> bool {
        match self {
            PrimitiveTy::F32 => true,
            PrimitiveTy::F64 => true,
            PrimitiveTy::I8 => false,
            PrimitiveTy::I16 => false,
            PrimitiveTy::I32 => false,
            PrimitiveTy::I64 => false,
            PrimitiveTy::I128 => false,
            PrimitiveTy::Isize => false,
            PrimitiveTy::U8 => false,
            PrimitiveTy::U16 => false,
            PrimitiveTy::U32 => false,
            PrimitiveTy::U64 => false,
            PrimitiveTy::U128 => false,
            PrimitiveTy::Usize => false,
            PrimitiveTy::Bool => false,
            PrimitiveTy::Char => false,
            PrimitiveTy::Str => false,
            PrimitiveTy::Unit => false,
        }
    }

    /// Check if this is a numeric type (integer or float).
    pub fn is_numeric(&self) -> bool {
        self.is_integer() || self.is_float();
    }

    /// Get the bit width of this type, if fixed.
    /// Returns None for pointer-sized types (isize, usize).
    pub fn bit_width(&self) -> Option<u32> {
        match self {
            PrimitiveTy::I8 => Some(8),
            PrimitiveTy::I16 => Some(16),
            PrimitiveTy::I32 => Some(32),
            PrimitiveTy::I64 => Some(64),
            PrimitiveTy::I128 => Some(128),
            PrimitiveTy::Isize => None,
            PrimitiveTy::U8 => Some(8),
            PrimitiveTy::U16 => Some(16),
            PrimitiveTy::U32 => Some(32),
            PrimitiveTy::U64 => Some(64),
            PrimitiveTy::U128 => Some(128),
            PrimitiveTy::Usize => None,
            PrimitiveTy::F32 => Some(32),
            PrimitiveTy::F64 => Some(64),
            PrimitiveTy::Bool => Some(1),
            PrimitiveTy::Char => Some(32),
            PrimitiveTy::Str => None,
            PrimitiveTy::Unit => Some(0),
        }
    }
}

impl Clone for PrimitiveTy {
    fn clone(&self) -> PrimitiveTy {
        match self {
            PrimitiveTy::I8 => PrimitiveTy::I8,
            PrimitiveTy::I16 => PrimitiveTy::I16,
            PrimitiveTy::I32 => PrimitiveTy::I32,
            PrimitiveTy::I64 => PrimitiveTy::I64,
            PrimitiveTy::I128 => PrimitiveTy::I128,
            PrimitiveTy::Isize => PrimitiveTy::Isize,
            PrimitiveTy::U8 => PrimitiveTy::U8,
            PrimitiveTy::U16 => PrimitiveTy::U16,
            PrimitiveTy::U32 => PrimitiveTy::U32,
            PrimitiveTy::U64 => PrimitiveTy::U64,
            PrimitiveTy::U128 => PrimitiveTy::U128,
            PrimitiveTy::Usize => PrimitiveTy::Usize,
            PrimitiveTy::F32 => PrimitiveTy::F32,
            PrimitiveTy::F64 => PrimitiveTy::F64,
            PrimitiveTy::Bool => PrimitiveTy::Bool,
            PrimitiveTy::Char => PrimitiveTy::Char,
            PrimitiveTy::Str => PrimitiveTy::Str,
            PrimitiveTy::Unit => PrimitiveTy::Unit,
        }
    }
}

impl PartialEq for PrimitiveTy {
    fn eq(&self, other: &PrimitiveTy) -> bool {
        match (self, other) {
            (PrimitiveTy::I8, PrimitiveTy::I8) => true,
            (PrimitiveTy::I16, PrimitiveTy::I16) => true,
            (PrimitiveTy::I32, PrimitiveTy::I32) => true,
            (PrimitiveTy::I64, PrimitiveTy::I64) => true,
            (PrimitiveTy::I128, PrimitiveTy::I128) => true,
            (PrimitiveTy::Isize, PrimitiveTy::Isize) => true,
            (PrimitiveTy::U8, PrimitiveTy::U8) => true,
            (PrimitiveTy::U16, PrimitiveTy::U16) => true,
            (PrimitiveTy::U32, PrimitiveTy::U32) => true,
            (PrimitiveTy::U64, PrimitiveTy::U64) => true,
            (PrimitiveTy::U128, PrimitiveTy::U128) => true,
            (PrimitiveTy::Usize, PrimitiveTy::Usize) => true,
            (PrimitiveTy::F32, PrimitiveTy::F32) => true,
            (PrimitiveTy::F64, PrimitiveTy::F64) => true,
            (PrimitiveTy::Bool, PrimitiveTy::Bool) => true,
            (PrimitiveTy::Char, PrimitiveTy::Char) => true,
            (PrimitiveTy::Str, PrimitiveTy::Str) => true,
            (PrimitiveTy::Unit, PrimitiveTy::Unit) => true,
            // All non-matching pairs
            (PrimitiveTy::I8, _) => false,
            (PrimitiveTy::I16, _) => false,
            (PrimitiveTy::I32, _) => false,
            (PrimitiveTy::I64, _) => false,
            (PrimitiveTy::I128, _) => false,
            (PrimitiveTy::Isize, _) => false,
            (PrimitiveTy::U8, _) => false,
            (PrimitiveTy::U16, _) => false,
            (PrimitiveTy::U32, _) => false,
            (PrimitiveTy::U64, _) => false,
            (PrimitiveTy::U128, _) => false,
            (PrimitiveTy::Usize, _) => false,
            (PrimitiveTy::F32, _) => false,
            (PrimitiveTy::F64, _) => false,
            (PrimitiveTy::Bool, _) => false,
            (PrimitiveTy::Char, _) => false,
            (PrimitiveTy::Str, _) => false,
            (PrimitiveTy::Unit, _) => false,
        }
    }
}

/// Parse a primitive type from its name.
pub fn parse_primitive(name: &str) -> Option<PrimitiveTy> {
    match name {
        "i8" => Some(PrimitiveTy::I8),
        "i16" => Some(PrimitiveTy::I16),
        "i32" => Some(PrimitiveTy::I32),
        "i64" => Some(PrimitiveTy::I64),
        "i128" => Some(PrimitiveTy::I128),
        "isize" => Some(PrimitiveTy::Isize),
        "u8" => Some(PrimitiveTy::U8),
        "u16" => Some(PrimitiveTy::U16),
        "u32" => Some(PrimitiveTy::U32),
        "u64" => Some(PrimitiveTy::U64),
        "u128" => Some(PrimitiveTy::U128),
        "usize" => Some(PrimitiveTy::Usize),
        "f32" => Some(PrimitiveTy::F32),
        "f64" => Some(PrimitiveTy::F64),
        "bool" => Some(PrimitiveTy::Bool),
        "char" => Some(PrimitiveTy::Char),
        "str" => Some(PrimitiveTy::Str),
        "()" => Some(PrimitiveTy::Unit),
        _ => None,
    }
}

// ============================================================
// Mutability
// ============================================================

/// Mutability qualifier for references and pointers.
pub enum Mutability {
    /// Immutable (shared) reference: &T
    Immutable,
    /// Mutable (exclusive) reference: &mut T
    Mutable,
}

impl Mutability {
    pub fn is_mutable(&self) -> bool {
        match self {
            Mutability::Mutable => true,
            Mutability::Immutable => false,
        }
    }
}

impl Clone for Mutability {
    fn clone(&self) -> Mutability {
        match self {
            Mutability::Immutable => Mutability::Immutable,
            Mutability::Mutable => Mutability::Mutable,
        }
    }
}

impl PartialEq for Mutability {
    fn eq(&self, other: &Mutability) -> bool {
        match (self, other) {
            (Mutability::Immutable, Mutability::Immutable) => true,
            (Mutability::Mutable, Mutability::Mutable) => true,
            (Mutability::Immutable, Mutability::Mutable) => false,
            (Mutability::Mutable, Mutability::Immutable) => false,
        }
    }
}

// ============================================================
// Ownership Qualifiers
// ============================================================

/// Ownership qualifiers for Blood's generational memory safety.
///
/// These qualifiers control how values can be used and shared,
/// enabling safe memory management without a garbage collector.
pub enum Ownership {
    /// Linear: must be used exactly once
    ///
    /// Linear values cannot be duplicated or discarded. They must be
    /// consumed (moved) exactly once. This is useful for resources
    /// that require explicit cleanup.
    Linear,

    /// Affine: can be used at most once
    ///
    /// Affine values can be used zero or one times. They can be
    /// discarded without being used, but cannot be duplicated.
    /// This is the default for most move-only types.
    Affine,

    /// Default: normal Rust-like ownership semantics
    ///
    /// Values with default ownership follow standard move/copy semantics
    /// based on whether the type implements Copy.
    Default,
}

impl Clone for Ownership {
    fn clone(&self) -> Ownership {
        match self {
            Ownership::Linear => Ownership::Linear,
            Ownership::Affine => Ownership::Affine,
            Ownership::Default => Ownership::Default,
        }
    }
}

impl PartialEq for Ownership {
    fn eq(&self, other: &Ownership) -> bool {
        match (self, other) {
            (Ownership::Linear, Ownership::Linear) => true,
            (Ownership::Affine, Ownership::Affine) => true,
            (Ownership::Default, Ownership::Default) => true,
            (Ownership::Linear, Ownership::Affine) => false,
            (Ownership::Linear, Ownership::Default) => false,
            (Ownership::Affine, Ownership::Linear) => false,
            (Ownership::Affine, Ownership::Default) => false,
            (Ownership::Default, Ownership::Linear) => false,
            (Ownership::Default, Ownership::Affine) => false,
        }
    }
}

// ============================================================
// Effect Types
// ============================================================

/// An effect row represents a set of effects a computation may perform.
///
/// Effect rows support row polymorphism through an optional row variable,
/// allowing functions to be polymorphic over additional effects.
pub struct EffectRow {
    /// Concrete effects in this row
    effects: [EffectInstance],
    /// Optional row variable for polymorphism
    row_var: Option<EffectRowVarId>,
}

impl EffectRow {
    /// Create a new effect row with the given effects and optional row variable.
    pub fn new(effects: [EffectInstance], row_var: Option<EffectRowVarId>) -> EffectRow {
        EffectRow { effects, row_var }
    }

    /// Create a pure (empty) effect row - no effects.
    pub fn pure() -> EffectRow {
        EffectRow {
            effects: vec![],
            row_var: None,
        }
    }

    /// Create an open effect row with just a row variable.
    pub fn open(var: EffectRowVarId) -> EffectRow {
        EffectRow {
            effects: vec![],
            row_var: Some(var),
        }
    }

    /// Check if this effect row is pure (no effects, no row variable).
    pub fn is_pure(&self) -> bool {
        self.effects.len() == 0 && self.row_var.is_none();
    }

    /// Check if this effect row is closed (no row variable).
    pub fn is_closed(&self) -> bool {
        self.row_var.is_none();
    }

    /// Get the effects in this row.
    pub fn effects(&self) -> &[EffectInstance] {
        &self.effects
    }

    /// Get the row variable, if any.
    pub fn row_var(&self) -> Option<&EffectRowVarId> {
        self.row_var.as_ref();
    }

    /// Check if this row contains a specific effect.
    pub fn contains_effect(&self, def_id: &DefId) -> bool {
        let mut i: usize = 0;
        while i < self.effects.len() {
            if self.effects[i].def_id.eq(def_id) {
                return true;
            };
            i = i + 1;
        }
        false
    }
}

impl Clone for EffectRow {
    fn clone(&self) -> EffectRow {
        EffectRow {
            effects: self.effects.clone(),
            row_var: self.row_var.clone(),
        }
    }
}

/// An instance of an effect with type arguments.
pub struct EffectInstance {
    /// The effect definition being referenced
    pub def_id: DefId,
    /// Type arguments for parameterized effects
    pub type_args: [Type],
}

impl EffectInstance {
    pub fn new(def_id: DefId, type_args: [Type]) -> EffectInstance {
        EffectInstance { def_id, type_args }
    }

    pub fn simple(def_id: DefId) -> EffectInstance {
        EffectInstance {
            def_id,
            type_args: vec![],
        }
    }
}

impl Clone for EffectInstance {
    fn clone(&self) -> EffectInstance {
        EffectInstance {
            def_id: self.def_id.clone(),
            type_args: self.type_args.clone(),
        }
    }
}

// ============================================================
// Record Types (Row Polymorphism)
// ============================================================

/// A field in a record type.
pub struct RecordField {
    pub name: String,
    pub ty: Type,
}

impl RecordField {
    pub fn new(name: String, ty: Type) -> RecordField {
        RecordField { name, ty }
    }
}

impl Clone for RecordField {
    fn clone(&self) -> RecordField {
        RecordField {
            name: self.name.clone(),
            ty: self.ty.clone(),
        }
    }
}

// ============================================================
// The Type Structure
// ============================================================

/// A semantic type in Blood.
///
/// This is the central type representation used throughout type checking.
/// Types are structural - two types are equal if their structure is equal.
pub struct Type {
    kind: TypeKind,
}

impl Type {
    /// Create a new type from a kind.
    pub fn new(kind: TypeKind) -> Type {
        Type { kind }
    }

    /// Get the kind of this type.
    pub fn kind(&self) -> &TypeKind {
        &self.kind
    }

    // ---- Constructors for common types ----

    /// Create the unit type `()`.
    pub fn unit() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Unit))
    }

    /// Create the never type `!`.
    pub fn never() -> Type {
        Type::new(TypeKind::Never)
    }

    /// Create an error type (used for error recovery).
    pub fn error() -> Type {
        Type::new(TypeKind::Error)
    }

    /// Create a boolean type.
    pub fn bool() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Bool))
    }

    /// Create an i32 type.
    pub fn i32() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::I32))
    }

    /// Create an i64 type.
    pub fn i64() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::I64))
    }

    /// Create a usize type.
    pub fn usize() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Usize))
    }

    /// Create a char type.
    pub fn char() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Char))
    }

    /// Create a str type.
    pub fn str() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::Str))
    }

    /// Create an f64 type.
    pub fn f64() -> Type {
        Type::new(TypeKind::Primitive(PrimitiveTy::F64))
    }

    /// Create an inference variable.
    pub fn infer(id: TyVarId) -> Type {
        Type::new(TypeKind::Infer(id))
    }

    /// Create a type parameter.
    pub fn param(id: TyVarId) -> Type {
        Type::new(TypeKind::Param(id))
    }

    /// Create a tuple type.
    pub fn tuple(elements: [Type]) -> Type {
        Type::new(TypeKind::Tuple(elements))
    }

    /// Create an array type.
    pub fn array(element: Type, size: u64) -> Type {
        Type::new(TypeKind::Array {
            element: Box::new(element),
            size,
        })
    }

    /// Create a slice type.
    pub fn slice(element: Type) -> Type {
        Type::new(TypeKind::Slice {
            element: Box::new(element),
        })
    }

    /// Create an immutable reference type.
    pub fn ref_to(inner: Type) -> Type {
        Type::new(TypeKind::Ref {
            inner: Box::new(inner),
            mutability: Mutability::Immutable,
        })
    }

    /// Create a mutable reference type.
    pub fn ref_mut(inner: Type) -> Type {
        Type::new(TypeKind::Ref {
            inner: Box::new(inner),
            mutability: Mutability::Mutable,
        })
    }

    // ---- Type predicates ----

    /// Check if this type is a primitive.
    pub fn is_primitive(&self) -> bool {
        match &self.kind {
            TypeKind::Primitive(_) => true,
            TypeKind::Never => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is the unit type.
    pub fn is_unit(&self) -> bool {
        match &self.kind {
            TypeKind::Primitive(PrimitiveTy::Unit) => true,
            TypeKind::Tuple(elements) => elements.len() == 0,
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is the never type.
    pub fn is_never(&self) -> bool {
        match &self.kind {
            TypeKind::Never => true,
            TypeKind::Primitive(_) => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is a reference.
    pub fn is_ref(&self) -> bool {
        match &self.kind {
            TypeKind::Ref { inner: _, mutability: _ } => true,
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is a function type.
    pub fn is_fn(&self) -> bool {
        match &self.kind {
            TypeKind::Fn { params: _, ret: _, effect: _ } => true,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => true,
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is an inference variable.
    pub fn is_infer(&self) -> bool {
        match &self.kind {
            TypeKind::Infer(_) => true,
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
            TypeKind::Error => false,
        }
    }

    /// Check if this type is an error type.
    pub fn is_error(&self) -> bool {
        match &self.kind {
            TypeKind::Error => true,
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Tuple(_) => false,
            TypeKind::Array { element: _, size: _ } => false,
            TypeKind::Slice { element: _ } => false,
            TypeKind::Ref { inner: _, mutability: _ } => false,
            TypeKind::Ptr { inner: _, mutability: _ } => false,
            TypeKind::Fn { params: _, ret: _, effect: _ } => false,
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
            TypeKind::Adt { def_id: _, type_args: _ } => false,
            TypeKind::Range { element: _, inclusive: _ } => false,
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields: _, row_var: _ } => false,
            TypeKind::Forall { params: _, body: _ } => false,
            TypeKind::Infer(_) => false,
            TypeKind::Param(_) => false,
            TypeKind::Ownership { inner: _, ownership: _ } => false,
        }
    }

    /// Format this type as a human-readable string.
    pub fn display(&self) -> String {
        match &self.kind {
            TypeKind::Primitive(p) => p.name().to_string(),
            TypeKind::Never => "!".to_string(),
            TypeKind::Tuple(elements) => {
                if elements.len() == 0 {
                    "()".to_string()
                } else {
                    let mut result = "(".to_string();
                    let mut i: usize = 0;
                    while i < elements.len() {
                        if i > 0 {
                            result = result + ", ";
                        };
                        result = result + &elements[i].display();
                        i = i + 1;
                    }
                    result + ")"
                }
            }
            TypeKind::Array { element, size } => {
                format!("[{}; {}]", element.display(), size)
            }
            TypeKind::Slice { element } => {
                format!("[{}]", element.display())
            }
            TypeKind::Ref { inner, mutability } => {
                match mutability {
                    Mutability::Immutable => format!("&{}", inner.display()),
                    Mutability::Mutable => format!("&mut {}", inner.display()),
                }
            }
            TypeKind::Ptr { inner, mutability } => {
                match mutability {
                    Mutability::Immutable => format!("*const {}", inner.display()),
                    Mutability::Mutable => format!("*mut {}", inner.display()),
                }
            }
            TypeKind::Fn { params, ret, effect: _ } => {
                let mut result = "fn(".to_string();
                let mut i: usize = 0;
                while i < params.len() {
                    if i > 0 {
                        result = result + ", ";
                    };
                    result = result + &params[i].display();
                    i = i + 1;
                }
                result + ") -> " + &ret.display()
            }
            TypeKind::Closure { params, ret, effect: _, captures: _ } => {
                let mut result = "|".to_string();
                let mut i: usize = 0;
                while i < params.len() {
                    if i > 0 {
                        result = result + ", ";
                    };
                    result = result + &params[i].display();
                    i = i + 1;
                }
                result + "| -> " + &ret.display()
            }
            TypeKind::Adt { def_id, type_args } => {
                let mut result = format!("Adt#{}", def_id.id());
                if type_args.len() > 0 {
                    result = result + "<";
                    let mut i: usize = 0;
                    while i < type_args.len() {
                        if i > 0 {
                            result = result + ", ";
                        };
                        result = result + &type_args[i].display();
                        i = i + 1;
                    };
                    result = result + ">";
                }
                result
            }
            TypeKind::Range { element, inclusive } => {
                if *inclusive {
                    format!("RangeInclusive<{}>", element.display())
                } else {
                    format!("Range<{}>", element.display())
                }
            }
            TypeKind::DynTrait { trait_id } => {
                format!("dyn Trait#{}", trait_id.id())
            }
            TypeKind::Record { fields, row_var } => {
                let mut result = "{ ".to_string();
                let mut i: usize = 0;
                while i < fields.len() {
                    if i > 0 {
                        result = result + ", ";
                    };
                    result = result + &fields[i].name + ": " + &fields[i].ty.display();
                    i = i + 1;
                };
                match row_var {
                    Some(var) => result + ", ..r" + &var.id().to_string() + " }",
                    None => result + " }",
                }
            }
            TypeKind::Forall { params, body } => {
                let mut result = "forall<".to_string();
                let mut i: usize = 0;
                while i < params.len() {
                    if i > 0 {
                        result = result + ", ";
                    };
                    result = result + "T" + &params[i].id().to_string();
                    i = i + 1;
                }
                result + ">. " + &body.display()
            }
            TypeKind::Infer(id) => {
                format!("?{}", id.id())
            }
            TypeKind::Param(id) => {
                format!("T{}", id.id())
            }
            TypeKind::Ownership { inner, ownership } => {
                match ownership {
                    Ownership::Linear => format!("linear {}", inner.display()),
                    Ownership::Affine => format!("affine {}", inner.display()),
                    Ownership::Default => inner.display(),
                }
            }
            TypeKind::Error => "<error>".to_string(),
        }
    }
}

impl Clone for Type {
    fn clone(&self) -> Type {
        Type {
            kind: self.kind.clone(),
        }
    }
}

// ============================================================
// Type Kind
// ============================================================

/// The kind (structure) of a type.
///
/// Every variant represents a distinct kind of type in the Blood type system.
/// This enum is exhaustive - there are no other type kinds.
pub enum TypeKind {
    /// Primitive types: i32, bool, etc.
    Primitive(PrimitiveTy),

    /// Never type: ! (the type of expressions that don't return)
    Never,

    /// Tuple type: (T1, T2, ...)
    Tuple([Type]),

    /// Array type: [T; N] (fixed size)
    Array {
        element: Box<Type>,
        size: u64,
    },

    /// Slice type: [T] (dynamically sized)
    Slice {
        element: Box<Type>,
    },

    /// Reference type: &T or &mut T
    Ref {
        inner: Box<Type>,
        mutability: Mutability,
    },

    /// Raw pointer type: *const T or *mut T
    Ptr {
        inner: Box<Type>,
        mutability: Mutability,
    },

    /// Function type: fn(T1, T2) -> R / Effects
    Fn {
        params: [Type],
        ret: Box<Type>,
        effect: Option<EffectRow>,
    },

    /// Closure type: function with captured environment
    ///
    /// Closures are like functions but capture values from their environment.
    /// The captures field records the types of captured variables.
    Closure {
        params: [Type],
        ret: Box<Type>,
        effect: Option<EffectRow>,
        captures: [Type],
    },

    /// Algebraic data type (struct or enum): Foo<T1, T2>
    Adt {
        def_id: DefId,
        type_args: [Type],
    },

    /// Range type: Range<T>
    Range {
        element: Box<Type>,
        inclusive: bool,
    },

    /// Dynamic trait object: dyn Trait
    DynTrait {
        trait_id: DefId,
    },

    /// Record type (anonymous struct with row polymorphism)
    Record {
        fields: [RecordField],
        row_var: Option<RecordRowVarId>,
    },

    /// Universal quantification: forall<T>. Type
    Forall {
        params: [TyVarId],
        body: Box<Type>,
    },

    /// Type inference variable (unresolved)
    Infer(TyVarId),

    /// Type parameter (bound by forall or generic)
    Param(TyVarId),

    /// Ownership-qualified type
    ///
    /// Wraps a type with an ownership qualifier for Blood's
    /// generational memory safety system.
    Ownership {
        inner: Box<Type>,
        ownership: Ownership,
    },

    /// Error type (for error recovery, unifies with anything)
    Error,
}

impl Clone for TypeKind {
    fn clone(&self) -> TypeKind {
        match self {
            TypeKind::Primitive(p) => TypeKind::Primitive(p.clone()),
            TypeKind::Never => TypeKind::Never,
            TypeKind::Tuple(types) => TypeKind::Tuple(types.clone()),
            TypeKind::Array { element, size } => TypeKind::Array {
                element: element.clone(),
                size: *size,
            },
            TypeKind::Slice { element } => TypeKind::Slice {
                element: element.clone(),
            },
            TypeKind::Ref { inner, mutability } => TypeKind::Ref {
                inner: inner.clone(),
                mutability: mutability.clone(),
            },
            TypeKind::Ptr { inner, mutability } => TypeKind::Ptr {
                inner: inner.clone(),
                mutability: mutability.clone(),
            },
            TypeKind::Fn { params, ret, effect } => TypeKind::Fn {
                params: params.clone(),
                ret: ret.clone(),
                effect: effect.clone(),
            },
            TypeKind::Closure { params, ret, effect, captures } => TypeKind::Closure {
                params: params.clone(),
                ret: ret.clone(),
                effect: effect.clone(),
                captures: captures.clone(),
            },
            TypeKind::Adt { def_id, type_args } => TypeKind::Adt {
                def_id: def_id.clone(),
                type_args: type_args.clone(),
            },
            TypeKind::Range { element, inclusive } => TypeKind::Range {
                element: element.clone(),
                inclusive: *inclusive,
            },
            TypeKind::DynTrait { trait_id } => TypeKind::DynTrait {
                trait_id: trait_id.clone(),
            },
            TypeKind::Record { fields, row_var } => TypeKind::Record {
                fields: fields.clone(),
                row_var: row_var.clone(),
            },
            TypeKind::Forall { params, body } => TypeKind::Forall {
                params: params.clone(),
                body: body.clone(),
            },
            TypeKind::Infer(id) => TypeKind::Infer(id.clone()),
            TypeKind::Param(id) => TypeKind::Param(id.clone()),
            TypeKind::Ownership { inner, ownership } => TypeKind::Ownership {
                inner: inner.clone(),
                ownership: ownership.clone(),
            },
            TypeKind::Error => TypeKind::Error,
        }
    }
}
