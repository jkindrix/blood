/// Name Resolution for Blood Type Checker
///
/// This module handles scoping and name resolution, mapping identifiers
/// to their definitions and types.
///
/// # Design Principles
///
/// 1. **Lexical scoping**: Variables are resolved in nested scopes
/// 2. **Explicit definitions**: All definitions are tracked explicitly
/// 3. **Type and value namespaces**: Types and values have separate namespaces

use std.collections::{HashMap};
use std.compiler.typeck.types::{Type, TypeKind, TyVarId, DefId, EffectRow};

// ============================================================
// Scope
// ============================================================

/// A scope for name resolution.
///
/// Scopes form a tree structure where each scope may have a parent.
/// Names are resolved by searching the current scope, then ancestors.
pub struct Scope {
    /// Variables in this scope: name -> type
    variables: HashMap<String, Type>,
    /// Types in this scope: name -> DefId
    types: HashMap<String, DefId>,
    /// Functions in this scope: name -> DefId
    functions: HashMap<String, DefId>,
    /// Effects in this scope: name -> DefId
    effects: HashMap<String, DefId>,
    /// Traits in this scope: name -> DefId
    traits: HashMap<String, DefId>,
    /// Parent scope (if any)
    parent: Option<Box<Scope>>,
}

impl Scope {
    /// Create a new empty scope.
    pub fn new() -> Scope {
        Scope {
            variables: HashMap::new(),
            types: HashMap::new(),
            functions: HashMap::new(),
            effects: HashMap::new(),
            traits: HashMap::new(),
            parent: None,
        }
    }

    /// Create a child scope with this scope as parent.
    pub fn child(&self) -> Scope {
        Scope {
            variables: HashMap::new(),
            types: HashMap::new(),
            functions: HashMap::new(),
            effects: HashMap::new(),
            traits: HashMap::new(),
            parent: Some(Box::new(self.clone())),
        }
    }

    // --------------------------------------------------------
    // Variable Lookup/Definition
    // --------------------------------------------------------

    /// Look up a variable in this scope or parents.
    pub fn lookup_var(&self, name: &str) -> Option<Type> {
        match self.variables.get(name) {
            Some(ty) => Some(ty.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_var(name),
                    None => None,
                }
            }
        }
    }

    /// Define a variable in this scope.
    pub fn define_var(&mut self, name: String, ty: Type) {
        self.variables.insert(name, ty);
    }

    /// Check if a variable is defined in this exact scope (not parents).
    pub fn has_var_local(&self, name: &str) -> bool {
        self.variables.contains_key(name);
    }

    // --------------------------------------------------------
    // Type Lookup/Definition
    // --------------------------------------------------------

    /// Look up a type in this scope or parents.
    pub fn lookup_type(&self, name: &str) -> Option<DefId> {
        match self.types.get(name) {
            Some(id) => Some(id.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_type(name),
                    None => None,
                }
            }
        }
    }

    /// Define a type in this scope.
    pub fn define_type(&mut self, name: String, id: DefId) {
        self.types.insert(name, id);
    }

    /// Check if a type is defined in this exact scope (not parents).
    pub fn has_type_local(&self, name: &str) -> bool {
        self.types.contains_key(name);
    }

    // --------------------------------------------------------
    // Function Lookup/Definition
    // --------------------------------------------------------

    /// Look up a function in this scope or parents.
    pub fn lookup_fn(&self, name: &str) -> Option<DefId> {
        match self.functions.get(name) {
            Some(id) => Some(id.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_fn(name),
                    None => None,
                }
            }
        }
    }

    /// Define a function in this scope.
    pub fn define_fn(&mut self, name: String, id: DefId) {
        self.functions.insert(name, id);
    }

    // --------------------------------------------------------
    // Effect Lookup/Definition
    // --------------------------------------------------------

    /// Look up an effect in this scope or parents.
    pub fn lookup_effect(&self, name: &str) -> Option<DefId> {
        match self.effects.get(name) {
            Some(id) => Some(id.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_effect(name),
                    None => None,
                }
            }
        }
    }

    /// Define an effect in this scope.
    pub fn define_effect(&mut self, name: String, id: DefId) {
        self.effects.insert(name, id);
    }

    // --------------------------------------------------------
    // Trait Lookup/Definition
    // --------------------------------------------------------

    /// Look up a trait in this scope or parents.
    pub fn lookup_trait(&self, name: &str) -> Option<DefId> {
        match self.traits.get(name) {
            Some(id) => Some(id.clone()),
            None => {
                match &self.parent {
                    Some(parent) => parent.lookup_trait(name),
                    None => None,
                }
            }
        }
    }

    /// Define a trait in this scope.
    pub fn define_trait(&mut self, name: String, id: DefId) {
        self.traits.insert(name, id);
    }
}

impl Clone for Scope {
    fn clone(&self) -> Scope {
        Scope {
            variables: self.variables.clone(),
            types: self.types.clone(),
            functions: self.functions.clone(),
            effects: self.effects.clone(),
            traits: self.traits.clone(),
            parent: self.parent.clone(),
        }
    }
}

// ============================================================
// Type Definitions
// ============================================================

/// A type definition (struct or enum).
pub struct TypeDef {
    /// The name of the type
    pub name: String,
    /// Type parameters (generics)
    pub type_params: [TyVarId],
    /// The kind of type definition
    pub kind: TypeDefKind,
}

impl TypeDef {
    pub fn new_struct(name: String, type_params: [TyVarId], fields: [StructFieldDef]) -> TypeDef {
        TypeDef {
            name,
            type_params,
            kind: TypeDefKind::Struct { fields },
        }
    }

    pub fn new_enum(name: String, type_params: [TyVarId], variants: [EnumVariantDef]) -> TypeDef {
        TypeDef {
            name,
            type_params,
            kind: TypeDefKind::Enum { variants },
        }
    }
}

impl Clone for TypeDef {
    fn clone(&self) -> TypeDef {
        TypeDef {
            name: self.name.clone(),
            type_params: self.type_params.clone(),
            kind: self.kind.clone(),
        }
    }
}

/// The kind of a type definition.
pub enum TypeDefKind {
    /// Struct type with named fields
    Struct { fields: [StructFieldDef] },
    /// Enum type with variants
    Enum { variants: [EnumVariantDef] },
}

impl Clone for TypeDefKind {
    fn clone(&self) -> TypeDefKind {
        match self {
            TypeDefKind::Struct { fields } => {
                TypeDefKind::Struct { fields: fields.clone() }
            }
            TypeDefKind::Enum { variants } => {
                TypeDefKind::Enum { variants: variants.clone() }
            }
        }
    }
}

/// A field in a struct definition.
pub struct StructFieldDef {
    /// Field name
    pub name: String,
    /// Field type
    pub ty: Type,
}

impl Clone for StructFieldDef {
    fn clone(&self) -> StructFieldDef {
        StructFieldDef {
            name: self.name.clone(),
            ty: self.ty.clone(),
        }
    }
}

/// A variant in an enum definition.
pub struct EnumVariantDef {
    /// Variant name
    pub name: String,
    /// Payload type (if any)
    pub payload: Option<Type>,
}

impl Clone for EnumVariantDef {
    fn clone(&self) -> EnumVariantDef {
        EnumVariantDef {
            name: self.name.clone(),
            payload: self.payload.clone(),
        }
    }
}

// ============================================================
// Function Definitions
// ============================================================

/// A function definition.
pub struct FnDef {
    /// Function name
    pub name: String,
    /// Type parameters (generics)
    pub type_params: [TyVarId],
    /// Parameter types
    pub params: [Type],
    /// Return type
    pub ret: Type,
    /// Effect signature (if any)
    pub effect: Option<EffectRow>,
}

impl FnDef {
    pub fn new(
        name: String,
        type_params: [TyVarId],
        params: [Type],
        ret: Type,
        effect: Option<EffectRow>,
    ) -> FnDef {
        FnDef { name, type_params, params, ret, effect }
    }

    /// Get the function type.
    pub fn fn_type(&self) -> Type {
        Type::new(TypeKind::Fn {
            params: self.params.clone(),
            ret: Box::new(self.ret.clone()),
            effect: self.effect.clone(),
        })
    }
}

impl Clone for FnDef {
    fn clone(&self) -> FnDef {
        FnDef {
            name: self.name.clone(),
            type_params: self.type_params.clone(),
            params: self.params.clone(),
            ret: self.ret.clone(),
            effect: self.effect.clone(),
        }
    }
}

// ============================================================
// Effect Definitions
// ============================================================

/// An effect definition.
pub struct EffectDef {
    /// Effect name
    pub name: String,
    /// Type parameters (generics)
    pub type_params: [TyVarId],
    /// Operations provided by this effect
    pub operations: [EffectOpDef],
}

impl EffectDef {
    pub fn new(name: String, type_params: [TyVarId], operations: [EffectOpDef]) -> EffectDef {
        EffectDef { name, type_params, operations }
    }

    /// Find an operation by name.
    pub fn find_operation(&self, name: &str) -> Option<&EffectOpDef> {
        let mut i: usize = 0;
        while i < self.operations.len() {
            if self.operations[i].name == name {
                return Some(&self.operations[i]);
            };
            i = i + 1;
        }
        None
    }
}

impl Clone for EffectDef {
    fn clone(&self) -> EffectDef {
        EffectDef {
            name: self.name.clone(),
            type_params: self.type_params.clone(),
            operations: self.operations.clone(),
        }
    }
}

/// An operation in an effect definition.
pub struct EffectOpDef {
    /// Operation name
    pub name: String,
    /// Parameter types
    pub params: [Type],
    /// Return type
    pub ret: Type,
}

impl EffectOpDef {
    pub fn new(name: String, params: [Type], ret: Type) -> EffectOpDef {
        EffectOpDef { name, params, ret }
    }
}

impl Clone for EffectOpDef {
    fn clone(&self) -> EffectOpDef {
        EffectOpDef {
            name: self.name.clone(),
            params: self.params.clone(),
            ret: self.ret.clone(),
        }
    }
}

// ============================================================
// Trait Definitions
// ============================================================

/// A trait definition.
pub struct TraitDef {
    /// Trait name
    pub name: String,
    /// Definition ID for this trait
    pub def_id: DefId,
    /// Type parameters (generics)
    pub type_params: [TyVarId],
    /// Supertraits that this trait requires
    pub supertraits: [DefId],
    /// Methods defined in this trait
    pub methods: [TraitMethodDef],
    /// Associated types
    pub assoc_types: [TraitAssocTypeDef],
}

impl TraitDef {
    /// Find a method by name.
    pub fn find_method(&self, name: &str) -> Option<&TraitMethodDef> {
        let mut i: usize = 0;
        while i < self.methods.len() {
            if self.methods[i].name == name {
                return Some(&self.methods[i]);
            };
            i = i + 1;
        }
        None
    }

    /// Find an associated type by name.
    pub fn find_assoc_type(&self, name: &str) -> Option<&TraitAssocTypeDef> {
        let mut i: usize = 0;
        while i < self.assoc_types.len() {
            if self.assoc_types[i].name == name {
                return Some(&self.assoc_types[i]);
            };
            i = i + 1;
        }
        None
    }
}

impl Clone for TraitDef {
    fn clone(&self) -> TraitDef {
        TraitDef {
            name: self.name.clone(),
            def_id: self.def_id.clone(),
            type_params: self.type_params.clone(),
            supertraits: self.supertraits.clone(),
            methods: self.methods.clone(),
            assoc_types: self.assoc_types.clone(),
        }
    }
}

/// A method signature in a trait.
pub struct TraitMethodDef {
    /// Method name
    pub name: String,
    /// Method-level type parameters
    pub type_params: [TyVarId],
    /// Parameter types (first is Self if instance method)
    pub params: [Type],
    /// Return type
    pub ret: Type,
    /// Whether this method has a default implementation
    pub has_default: bool,
}

impl Clone for TraitMethodDef {
    fn clone(&self) -> TraitMethodDef {
        TraitMethodDef {
            name: self.name.clone(),
            type_params: self.type_params.clone(),
            params: self.params.clone(),
            ret: self.ret.clone(),
            has_default: self.has_default,
        }
    }
}

/// An associated type in a trait.
pub struct TraitAssocTypeDef {
    /// Associated type name
    pub name: String,
    /// Bounds on the associated type
    pub bounds: [DefId],
    /// Default type (if any)
    pub default: Option<Type>,
}

impl Clone for TraitAssocTypeDef {
    fn clone(&self) -> TraitAssocTypeDef {
        TraitAssocTypeDef {
            name: self.name.clone(),
            bounds: self.bounds.clone(),
            default: self.default.clone(),
        }
    }
}

// ============================================================
// Trait Implementations
// ============================================================

/// A trait implementation.
pub struct ImplDef {
    /// The trait being implemented
    pub trait_id: DefId,
    /// Type parameters for this impl
    pub type_params: [TyVarId],
    /// The Self type
    pub self_ty: Type,
    /// Method implementations
    pub methods: [ImplMethodDef],
    /// Associated type definitions
    pub assoc_types: [ImplAssocTypeDef],
}

impl Clone for ImplDef {
    fn clone(&self) -> ImplDef {
        ImplDef {
            trait_id: self.trait_id.clone(),
            type_params: self.type_params.clone(),
            self_ty: self.self_ty.clone(),
            methods: self.methods.clone(),
            assoc_types: self.assoc_types.clone(),
        }
    }
}

/// A method in a trait implementation.
pub struct ImplMethodDef {
    /// Method name (must match trait method)
    pub name: String,
    /// Function definition ID
    pub fn_def_id: DefId,
}

impl Clone for ImplMethodDef {
    fn clone(&self) -> ImplMethodDef {
        ImplMethodDef {
            name: self.name.clone(),
            fn_def_id: self.fn_def_id.clone(),
        }
    }
}

/// An associated type definition in an impl.
pub struct ImplAssocTypeDef {
    /// Associated type name
    pub name: String,
    /// The concrete type
    pub ty: Type,
}

impl Clone for ImplAssocTypeDef {
    fn clone(&self) -> ImplAssocTypeDef {
        ImplAssocTypeDef {
            name: self.name.clone(),
            ty: self.ty.clone(),
        }
    }
}

// ============================================================
// Definition Registry
// ============================================================

/// Registry holding all definitions during type checking.
pub struct DefRegistry {
    /// All type definitions
    pub types: HashMap<u32, TypeDef>,
    /// All function definitions
    pub functions: HashMap<u32, FnDef>,
    /// All effect definitions
    pub effects: HashMap<u32, EffectDef>,
    /// All trait definitions
    pub traits: HashMap<u32, TraitDef>,
    /// All trait implementations
    pub impls: [ImplDef],
    /// Next definition ID
    next_id: u32,
}

impl DefRegistry {
    pub fn new() -> DefRegistry {
        DefRegistry {
            types: HashMap::new(),
            functions: HashMap::new(),
            effects: HashMap::new(),
            traits: HashMap::new(),
            impls: vec![],
            next_id: 0,
        }
    }

    /// Allocate a new definition ID.
    pub fn fresh_def_id(&mut self) -> DefId {
        let id = DefId::new(self.next_id);
        self.next_id = self.next_id + 1;
        id
    }

    /// Register a type definition.
    pub fn register_type(&mut self, id: DefId, def: TypeDef) {
        self.types.insert(id.id(), def);
    }

    /// Register a function definition.
    pub fn register_fn(&mut self, id: DefId, def: FnDef) {
        self.functions.insert(id.id(), def);
    }

    /// Register an effect definition.
    pub fn register_effect(&mut self, id: DefId, def: EffectDef) {
        self.effects.insert(id.id(), def);
    }

    /// Register a trait definition.
    pub fn register_trait(&mut self, id: DefId, def: TraitDef) {
        self.traits.insert(id.id(), def);
    }

    /// Register a trait implementation.
    pub fn register_impl(&mut self, def: ImplDef) {
        self.impls.push(def);
    }

    /// Get a type definition by ID.
    pub fn get_type(&self, id: &DefId) -> Option<&TypeDef> {
        self.types.get(&id.id());
    }

    /// Get a function definition by ID.
    pub fn get_fn(&self, id: &DefId) -> Option<&FnDef> {
        self.functions.get(&id.id());
    }

    /// Get an effect definition by ID.
    pub fn get_effect(&self, id: &DefId) -> Option<&EffectDef> {
        self.effects.get(&id.id());
    }

    /// Get a trait definition by ID.
    pub fn get_trait(&self, id: &DefId) -> Option<&TraitDef> {
        self.traits.get(&id.id());
    }

    /// Find implementations of a trait.
    pub fn find_impls(&self, trait_id: &DefId) -> [&ImplDef] {
        let mut result: [&ImplDef] = vec![];
        let mut i: usize = 0;
        while i < self.impls.len() {
            if self.impls[i].trait_id.eq(trait_id) {
                result.push(&self.impls[i]);
            };
            i = i + 1;
        }
        result
    }
}
