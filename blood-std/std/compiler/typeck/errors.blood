/// Type Error Representations for Blood Type Checker
///
/// This module defines all error types that can occur during type checking.
/// Each error variant carries sufficient information for precise diagnostics.
///
/// # Design Principles
///
/// 1. **Explicit error variants**: Every type error has a dedicated variant
/// 2. **Rich diagnostics**: Errors carry enough context for helpful messages
/// 3. **No catch-all**: No "Other" variant that hides error semantics
/// 4. **Span tracking**: Every error knows its source location

use std.compiler.parser::{Span};
use std.compiler.typeck.types::{Type, TyVarId, EffectInstance};

// ============================================================
// Type Error
// ============================================================

/// A type error with source location information.
///
/// This is the primary error type returned during type checking.
/// Each error carries both the specific kind of error and the
/// source span where the error occurred.
pub struct TypeError {
    /// The specific kind of type error
    kind: TypeErrorKind,
    /// The source location where the error occurred
    span: Span,
}

impl TypeError {
    /// Create a new type error.
    pub fn new(kind: TypeErrorKind, span: Span) -> TypeError {
        TypeError { kind, span }
    }

    /// Get the error kind.
    pub fn kind(&self) -> &TypeErrorKind {
        &self.kind
    }

    /// Get the source span.
    pub fn span(&self) -> &Span {
        &self.span
    }

    // Factory methods for common error types

    /// Create a type mismatch error.
    pub fn mismatch(expected: Type, found: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::Mismatch { expected, found }, span)
    }

    /// Create an unresolved name error.
    pub fn unresolved_name(name: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnresolvedName { name }, span)
    }

    /// Create an unresolved type error.
    pub fn unresolved_type(name: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnresolvedType { name }, span)
    }

    /// Create a wrong arity error.
    pub fn wrong_arity(expected: u32, found: u32, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::WrongArity { expected, found }, span)
    }

    /// Create an occurs check failure error.
    pub fn occurs_check(var: TyVarId, ty: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::OccursCheck { var, ty }, span)
    }

    /// Create an unhandled effect error.
    pub fn unhandled_effect(effect: EffectInstance, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnhandledEffect { effect }, span)
    }

    /// Create an invalid effect operation error.
    pub fn invalid_effect_op(effect: String, op: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::InvalidEffectOp { effect, op }, span)
    }

    /// Create a duplicate definition error.
    pub fn duplicate_definition(name: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::DuplicateDefinition { name }, span)
    }

    /// Create a missing field error.
    pub fn missing_field(struct_name: String, field: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::MissingField { struct_name, field }, span)
    }

    /// Create an unknown field error.
    pub fn unknown_field(struct_name: String, field: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnknownField { struct_name, field }, span)
    }

    /// Create a pattern mismatch error.
    pub fn pattern_mismatch(expected: Type, found: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::PatternMismatch { expected, found }, span)
    }

    /// Create a non-exhaustive patterns error.
    pub fn non_exhaustive(missing: [String], span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::NonExhaustive { missing }, span)
    }

    /// Create a cannot dereference error.
    pub fn cannot_deref(ty: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::CannotDeref { ty }, span)
    }

    /// Create a cannot call error.
    pub fn cannot_call(ty: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::CannotCall { ty }, span)
    }

    /// Create a cannot index error.
    pub fn cannot_index(ty: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::CannotIndex { ty }, span)
    }

    /// Create a not iterable error.
    pub fn not_iterable(ty: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::NotIterable { ty }, span)
    }

    /// Create a cannot access field error.
    pub fn cannot_access_field(ty: Type, field: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::CannotAccessField { ty, field }, span)
    }

    /// Create an effect mismatch error.
    pub fn effect_mismatch(expected_pure: bool, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::EffectMismatch { expected_pure }, span)
    }

    /// Create an effect row mismatch error.
    pub fn effect_row_mismatch(expected_count: u32, found_count: u32, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::EffectRowMismatch { expected_count, found_count }, span)
    }

    /// Create an effect not in row error.
    pub fn effect_not_in_row(effect: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::EffectNotInRow { effect }, span)
    }

    /// Create a tuple field not numeric error.
    pub fn tuple_field_not_numeric(field: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::TupleFieldNotNumeric { field }, span)
    }

    /// Create a tuple field out of bounds error.
    pub fn tuple_field_out_of_bounds(index: u32, tuple_len: u32, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::TupleFieldOutOfBounds { index, tuple_len }, span)
    }

    /// Create a cannot construct enum error.
    pub fn cannot_construct_enum(name: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::CannotConstructEnum { name }, span)
    }

    /// Create an enum used as value error.
    pub fn enum_used_as_value(name: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::EnumUsedAsValue { name }, span)
    }

    /// Create a module path not implemented error.
    pub fn module_path_not_implemented(span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::ModulePathNotImplemented, span)
    }

    /// Create a binary op type error.
    pub fn binary_op_type_error(op: String, left: Type, right: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::BinaryOpTypeError { op, left, right }, span)
    }

    /// Create a unary op type error.
    pub fn unary_op_type_error(op: String, operand: Type, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnaryOpTypeError { op, operand }, span)
    }

    /// Create a return outside function error.
    pub fn return_outside_function(span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::ReturnOutsideFunction, span)
    }

    /// Create a break outside loop error.
    pub fn break_outside_loop(span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::BreakOutsideLoop, span)
    }

    /// Create a continue outside loop error.
    pub fn continue_outside_loop(span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::ContinueOutsideLoop, span)
    }

    /// Create an unsupported expression error.
    pub fn unsupported_expression(description: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnsupportedExpression { description }, span)
    }

    /// Create an unsupported type syntax error.
    pub fn unsupported_type_syntax(description: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::UnsupportedTypeSyntax { description }, span)
    }

    /// Create a const evaluation error.
    pub fn const_eval_error(reason: String, span: Span) -> TypeError {
        TypeError::new(TypeErrorKind::ConstEvalError { reason }, span)
    }
}

impl Clone for TypeError {
    fn clone(&self) -> TypeError {
        TypeError {
            kind: self.kind.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// Type Error Kind
// ============================================================

/// The specific kind of type error.
///
/// Each variant represents a distinct class of type error with
/// its own diagnostic message format and recovery strategy.
pub enum TypeErrorKind {
    // --------------------------------------------------------
    // Type Mismatch Errors
    // --------------------------------------------------------

    /// Type mismatch: expected one type, found another.
    ///
    /// This is the most common type error, occurring when an expression
    /// produces a type that doesn't match what's expected by context.
    Mismatch {
        expected: Type,
        found: Type,
    },

    /// Pattern type mismatch: pattern expects different type than scrutinee.
    PatternMismatch {
        expected: Type,
        found: Type,
    },

    // --------------------------------------------------------
    // Resolution Errors
    // --------------------------------------------------------

    /// Cannot find name in scope.
    ///
    /// Occurs when referencing a variable, function, or other binding
    /// that hasn't been defined in the current scope.
    UnresolvedName {
        name: String,
    },

    /// Cannot find type in scope.
    ///
    /// Occurs when referencing a type name that hasn't been defined.
    UnresolvedType {
        name: String,
    },

    // --------------------------------------------------------
    // Arity Errors
    // --------------------------------------------------------

    /// Wrong number of type arguments or function arguments.
    WrongArity {
        expected: u32,
        found: u32,
    },

    // --------------------------------------------------------
    // Unification Errors
    // --------------------------------------------------------

    /// Occurs check failure: type variable appears in its own definition.
    ///
    /// This indicates an infinite type like `T = [T]` which cannot
    /// be represented in a finite type system.
    OccursCheck {
        var: TyVarId,
        ty: Type,
    },

    // --------------------------------------------------------
    // Effect Errors
    // --------------------------------------------------------

    /// Effect is used but not handled.
    UnhandledEffect {
        effect: EffectInstance,
    },

    /// Invalid effect operation: operation doesn't exist on effect.
    InvalidEffectOp {
        effect: String,
        op: String,
    },

    /// Effect mismatch: expected pure/effectful, found the opposite.
    EffectMismatch {
        expected_pure: bool,
    },

    /// Effect row length mismatch.
    EffectRowMismatch {
        expected_count: u32,
        found_count: u32,
    },

    /// Effect not found in effect row.
    EffectNotInRow {
        effect: String,
    },

    // --------------------------------------------------------
    // Definition Errors
    // --------------------------------------------------------

    /// Duplicate definition with the same name.
    DuplicateDefinition {
        name: String,
    },

    // --------------------------------------------------------
    // Struct/Record Errors
    // --------------------------------------------------------

    /// Missing required field in struct construction.
    MissingField {
        struct_name: String,
        field: String,
    },

    /// Unknown field in struct access or construction.
    UnknownField {
        struct_name: String,
        field: String,
    },

    /// Cannot access field on this type.
    CannotAccessField {
        ty: Type,
        field: String,
    },

    // --------------------------------------------------------
    // Pattern Errors
    // --------------------------------------------------------

    /// Non-exhaustive pattern match: some cases are not covered.
    NonExhaustive {
        missing: [String],
    },

    // --------------------------------------------------------
    // Operation Errors
    // --------------------------------------------------------

    /// Cannot dereference non-reference type.
    CannotDeref {
        ty: Type,
    },

    /// Cannot call non-function type.
    CannotCall {
        ty: Type,
    },

    /// Type does not support indexing.
    CannotIndex {
        ty: Type,
    },

    /// Type is not iterable.
    NotIterable {
        ty: Type,
    },

    // --------------------------------------------------------
    // Tuple Errors
    // --------------------------------------------------------

    /// Tuple field access must be numeric.
    TupleFieldNotNumeric {
        field: String,
    },

    /// Tuple field index out of bounds.
    TupleFieldOutOfBounds {
        index: u32,
        tuple_len: u32,
    },

    // --------------------------------------------------------
    // Enum Errors
    // --------------------------------------------------------

    /// Cannot construct enum with struct syntax.
    CannotConstructEnum {
        name: String,
    },

    /// Enum type cannot be used as value.
    EnumUsedAsValue {
        name: String,
    },

    // --------------------------------------------------------
    // Operator Errors
    // --------------------------------------------------------

    /// Binary operator not supported for these types.
    BinaryOpTypeError {
        op: String,
        left: Type,
        right: Type,
    },

    /// Unary operator not supported for this type.
    UnaryOpTypeError {
        op: String,
        operand: Type,
    },

    // --------------------------------------------------------
    // Control Flow Errors
    // --------------------------------------------------------

    /// Return statement outside of function.
    ReturnOutsideFunction,

    /// Break statement outside of loop.
    BreakOutsideLoop,

    /// Continue statement outside of loop.
    ContinueOutsideLoop,

    // --------------------------------------------------------
    // Not Yet Implemented
    // --------------------------------------------------------

    /// Module paths not yet implemented.
    ModulePathNotImplemented,

    /// Unsupported expression (with description of what's unsupported).
    UnsupportedExpression {
        description: String,
    },

    /// Unsupported type syntax (with description of what's unsupported).
    UnsupportedTypeSyntax {
        description: String,
    },

    // --------------------------------------------------------
    // Const Evaluation Errors
    // --------------------------------------------------------

    /// Const evaluation error (expression cannot be evaluated at compile time).
    ConstEvalError {
        reason: String,
    },
}

impl Clone for TypeErrorKind {
    fn clone(&self) -> TypeErrorKind {
        match self {
            TypeErrorKind::Mismatch { expected, found } => {
                TypeErrorKind::Mismatch {
                    expected: expected.clone(),
                    found: found.clone(),
                }
            }
            TypeErrorKind::PatternMismatch { expected, found } => {
                TypeErrorKind::PatternMismatch {
                    expected: expected.clone(),
                    found: found.clone(),
                }
            }
            TypeErrorKind::UnresolvedName { name } => {
                TypeErrorKind::UnresolvedName { name: name.clone() }
            }
            TypeErrorKind::UnresolvedType { name } => {
                TypeErrorKind::UnresolvedType { name: name.clone() }
            }
            TypeErrorKind::WrongArity { expected, found } => {
                TypeErrorKind::WrongArity {
                    expected: *expected,
                    found: *found,
                }
            }
            TypeErrorKind::OccursCheck { var, ty } => {
                TypeErrorKind::OccursCheck {
                    var: var.clone(),
                    ty: ty.clone(),
                }
            }
            TypeErrorKind::UnhandledEffect { effect } => {
                TypeErrorKind::UnhandledEffect { effect: effect.clone() }
            }
            TypeErrorKind::InvalidEffectOp { effect, op } => {
                TypeErrorKind::InvalidEffectOp {
                    effect: effect.clone(),
                    op: op.clone(),
                }
            }
            TypeErrorKind::EffectMismatch { expected_pure } => {
                TypeErrorKind::EffectMismatch { expected_pure: *expected_pure }
            }
            TypeErrorKind::EffectRowMismatch { expected_count, found_count } => {
                TypeErrorKind::EffectRowMismatch {
                    expected_count: *expected_count,
                    found_count: *found_count,
                }
            }
            TypeErrorKind::EffectNotInRow { effect } => {
                TypeErrorKind::EffectNotInRow { effect: effect.clone() }
            }
            TypeErrorKind::DuplicateDefinition { name } => {
                TypeErrorKind::DuplicateDefinition { name: name.clone() }
            }
            TypeErrorKind::MissingField { struct_name, field } => {
                TypeErrorKind::MissingField {
                    struct_name: struct_name.clone(),
                    field: field.clone(),
                }
            }
            TypeErrorKind::UnknownField { struct_name, field } => {
                TypeErrorKind::UnknownField {
                    struct_name: struct_name.clone(),
                    field: field.clone(),
                }
            }
            TypeErrorKind::CannotAccessField { ty, field } => {
                TypeErrorKind::CannotAccessField {
                    ty: ty.clone(),
                    field: field.clone(),
                }
            }
            TypeErrorKind::NonExhaustive { missing } => {
                TypeErrorKind::NonExhaustive { missing: missing.clone() }
            }
            TypeErrorKind::CannotDeref { ty } => {
                TypeErrorKind::CannotDeref { ty: ty.clone() }
            }
            TypeErrorKind::CannotCall { ty } => {
                TypeErrorKind::CannotCall { ty: ty.clone() }
            }
            TypeErrorKind::CannotIndex { ty } => {
                TypeErrorKind::CannotIndex { ty: ty.clone() }
            }
            TypeErrorKind::NotIterable { ty } => {
                TypeErrorKind::NotIterable { ty: ty.clone() }
            }
            TypeErrorKind::TupleFieldNotNumeric { field } => {
                TypeErrorKind::TupleFieldNotNumeric { field: field.clone() }
            }
            TypeErrorKind::TupleFieldOutOfBounds { index, tuple_len } => {
                TypeErrorKind::TupleFieldOutOfBounds {
                    index: *index,
                    tuple_len: *tuple_len,
                }
            }
            TypeErrorKind::CannotConstructEnum { name } => {
                TypeErrorKind::CannotConstructEnum { name: name.clone() }
            }
            TypeErrorKind::EnumUsedAsValue { name } => {
                TypeErrorKind::EnumUsedAsValue { name: name.clone() }
            }
            TypeErrorKind::BinaryOpTypeError { op, left, right } => {
                TypeErrorKind::BinaryOpTypeError {
                    op: op.clone(),
                    left: left.clone(),
                    right: right.clone(),
                }
            }
            TypeErrorKind::UnaryOpTypeError { op, operand } => {
                TypeErrorKind::UnaryOpTypeError {
                    op: op.clone(),
                    operand: operand.clone(),
                }
            }
            TypeErrorKind::ReturnOutsideFunction => TypeErrorKind::ReturnOutsideFunction,
            TypeErrorKind::BreakOutsideLoop => TypeErrorKind::BreakOutsideLoop,
            TypeErrorKind::ContinueOutsideLoop => TypeErrorKind::ContinueOutsideLoop,
            TypeErrorKind::ModulePathNotImplemented => TypeErrorKind::ModulePathNotImplemented,
            TypeErrorKind::UnsupportedExpression { description } => {
                TypeErrorKind::UnsupportedExpression { description: description.clone() }
            }
            TypeErrorKind::UnsupportedTypeSyntax { description } => {
                TypeErrorKind::UnsupportedTypeSyntax { description: description.clone() }
            }
            TypeErrorKind::ConstEvalError { reason } => {
                TypeErrorKind::ConstEvalError { reason: reason.clone() }
            }
        }
    }
}

// ============================================================
// Error Formatting
// ============================================================

impl TypeErrorKind {
    /// Format this error kind as a human-readable message.
    pub fn message(&self) -> String {
        match self {
            TypeErrorKind::Mismatch { expected, found } => {
                format!("type mismatch: expected {}, found {}",
                    expected.display(), found.display());
            }
            TypeErrorKind::PatternMismatch { expected, found } => {
                format!("pattern type mismatch: expected {}, found {}",
                    expected.display(), found.display());
            }
            TypeErrorKind::UnresolvedName { name } => {
                format!("cannot find value `{}` in this scope", name)
            }
            TypeErrorKind::UnresolvedType { name } => {
                format!("cannot find type `{}` in this scope", name)
            }
            TypeErrorKind::WrongArity { expected, found } => {
                format!("wrong number of arguments: expected {}, found {}", expected, found)
            }
            TypeErrorKind::OccursCheck { var, ty } => {
                format!("infinite type: type variable {:?} appears in type {}",
                    var.id(), ty.display());
            }
            TypeErrorKind::UnhandledEffect { effect } => {
                format!("unhandled effect: {:?}", effect.def_id.id())
            }
            TypeErrorKind::InvalidEffectOp { effect, op } => {
                format!("effect `{}` has no operation `{}`", effect, op)
            }
            TypeErrorKind::EffectMismatch { expected_pure } => {
                if *expected_pure {
                    "effect mismatch: expected pure, found effectful".to_string()
                } else {
                    "effect mismatch: expected effectful, found pure".to_string()
                }
            }
            TypeErrorKind::EffectRowMismatch { expected_count, found_count } => {
                format!("effect row length mismatch: expected {}, found {}",
                    expected_count, found_count)
            }
            TypeErrorKind::EffectNotInRow { effect } => {
                format!("effect `{}` not found in row", effect)
            }
            TypeErrorKind::DuplicateDefinition { name } => {
                format!("duplicate definition: `{}` is defined multiple times", name)
            }
            TypeErrorKind::MissingField { struct_name, field } => {
                format!("missing field `{}` in struct `{}`", field, struct_name)
            }
            TypeErrorKind::UnknownField { struct_name, field } => {
                format!("unknown field `{}` in struct `{}`", field, struct_name)
            }
            TypeErrorKind::CannotAccessField { ty, field } => {
                format!("cannot access field `{}` on type {}", field, ty.display())
            }
            TypeErrorKind::NonExhaustive { missing } => {
                format!("non-exhaustive patterns: missing {}", missing.join(", "))
            }
            TypeErrorKind::CannotDeref { ty } => {
                format!("cannot dereference value of type {}", ty.display())
            }
            TypeErrorKind::CannotCall { ty } => {
                format!("cannot call value of type {}", ty.display())
            }
            TypeErrorKind::CannotIndex { ty } => {
                format!("type {} does not support indexing", ty.display())
            }
            TypeErrorKind::NotIterable { ty } => {
                format!("type {} is not iterable", ty.display())
            }
            TypeErrorKind::TupleFieldNotNumeric { field } => {
                format!("tuple field access `{}` must be numeric", field)
            }
            TypeErrorKind::TupleFieldOutOfBounds { index, tuple_len } => {
                format!("tuple field index {} is out of bounds (tuple has {} elements)",
                    index, tuple_len)
            }
            TypeErrorKind::CannotConstructEnum { name } => {
                format!("cannot construct enum `{}` with struct syntax", name)
            }
            TypeErrorKind::EnumUsedAsValue { name } => {
                format!("enum type `{}` cannot be used as a value", name)
            }
            TypeErrorKind::BinaryOpTypeError { op, left, right } => {
                format!("binary operator `{}` cannot be applied to {} and {}",
                    op, left.display(), right.display())
            }
            TypeErrorKind::UnaryOpTypeError { op, operand } => {
                format!("unary operator `{}` cannot be applied to {}",
                    op, operand.display())
            }
            TypeErrorKind::ReturnOutsideFunction => {
                "return statement outside of function".to_string()
            }
            TypeErrorKind::BreakOutsideLoop => {
                "break statement outside of loop".to_string()
            }
            TypeErrorKind::ContinueOutsideLoop => {
                "continue statement outside of loop".to_string()
            }
            TypeErrorKind::ModulePathNotImplemented => {
                "module paths are not yet implemented".to_string()
            }
            TypeErrorKind::UnsupportedExpression { description } => {
                format!("unsupported expression: {}", description)
            }
            TypeErrorKind::UnsupportedTypeSyntax { description } => {
                format!("unsupported type syntax: {}", description)
            }
            TypeErrorKind::ConstEvalError { reason } => {
                format!("cannot evaluate at compile time: {}", reason)
            }
        }
    }
}

// ============================================================
// Error Collection
// ============================================================

/// A collection of type errors accumulated during type checking.
///
/// The type checker continues checking after encountering errors
/// to report as many errors as possible in a single pass.
pub struct TypeErrors {
    errors: [TypeError],
}

impl TypeErrors {
    /// Create an empty error collection.
    pub fn new() -> TypeErrors {
        TypeErrors { errors: vec![] }
    }

    /// Add an error to the collection.
    pub fn push(&mut self, error: TypeError) {
        self.errors.push(error);
    }

    /// Check if any errors have been recorded.
    pub fn has_errors(&self) -> bool {
        self.errors.len() > 0
    }

    /// Get the number of errors.
    pub fn len(&self) -> u64 {
        self.errors.len();
    }

    /// Get all errors.
    pub fn errors(&self) -> &[TypeError] {
        &self.errors
    }

    /// Convert to a Vec of errors.
    pub fn into_vec(self) -> [TypeError] {
        self.errors
    }

    /// Clear all errors.
    pub fn clear(&mut self) {
        self.errors = vec![];
    }
}

impl Clone for TypeErrors {
    fn clone(&self) -> TypeErrors {
        TypeErrors { errors: self.errors.clone() }
    }
}
