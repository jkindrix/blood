/// Effect Type Checking for Blood Type Checker
///
/// This module handles effect tracking during type checking, ensuring that
/// all effects performed by a function are either declared in its signature
/// or handled by an enclosing effect handler.
///
/// # Design Principles
///
/// 1. **Effect safety**: All effects must be declared or handled
/// 2. **Row polymorphism**: Support for open effect rows
/// 3. **Handler tracking**: Track enclosing handlers for effect resolution
///
/// # Integration with Effects Module
///
/// This module uses types from `std::compiler::effects` for row operations
/// and delegates row-level operations to that module. This module focuses
/// specifically on type-checking concerns:
///
/// - Tracking declared effects in function signatures
/// - Recording effects performed in function bodies
/// - Checking that all effects are declared or handled
/// - Managing the handler stack during type checking

use std.compiler.typeck.types::{Type, DefId};
use std.compiler.hir::{Span, Body, Expr};

// Import from the new effects module
use std.compiler.effects::{
    EffectRow,
    EffectRef,
    RowVar,
    rows_compatible,
    row_difference,
    merge_rows,
    is_subset,
    intersect_rows,
    infer_effects,
    verify_effects_subset,
    StandardEffects,
    STATE_EFFECT_ID,
    ERROR_EFFECT_ID,
    IO_EFFECT_ID,
};

// ============================================================
// Effect Instance (Type-Check Time)
// ============================================================

/// An effect instance as used during type checking.
///
/// This represents a specific use of an effect with its type arguments.
pub struct EffectInstance {
    /// The effect's definition ID
    pub def_id: DefId,
    /// Type arguments for parameterized effects (e.g., State<i32>)
    pub type_args: [Type],
    /// Source location where this effect was used
    pub span: Option<Span>,
}

impl EffectInstance {
    /// Create a new effect instance.
    pub fn new(def_id: DefId, type_args: [Type]) -> EffectInstance {
        EffectInstance {
            def_id,
            type_args,
            span: None,
        }
    }

    /// Create an effect instance with a source span.
    pub fn with_span(def_id: DefId, type_args: [Type], span: Span) -> EffectInstance {
        EffectInstance {
            def_id,
            type_args,
            span: Some(span),
        }
    }

    /// Convert to an EffectRef for row operations.
    pub fn to_effect_ref(&self) -> EffectRef {
        EffectRef::new(self.def_id.clone(), self.type_args.clone())
    }

    /// Check if this is a standard effect.
    pub fn is_standard(&self) -> bool {
        StandardEffects::is_standard_effect(self.def_id.clone())
    }

    /// Get the effect name if it's a standard effect.
    pub fn standard_name(&self) -> Option<String> {
        StandardEffects::effect_name(self.def_id.clone())
    }
}

impl Clone for EffectInstance {
    fn clone(&self) -> EffectInstance {
        EffectInstance {
            def_id: self.def_id.clone(),
            type_args: self.type_args.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// Effect Context
// ============================================================

/// Tracks effect information during type checking of a function body.
///
/// The effect context records which effects are declared in the current
/// function signature and which effects have actually been performed
/// in the function body.
pub struct EffectContext {
    /// Effects declared in the current function signature
    declared: Option<EffectRow>,
    /// Effects actually used in the function body
    used: [EffectInstance],
    /// Whether effect checking is enabled
    checking_enabled: bool,
}

impl EffectContext {
    /// Create a new empty effect context.
    pub fn new() -> EffectContext {
        EffectContext {
            declared: None,
            used: vec![],
            checking_enabled: true,
        }
    }

    /// Create an effect context with declared effects.
    pub fn with_declared(declared: Option<EffectRow>) -> EffectContext {
        EffectContext {
            declared,
            used: vec![],
            checking_enabled: true,
        }
    }

    /// Create an effect context with checking disabled (for unsafe blocks).
    pub fn unchecked() -> EffectContext {
        EffectContext {
            declared: None,
            used: vec![],
            checking_enabled: false,
        }
    }

    /// Check if effect checking is enabled.
    pub fn is_checking_enabled(&self) -> bool {
        self.checking_enabled
    }

    /// Get the declared effects.
    pub fn declared(&self) -> Option<&EffectRow> {
        self.declared.as_ref();
    }

    /// Get the used effects.
    pub fn used(&self) -> &[EffectInstance] {
        &self.used
    }

    /// Get mutable access to used effects.
    pub fn used_mut(&mut self) -> &mut [EffectInstance] {
        &mut self.used
    }

    /// Record that an effect was used.
    pub fn use_effect(&mut self, effect: EffectInstance) {
        // Avoid duplicates
        let mut i: usize = 0;
        while i < self.used.len() {
            if self.used[i].def_id.eq(&effect.def_id) {
                // Effect already recorded, check if type args match
                // For now, just skip duplicates
                return;
            };
            i = i + 1;
        };
        self.used.push(effect);
    }

    /// Record an effect use with span information.
    pub fn use_effect_at(&mut self, def_id: DefId, type_args: [Type], span: Span) {
        self.use_effect(EffectInstance::with_span(def_id, type_args, span));
    }

    /// Check if an effect is declared in the function signature.
    pub fn is_declared(&self, effect_id: &DefId) -> bool {
        match &self.declared {
            Some(row) => {
                let effects = row.effects();
                let mut i: usize = 0;
                while i < effects.len() {
                    if effects[i].def_id.eq(effect_id) {
                        return true;
                    };
                    i = i + 1;
                };
                // Also check if row is open (has row variable)
                row.row_var().is_some();
            };
            None => false,
        }
    }

    /// Check if an effect is available (declared or in an open row).
    pub fn is_effect_available(&self, effect_id: &DefId, handled: &[EffectRow]) -> bool {
        // Check if declared in current function
        if self.is_declared(effect_id) {
            return true;
        };

        // Check if handled by an enclosing handler
        let mut i: usize = 0;
        while i < handled.len() {
            let effects = handled[i].effects();
            let mut j: usize = 0;
            while j < effects.len() {
                if effects[j].def_id.eq(effect_id) {
                    return true;
                };
                j = j + 1;
            };
            i = i + 1;
        }

        false
    }

    /// Check if all used effects are declared or handled.
    ///
    /// Returns a list of unhandled effects with their source spans.
    pub fn check_effects(&self, handled: &[EffectRow]) -> [EffectInstance] {
        if !self.checking_enabled {
            return vec![];
        };

        let mut unhandled: [EffectInstance] = vec![];
        let mut i: usize = 0;
        while i < self.used.len() {
            if !self.is_effect_available(&self.used[i].def_id, handled) {
                unhandled.push(self.used[i].clone());
            };
            i = i + 1;
        }
        unhandled
    }

    /// Get the computed effect row from used effects.
    ///
    /// This is useful for inferring effect signatures.
    pub fn computed_row(&self) -> EffectRow {
        let mut refs: [EffectRef] = vec![];
        let mut i: usize = 0;
        while i < self.used.len() {
            refs.push(self.used[i].to_effect_ref());
            i = i + 1;
        }
        EffectRow::closed(refs)
    }

    /// Clear all used effects.
    pub fn clear_used(&mut self) {
        self.used = vec![];
    }

    /// Merge another context's used effects into this one.
    pub fn merge_used(&mut self, other: &EffectContext) {
        let mut i: usize = 0;
        while i < other.used.len() {
            self.use_effect(other.used[i].clone());
            i = i + 1;
        }
    }
}

impl Clone for EffectContext {
    fn clone(&self) -> EffectContext {
        EffectContext {
            declared: self.declared.clone(),
            used: self.used.clone(),
            checking_enabled: self.checking_enabled,
        }
    }
}

// ============================================================
// Effect Handler Stack
// ============================================================

/// Information about an active handler during type checking.
pub struct HandlerInfo {
    /// The effect row being handled.
    pub handled_row: EffectRow,
    /// The handler's source span.
    pub span: Option<Span>,
    /// Whether this is a shallow handler (consumed after first use).
    pub is_shallow: bool,
}

impl HandlerInfo {
    /// Create a new handler info.
    pub fn new(handled_row: EffectRow) -> HandlerInfo {
        HandlerInfo {
            handled_row,
            span: None,
            is_shallow: false,
        }
    }

    /// Create a handler info with span.
    pub fn with_span(handled_row: EffectRow, span: Span) -> HandlerInfo {
        HandlerInfo {
            handled_row,
            span: Some(span),
            is_shallow: false,
        }
    }

    /// Mark this handler as shallow.
    pub fn shallow(mut self) -> HandlerInfo {
        self.is_shallow = true;
        self
    }
}

impl Clone for HandlerInfo {
    fn clone(&self) -> HandlerInfo {
        HandlerInfo {
            handled_row: self.handled_row.clone(),
            span: self.span.clone(),
            is_shallow: self.is_shallow,
        }
    }
}

/// A stack of effect handlers for tracking handled effects.
///
/// When entering an effect handler block, we push the handled effects
/// onto this stack. Effects performed within the handler can use any
/// effect in the stack (they're handled by enclosing handlers).
pub struct HandlerStack {
    /// Stack of handler information
    handlers: [HandlerInfo],
}

impl HandlerStack {
    /// Create an empty handler stack.
    pub fn new() -> HandlerStack {
        HandlerStack { handlers: vec![] }
    }

    /// Push a handler onto the stack.
    pub fn push(&mut self, info: HandlerInfo) {
        self.handlers.push(info);
    }

    /// Push a handler with just an effect row.
    pub fn push_row(&mut self, row: EffectRow) {
        self.handlers.push(HandlerInfo::new(row));
    }

    /// Pop a handler from the stack.
    pub fn pop(&mut self) -> Option<HandlerInfo> {
        if self.handlers.len() > 0 {
            let idx = self.handlers.len() - 1;
            Some(self.handlers.remove(idx))
        } else {
            None
        }
    }

    /// Get the number of handlers on the stack.
    pub fn len(&self) -> usize {
        self.handlers.len();
    }

    /// Check if the stack is empty.
    pub fn is_empty(&self) -> bool {
        self.handlers.len() == 0
    }

    /// Get all handler infos.
    pub fn all(&self) -> &[HandlerInfo] {
        &self.handlers
    }

    /// Get all handled effect rows.
    pub fn all_rows(&self) -> [EffectRow] {
        let mut rows: [EffectRow] = vec![];
        let mut i: usize = 0;
        while i < self.handlers.len() {
            rows.push(self.handlers[i].handled_row.clone());
            i = i + 1;
        }
        rows
    }

    /// Check if an effect is handled by any handler in the stack.
    pub fn handles(&self, effect_id: &DefId) -> bool {
        let mut i: usize = 0;
        while i < self.handlers.len() {
            let effects = self.handlers[i].handled_row.effects();
            let mut j: usize = 0;
            while j < effects.len() {
                if effects[j].def_id.eq(effect_id) {
                    return true;
                };
                j = j + 1;
            };
            i = i + 1;
        }
        false
    }

    /// Find the handler that handles a specific effect.
    ///
    /// Returns the innermost (most recent) handler that handles the effect.
    pub fn find_handler(&self, effect_id: &DefId) -> Option<&HandlerInfo> {
        let mut i: usize = self.handlers.len();
        while i > 0 {
            i = i - 1;
            let effects = self.handlers[i].handled_row.effects();
            let mut j: usize = 0;
            while j < effects.len() {
                if effects[j].def_id.eq(effect_id) {
                    return Some(&self.handlers[i]);
                };
                j = j + 1;
            }
        }
        None
    }

    /// Get the handler depth for an effect.
    ///
    /// Returns None if the effect is not handled.
    pub fn handler_depth(&self, effect_id: &DefId) -> Option<usize> {
        let mut i: usize = self.handlers.len();
        while i > 0 {
            i = i - 1;
            let effects = self.handlers[i].handled_row.effects();
            let mut j: usize = 0;
            while j < effects.len() {
                if effects[j].def_id.eq(effect_id) {
                    return Some(self.handlers.len() - i - 1);
                };
                j = j + 1;
            }
        }
        None
    }

    /// Get all effects currently handled.
    pub fn all_handled_effects(&self) -> [EffectRef] {
        let mut all: [EffectRef] = vec![];
        let mut i: usize = 0;
        while i < self.handlers.len() {
            let effects = self.handlers[i].handled_row.effects();
            let mut j: usize = 0;
            while j < effects.len() {
                // Check for duplicates
                let mut found = false;
                let mut k: usize = 0;
                while k < all.len() {
                    if all[k].def_id.eq(&effects[j].def_id) {
                        found = true;
                        break;
                    };
                    k = k + 1;
                };
                if !found {
                    all.push(effects[j].clone());
                };
                j = j + 1;
            };
            i = i + 1;
        }
        all
    }
}

impl Clone for HandlerStack {
    fn clone(&self) -> HandlerStack {
        HandlerStack {
            handlers: self.handlers.clone(),
        }
    }
}

// ============================================================
// Effect Checking Utilities
// ============================================================

/// Check if two effect rows are compatible.
///
/// Delegates to the effects module's rows_compatible function.
pub fn effect_rows_compatible(r1: &EffectRow, r2: &EffectRow) -> bool {
    rows_compatible(r1, r2)
}

/// Compute the difference between two effect rows.
///
/// Returns the effects in `source` that are not in `target`.
/// Delegates to the effects module's row_difference function.
pub fn effect_row_diff(source: &EffectRow, target: &EffectRow) -> EffectRow {
    row_difference(source, target)
}

/// Merge two effect rows, combining their effects.
///
/// Delegates to the effects module's merge_rows function.
pub fn merge_effect_rows(r1: &EffectRow, r2: &EffectRow) -> EffectRow {
    merge_rows(r1, r2)
}

/// Check if an effect row is a subset of another.
///
/// Delegates to the effects module's is_subset function.
pub fn effect_row_subset(subset: &EffectRow, superset: &EffectRow) -> bool {
    is_subset(subset, superset)
}

/// Check if an effect instance is in a list of effect refs.
fn effect_in_refs(effect: &EffectInstance, refs: &[EffectRef]) -> bool {
    let mut i: usize = 0;
    while i < refs.len() {
        if refs[i].def_id.eq(&effect.def_id) {
            return true;
        };
        i = i + 1;
    }
    false
}

// ============================================================
// Effect Type Checking
// ============================================================

/// Result of effect checking.
pub struct EffectCheckResult {
    /// Whether the check passed.
    pub success: bool,
    /// Unhandled effects (if any).
    pub unhandled: [EffectInstance],
    /// Inferred effect row.
    pub inferred: EffectRow,
}

impl EffectCheckResult {
    /// Create a successful result.
    pub fn ok(inferred: EffectRow) -> EffectCheckResult {
        EffectCheckResult {
            success: true,
            unhandled: vec![],
            inferred,
        }
    }

    /// Create a failed result with unhandled effects.
    pub fn fail(unhandled: [EffectInstance], inferred: EffectRow) -> EffectCheckResult {
        EffectCheckResult {
            success: false,
            unhandled,
            inferred,
        }
    }
}

/// Effect type checker that coordinates effect context and handler stack.
pub struct EffectChecker {
    /// Current effect context.
    context: EffectContext,
    /// Handler stack.
    handlers: HandlerStack,
}

impl EffectChecker {
    /// Create a new effect checker.
    pub fn new() -> EffectChecker {
        EffectChecker {
            context: EffectContext::new(),
            handlers: HandlerStack::new(),
        }
    }

    /// Create an effect checker with declared effects.
    pub fn with_declared(declared: Option<EffectRow>) -> EffectChecker {
        EffectChecker {
            context: EffectContext::with_declared(declared),
            handlers: HandlerStack::new(),
        }
    }

    /// Get the effect context.
    pub fn context(&self) -> &EffectContext {
        &self.context
    }

    /// Get mutable access to the effect context.
    pub fn context_mut(&mut self) -> &mut EffectContext {
        &mut self.context
    }

    /// Get the handler stack.
    pub fn handlers(&self) -> &HandlerStack {
        &self.handlers
    }

    /// Get mutable access to the handler stack.
    pub fn handlers_mut(&mut self) -> &mut HandlerStack {
        &mut self.handlers
    }

    /// Record an effect use.
    pub fn use_effect(&mut self, effect: EffectInstance) {
        self.context.use_effect(effect);
    }

    /// Record an effect use with span.
    pub fn use_effect_at(&mut self, def_id: DefId, type_args: [Type], span: Span) {
        self.context.use_effect_at(def_id, type_args, span);
    }

    /// Enter a handler scope.
    pub fn enter_handler(&mut self, handled: EffectRow) {
        self.handlers.push_row(handled);
    }

    /// Enter a handler scope with info.
    pub fn enter_handler_with_info(&mut self, info: HandlerInfo) {
        self.handlers.push(info);
    }

    /// Exit a handler scope.
    pub fn exit_handler(&mut self) -> Option<HandlerInfo> {
        self.handlers.pop();
    }

    /// Check if an effect is available.
    pub fn is_effect_available(&self, effect_id: &DefId) -> bool {
        self.context.is_effect_available(effect_id, &self.handlers.all_rows());
    }

    /// Perform final effect checking.
    pub fn check(&self) -> EffectCheckResult {
        let unhandled = self.context.check_effects(&self.handlers.all_rows());
        let inferred = self.context.computed_row();

        if unhandled.is_empty() {
            EffectCheckResult::ok(inferred)
        } else {
            EffectCheckResult::fail(unhandled, inferred)
        }
    }

    /// Verify that inferred effects match declared effects.
    pub fn verify_signature(&self, declared: &EffectRow) -> bool {
        let inferred = self.context.computed_row();
        is_subset(&inferred, declared)
    }
}

// ============================================================
// Integration with Effect Inference
// ============================================================

/// Infer effects for a function body using the effects module.
///
/// This delegates to the effects module's inference system for
/// more comprehensive effect inference.
pub fn infer_body_effects(body: &Body) -> EffectRow {
    infer_effects(body)
}

/// Verify that inferred effects are a subset of declared effects.
pub fn verify_declared_effects(inferred: &EffectRow, declared: &EffectRow) -> bool {
    verify_effects_subset(inferred, declared)
}
