/// Expression Type Checking for Blood Type Checker
///
/// This module provides infrastructure and utilities for type checking expressions.
/// It includes operator type checking, literal inference, and expression context tracking.
///
/// # Design Principles
///
/// 1. **No catch-all patterns**: Every expression kind is explicitly handled
/// 2. **Proper error types**: Use specific TypeErrorKind variants, not generic "Other"
/// 3. **Clear context**: Track return types, loop types, and effect contexts
/// 4. **Separation of concerns**: Expression utilities separate from main checker

use super.types::{
    Type, TypeKind, DefId, TyVarId, PrimitiveTy, Mutability, Ownership,
    EffectRow, EffectInstance, RecordField,
};
use super.errors::{TypeError, TypeErrorKind};
use super.effects::EffectContext;

// ============================================================
// Binary Operators
// ============================================================

/// Classification of binary operators for type checking.
pub enum BinOpCategory {
    /// Arithmetic: +, -, *, /, %
    Arithmetic,
    /// Comparison: ==, !=, <, >, <=, >=
    Comparison,
    /// Logical: &&, ||
    Logical,
    /// Bitwise: &, |, ^, <<, >>
    Bitwise,
    /// Assignment: =, +=, -=, etc.
    Assignment,
}

/// A binary operator in Blood.
pub enum BinOp {
    // Arithmetic
    Add,      // +
    Sub,      // -
    Mul,      // *
    Div,      // /
    Rem,      // %
    // Comparison
    Eq,       // ==
    Ne,       // !=
    Lt,       // <
    Le,       // <=
    Gt,       // >
    Ge,       // >=
    // Logical
    And,      // &&
    Or,       // ||
    // Bitwise
    BitAnd,   // &
    BitOr,    // |
    BitXor,   // ^
    Shl,      // <<
    Shr,      // >>
    // Assignment
    Assign,   // =
    AddAssign, // +=
    SubAssign, // -=
    MulAssign, // *=
    DivAssign, // /=
    RemAssign, // %=
    BitAndAssign, // &=
    BitOrAssign,  // |=
    BitXorAssign, // ^=
    ShlAssign, // <<=
    ShrAssign, // >>=
}

impl BinOp {
    /// Get the category of this operator.
    pub fn category(&self) -> BinOpCategory {
        match self {
            BinOp::Add => BinOpCategory::Arithmetic,
            BinOp::Sub => BinOpCategory::Arithmetic,
            BinOp::Mul => BinOpCategory::Arithmetic,
            BinOp::Div => BinOpCategory::Arithmetic,
            BinOp::Rem => BinOpCategory::Arithmetic,
            BinOp::Eq => BinOpCategory::Comparison,
            BinOp::Ne => BinOpCategory::Comparison,
            BinOp::Lt => BinOpCategory::Comparison,
            BinOp::Le => BinOpCategory::Comparison,
            BinOp::Gt => BinOpCategory::Comparison,
            BinOp::Ge => BinOpCategory::Comparison,
            BinOp::And => BinOpCategory::Logical,
            BinOp::Or => BinOpCategory::Logical,
            BinOp::BitAnd => BinOpCategory::Bitwise,
            BinOp::BitOr => BinOpCategory::Bitwise,
            BinOp::BitXor => BinOpCategory::Bitwise,
            BinOp::Shl => BinOpCategory::Bitwise,
            BinOp::Shr => BinOpCategory::Bitwise,
            BinOp::Assign => BinOpCategory::Assignment,
            BinOp::AddAssign => BinOpCategory::Assignment,
            BinOp::SubAssign => BinOpCategory::Assignment,
            BinOp::MulAssign => BinOpCategory::Assignment,
            BinOp::DivAssign => BinOpCategory::Assignment,
            BinOp::RemAssign => BinOpCategory::Assignment,
            BinOp::BitAndAssign => BinOpCategory::Assignment,
            BinOp::BitOrAssign => BinOpCategory::Assignment,
            BinOp::BitXorAssign => BinOpCategory::Assignment,
            BinOp::ShlAssign => BinOpCategory::Assignment,
            BinOp::ShrAssign => BinOpCategory::Assignment,
        }
    }

    /// Get the name of this operator for error messages.
    pub fn name(&self) -> &str {
        match self {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Rem => "%",
            BinOp::Eq => "==",
            BinOp::Ne => "!=",
            BinOp::Lt => "<",
            BinOp::Le => "<=",
            BinOp::Gt => ">",
            BinOp::Ge => ">=",
            BinOp::And => "&&",
            BinOp::Or => "||",
            BinOp::BitAnd => "&",
            BinOp::BitOr => "|",
            BinOp::BitXor => "^",
            BinOp::Shl => "<<",
            BinOp::Shr => ">>",
            BinOp::Assign => "=",
            BinOp::AddAssign => "+=",
            BinOp::SubAssign => "-=",
            BinOp::MulAssign => "*=",
            BinOp::DivAssign => "/=",
            BinOp::RemAssign => "%=",
            BinOp::BitAndAssign => "&=",
            BinOp::BitOrAssign => "|=",
            BinOp::BitXorAssign => "^=",
            BinOp::ShlAssign => "<<=",
            BinOp::ShrAssign => ">>=",
        }
    }

    /// Check if this operator is a comparison (returns bool).
    pub fn is_comparison(&self) -> bool {
        match self {
            BinOp::Eq => true,
            BinOp::Ne => true,
            BinOp::Lt => true,
            BinOp::Le => true,
            BinOp::Gt => true,
            BinOp::Ge => true,
            BinOp::Add => false,
            BinOp::Sub => false,
            BinOp::Mul => false,
            BinOp::Div => false,
            BinOp::Rem => false,
            BinOp::And => false,
            BinOp::Or => false,
            BinOp::BitAnd => false,
            BinOp::BitOr => false,
            BinOp::BitXor => false,
            BinOp::Shl => false,
            BinOp::Shr => false,
            BinOp::Assign => false,
            BinOp::AddAssign => false,
            BinOp::SubAssign => false,
            BinOp::MulAssign => false,
            BinOp::DivAssign => false,
            BinOp::RemAssign => false,
            BinOp::BitAndAssign => false,
            BinOp::BitOrAssign => false,
            BinOp::BitXorAssign => false,
            BinOp::ShlAssign => false,
            BinOp::ShrAssign => false,
        }
    }

    /// Check if this is a logical operator (requires bool operands).
    pub fn is_logical(&self) -> bool {
        match self {
            BinOp::And => true,
            BinOp::Or => true,
            BinOp::Eq => false,
            BinOp::Ne => false,
            BinOp::Lt => false,
            BinOp::Le => false,
            BinOp::Gt => false,
            BinOp::Ge => false,
            BinOp::Add => false,
            BinOp::Sub => false,
            BinOp::Mul => false,
            BinOp::Div => false,
            BinOp::Rem => false,
            BinOp::BitAnd => false,
            BinOp::BitOr => false,
            BinOp::BitXor => false,
            BinOp::Shl => false,
            BinOp::Shr => false,
            BinOp::Assign => false,
            BinOp::AddAssign => false,
            BinOp::SubAssign => false,
            BinOp::MulAssign => false,
            BinOp::DivAssign => false,
            BinOp::RemAssign => false,
            BinOp::BitAndAssign => false,
            BinOp::BitOrAssign => false,
            BinOp::BitXorAssign => false,
            BinOp::ShlAssign => false,
            BinOp::ShrAssign => false,
        }
    }

    /// Check if this is an assignment operator.
    pub fn is_assignment(&self) -> bool {
        match self {
            BinOp::Assign => true,
            BinOp::AddAssign => true,
            BinOp::SubAssign => true,
            BinOp::MulAssign => true,
            BinOp::DivAssign => true,
            BinOp::RemAssign => true,
            BinOp::BitAndAssign => true,
            BinOp::BitOrAssign => true,
            BinOp::BitXorAssign => true,
            BinOp::ShlAssign => true,
            BinOp::ShrAssign => true,
            BinOp::Add => false,
            BinOp::Sub => false,
            BinOp::Mul => false,
            BinOp::Div => false,
            BinOp::Rem => false,
            BinOp::Eq => false,
            BinOp::Ne => false,
            BinOp::Lt => false,
            BinOp::Le => false,
            BinOp::Gt => false,
            BinOp::Ge => false,
            BinOp::And => false,
            BinOp::Or => false,
            BinOp::BitAnd => false,
            BinOp::BitOr => false,
            BinOp::BitXor => false,
            BinOp::Shl => false,
            BinOp::Shr => false,
        }
    }
}

impl Clone for BinOp {
    fn clone(&self) -> BinOp {
        match self {
            BinOp::Add => BinOp::Add,
            BinOp::Sub => BinOp::Sub,
            BinOp::Mul => BinOp::Mul,
            BinOp::Div => BinOp::Div,
            BinOp::Rem => BinOp::Rem,
            BinOp::Eq => BinOp::Eq,
            BinOp::Ne => BinOp::Ne,
            BinOp::Lt => BinOp::Lt,
            BinOp::Le => BinOp::Le,
            BinOp::Gt => BinOp::Gt,
            BinOp::Ge => BinOp::Ge,
            BinOp::And => BinOp::And,
            BinOp::Or => BinOp::Or,
            BinOp::BitAnd => BinOp::BitAnd,
            BinOp::BitOr => BinOp::BitOr,
            BinOp::BitXor => BinOp::BitXor,
            BinOp::Shl => BinOp::Shl,
            BinOp::Shr => BinOp::Shr,
            BinOp::Assign => BinOp::Assign,
            BinOp::AddAssign => BinOp::AddAssign,
            BinOp::SubAssign => BinOp::SubAssign,
            BinOp::MulAssign => BinOp::MulAssign,
            BinOp::DivAssign => BinOp::DivAssign,
            BinOp::RemAssign => BinOp::RemAssign,
            BinOp::BitAndAssign => BinOp::BitAndAssign,
            BinOp::BitOrAssign => BinOp::BitOrAssign,
            BinOp::BitXorAssign => BinOp::BitXorAssign,
            BinOp::ShlAssign => BinOp::ShlAssign,
            BinOp::ShrAssign => BinOp::ShrAssign,
        }
    }
}

impl Clone for BinOpCategory {
    fn clone(&self) -> BinOpCategory {
        match self {
            BinOpCategory::Arithmetic => BinOpCategory::Arithmetic,
            BinOpCategory::Comparison => BinOpCategory::Comparison,
            BinOpCategory::Logical => BinOpCategory::Logical,
            BinOpCategory::Bitwise => BinOpCategory::Bitwise,
            BinOpCategory::Assignment => BinOpCategory::Assignment,
        }
    }
}

// ============================================================
// Unary Operators
// ============================================================

/// A unary operator in Blood.
pub enum UnaryOp {
    /// Negation: -x
    Neg,
    /// Logical not: !x
    Not,
    /// Bitwise not: ~x
    BitNot,
    /// Dereference: *x
    Deref,
    /// Reference: &x
    Ref,
    /// Mutable reference: &mut x
    RefMut,
}

impl UnaryOp {
    /// Get the name of this operator for error messages.
    pub fn name(&self) -> &str {
        match self {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
            UnaryOp::BitNot => "~",
            UnaryOp::Deref => "*",
            UnaryOp::Ref => "&",
            UnaryOp::RefMut => "&mut",
        }
    }

    /// Check if this operator requires a numeric operand.
    pub fn requires_numeric(&self) -> bool {
        match self {
            UnaryOp::Neg => true,
            UnaryOp::Not => false,
            UnaryOp::BitNot => true,
            UnaryOp::Deref => false,
            UnaryOp::Ref => false,
            UnaryOp::RefMut => false,
        }
    }
}

impl Clone for UnaryOp {
    fn clone(&self) -> UnaryOp {
        match self {
            UnaryOp::Neg => UnaryOp::Neg,
            UnaryOp::Not => UnaryOp::Not,
            UnaryOp::BitNot => UnaryOp::BitNot,
            UnaryOp::Deref => UnaryOp::Deref,
            UnaryOp::Ref => UnaryOp::Ref,
            UnaryOp::RefMut => UnaryOp::RefMut,
        }
    }
}

// ============================================================
// Literal Types
// ============================================================

/// Classification of literals for type inference.
pub enum LiteralKind {
    /// Integer literal: 42, 0xFF, 0b1010
    Integer {
        value: i128,
        suffix: Option<IntSuffix>,
    },
    /// Float literal: 3.14, 1e10
    Float {
        value: f64,
        suffix: Option<FloatSuffix>,
    },
    /// Boolean literal: true, false
    Bool(bool),
    /// Character literal: 'a', '\n'
    Char(char),
    /// String literal: "hello"
    String(String),
    /// Byte literal: b'a'
    Byte(u8),
    /// Byte string literal: b"hello"
    ByteString([u8]),
}

/// Integer literal suffix.
pub enum IntSuffix {
    I8,
    I16,
    I32,
    I64,
    I128,
    Isize,
    U8,
    U16,
    U32,
    U64,
    U128,
    Usize,
}

/// Float literal suffix.
pub enum FloatSuffix {
    F32,
    F64,
}

impl IntSuffix {
    /// Convert to the corresponding primitive type.
    pub fn to_primitive(&self) -> PrimitiveTy {
        match self {
            IntSuffix::I8 => PrimitiveTy::I8,
            IntSuffix::I16 => PrimitiveTy::I16,
            IntSuffix::I32 => PrimitiveTy::I32,
            IntSuffix::I64 => PrimitiveTy::I64,
            IntSuffix::I128 => PrimitiveTy::I128,
            IntSuffix::Isize => PrimitiveTy::Isize,
            IntSuffix::U8 => PrimitiveTy::U8,
            IntSuffix::U16 => PrimitiveTy::U16,
            IntSuffix::U32 => PrimitiveTy::U32,
            IntSuffix::U64 => PrimitiveTy::U64,
            IntSuffix::U128 => PrimitiveTy::U128,
            IntSuffix::Usize => PrimitiveTy::Usize,
        }
    }
}

impl FloatSuffix {
    /// Convert to the corresponding primitive type.
    pub fn to_primitive(&self) -> PrimitiveTy {
        match self {
            FloatSuffix::F32 => PrimitiveTy::F32,
            FloatSuffix::F64 => PrimitiveTy::F64,
        }
    }
}

impl Clone for LiteralKind {
    fn clone(&self) -> LiteralKind {
        match self {
            LiteralKind::Integer { value, suffix } => LiteralKind::Integer {
                value: *value,
                suffix: suffix.clone(),
            },
            LiteralKind::Float { value, suffix } => LiteralKind::Float {
                value: *value,
                suffix: suffix.clone(),
            },
            LiteralKind::Bool(b) => LiteralKind::Bool(*b),
            LiteralKind::Char(c) => LiteralKind::Char(*c),
            LiteralKind::String(s) => LiteralKind::String(s.clone()),
            LiteralKind::Byte(b) => LiteralKind::Byte(*b),
            LiteralKind::ByteString(bs) => LiteralKind::ByteString(bs.clone()),
        }
    }
}

impl Clone for IntSuffix {
    fn clone(&self) -> IntSuffix {
        match self {
            IntSuffix::I8 => IntSuffix::I8,
            IntSuffix::I16 => IntSuffix::I16,
            IntSuffix::I32 => IntSuffix::I32,
            IntSuffix::I64 => IntSuffix::I64,
            IntSuffix::I128 => IntSuffix::I128,
            IntSuffix::Isize => IntSuffix::Isize,
            IntSuffix::U8 => IntSuffix::U8,
            IntSuffix::U16 => IntSuffix::U16,
            IntSuffix::U32 => IntSuffix::U32,
            IntSuffix::U64 => IntSuffix::U64,
            IntSuffix::U128 => IntSuffix::U128,
            IntSuffix::Usize => IntSuffix::Usize,
        }
    }
}

impl Clone for FloatSuffix {
    fn clone(&self) -> FloatSuffix {
        match self {
            FloatSuffix::F32 => FloatSuffix::F32,
            FloatSuffix::F64 => FloatSuffix::F64,
        }
    }
}

// ============================================================
// Expression Context
// ============================================================

/// Context for expression type checking.
///
/// This tracks the current function's return type, whether we're in a loop,
/// and the expected types from context (for bidirectional type checking).
pub struct ExprContext {
    /// Expected return type of the current function
    return_type: Option<Type>,
    /// Expected type from enclosing loop (for break with value)
    loop_type: Option<Type>,
    /// Current loop depth (for break/continue validation)
    loop_depth: u32,
    /// Effect context for tracking effect usage
    effect_context: EffectContext,
    /// Stack of handled effect rows
    handled_effects: [EffectRow],
    /// Expected type from context (for bidirectional checking)
    expected_type: Option<Type>,
}

impl ExprContext {
    /// Create a new empty expression context.
    pub fn new() -> ExprContext {
        ExprContext {
            return_type: None,
            loop_type: None,
            loop_depth: 0,
            effect_context: EffectContext::new(),
            handled_effects: vec![],
            expected_type: None,
        }
    }

    /// Create a context for a function with the given return type and effects.
    pub fn for_function(return_type: Type, declared_effects: Option<EffectRow>) -> ExprContext {
        ExprContext {
            return_type: Some(return_type),
            loop_type: None,
            loop_depth: 0,
            effect_context: EffectContext::with_declared(declared_effects),
            handled_effects: vec![],
            expected_type: None,
        }
    }

    /// Get the current return type.
    pub fn return_type(&self) -> Option<&Type> {
        self.return_type.as_ref();
    }

    /// Get the current loop type.
    pub fn loop_type(&self) -> Option<&Type> {
        self.loop_type.as_ref();
    }

    /// Check if we're inside a loop.
    pub fn in_loop(&self) -> bool {
        self.loop_depth > 0
    }

    /// Get the loop depth.
    pub fn loop_depth(&self) -> u32 {
        self.loop_depth
    }

    /// Get the effect context.
    pub fn effect_context(&self) -> &EffectContext {
        &self.effect_context
    }

    /// Get a mutable reference to the effect context.
    pub fn effect_context_mut(&mut self) -> &mut EffectContext {
        &mut self.effect_context
    }

    /// Get the handled effects stack.
    pub fn handled_effects(&self) -> &[EffectRow] {
        &self.handled_effects
    }

    /// Get the expected type.
    pub fn expected_type(&self) -> Option<&Type> {
        self.expected_type.as_ref();
    }

    /// Enter a loop context.
    pub fn enter_loop(&mut self, loop_type: Option<Type>) {
        self.loop_depth = self.loop_depth + 1;
        if loop_type.is_some() {
            self.loop_type = loop_type;
        }
    }

    /// Exit a loop context.
    pub fn exit_loop(&mut self) {
        if self.loop_depth > 0 {
            self.loop_depth = self.loop_depth - 1;
        };
        if self.loop_depth == 0 {
            self.loop_type = None;
        }
    }

    /// Push handled effects onto the stack.
    pub fn push_handled(&mut self, row: EffectRow) {
        self.handled_effects.push(row);
    }

    /// Pop handled effects from the stack.
    pub fn pop_handled(&mut self) -> Option<EffectRow> {
        if self.handled_effects.len() > 0 {
            let idx = self.handled_effects.len() - 1;
            Some(self.handled_effects.remove(idx))
        } else {
            None
        }
    }

    /// Set the expected type for bidirectional checking.
    pub fn with_expected(&mut self, ty: Type) {
        self.expected_type = Some(ty);
    }

    /// Clear the expected type.
    pub fn clear_expected(&mut self) {
        self.expected_type = None;
    }
}

impl Clone for ExprContext {
    fn clone(&self) -> ExprContext {
        ExprContext {
            return_type: self.return_type.clone(),
            loop_type: self.loop_type.clone(),
            loop_depth: self.loop_depth,
            effect_context: self.effect_context.clone(),
            handled_effects: self.handled_effects.clone(),
            expected_type: self.expected_type.clone(),
        }
    }
}

// ============================================================
// Operator Type Checking Utilities
// ============================================================

/// Check if a type supports arithmetic operations.
pub fn supports_arithmetic(ty: &Type) -> bool {
    match ty.kind() {
        TypeKind::Primitive(p) => p.is_numeric(),
        TypeKind::Infer(_) => true, // Defer to unification
        TypeKind::Error => true, // Error recovery
        TypeKind::Never => false,
        TypeKind::Tuple(_) => false,
        TypeKind::Array { element: _, size: _ } => false,
        TypeKind::Slice { element: _ } => false,
        TypeKind::Ref { inner: _, mutability: _ } => false,
        TypeKind::Ptr { inner: _, mutability: _ } => false,
        TypeKind::Fn { params: _, ret: _, effect: _ } => false,
        TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
        TypeKind::Adt { def_id: _, type_args: _ } => false, // Could check for operator trait
        TypeKind::Range { element: _, inclusive: _ } => false,
        TypeKind::DynTrait { trait_id: _ } => false,
        TypeKind::Record { fields: _, row_var: _ } => false,
        TypeKind::Forall { params: _, body: _ } => false,
        TypeKind::Param(_) => true, // Could be constrained
        TypeKind::Ownership { inner, ownership: _ } => supports_arithmetic(inner),
    }
}

/// Check if a type supports comparison operations.
pub fn supports_comparison(ty: &Type) -> bool {
    match ty.kind() {
        TypeKind::Primitive(p) => {
            match p {
                PrimitiveTy::I8 => true,
                PrimitiveTy::I16 => true,
                PrimitiveTy::I32 => true,
                PrimitiveTy::I64 => true,
                PrimitiveTy::I128 => true,
                PrimitiveTy::Isize => true,
                PrimitiveTy::U8 => true,
                PrimitiveTy::U16 => true,
                PrimitiveTy::U32 => true,
                PrimitiveTy::U64 => true,
                PrimitiveTy::U128 => true,
                PrimitiveTy::Usize => true,
                PrimitiveTy::F32 => true,
                PrimitiveTy::F64 => true,
                PrimitiveTy::Bool => true,
                PrimitiveTy::Char => true,
                PrimitiveTy::Str => true,
                PrimitiveTy::Unit => true,
            }
        }
        TypeKind::Infer(_) => true,
        TypeKind::Error => true,
        TypeKind::Never => false,
        TypeKind::Tuple(_) => true, // Structural comparison
        TypeKind::Array { element: _, size: _ } => true, // Element-wise
        TypeKind::Slice { element: _ } => true,
        TypeKind::Ref { inner, mutability: _ } => supports_comparison(inner),
        TypeKind::Ptr { inner: _, mutability: _ } => true, // Pointer comparison
        TypeKind::Fn { params: _, ret: _, effect: _ } => false,
        TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
        TypeKind::Adt { def_id: _, type_args: _ } => true, // Could derive
        TypeKind::Range { element: _, inclusive: _ } => false,
        TypeKind::DynTrait { trait_id: _ } => false,
        TypeKind::Record { fields: _, row_var: _ } => true,
        TypeKind::Forall { params: _, body: _ } => false,
        TypeKind::Param(_) => true,
        TypeKind::Ownership { inner, ownership: _ } => supports_comparison(inner),
    }
}

/// Check if a type supports bitwise operations.
pub fn supports_bitwise(ty: &Type) -> bool {
    match ty.kind() {
        TypeKind::Primitive(p) => p.is_integer(),
        TypeKind::Infer(_) => true,
        TypeKind::Error => true,
        TypeKind::Never => false,
        TypeKind::Tuple(_) => false,
        TypeKind::Array { element: _, size: _ } => false,
        TypeKind::Slice { element: _ } => false,
        TypeKind::Ref { inner: _, mutability: _ } => false,
        TypeKind::Ptr { inner: _, mutability: _ } => false,
        TypeKind::Fn { params: _, ret: _, effect: _ } => false,
        TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => false,
        TypeKind::Adt { def_id: _, type_args: _ } => false,
        TypeKind::Range { element: _, inclusive: _ } => false,
        TypeKind::DynTrait { trait_id: _ } => false,
        TypeKind::Record { fields: _, row_var: _ } => false,
        TypeKind::Forall { params: _, body: _ } => false,
        TypeKind::Param(_) => true,
        TypeKind::Ownership { inner, ownership: _ } => supports_bitwise(inner),
    }
}

/// Get the result type of a binary operation.
///
/// Returns the expected result type given the operator and operand types.
pub fn binary_result_type(op: &BinOp, left: &Type, right: &Type) -> Type {
    match op {
        // Comparison operators always return bool
        BinOp::Eq => Type::bool(),
        BinOp::Ne => Type::bool(),
        BinOp::Lt => Type::bool(),
        BinOp::Le => Type::bool(),
        BinOp::Gt => Type::bool(),
        BinOp::Ge => Type::bool(),

        // Logical operators return bool
        BinOp::And => Type::bool(),
        BinOp::Or => Type::bool(),

        // Arithmetic and bitwise return the common type
        BinOp::Add => left.clone(),
        BinOp::Sub => left.clone(),
        BinOp::Mul => left.clone(),
        BinOp::Div => left.clone(),
        BinOp::Rem => left.clone(),
        BinOp::BitAnd => left.clone(),
        BinOp::BitOr => left.clone(),
        BinOp::BitXor => left.clone(),
        BinOp::Shl => left.clone(),
        BinOp::Shr => left.clone(),

        // Assignment returns unit
        BinOp::Assign => Type::unit(),
        BinOp::AddAssign => Type::unit(),
        BinOp::SubAssign => Type::unit(),
        BinOp::MulAssign => Type::unit(),
        BinOp::DivAssign => Type::unit(),
        BinOp::RemAssign => Type::unit(),
        BinOp::BitAndAssign => Type::unit(),
        BinOp::BitOrAssign => Type::unit(),
        BinOp::BitXorAssign => Type::unit(),
        BinOp::ShlAssign => Type::unit(),
        BinOp::ShrAssign => Type::unit(),
    }
}

/// Get the result type of a unary operation.
pub fn unary_result_type(op: &UnaryOp, operand: &Type) -> Type {
    match op {
        UnaryOp::Neg => operand.clone(),
        UnaryOp::Not => {
            // For bool, returns bool. For integers, returns same type.
            operand.clone();
        }
        UnaryOp::BitNot => operand.clone(),
        UnaryOp::Deref => {
            // Need to extract inner type from ref/ptr
            match operand.kind() {
                TypeKind::Ref { inner, mutability: _ } => (**inner).clone(),
                TypeKind::Ptr { inner, mutability: _ } => (**inner).clone(),
                TypeKind::Infer(_) => Type::error(), // Will be resolved later
                TypeKind::Error => Type::error(),
                TypeKind::Primitive(_) => Type::error(),
                TypeKind::Never => Type::error(),
                TypeKind::Tuple(_) => Type::error(),
                TypeKind::Array { element: _, size: _ } => Type::error(),
                TypeKind::Slice { element: _ } => Type::error(),
                TypeKind::Fn { params: _, ret: _, effect: _ } => Type::error(),
                TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => Type::error(),
                TypeKind::Adt { def_id: _, type_args: _ } => Type::error(),
                TypeKind::Range { element: _, inclusive: _ } => Type::error(),
                TypeKind::DynTrait { trait_id: _ } => Type::error(),
                TypeKind::Record { fields: _, row_var: _ } => Type::error(),
                TypeKind::Forall { params: _, body: _ } => Type::error(),
                TypeKind::Param(_) => Type::error(),
                TypeKind::Ownership { inner: _, ownership: _ } => Type::error(),
            }
        }
        UnaryOp::Ref => Type::ref_to(operand.clone()),
        UnaryOp::RefMut => Type::ref_mut(operand.clone()),
    }
}

// ============================================================
// Literal Type Inference
// ============================================================

/// Infer the type of a literal.
pub fn infer_literal_type(lit: &LiteralKind) -> Type {
    match lit {
        LiteralKind::Integer { value: _, suffix } => {
            match suffix {
                Some(s) => Type::new(TypeKind::Primitive(s.to_primitive())),
                None => Type::i32(), // Default integer type
            }
        }
        LiteralKind::Float { value: _, suffix } => {
            match suffix {
                Some(s) => Type::new(TypeKind::Primitive(s.to_primitive())),
                None => Type::f64(), // Default float type
            }
        }
        LiteralKind::Bool(_) => Type::bool(),
        LiteralKind::Char(_) => Type::char(),
        LiteralKind::String(_) => Type::str(),
        LiteralKind::Byte(_) => Type::new(TypeKind::Primitive(PrimitiveTy::U8)),
        LiteralKind::ByteString(bs) => Type::array(
            Type::new(TypeKind::Primitive(PrimitiveTy::U8)),
            bs.len() as u64,
        ),
    }
}

// ============================================================
// Auto-Deref Utility
// ============================================================

/// Strip references from a type (auto-deref).
///
/// Returns the innermost non-reference type.
pub fn auto_deref(ty: &Type) -> Type {
    match ty.kind() {
        TypeKind::Ref { inner, mutability: _ } => auto_deref(inner),
        TypeKind::Primitive(p) => Type::new(TypeKind::Primitive(p.clone())),
        TypeKind::Never => Type::never(),
        TypeKind::Tuple(tys) => Type::tuple(tys.clone()),
        TypeKind::Array { element, size } => Type::array((**element).clone(), *size),
        TypeKind::Slice { element } => Type::slice((**element).clone()),
        TypeKind::Ptr { inner, mutability } => Type::new(TypeKind::Ptr {
            inner: inner.clone(),
            mutability: mutability.clone(),
        }),
        TypeKind::Fn { params, ret, effect } => Type::new(TypeKind::Fn {
            params: params.clone(),
            ret: ret.clone(),
            effect: effect.clone(),
        }),
        TypeKind::Closure { params, ret, effect, captures } => Type::new(TypeKind::Closure {
            params: params.clone(),
            ret: ret.clone(),
            effect: effect.clone(),
            captures: captures.clone(),
        }),
        TypeKind::Adt { def_id, type_args } => Type::new(TypeKind::Adt {
            def_id: def_id.clone(),
            type_args: type_args.clone(),
        }),
        TypeKind::Range { element, inclusive } => Type::new(TypeKind::Range {
            element: element.clone(),
            inclusive: *inclusive,
        }),
        TypeKind::DynTrait { trait_id } => Type::new(TypeKind::DynTrait {
            trait_id: trait_id.clone(),
        }),
        TypeKind::Record { fields, row_var } => Type::new(TypeKind::Record {
            fields: fields.clone(),
            row_var: row_var.clone(),
        }),
        TypeKind::Forall { params, body } => Type::new(TypeKind::Forall {
            params: params.clone(),
            body: body.clone(),
        }),
        TypeKind::Infer(id) => Type::infer(id.clone()),
        TypeKind::Param(id) => Type::param(id.clone()),
        TypeKind::Ownership { inner, ownership } => Type::new(TypeKind::Ownership {
            inner: inner.clone(),
            ownership: ownership.clone(),
        }),
        TypeKind::Error => Type::error(),
    }
}
