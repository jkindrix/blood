/// Tests for effects.blood - Effect Type Checking
///
/// These tests verify effect tracking and handler resolution work correctly.

use std.compiler.typeck.effects::{
    EffectContext, HandlerStack,
    effect_rows_compatible, effect_row_diff, merge_effect_rows, effect_row_subset,
};
use std.compiler.typeck.types::{Type, DefId, EffectRow, EffectInstance, EffectRowVarId};

// ============================================================
// EffectContext Tests
// ============================================================

#[test]
fn test_effect_context_new() {
    let ctx = EffectContext::new();
    assert!(ctx.declared().is_none());
    assert_eq!(ctx.used().len(), 0);
}

#[test]
fn test_effect_context_with_declared() {
    let row = EffectRow::pure();
    let ctx = EffectContext::with_declared(Some(row));
    assert!(ctx.declared().is_some());
}

#[test]
fn test_effect_context_with_declared_none() {
    let ctx = EffectContext::with_declared(None);
    assert!(ctx.declared().is_none());
}

#[test]
fn test_effect_context_use_effect() {
    let mut ctx = EffectContext::new();
    let effect = EffectInstance::simple(DefId::new(1));

    ctx.use_effect(effect);

    assert_eq!(ctx.used().len(), 1);
}

#[test]
fn test_effect_context_use_multiple_effects() {
    let mut ctx = EffectContext::new();
    ctx.use_effect(EffectInstance::simple(DefId::new(1)));
    ctx.use_effect(EffectInstance::simple(DefId::new(2)));
    ctx.use_effect(EffectInstance::simple(DefId::new(3)));

    assert_eq!(ctx.used().len(), 3);
}

#[test]
fn test_effect_context_is_declared_true() {
    let effect = EffectInstance::simple(DefId::new(1));
    let row = EffectRow::new(vec![effect], None);
    let ctx = EffectContext::with_declared(Some(row));

    assert!(ctx.is_declared(&DefId::new(1)));
}

#[test]
fn test_effect_context_is_declared_false() {
    let effect = EffectInstance::simple(DefId::new(1));
    let row = EffectRow::new(vec![effect], None);
    let ctx = EffectContext::with_declared(Some(row));

    assert!(!ctx.is_declared(&DefId::new(2)));
}

#[test]
fn test_effect_context_is_declared_no_declaration() {
    let ctx = EffectContext::new();
    assert!(!ctx.is_declared(&DefId::new(1)));
}

#[test]
fn test_effect_context_is_effect_available_declared() {
    let effect = EffectInstance::simple(DefId::new(1));
    let row = EffectRow::new(vec![effect], None);
    let ctx = EffectContext::with_declared(Some(row));

    let handled: [EffectRow] = vec![];
    assert!(ctx.is_effect_available(&DefId::new(1), &handled));
}

#[test]
fn test_effect_context_is_effect_available_handled() {
    let ctx = EffectContext::new();
    let handler_effect = EffectInstance::simple(DefId::new(1));
    let handler_row = EffectRow::new(vec![handler_effect], None);
    let handled = vec![handler_row];

    assert!(ctx.is_effect_available(&DefId::new(1), &handled));
}

#[test]
fn test_effect_context_is_effect_available_not_available() {
    let ctx = EffectContext::new();
    let handled: [EffectRow] = vec![];

    assert!(!ctx.is_effect_available(&DefId::new(1), &handled));
}

#[test]
fn test_effect_context_check_effects_all_handled() {
    let mut ctx = EffectContext::new();
    ctx.use_effect(EffectInstance::simple(DefId::new(1)));

    let handler_row = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let handled = vec![handler_row];

    let unhandled = ctx.check_effects(&handled);
    assert_eq!(unhandled.len(), 0);
}

#[test]
fn test_effect_context_check_effects_some_unhandled() {
    let mut ctx = EffectContext::new();
    ctx.use_effect(EffectInstance::simple(DefId::new(1)));
    ctx.use_effect(EffectInstance::simple(DefId::new(2)));

    let handler_row = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let handled = vec![handler_row];

    let unhandled = ctx.check_effects(&handled);
    assert_eq!(unhandled.len(), 1);
    assert_eq!(unhandled[0].def_id.id(), 2);
}

#[test]
fn test_effect_context_check_effects_all_unhandled() {
    let mut ctx = EffectContext::new();
    ctx.use_effect(EffectInstance::simple(DefId::new(1)));

    let handled: [EffectRow] = vec![];

    let unhandled = ctx.check_effects(&handled);
    assert_eq!(unhandled.len(), 1);
}

#[test]
fn test_effect_context_clear_used() {
    let mut ctx = EffectContext::new();
    ctx.use_effect(EffectInstance::simple(DefId::new(1)));
    ctx.use_effect(EffectInstance::simple(DefId::new(2)));

    assert_eq!(ctx.used().len(), 2);

    ctx.clear_used();

    assert_eq!(ctx.used().len(), 0);
}

#[test]
fn test_effect_context_clone() {
    let effect = EffectInstance::simple(DefId::new(1));
    let row = EffectRow::new(vec![effect], None);
    let mut ctx = EffectContext::with_declared(Some(row));
    ctx.use_effect(EffectInstance::simple(DefId::new(2)));

    let cloned = ctx.clone();

    assert!(cloned.declared().is_some());
    assert_eq!(cloned.used().len(), 1);
}

// ============================================================
// HandlerStack Tests
// ============================================================

#[test]
fn test_handler_stack_new() {
    let stack = HandlerStack::new();
    assert_eq!(stack.all().len(), 0);
}

#[test]
fn test_handler_stack_push() {
    let mut stack = HandlerStack::new();
    let row = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    stack.push(row);

    assert_eq!(stack.all().len(), 1);
}

#[test]
fn test_handler_stack_push_multiple() {
    let mut stack = HandlerStack::new();
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None));
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(3))], None));

    assert_eq!(stack.all().len(), 3);
}

#[test]
fn test_handler_stack_pop() {
    let mut stack = HandlerStack::new();
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None));

    let popped = stack.pop();
    assert!(popped.is_some());
    // Should pop the last pushed (LIFO);
    assert_eq!(stack.all().len(), 1);

    let popped2 = stack.pop();
    assert!(popped2.is_some());
    assert_eq!(stack.all().len(), 0);

    let popped3 = stack.pop();
    assert!(popped3.is_none());
}

#[test]
fn test_handler_stack_pop_empty() {
    let mut stack = HandlerStack::new();
    let result = stack.pop();
    assert!(result.is_none());
}

#[test]
fn test_handler_stack_handles() {
    let mut stack = HandlerStack::new();
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None));

    assert!(stack.handles(&DefId::new(1)));
    assert!(stack.handles(&DefId::new(2)));
    assert!(!stack.handles(&DefId::new(3)));
}

#[test]
fn test_handler_stack_handles_empty() {
    let stack = HandlerStack::new();
    assert!(!stack.handles(&DefId::new(1)));
}

#[test]
fn test_handler_stack_handles_multiple_in_one_row() {
    let mut stack = HandlerStack::new();
    let row = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );
    stack.push(row);

    assert!(stack.handles(&DefId::new(1)));
    assert!(stack.handles(&DefId::new(2)));
    assert!(!stack.handles(&DefId::new(3)));
}

#[test]
fn test_handler_stack_find_handler() {
    let mut stack = HandlerStack::new();
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None));

    let handler1 = stack.find_handler(&DefId::new(1));
    assert!(handler1.is_some());

    let handler2 = stack.find_handler(&DefId::new(2));
    assert!(handler2.is_some());

    let handler3 = stack.find_handler(&DefId::new(3));
    assert!(handler3.is_none());
}

#[test]
fn test_handler_stack_find_handler_returns_innermost() {
    let mut stack = HandlerStack::new();
    // Outer handler handles effect 1
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));
    // Inner handler also handles effect 1
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));

    // find_handler should find a handler (searches from innermost);
    let handler = stack.find_handler(&DefId::new(1));
    assert!(handler.is_some());
}

#[test]
fn test_handler_stack_clone() {
    let mut stack = HandlerStack::new();
    stack.push(EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None));

    let cloned = stack.clone();

    assert_eq!(cloned.all().len(), 1);
    assert!(cloned.handles(&DefId::new(1)));
}

// ============================================================
// effect_rows_compatible Tests
// ============================================================

#[test]
fn test_effect_rows_compatible_both_pure() {
    let r1 = EffectRow::pure();
    let r2 = EffectRow::pure();

    assert!(effect_rows_compatible(&r1, &r2));
}

#[test]
fn test_effect_rows_compatible_same_effects() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    assert!(effect_rows_compatible(&r1, &r2));
}

#[test]
fn test_effect_rows_compatible_different_effects() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None);

    assert!(!effect_rows_compatible(&r1, &r2));
}

#[test]
fn test_effect_rows_compatible_different_lengths() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );

    assert!(!effect_rows_compatible(&r1, &r2));
}

#[test]
fn test_effect_rows_compatible_open_row() {
    let r1 = EffectRow::open(EffectRowVarId::new(0));
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    // Open rows are compatible with anything
    assert!(effect_rows_compatible(&r1, &r2));
}

// ============================================================
// effect_row_diff Tests
// ============================================================

#[test]
fn test_effect_row_diff_no_diff() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    let diff = effect_row_diff(&r1, &r2);
    assert_eq!(diff.len(), 0);
}

#[test]
fn test_effect_row_diff_has_diff() {
    let r1 = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    let diff = effect_row_diff(&r1, &r2);
    assert_eq!(diff.len(), 1);
    assert_eq!(diff[0].def_id.id(), 2);
}

#[test]
fn test_effect_row_diff_all_diff() {
    let r1 = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );
    let r2 = EffectRow::pure();

    let diff = effect_row_diff(&r1, &r2);
    assert_eq!(diff.len(), 2);
}

#[test]
fn test_effect_row_diff_empty_source() {
    let r1 = EffectRow::pure();
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    let diff = effect_row_diff(&r1, &r2);
    assert_eq!(diff.len(), 0);
}

// ============================================================
// merge_effect_rows Tests
// ============================================================

#[test]
fn test_merge_effect_rows_both_pure() {
    let r1 = EffectRow::pure();
    let r2 = EffectRow::pure();

    let merged = merge_effect_rows(&r1, &r2);
    assert!(merged.is_pure());
}

#[test]
fn test_merge_effect_rows_disjoint() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None);

    let merged = merge_effect_rows(&r1, &r2);
    assert_eq!(merged.effects().len(), 2);
}

#[test]
fn test_merge_effect_rows_overlapping() {
    let r1 = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );
    let r2 = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(2)),
            EffectInstance::simple(DefId::new(3)),
        ],
        None,
    );

    let merged = merge_effect_rows(&r1, &r2);
    // Should be 1, 2, 3 (no duplicates);
    assert_eq!(merged.effects().len(), 3);
}

#[test]
fn test_merge_effect_rows_preserves_row_var() {
    let r1 = EffectRow::open(EffectRowVarId::new(0));
    let r2 = EffectRow::pure();

    let merged = merge_effect_rows(&r1, &r2);
    assert!(!merged.is_closed());
}

// ============================================================
// effect_row_subset Tests
// ============================================================

#[test]
fn test_effect_row_subset_true() {
    let subset = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let superset = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );

    assert!(effect_row_subset(&subset, &superset));
}

#[test]
fn test_effect_row_subset_equal() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    assert!(effect_row_subset(&r1, &r2));
}

#[test]
fn test_effect_row_subset_false() {
    let subset = EffectRow::new(
        vec![
            EffectInstance::simple(DefId::new(1)),
            EffectInstance::simple(DefId::new(2)),
        ],
        None,
    );
    let superset = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    assert!(!effect_row_subset(&subset, &superset));
}

#[test]
fn test_effect_row_subset_empty() {
    let empty = EffectRow::pure();
    let non_empty = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);

    // Empty is subset of anything
    assert!(effect_row_subset(&empty, &non_empty));
    assert!(effect_row_subset(&empty, &empty));
}

#[test]
fn test_effect_row_subset_disjoint() {
    let r1 = EffectRow::new(vec![EffectInstance::simple(DefId::new(1))], None);
    let r2 = EffectRow::new(vec![EffectInstance::simple(DefId::new(2))], None);

    assert!(!effect_row_subset(&r1, &r2));
    assert!(!effect_row_subset(&r2, &r1));
}
