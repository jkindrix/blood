/// Tests for unify.blood - Type Unification
///
/// These tests verify the Hindley-Milner style type unification works correctly.

use super.super.unify::Unifier;
use super.super.types::{
    Type, TypeKind, TyVarId, DefId, PrimitiveTy, Mutability, Ownership,
    EffectRow, EffectInstance, EffectRowVarId, RecordField, RecordRowVarId,
};
use super.super.errors::{Span};

// ============================================================
// Unifier Creation Tests
// ============================================================

#[test]
fn test_unifier_new() {
    let u = Unifier::new();
    // Fresh unifier should work - verified by fresh_var working
    let var = u.fresh_var();
    assert!(var.is_infer());
}

// ============================================================
// Fresh Variable Generation Tests
// ============================================================

#[test]
fn test_fresh_var() {
    let mut u = Unifier::new();
    let v1 = u.fresh_var();
    let v2 = u.fresh_var();

    // Each fresh var should be an inference variable
    assert!(v1.is_infer());
    assert!(v2.is_infer());

    // They should have different IDs
    match (v1.kind(), v2.kind()) {
        (TypeKind::Infer(id1), TypeKind::Infer(id2)) => {
            assert!(!id1.eq(id2));
        }
        _ => panic!("Expected Infer types"),
    }
}

#[test]
fn test_fresh_vars() {
    let mut u = Unifier::new();
    let vars = u.fresh_vars(3);

    assert_eq!(vars.len(), 3);

    // All should be infer types with unique IDs
    let mut i: usize = 0;
    while i < vars.len() {
        assert!(vars[i].is_infer());
        i = i + 1;
    }
}

#[test]
fn test_fresh_forall_var() {
    let mut u = Unifier::new();
    let id1 = u.fresh_forall_var();
    let id2 = u.fresh_forall_var();

    // Should have different IDs
    assert!(!id1.eq(&id2));
}

#[test]
fn test_fresh_row_var() {
    let mut u = Unifier::new();
    let rv1 = u.fresh_row_var();
    let rv2 = u.fresh_row_var();

    // Should have different IDs
    assert!(!rv1.eq(&rv2));
}

#[test]
fn test_fresh_effect_row_var() {
    let mut u = Unifier::new();
    let erv1 = u.fresh_effect_row_var();
    let erv2 = u.fresh_effect_row_var();

    // Should have different IDs
    assert!(!erv1.eq(&erv2));
}

// ============================================================
// Type Resolution Tests
// ============================================================

#[test]
fn test_resolve_non_infer() {
    let u = Unifier::new();

    // Non-inference types resolve to themselves
    let i32_ty = Type::i32();
    let resolved = u.resolve(&i32_ty);
    assert_eq!(resolved.display(), "i32");

    let bool_ty = Type::bool();
    let resolved = u.resolve(&bool_ty);
    assert_eq!(resolved.display(), "bool");
}

#[test]
fn test_resolve_unbound_infer() {
    let mut u = Unifier::new();
    let var = u.fresh_var();

    // Unbound inference variable resolves to itself
    let resolved = u.resolve(&var);
    assert!(resolved.is_infer());
}

#[test]
fn test_resolve_bound_infer() {
    let mut u = Unifier::new();
    let var = u.fresh_var();

    // Unify the variable with i32
    let result = u.unify(&var, &Type::i32(), Span::dummy());
    assert!(result.is_ok());

    // Now resolve should give i32
    let resolved = u.resolve(&var);
    assert_eq!(resolved.display(), "i32");
}

#[test]
fn test_resolve_chain() {
    let mut u = Unifier::new();
    let v1 = u.fresh_var();
    let v2 = u.fresh_var();

    // v1 -> v2 -> i32
    let _ = u.unify(&v1, &v2, Span::dummy());
    let _ = u.unify(&v2, &Type::i32(), Span::dummy());

    // Resolving v1 should follow the chain to i32
    let resolved = u.resolve(&v1);
    assert_eq!(resolved.display(), "i32");
}

// ============================================================
// Apply Tests
// ============================================================

#[test]
fn test_apply_primitive() {
    let u = Unifier::new();
    let ty = Type::i32();
    let applied = u.apply(&ty);
    assert_eq!(applied.display(), "i32");
}

#[test]
fn test_apply_tuple() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let tuple = Type::tuple(vec![v.clone(), Type::bool()]);

    // Bind the variable
    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    // Apply should resolve the variable inside the tuple
    let applied = u.apply(&tuple);
    assert_eq!(applied.display(), "(i32, bool)");
}

#[test]
fn test_apply_array() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let arr = Type::array(v.clone(), 5);

    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    let applied = u.apply(&arr);
    assert_eq!(applied.display(), "[i32; 5]");
}

#[test]
fn test_apply_slice() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let slice = Type::slice(v.clone());

    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    let applied = u.apply(&slice);
    assert_eq!(applied.display(), "[i32]");
}

#[test]
fn test_apply_ref() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let ref_ty = Type::ref_to(v.clone());

    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    let applied = u.apply(&ref_ty);
    assert_eq!(applied.display(), "&i32");
}

#[test]
fn test_apply_fn() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let fn_ty = Type::new(TypeKind::Fn {
        params: vec![v.clone()],
        ret: Box::new(Type::bool()),
        effect: None,
    });

    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    let applied = u.apply(&fn_ty);
    match applied.kind() {
        TypeKind::Fn { params, ret: _, effect: _ } => {
            assert_eq!(params[0].display(), "i32");
        }
        _ => panic!("Expected Fn type"),
    }
}

// ============================================================
// Unification Success Tests
// ============================================================

#[test]
fn test_unify_same_primitive() {
    let mut u = Unifier::new();
    let result = u.unify(&Type::i32(), &Type::i32(), Span::dummy());
    assert!(result.is_ok());
}

#[test]
fn test_unify_var_with_concrete() {
    let mut u = Unifier::new();
    let v = u.fresh_var();

    let result = u.unify(&v, &Type::i32(), Span::dummy());
    assert!(result.is_ok());

    // Variable should now resolve to i32
    let resolved = u.resolve(&v);
    assert_eq!(resolved.display(), "i32");
}

#[test]
fn test_unify_concrete_with_var() {
    let mut u = Unifier::new();
    let v = u.fresh_var();

    let result = u.unify(&Type::i32(), &v, Span::dummy());
    assert!(result.is_ok());

    let resolved = u.resolve(&v);
    assert_eq!(resolved.display(), "i32");
}

#[test]
fn test_unify_never_with_anything() {
    let mut u = Unifier::new();

    // Never unifies with any type
    assert!(u.unify(&Type::never(), &Type::i32(), Span::dummy()).is_ok());
    assert!(u.unify(&Type::bool(), &Type::never(), Span::dummy()).is_ok());
}

#[test]
fn test_unify_error_with_anything() {
    let mut u = Unifier::new();

    // Error type unifies with anything (for error recovery);
    assert!(u.unify(&Type::error(), &Type::i32(), Span::dummy()).is_ok());
    assert!(u.unify(&Type::bool(), &Type::error(), Span::dummy()).is_ok());
}

#[test]
fn test_unify_tuples_same_length() {
    let mut u = Unifier::new();
    let t1 = Type::tuple(vec![Type::i32(), Type::bool()]);
    let t2 = Type::tuple(vec![Type::i32(), Type::bool()]);

    assert!(u.unify(&t1, &t2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_tuples_with_vars() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let t1 = Type::tuple(vec![v.clone(), Type::bool()]);
    let t2 = Type::tuple(vec![Type::i32(), Type::bool()]);

    assert!(u.unify(&t1, &t2, Span::dummy()).is_ok());

    // v should now be i32
    let resolved = u.resolve(&v);
    assert_eq!(resolved.display(), "i32");
}

#[test]
fn test_unify_arrays() {
    let mut u = Unifier::new();
    let a1 = Type::array(Type::i32(), 10);
    let a2 = Type::array(Type::i32(), 10);

    assert!(u.unify(&a1, &a2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_slices() {
    let mut u = Unifier::new();
    let s1 = Type::slice(Type::i32());
    let s2 = Type::slice(Type::i32());

    assert!(u.unify(&s1, &s2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_refs_same_mutability() {
    let mut u = Unifier::new();
    let r1 = Type::ref_to(Type::i32());
    let r2 = Type::ref_to(Type::i32());

    assert!(u.unify(&r1, &r2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_refs_mut() {
    let mut u = Unifier::new();
    let r1 = Type::ref_mut(Type::i32());
    let r2 = Type::ref_mut(Type::i32());

    assert!(u.unify(&r1, &r2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_fn_types() {
    let mut u = Unifier::new();
    let f1 = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_adt_same() {
    let mut u = Unifier::new();
    let def = DefId::new(1);
    let a1 = Type::new(TypeKind::Adt {
        def_id: def.clone(),
        type_args: vec![Type::i32()],
    });
    let a2 = Type::new(TypeKind::Adt {
        def_id: def.clone(),
        type_args: vec![Type::i32()],
    });

    assert!(u.unify(&a1, &a2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_params_same() {
    let mut u = Unifier::new();
    let id = TyVarId::new(1);
    let p1 = Type::param(id.clone());
    let p2 = Type::param(id.clone());

    assert!(u.unify(&p1, &p2, Span::dummy()).is_ok());
}

// ============================================================
// Unification Failure Tests
// ============================================================

#[test]
fn test_unify_different_primitives() {
    let mut u = Unifier::new();
    let result = u.unify(&Type::i32(), &Type::bool(), Span::dummy());
    assert!(result.is_err());
}

#[test]
fn test_unify_tuples_different_length() {
    let mut u = Unifier::new();
    let t1 = Type::tuple(vec![Type::i32()]);
    let t2 = Type::tuple(vec![Type::i32(), Type::bool()]);

    assert!(u.unify(&t1, &t2, Span::dummy()).is_err());
}

#[test]
fn test_unify_arrays_different_size() {
    let mut u = Unifier::new();
    let a1 = Type::array(Type::i32(), 5);
    let a2 = Type::array(Type::i32(), 10);

    assert!(u.unify(&a1, &a2, Span::dummy()).is_err());
}

#[test]
fn test_unify_arrays_different_element() {
    let mut u = Unifier::new();
    let a1 = Type::array(Type::i32(), 5);
    let a2 = Type::array(Type::bool(), 5);

    assert!(u.unify(&a1, &a2, Span::dummy()).is_err());
}

#[test]
fn test_unify_refs_different_mutability() {
    let mut u = Unifier::new();
    let r1 = Type::ref_to(Type::i32());
    let r2 = Type::ref_mut(Type::i32());

    assert!(u.unify(&r1, &r2, Span::dummy()).is_err());
}

#[test]
fn test_unify_fn_different_arity() {
    let mut u = Unifier::new();
    let f1 = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![Type::i32(), Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_err());
}

#[test]
fn test_unify_fn_different_return() {
    let mut u = Unifier::new();
    let f1 = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::i32()),
        effect: None,
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_err());
}

#[test]
fn test_unify_adt_different_def() {
    let mut u = Unifier::new();
    let a1 = Type::new(TypeKind::Adt {
        def_id: DefId::new(1),
        type_args: vec![],
    });
    let a2 = Type::new(TypeKind::Adt {
        def_id: DefId::new(2),
        type_args: vec![],
    });

    assert!(u.unify(&a1, &a2, Span::dummy()).is_err());
}

#[test]
fn test_unify_params_different() {
    let mut u = Unifier::new();
    let p1 = Type::param(TyVarId::new(1));
    let p2 = Type::param(TyVarId::new(2));

    assert!(u.unify(&p1, &p2, Span::dummy()).is_err());
}

#[test]
fn test_unify_primitive_with_tuple() {
    let mut u = Unifier::new();
    let result = u.unify(&Type::i32(), &Type::tuple(vec![Type::i32()]), Span::dummy());
    assert!(result.is_err());
}

#[test]
fn test_unify_primitive_with_array() {
    let mut u = Unifier::new();
    let result = u.unify(&Type::i32(), &Type::array(Type::i32(), 5), Span::dummy());
    assert!(result.is_err());
}

#[test]
fn test_unify_primitive_with_ref() {
    let mut u = Unifier::new();
    let result = u.unify(&Type::i32(), &Type::ref_to(Type::i32()), Span::dummy());
    assert!(result.is_err());
}

// ============================================================
// Occurs Check Tests
// ============================================================

#[test]
fn test_occurs_check_prevents_infinite_type() {
    let mut u = Unifier::new();
    let v = u.fresh_var();

    // Try to unify v with [v] (array of v) - should fail
    let arr_v = Type::array(v.clone(), 5);
    let result = u.unify(&v, &arr_v, Span::dummy());

    assert!(result.is_err());
}

#[test]
fn test_occurs_check_tuple() {
    let mut u = Unifier::new();
    let v = u.fresh_var();

    // Try to unify v with (v, i32) - should fail
    let tuple = Type::tuple(vec![v.clone(), Type::i32()]);
    let result = u.unify(&v, &tuple, Span::dummy());

    assert!(result.is_err());
}

#[test]
fn test_occurs_check_ref() {
    let mut u = Unifier::new();
    let v = u.fresh_var();

    // Try to unify v with &v - should fail
    let ref_v = Type::ref_to(v.clone());
    let result = u.unify(&v, &ref_v, Span::dummy());

    assert!(result.is_err());
}

// ============================================================
// Effect Unification Tests
// ============================================================

#[test]
fn test_unify_pure_effects() {
    let mut u = Unifier::new();
    let f1 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: Some(EffectRow::pure()),
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: Some(EffectRow::pure()),
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_none_with_pure_effect() {
    let mut u = Unifier::new();
    let f1 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: None,
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: Some(EffectRow::pure()),
    });

    // None and pure should be compatible
    assert!(u.unify(&f1, &f2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_effects_same() {
    let mut u = Unifier::new();
    let effect = EffectInstance::simple(DefId::new(1));
    let row = EffectRow::new(vec![effect.clone()], None);

    let f1 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: Some(row.clone()),
    });
    let f2 = Type::new(TypeKind::Fn {
        params: vec![],
        ret: Box::new(Type::unit()),
        effect: Some(row.clone()),
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_ok());
}

// ============================================================
// Range Unification Tests
// ============================================================

#[test]
fn test_unify_ranges_same() {
    let mut u = Unifier::new();
    let r1 = Type::new(TypeKind::Range {
        element: Box::new(Type::i32()),
        inclusive: false,
    });
    let r2 = Type::new(TypeKind::Range {
        element: Box::new(Type::i32()),
        inclusive: false,
    });

    assert!(u.unify(&r1, &r2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_ranges_different_inclusive() {
    let mut u = Unifier::new();
    let r1 = Type::new(TypeKind::Range {
        element: Box::new(Type::i32()),
        inclusive: false,
    });
    let r2 = Type::new(TypeKind::Range {
        element: Box::new(Type::i32()),
        inclusive: true,
    });

    assert!(u.unify(&r1, &r2, Span::dummy()).is_err());
}

// ============================================================
// Record Unification Tests
// ============================================================

#[test]
fn test_unify_records_same() {
    let mut u = Unifier::new();
    let r1 = Type::new(TypeKind::Record {
        fields: vec![
            RecordField::new("x".to_string(), Type::i32()),
            RecordField::new("y".to_string(), Type::i32()),
        ],
        row_var: None,
    });
    let r2 = Type::new(TypeKind::Record {
        fields: vec![
            RecordField::new("x".to_string(), Type::i32()),
            RecordField::new("y".to_string(), Type::i32()),
        ],
        row_var: None,
    });

    assert!(u.unify(&r1, &r2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_records_different_field_count() {
    let mut u = Unifier::new();
    let r1 = Type::new(TypeKind::Record {
        fields: vec![
            RecordField::new("x".to_string(), Type::i32()),
        ],
        row_var: None,
    });
    let r2 = Type::new(TypeKind::Record {
        fields: vec![
            RecordField::new("x".to_string(), Type::i32()),
            RecordField::new("y".to_string(), Type::i32()),
        ],
        row_var: None,
    });

    assert!(u.unify(&r1, &r2, Span::dummy()).is_err());
}

#[test]
fn test_unify_records_different_field_names() {
    let mut u = Unifier::new();
    let r1 = Type::new(TypeKind::Record {
        fields: vec![RecordField::new("x".to_string(), Type::i32())],
        row_var: None,
    });
    let r2 = Type::new(TypeKind::Record {
        fields: vec![RecordField::new("y".to_string(), Type::i32())],
        row_var: None,
    });

    assert!(u.unify(&r1, &r2, Span::dummy()).is_err());
}

// ============================================================
// DynTrait Unification Tests
// ============================================================

#[test]
fn test_unify_dyn_trait_same() {
    let mut u = Unifier::new();
    let d1 = Type::new(TypeKind::DynTrait { trait_id: DefId::new(1) });
    let d2 = Type::new(TypeKind::DynTrait { trait_id: DefId::new(1) });

    assert!(u.unify(&d1, &d2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_dyn_trait_different() {
    let mut u = Unifier::new();
    let d1 = Type::new(TypeKind::DynTrait { trait_id: DefId::new(1) });
    let d2 = Type::new(TypeKind::DynTrait { trait_id: DefId::new(2) });

    assert!(u.unify(&d1, &d2, Span::dummy()).is_err());
}

// ============================================================
// Ownership Unification Tests
// ============================================================

#[test]
fn test_unify_ownership_same() {
    let mut u = Unifier::new();
    let o1 = Type::new(TypeKind::Ownership {
        inner: Box::new(Type::i32()),
        ownership: Ownership::Linear,
    });
    let o2 = Type::new(TypeKind::Ownership {
        inner: Box::new(Type::i32()),
        ownership: Ownership::Linear,
    });

    assert!(u.unify(&o1, &o2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_ownership_different() {
    let mut u = Unifier::new();
    let o1 = Type::new(TypeKind::Ownership {
        inner: Box::new(Type::i32()),
        ownership: Ownership::Linear,
    });
    let o2 = Type::new(TypeKind::Ownership {
        inner: Box::new(Type::i32()),
        ownership: Ownership::Affine,
    });

    assert!(u.unify(&o1, &o2, Span::dummy()).is_err());
}

// ============================================================
// Forall Unification Tests
// ============================================================

#[test]
fn test_unify_forall_same() {
    let mut u = Unifier::new();
    let id = TyVarId::new(0);
    let f1 = Type::new(TypeKind::Forall {
        params: vec![id.clone()],
        body: Box::new(Type::param(id.clone())),
    });
    let f2 = Type::new(TypeKind::Forall {
        params: vec![id.clone()],
        body: Box::new(Type::param(id.clone())),
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_forall_different_param_count() {
    let mut u = Unifier::new();
    let id1 = TyVarId::new(0);
    let id2 = TyVarId::new(1);
    let f1 = Type::new(TypeKind::Forall {
        params: vec![id1.clone()],
        body: Box::new(Type::param(id1.clone())),
    });
    let f2 = Type::new(TypeKind::Forall {
        params: vec![id1.clone(), id2.clone()],
        body: Box::new(Type::param(id1.clone())),
    });

    assert!(u.unify(&f1, &f2, Span::dummy()).is_err());
}

// ============================================================
// Ptr Unification Tests
// ============================================================

#[test]
fn test_unify_ptr_same() {
    let mut u = Unifier::new();
    let p1 = Type::new(TypeKind::Ptr {
        inner: Box::new(Type::i32()),
        mutability: Mutability::Immutable,
    });
    let p2 = Type::new(TypeKind::Ptr {
        inner: Box::new(Type::i32()),
        mutability: Mutability::Immutable,
    });

    assert!(u.unify(&p1, &p2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_ptr_different_mutability() {
    let mut u = Unifier::new();
    let p1 = Type::new(TypeKind::Ptr {
        inner: Box::new(Type::i32()),
        mutability: Mutability::Immutable,
    });
    let p2 = Type::new(TypeKind::Ptr {
        inner: Box::new(Type::i32()),
        mutability: Mutability::Mutable,
    });

    assert!(u.unify(&p1, &p2, Span::dummy()).is_err());
}

// ============================================================
// Closure Unification Tests
// ============================================================

#[test]
fn test_unify_closures_same() {
    let mut u = Unifier::new();
    let c1 = Type::new(TypeKind::Closure {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
        captures: vec![Type::str()],
    });
    let c2 = Type::new(TypeKind::Closure {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
        captures: vec![Type::str()],
    });

    assert!(u.unify(&c1, &c2, Span::dummy()).is_ok());
}

#[test]
fn test_unify_closures_different_captures() {
    let mut u = Unifier::new();
    let c1 = Type::new(TypeKind::Closure {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
        captures: vec![Type::str()],
    });
    let c2 = Type::new(TypeKind::Closure {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
        captures: vec![Type::str(), Type::i32()],
    });

    assert!(u.unify(&c1, &c2, Span::dummy()).is_err());
}

// ============================================================
// Unifier Clone Tests
// ============================================================

#[test]
fn test_unifier_clone() {
    let mut u = Unifier::new();
    let v = u.fresh_var();
    let _ = u.unify(&v, &Type::i32(), Span::dummy());

    let u2 = u.clone();
    let resolved = u2.resolve(&v);
    assert_eq!(resolved.display(), "i32");
}
