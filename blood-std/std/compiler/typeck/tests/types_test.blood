/// Tests for types.blood - Type Representations
///
/// These tests verify the core type system representations work correctly.

use super.super.types::{
    Type, TypeKind, PrimitiveTy, TyVarId, DefId, Mutability, Ownership,
    EffectRow, EffectInstance, EffectRowVarId, RecordField, RecordRowVarId,
    parse_primitive,
};

// ============================================================
// PrimitiveTy Tests
// ============================================================

#[test]
fn test_primitive_name() {
    assert_eq!(PrimitiveTy::I32.name(), "i32");
    assert_eq!(PrimitiveTy::Bool.name(), "bool");
    assert_eq!(PrimitiveTy::Unit.name(), "()");
    assert_eq!(PrimitiveTy::Str.name(), "str");
    assert_eq!(PrimitiveTy::F64.name(), "f64");
}

#[test]
fn test_primitive_is_signed_int() {
    assert!(PrimitiveTy::I8.is_signed_int());
    assert!(PrimitiveTy::I32.is_signed_int());
    assert!(PrimitiveTy::I64.is_signed_int());
    assert!(PrimitiveTy::Isize.is_signed_int());
    assert!(!PrimitiveTy::U32.is_signed_int());
    assert!(!PrimitiveTy::Bool.is_signed_int());
    assert!(!PrimitiveTy::F64.is_signed_int());
}

#[test]
fn test_primitive_is_unsigned_int() {
    assert!(PrimitiveTy::U8.is_unsigned_int());
    assert!(PrimitiveTy::U32.is_unsigned_int());
    assert!(PrimitiveTy::Usize.is_unsigned_int());
    assert!(!PrimitiveTy::I32.is_unsigned_int());
    assert!(!PrimitiveTy::Bool.is_unsigned_int());
}

#[test]
fn test_primitive_is_integer() {
    assert!(PrimitiveTy::I32.is_integer());
    assert!(PrimitiveTy::U64.is_integer());
    assert!(!PrimitiveTy::F32.is_integer());
    assert!(!PrimitiveTy::Bool.is_integer());
}

#[test]
fn test_primitive_is_float() {
    assert!(PrimitiveTy::F32.is_float());
    assert!(PrimitiveTy::F64.is_float());
    assert!(!PrimitiveTy::I32.is_float());
    assert!(!PrimitiveTy::Bool.is_float());
}

#[test]
fn test_primitive_is_numeric() {
    assert!(PrimitiveTy::I32.is_numeric());
    assert!(PrimitiveTy::F64.is_numeric());
    assert!(!PrimitiveTy::Bool.is_numeric());
    assert!(!PrimitiveTy::Char.is_numeric());
}

#[test]
fn test_primitive_bit_width() {
    assert_eq!(PrimitiveTy::I8.bit_width(), Some(8));
    assert_eq!(PrimitiveTy::I32.bit_width(), Some(32));
    assert_eq!(PrimitiveTy::I64.bit_width(), Some(64));
    assert_eq!(PrimitiveTy::Isize.bit_width(), None);
    assert_eq!(PrimitiveTy::Usize.bit_width(), None);
    assert_eq!(PrimitiveTy::Bool.bit_width(), Some(1));
    assert_eq!(PrimitiveTy::Unit.bit_width(), Some(0));
}

#[test]
fn test_parse_primitive() {
    assert_eq!(parse_primitive("i32"), Some(PrimitiveTy::I32));
    assert_eq!(parse_primitive("bool"), Some(PrimitiveTy::Bool));
    assert_eq!(parse_primitive("()"), Some(PrimitiveTy::Unit));
    assert_eq!(parse_primitive("str"), Some(PrimitiveTy::Str));
    assert_eq!(parse_primitive("invalid"), None);
    assert_eq!(parse_primitive(""), None);
}

#[test]
fn test_primitive_clone() {
    let p = PrimitiveTy::I32;
    let p2 = p.clone();
    assert!(p.eq(&p2));
}

#[test]
fn test_primitive_eq() {
    assert!(PrimitiveTy::I32.eq(&PrimitiveTy::I32));
    assert!(!PrimitiveTy::I32.eq(&PrimitiveTy::I64));
    assert!(!PrimitiveTy::Bool.eq(&PrimitiveTy::I32));
}

// ============================================================
// TyVarId Tests
// ============================================================

#[test]
fn test_ty_var_id_new() {
    let id = TyVarId::new(42);
    assert_eq!(id.id(), 42);
}

#[test]
fn test_ty_var_id_clone() {
    let id1 = TyVarId::new(10);
    let id2 = id1.clone();
    assert_eq!(id1.id(), id2.id());
}

#[test]
fn test_ty_var_id_eq() {
    let id1 = TyVarId::new(5);
    let id2 = TyVarId::new(5);
    let id3 = TyVarId::new(10);
    assert!(id1.eq(&id2));
    assert!(!id1.eq(&id3));
}

// ============================================================
// DefId Tests
// ============================================================

#[test]
fn test_def_id_new() {
    let id = DefId::new(100);
    assert_eq!(id.id(), 100);
}

#[test]
fn test_def_id_clone() {
    let id1 = DefId::new(50);
    let id2 = id1.clone();
    assert_eq!(id1.id(), id2.id());
}

#[test]
fn test_def_id_eq() {
    let id1 = DefId::new(7);
    let id2 = DefId::new(7);
    let id3 = DefId::new(8);
    assert!(id1.eq(&id2));
    assert!(!id1.eq(&id3));
}

// ============================================================
// Mutability Tests
// ============================================================

#[test]
fn test_mutability_is_mutable() {
    assert!(Mutability::Mutable.is_mutable());
    assert!(!Mutability::Immutable.is_mutable());
}

#[test]
fn test_mutability_clone() {
    let m1 = Mutability::Mutable;
    let m2 = m1.clone();
    assert!(m1.eq(&m2));
}

#[test]
fn test_mutability_eq() {
    assert!(Mutability::Mutable.eq(&Mutability::Mutable));
    assert!(Mutability::Immutable.eq(&Mutability::Immutable));
    assert!(!Mutability::Mutable.eq(&Mutability::Immutable));
}

// ============================================================
// Ownership Tests
// ============================================================

#[test]
fn test_ownership_clone() {
    let o1 = Ownership::Linear;
    let o2 = o1.clone();
    assert!(o1.eq(&o2));
}

#[test]
fn test_ownership_eq() {
    assert!(Ownership::Linear.eq(&Ownership::Linear));
    assert!(Ownership::Affine.eq(&Ownership::Affine));
    assert!(Ownership::Default.eq(&Ownership::Default));
    assert!(!Ownership::Linear.eq(&Ownership::Affine));
    assert!(!Ownership::Linear.eq(&Ownership::Default));
}

// ============================================================
// Type Constructor Tests
// ============================================================

#[test]
fn test_type_unit() {
    let t = Type::unit();
    assert!(t.is_unit());
    assert!(t.is_primitive());
}

#[test]
fn test_type_never() {
    let t = Type::never();
    assert!(t.is_never());
    assert!(!t.is_primitive());
}

#[test]
fn test_type_error() {
    let t = Type::error();
    assert!(t.is_error());
}

#[test]
fn test_type_bool() {
    let t = Type::bool();
    assert!(t.is_primitive());
    match t.kind() {
        TypeKind::Primitive(p) => assert!(p.eq(&PrimitiveTy::Bool)),
        _ => panic!("Expected primitive type"),
    }
}

#[test]
fn test_type_i32() {
    let t = Type::i32();
    assert!(t.is_primitive());
}

#[test]
fn test_type_infer() {
    let id = TyVarId::new(0);
    let t = Type::infer(id);
    assert!(t.is_infer());
}

#[test]
fn test_type_param() {
    let id = TyVarId::new(1);
    let t = Type::param(id);
    assert!(!t.is_infer()); // param is different from infer
}

#[test]
fn test_type_tuple() {
    let t = Type::tuple(vec![Type::i32(), Type::bool()]);
    match t.kind() {
        TypeKind::Tuple(elements) => assert_eq!(elements.len(), 2),
        _ => panic!("Expected tuple type"),
    }
}

#[test]
fn test_type_empty_tuple_is_unit() {
    let t = Type::tuple(vec![]);
    assert!(t.is_unit());
}

#[test]
fn test_type_array() {
    let t = Type::array(Type::i32(), 10);
    match t.kind() {
        TypeKind::Array { element: _, size } => assert_eq!(*size, 10),
        _ => panic!("Expected array type"),
    }
}

#[test]
fn test_type_slice() {
    let t = Type::slice(Type::i32());
    match t.kind() {
        TypeKind::Slice { element: _ } => {}
        _ => panic!("Expected slice type"),
    }
}

#[test]
fn test_type_ref() {
    let t = Type::ref_to(Type::i32());
    assert!(t.is_ref());
    match t.kind() {
        TypeKind::Ref { inner: _, mutability } => {
            assert!(!mutability.is_mutable());
        }
        _ => panic!("Expected ref type"),
    }
}

#[test]
fn test_type_ref_mut() {
    let t = Type::ref_mut(Type::i32());
    assert!(t.is_ref());
    match t.kind() {
        TypeKind::Ref { inner: _, mutability } => {
            assert!(mutability.is_mutable());
        }
        _ => panic!("Expected ref type"),
    }
}

// ============================================================
// Type Predicate Tests
// ============================================================

#[test]
fn test_is_primitive() {
    assert!(Type::i32().is_primitive());
    assert!(Type::bool().is_primitive());
    assert!(!Type::never().is_primitive());
    assert!(!Type::tuple(vec![]).is_primitive());
}

#[test]
fn test_is_fn() {
    let fn_ty = Type::new(TypeKind::Fn {
        params: vec![Type::i32()],
        ret: Box::new(Type::bool()),
        effect: None,
    });
    assert!(fn_ty.is_fn());
    assert!(!Type::i32().is_fn());
}

// ============================================================
// Type Display Tests
// ============================================================

#[test]
fn test_type_display_primitive() {
    assert_eq!(Type::i32().display(), "i32");
    assert_eq!(Type::bool().display(), "bool");
    assert_eq!(Type::unit().display(), "()");
}

#[test]
fn test_type_display_never() {
    assert_eq!(Type::never().display(), "!");
}

#[test]
fn test_type_display_tuple() {
    let t = Type::tuple(vec![Type::i32(), Type::bool()]);
    assert_eq!(t.display(), "(i32, bool)");
}

#[test]
fn test_type_display_array() {
    let t = Type::array(Type::i32(), 5);
    assert_eq!(t.display(), "[i32; 5]");
}

#[test]
fn test_type_display_slice() {
    let t = Type::slice(Type::i32());
    assert_eq!(t.display(), "[i32]");
}

#[test]
fn test_type_display_ref() {
    let t = Type::ref_to(Type::i32());
    assert_eq!(t.display(), "&i32");
}

#[test]
fn test_type_display_ref_mut() {
    let t = Type::ref_mut(Type::i32());
    assert_eq!(t.display(), "&mut i32");
}

#[test]
fn test_type_display_infer() {
    let t = Type::infer(TyVarId::new(5));
    assert_eq!(t.display(), "?5");
}

#[test]
fn test_type_display_param() {
    let t = Type::param(TyVarId::new(3));
    assert_eq!(t.display(), "T3");
}

#[test]
fn test_type_display_error() {
    assert_eq!(Type::error().display(), "<error>");
}

// ============================================================
// EffectRow Tests
// ============================================================

#[test]
fn test_effect_row_pure() {
    let row = EffectRow::pure();
    assert!(row.is_pure());
    assert!(row.is_closed());
    assert_eq!(row.effects().len(), 0);
}

#[test]
fn test_effect_row_open() {
    let var = EffectRowVarId::new(0);
    let row = EffectRow::open(var);
    assert!(!row.is_pure());
    assert!(!row.is_closed());
}

#[test]
fn test_effect_row_contains() {
    let def_id = DefId::new(1);
    let effect = EffectInstance::simple(def_id.clone());
    let row = EffectRow::new(vec![effect], None);

    assert!(row.contains_effect(&def_id));
    assert!(!row.contains_effect(&DefId::new(2)));
}

// ============================================================
// RecordField Tests
// ============================================================

#[test]
fn test_record_field_new() {
    let field = RecordField::new("name".to_string(), Type::str());
    assert_eq!(field.name, "name");
}

#[test]
fn test_record_field_clone() {
    let field1 = RecordField::new("x".to_string(), Type::i32());
    let field2 = field1.clone();
    assert_eq!(field1.name, field2.name);
}

// ============================================================
// TypeKind Clone Tests
// ============================================================

#[test]
fn test_type_clone() {
    let t1 = Type::i32();
    let t2 = t1.clone();
    assert_eq!(t1.display(), t2.display());
}

#[test]
fn test_complex_type_clone() {
    let t1 = Type::new(TypeKind::Fn {
        params: vec![Type::i32(), Type::bool()],
        ret: Box::new(Type::str()),
        effect: None,
    });
    let t2 = t1.clone();
    assert_eq!(t1.display(), t2.display());
}
