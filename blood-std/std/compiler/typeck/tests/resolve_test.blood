/// Tests for resolve.blood - Name Resolution
///
/// These tests verify scoping, name resolution, and definition registry work correctly.

use std.compiler.typeck.resolve::{
    Scope, TypeDef, TypeDefKind, StructFieldDef, EnumVariantDef,
    FnDef, EffectDef, EffectOpDef, TraitDef, TraitMethodDef, TraitAssocTypeDef,
    ImplDef, ImplMethodDef, ImplAssocTypeDef, DefRegistry,
};
use std.compiler.typeck.types::{Type, TyVarId, DefId};

// ============================================================
// Scope Tests
// ============================================================

#[test]
fn test_scope_new() {
    let scope = Scope::new();
    // Fresh scope should have nothing defined
    assert!(scope.lookup_var("x").is_none());
    assert!(scope.lookup_type("Foo").is_none());
    assert!(scope.lookup_fn("bar").is_none());
}

#[test]
fn test_scope_define_var() {
    let mut scope = Scope::new();
    scope.define_var("x".to_string(), Type::i32());

    let result = scope.lookup_var("x");
    assert!(result.is_some());
    assert_eq!(result.unwrap().display(), "i32");
}

#[test]
fn test_scope_lookup_var_not_found() {
    let scope = Scope::new();
    assert!(scope.lookup_var("undefined").is_none());
}

#[test]
fn test_scope_has_var_local() {
    let mut scope = Scope::new();
    scope.define_var("x".to_string(), Type::i32());

    assert!(scope.has_var_local("x"));
    assert!(!scope.has_var_local("y"));
}

#[test]
fn test_scope_define_type() {
    let mut scope = Scope::new();
    let id = DefId::new(1);
    scope.define_type("Point".to_string(), id.clone());

    let result = scope.lookup_type("Point");
    assert!(result.is_some());
    assert_eq!(result.unwrap().id(), 1);
}

#[test]
fn test_scope_lookup_type_not_found() {
    let scope = Scope::new();
    assert!(scope.lookup_type("Undefined").is_none());
}

#[test]
fn test_scope_has_type_local() {
    let mut scope = Scope::new();
    scope.define_type("Foo".to_string(), DefId::new(1));

    assert!(scope.has_type_local("Foo"));
    assert!(!scope.has_type_local("Bar"));
}

#[test]
fn test_scope_define_fn() {
    let mut scope = Scope::new();
    let id = DefId::new(5);
    scope.define_fn("add".to_string(), id.clone());

    let result = scope.lookup_fn("add");
    assert!(result.is_some());
    assert_eq!(result.unwrap().id(), 5);
}

#[test]
fn test_scope_lookup_fn_not_found() {
    let scope = Scope::new();
    assert!(scope.lookup_fn("undefined").is_none());
}

#[test]
fn test_scope_define_effect() {
    let mut scope = Scope::new();
    let id = DefId::new(10);
    scope.define_effect("Console".to_string(), id.clone());

    let result = scope.lookup_effect("Console");
    assert!(result.is_some());
    assert_eq!(result.unwrap().id(), 10);
}

#[test]
fn test_scope_lookup_effect_not_found() {
    let scope = Scope::new();
    assert!(scope.lookup_effect("IO").is_none());
}

#[test]
fn test_scope_define_trait() {
    let mut scope = Scope::new();
    let id = DefId::new(20);
    scope.define_trait("Clone".to_string(), id.clone());

    let result = scope.lookup_trait("Clone");
    assert!(result.is_some());
    assert_eq!(result.unwrap().id(), 20);
}

#[test]
fn test_scope_lookup_trait_not_found() {
    let scope = Scope::new();
    assert!(scope.lookup_trait("Iterator").is_none());
}

// ============================================================
// Child Scope Tests
// ============================================================

#[test]
fn test_scope_child() {
    let mut parent = Scope::new();
    parent.define_var("x".to_string(), Type::i32());

    let child = parent.child();

    // Child should see parent's variables
    assert!(child.lookup_var("x").is_some());
}

#[test]
fn test_scope_child_shadowing() {
    let mut parent = Scope::new();
    parent.define_var("x".to_string(), Type::i32());

    let mut child = parent.child();
    child.define_var("x".to_string(), Type::bool());

    // Child should see its own definition
    let x = child.lookup_var("x");
    assert!(x.is_some());
    assert_eq!(x.unwrap().display(), "bool");

    // has_var_local should only look in current scope
    assert!(child.has_var_local("x"));
}

#[test]
fn test_scope_child_type_lookup() {
    let mut parent = Scope::new();
    parent.define_type("Outer".to_string(), DefId::new(1));

    let mut child = parent.child();
    child.define_type("Inner".to_string(), DefId::new(2));

    // Child should see both
    assert!(child.lookup_type("Outer").is_some());
    assert!(child.lookup_type("Inner").is_some());

    // has_type_local should only see current scope
    assert!(!child.has_type_local("Outer"));
    assert!(child.has_type_local("Inner"));
}

#[test]
fn test_scope_child_fn_lookup() {
    let mut parent = Scope::new();
    parent.define_fn("outer_fn".to_string(), DefId::new(1));

    let mut child = parent.child();
    child.define_fn("inner_fn".to_string(), DefId::new(2));

    assert!(child.lookup_fn("outer_fn").is_some());
    assert!(child.lookup_fn("inner_fn").is_some());
}

#[test]
fn test_scope_child_effect_lookup() {
    let mut parent = Scope::new();
    parent.define_effect("IO".to_string(), DefId::new(1));

    let child = parent.child();

    assert!(child.lookup_effect("IO").is_some());
    assert!(child.lookup_effect("Console").is_none());
}

#[test]
fn test_scope_child_trait_lookup() {
    let mut parent = Scope::new();
    parent.define_trait("Clone".to_string(), DefId::new(1));

    let child = parent.child();

    assert!(child.lookup_trait("Clone").is_some());
}

#[test]
fn test_scope_clone() {
    let mut scope = Scope::new();
    scope.define_var("x".to_string(), Type::i32());

    let cloned = scope.clone();
    assert!(cloned.lookup_var("x").is_some());
}

// ============================================================
// TypeDef Tests
// ============================================================

#[test]
fn test_type_def_new_struct() {
    let fields = vec![
        StructFieldDef { name: "x".to_string(), ty: Type::i32() },
        StructFieldDef { name: "y".to_string(), ty: Type::i32() },
    ];
    let def = TypeDef::new_struct("Point".to_string(), vec![], fields);

    assert_eq!(def.name, "Point");
    assert_eq!(def.type_params.len(), 0);
    match &def.kind {
        TypeDefKind::Struct { fields } => {
            assert_eq!(fields.len(), 2);
            assert_eq!(fields[0].name, "x");
            assert_eq!(fields[1].name, "y");
        }
        TypeDefKind::Enum { variants: _ } => panic!("Expected struct"),
    }
}

#[test]
fn test_type_def_new_enum() {
    let variants = vec![
        EnumVariantDef { name: "None".to_string(), payload: None },
        EnumVariantDef { name: "Some".to_string(), payload: Some(Type::i32()) },
    ];
    let def = TypeDef::new_enum("Option".to_string(), vec![TyVarId::new(0)], variants);

    assert_eq!(def.name, "Option");
    assert_eq!(def.type_params.len(), 1);
    match &def.kind {
        TypeDefKind::Enum { variants } => {
            assert_eq!(variants.len(), 2);
            assert_eq!(variants[0].name, "None");
            assert!(variants[0].payload.is_none());
            assert_eq!(variants[1].name, "Some");
            assert!(variants[1].payload.is_some());
        }
        TypeDefKind::Struct { fields: _ } => panic!("Expected enum"),
    }
}

#[test]
fn test_type_def_clone() {
    let def = TypeDef::new_struct("Point".to_string(), vec![], vec![]);
    let cloned = def.clone();
    assert_eq!(cloned.name, "Point");
}

#[test]
fn test_struct_field_def_clone() {
    let field = StructFieldDef { name: "x".to_string(), ty: Type::i32() };
    let cloned = field.clone();
    assert_eq!(cloned.name, "x");
    assert_eq!(cloned.ty.display(), "i32");
}

#[test]
fn test_enum_variant_def_clone() {
    let variant = EnumVariantDef {
        name: "Some".to_string(),
        payload: Some(Type::i32()),
    };
    let cloned = variant.clone();
    assert_eq!(cloned.name, "Some");
    assert!(cloned.payload.is_some());
}

// ============================================================
// FnDef Tests
// ============================================================

#[test]
fn test_fn_def_new() {
    let def = FnDef::new(
        "add".to_string(),
        vec![],
        vec![Type::i32(), Type::i32()],
        Type::i32(),
        None,
    );

    assert_eq!(def.name, "add");
    assert_eq!(def.params.len(), 2);
    assert_eq!(def.ret.display(), "i32");
    assert!(def.effect.is_none());
}

#[test]
fn test_fn_def_fn_type() {
    let def = FnDef::new(
        "add".to_string(),
        vec![],
        vec![Type::i32(), Type::i32()],
        Type::i32(),
        None,
    );

    let fn_ty = def.fn_type();
    assert!(fn_ty.is_fn());
}

#[test]
fn test_fn_def_clone() {
    let def = FnDef::new(
        "foo".to_string(),
        vec![],
        vec![],
        Type::unit(),
        None,
    );
    let cloned = def.clone();
    assert_eq!(cloned.name, "foo");
}

// ============================================================
// EffectDef Tests
// ============================================================

#[test]
fn test_effect_def_new() {
    let ops = vec![
        EffectOpDef::new("print".to_string(), vec![Type::str()], Type::unit()),
        EffectOpDef::new("read".to_string(), vec![], Type::str()),
    ];
    let def = EffectDef::new("Console".to_string(), vec![], ops);

    assert_eq!(def.name, "Console");
    assert_eq!(def.operations.len(), 2);
}

#[test]
fn test_effect_def_find_operation() {
    let ops = vec![
        EffectOpDef::new("print".to_string(), vec![Type::str()], Type::unit()),
        EffectOpDef::new("read".to_string(), vec![], Type::str()),
    ];
    let def = EffectDef::new("Console".to_string(), vec![], ops);

    let print_op = def.find_operation("print");
    assert!(print_op.is_some());
    assert_eq!(print_op.unwrap().name, "print");

    let read_op = def.find_operation("read");
    assert!(read_op.is_some());
    assert_eq!(read_op.unwrap().name, "read");

    let missing = def.find_operation("write");
    assert!(missing.is_none());
}

#[test]
fn test_effect_def_clone() {
    let def = EffectDef::new("IO".to_string(), vec![], vec![]);
    let cloned = def.clone();
    assert_eq!(cloned.name, "IO");
}

#[test]
fn test_effect_op_def_new() {
    let op = EffectOpDef::new("print".to_string(), vec![Type::str()], Type::unit());

    assert_eq!(op.name, "print");
    assert_eq!(op.params.len(), 1);
    assert_eq!(op.ret.display(), "()");
}

#[test]
fn test_effect_op_def_clone() {
    let op = EffectOpDef::new("foo".to_string(), vec![], Type::unit());
    let cloned = op.clone();
    assert_eq!(cloned.name, "foo");
}

// ============================================================
// TraitDef Tests
// ============================================================

#[test]
fn test_trait_def_find_method() {
    let methods = vec![
        TraitMethodDef {
            name: "clone".to_string(),
            type_params: vec![],
            params: vec![],
            ret: Type::i32(), // placeholder
            has_default: false,
        },
    ];
    let def = TraitDef {
        name: "Clone".to_string(),
        def_id: DefId::new(1),
        type_params: vec![],
        supertraits: vec![],
        methods,
        assoc_types: vec![],
    };

    let method = def.find_method("clone");
    assert!(method.is_some());
    assert_eq!(method.unwrap().name, "clone");

    let missing = def.find_method("copy");
    assert!(missing.is_none());
}

#[test]
fn test_trait_def_find_assoc_type() {
    let assoc_types = vec![
        TraitAssocTypeDef {
            name: "Item".to_string(),
            bounds: vec![],
            default: None,
        },
    ];
    let def = TraitDef {
        name: "Iterator".to_string(),
        def_id: DefId::new(1),
        type_params: vec![],
        supertraits: vec![],
        methods: vec![],
        assoc_types,
    };

    let item = def.find_assoc_type("Item");
    assert!(item.is_some());
    assert_eq!(item.unwrap().name, "Item");

    let missing = def.find_assoc_type("Output");
    assert!(missing.is_none());
}

#[test]
fn test_trait_def_clone() {
    let def = TraitDef {
        name: "Clone".to_string(),
        def_id: DefId::new(1),
        type_params: vec![],
        supertraits: vec![],
        methods: vec![],
        assoc_types: vec![],
    };
    let cloned = def.clone();
    assert_eq!(cloned.name, "Clone");
}

#[test]
fn test_trait_method_def_clone() {
    let method = TraitMethodDef {
        name: "foo".to_string(),
        type_params: vec![],
        params: vec![],
        ret: Type::unit(),
        has_default: true,
    };
    let cloned = method.clone();
    assert_eq!(cloned.name, "foo");
    assert!(cloned.has_default);
}

#[test]
fn test_trait_assoc_type_def_clone() {
    let assoc = TraitAssocTypeDef {
        name: "Item".to_string(),
        bounds: vec![DefId::new(1)],
        default: Some(Type::i32()),
    };
    let cloned = assoc.clone();
    assert_eq!(cloned.name, "Item");
    assert!(cloned.default.is_some());
}

// ============================================================
// ImplDef Tests
// ============================================================

#[test]
fn test_impl_def_clone() {
    let def = ImplDef {
        trait_id: DefId::new(1),
        type_params: vec![],
        self_ty: Type::i32(),
        methods: vec![],
        assoc_types: vec![],
    };
    let cloned = def.clone();
    assert_eq!(cloned.trait_id.id(), 1);
    assert_eq!(cloned.self_ty.display(), "i32");
}

#[test]
fn test_impl_method_def_clone() {
    let method = ImplMethodDef {
        name: "clone".to_string(),
        fn_def_id: DefId::new(42),
    };
    let cloned = method.clone();
    assert_eq!(cloned.name, "clone");
    assert_eq!(cloned.fn_def_id.id(), 42);
}

#[test]
fn test_impl_assoc_type_def_clone() {
    let assoc = ImplAssocTypeDef {
        name: "Item".to_string(),
        ty: Type::i32(),
    };
    let cloned = assoc.clone();
    assert_eq!(cloned.name, "Item");
    assert_eq!(cloned.ty.display(), "i32");
}

// ============================================================
// DefRegistry Tests
// ============================================================

#[test]
fn test_def_registry_new() {
    let reg = DefRegistry::new();
    // Fresh registry should have nothing
    let id = DefId::new(0);
    assert!(reg.get_type(&id).is_none());
    assert!(reg.get_fn(&id).is_none());
    assert!(reg.get_effect(&id).is_none());
    assert!(reg.get_trait(&id).is_none());
}

#[test]
fn test_def_registry_fresh_def_id() {
    let mut reg = DefRegistry::new();
    let id1 = reg.fresh_def_id();
    let id2 = reg.fresh_def_id();

    assert_eq!(id1.id(), 0);
    assert_eq!(id2.id(), 1);
}

#[test]
fn test_def_registry_register_type() {
    let mut reg = DefRegistry::new();
    let id = reg.fresh_def_id();
    let def = TypeDef::new_struct("Point".to_string(), vec![], vec![]);

    reg.register_type(id.clone(), def);

    let retrieved = reg.get_type(&id);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().name, "Point");
}

#[test]
fn test_def_registry_register_fn() {
    let mut reg = DefRegistry::new();
    let id = reg.fresh_def_id();
    let def = FnDef::new("add".to_string(), vec![], vec![], Type::i32(), None);

    reg.register_fn(id.clone(), def);

    let retrieved = reg.get_fn(&id);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().name, "add");
}

#[test]
fn test_def_registry_register_effect() {
    let mut reg = DefRegistry::new();
    let id = reg.fresh_def_id();
    let def = EffectDef::new("Console".to_string(), vec![], vec![]);

    reg.register_effect(id.clone(), def);

    let retrieved = reg.get_effect(&id);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().name, "Console");
}

#[test]
fn test_def_registry_register_trait() {
    let mut reg = DefRegistry::new();
    let id = reg.fresh_def_id();
    let def = TraitDef {
        name: "Clone".to_string(),
        def_id: id.clone(),
        type_params: vec![],
        supertraits: vec![],
        methods: vec![],
        assoc_types: vec![],
    };

    reg.register_trait(id.clone(), def);

    let retrieved = reg.get_trait(&id);
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().name, "Clone");
}

#[test]
fn test_def_registry_register_impl() {
    let mut reg = DefRegistry::new();
    let trait_id = DefId::new(1);
    let impl_def = ImplDef {
        trait_id: trait_id.clone(),
        type_params: vec![],
        self_ty: Type::i32(),
        methods: vec![],
        assoc_types: vec![],
    };

    reg.register_impl(impl_def);

    let impls = reg.find_impls(&trait_id);
    assert_eq!(impls.len(), 1);
}

#[test]
fn test_def_registry_find_impls() {
    let mut reg = DefRegistry::new();
    let trait1 = DefId::new(1);
    let trait2 = DefId::new(2);

    reg.register_impl(ImplDef {
        trait_id: trait1.clone(),
        type_params: vec![],
        self_ty: Type::i32(),
        methods: vec![],
        assoc_types: vec![],
    });
    reg.register_impl(ImplDef {
        trait_id: trait1.clone(),
        type_params: vec![],
        self_ty: Type::bool(),
        methods: vec![],
        assoc_types: vec![],
    });
    reg.register_impl(ImplDef {
        trait_id: trait2.clone(),
        type_params: vec![],
        self_ty: Type::i32(),
        methods: vec![],
        assoc_types: vec![],
    });

    let impls1 = reg.find_impls(&trait1);
    assert_eq!(impls1.len(), 2);

    let impls2 = reg.find_impls(&trait2);
    assert_eq!(impls2.len(), 1);

    let impls_none = reg.find_impls(&DefId::new(99));
    assert_eq!(impls_none.len(), 0);
}

#[test]
fn test_def_registry_get_type_not_found() {
    let reg = DefRegistry::new();
    assert!(reg.get_type(&DefId::new(99)).is_none());
}

#[test]
fn test_def_registry_get_fn_not_found() {
    let reg = DefRegistry::new();
    assert!(reg.get_fn(&DefId::new(99)).is_none());
}

#[test]
fn test_def_registry_get_effect_not_found() {
    let reg = DefRegistry::new();
    assert!(reg.get_effect(&DefId::new(99)).is_none());
}

#[test]
fn test_def_registry_get_trait_not_found() {
    let reg = DefRegistry::new();
    assert!(reg.get_trait(&DefId::new(99)).is_none());
}

// ============================================================
// TypeDefKind Clone Tests
// ============================================================

#[test]
fn test_type_def_kind_clone_struct() {
    let kind = TypeDefKind::Struct {
        fields: vec![StructFieldDef { name: "x".to_string(), ty: Type::i32() }],
    };
    let cloned = kind.clone();
    match cloned {
        TypeDefKind::Struct { fields } => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0].name, "x");
        }
        TypeDefKind::Enum { variants: _ } => panic!("Expected Struct"),
    }
}

#[test]
fn test_type_def_kind_clone_enum() {
    let kind = TypeDefKind::Enum {
        variants: vec![EnumVariantDef { name: "A".to_string(), payload: None }],
    };
    let cloned = kind.clone();
    match cloned {
        TypeDefKind::Enum { variants } => {
            assert_eq!(variants.len(), 1);
            assert_eq!(variants[0].name, "A");
        }
        TypeDefKind::Struct { fields: _ } => panic!("Expected Enum"),
    }
}
