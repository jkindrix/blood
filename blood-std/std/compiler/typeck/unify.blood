/// Type Unification for Blood Type Checker
///
/// This module implements Hindley-Milner style type unification.
/// Unification is the process of making two types equal by finding
/// substitutions for type variables.
///
/// # Design Principles
///
/// 1. **Explicit patterns**: Every TypeKind variant is explicitly handled
/// 2. **Occurs check**: Prevents infinite types
/// 3. **Effect unification**: Supports row polymorphism for effects
/// 4. **Error recovery**: Error types unify with anything
///
/// # Implemented Features (Aligned with Rust Reference Compiler)
///
/// - **Unit type equivalence**: `unit` == `()`
/// - **Array-to-slice coercion**: `[T; N]` coerces to `[T]`
/// - **Closure-function unification**: Closures unify with compatible fn types
/// - **Ownership qualifier coercion**: `linear T` -> `affine T`, plain -> qualified
/// - **Record row polymorphism**: Full row variable binding and unification
/// - **Forall alpha-renaming**: Proper instantiation with fresh variables
///
/// # Known Limitations
///
/// - **Effect type arguments**: Effect def_id matching only; type args not fully checked
///   (See `effect_in_row` function for details)
/// - **Performance**: Uses string-based field names (O(n) lookup) vs interned symbols
/// - **Iterators**: Uses explicit while loops; Blood lacks iterator adapters
///
/// See COMPILER_NOTES.md for detailed design documentation.

use std.collections::{HashMap};
use std.compiler.parser::{Span};
use std.compiler.typeck.types::{
    Type, TypeKind, TyVarId, DefId, PrimitiveTy, Mutability, Ownership,
    EffectRow, EffectInstance, EffectRowVarId, RecordField, RecordRowVarId,
};
use std.compiler.typeck.errors::{TypeError, TypeErrorKind};

// ============================================================
// Unifier
// ============================================================

/// The unifier maintains type variable substitutions.
///
/// During type inference, the unifier records how type variables
/// map to concrete types, allowing unresolved types to be filled in.
pub struct Unifier {
    /// Type variable substitutions: id -> resolved type
    substitutions: HashMap<u32, Type>,
    /// The next type variable ID to assign
    next_var: u32,
    /// Row variable substitutions for record types
    row_substitutions: HashMap<u32, ([RecordField], Option<RecordRowVarId>)>,
    /// The next row variable ID
    next_row_var: u32,
    /// Effect row variable substitutions
    effect_row_substitutions: HashMap<u32, EffectRow>,
    /// The next effect row variable ID
    next_effect_row_var: u32,
}

impl Unifier {
    /// Create a new empty unifier.
    pub fn new() -> Unifier {
        Unifier {
            substitutions: HashMap::new(),
            next_var: 0,
            row_substitutions: HashMap::new(),
            next_row_var: 0,
            effect_row_substitutions: HashMap::new(),
            next_effect_row_var: 0,
        }
    }

    // --------------------------------------------------------
    // Fresh Variable Generation
    // --------------------------------------------------------

    /// Create a fresh type variable.
    pub fn fresh_var(&mut self) -> Type {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        Type::infer(id)
    }

    /// Create multiple fresh type variables.
    pub fn fresh_vars(&mut self, count: u32) -> [Type] {
        let mut vars: [Type] = vec![];
        let mut i: u32 = 0;
        while i < count {
            vars.push(self.fresh_var());
            i = i + 1;
        }
        vars
    }

    /// Create a fresh type variable ID for forall-bound parameters.
    pub fn fresh_forall_var(&mut self) -> TyVarId {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        id
    }

    /// Create a fresh row variable for record types.
    pub fn fresh_row_var(&mut self) -> RecordRowVarId {
        let id = RecordRowVarId::new(self.next_row_var);
        self.next_row_var = self.next_row_var + 1;
        id
    }

    /// Create a fresh effect row variable.
    pub fn fresh_effect_row_var(&mut self) -> EffectRowVarId {
        let id = EffectRowVarId::new(self.next_effect_row_var);
        self.next_effect_row_var = self.next_effect_row_var + 1;
        id
    }

    // --------------------------------------------------------
    // Type Resolution
    // --------------------------------------------------------

    /// Resolve a type by following substitutions.
    ///
    /// If the type is an inference variable that has been substituted,
    /// recursively resolve to find the final type.
    pub fn resolve(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id()) {
                    Some(resolved) => self.resolve(resolved),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Tuple(_) => ty.clone(),
            TypeKind::Array { element: _, size: _ } => ty.clone(),
            TypeKind::Slice { element: _ } => ty.clone(),
            TypeKind::Ref { inner: _, mutability: _ } => ty.clone(),
            TypeKind::Ptr { inner: _, mutability: _ } => ty.clone(),
            TypeKind::Fn { params: _, ret: _, effect: _ } => ty.clone(),
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => ty.clone(),
            TypeKind::Adt { def_id: _, type_args: _ } => ty.clone(),
            TypeKind::Range { element: _, inclusive: _ } => ty.clone(),
            TypeKind::DynTrait { trait_id: _ } => ty.clone(),
            TypeKind::Record { fields: _, row_var: _ } => ty.clone(),
            TypeKind::Forall { params: _, body: _ } => ty.clone(),
            TypeKind::Param(_) => ty.clone(),
            TypeKind::Ownership { inner: _, ownership: _ } => ty.clone(),
            TypeKind::Error => ty.clone(),
        }
    }

    /// Apply substitutions recursively to get a fully resolved type.
    pub fn apply(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id()) {
                    Some(resolved) => self.apply(resolved),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Error => ty.clone(),
            TypeKind::Param(_) => ty.clone(),
            TypeKind::Tuple(tys) => {
                let mut applied: [Type] = vec![];
                let mut i: usize = 0;
                while i < tys.len() {
                    applied.push(self.apply(&tys[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Tuple(applied))
            }
            TypeKind::Array { element, size } => {
                Type::new(TypeKind::Array {
                    element: Box::new(self.apply(element)),
                    size: *size,
                })
            }
            TypeKind::Slice { element } => {
                Type::new(TypeKind::Slice {
                    element: Box::new(self.apply(element)),
                })
            }
            TypeKind::Ref { inner, mutability } => {
                Type::new(TypeKind::Ref {
                    inner: Box::new(self.apply(inner)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Ptr { inner, mutability } => {
                Type::new(TypeKind::Ptr {
                    inner: Box::new(self.apply(inner)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Fn { params, ret, effect } => {
                let mut applied_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    applied_params.push(self.apply(&params[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Fn {
                    params: applied_params,
                    ret: Box::new(self.apply(ret)),
                    effect: effect.clone(),
                })
            }
            TypeKind::Closure { params, ret, effect, captures } => {
                let mut applied_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    applied_params.push(self.apply(&params[i]));
                    i = i + 1;
                };
                let mut applied_captures: [Type] = vec![];
                i = 0;
                while i < captures.len() {
                    applied_captures.push(self.apply(&captures[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Closure {
                    params: applied_params,
                    ret: Box::new(self.apply(ret)),
                    effect: effect.clone(),
                    captures: applied_captures,
                })
            }
            TypeKind::Adt { def_id, type_args } => {
                let mut applied_args: [Type] = vec![];
                let mut i: usize = 0;
                while i < type_args.len() {
                    applied_args.push(self.apply(&type_args[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Adt {
                    def_id: def_id.clone(),
                    type_args: applied_args,
                })
            }
            TypeKind::Range { element, inclusive } => {
                Type::new(TypeKind::Range {
                    element: Box::new(self.apply(element)),
                    inclusive: *inclusive,
                })
            }
            TypeKind::DynTrait { trait_id } => {
                Type::new(TypeKind::DynTrait {
                    trait_id: trait_id.clone(),
                })
            }
            TypeKind::Record { fields, row_var } => {
                let mut applied_fields: [RecordField] = vec![];
                let mut i: usize = 0;
                while i < fields.len() {
                    applied_fields.push(RecordField {
                        name: fields[i].name.clone(),
                        ty: self.apply(&fields[i].ty),
                    });
                    i = i + 1;
                }
                Type::new(TypeKind::Record {
                    fields: applied_fields,
                    row_var: row_var.clone(),
                })
            }
            TypeKind::Forall { params, body } => {
                Type::new(TypeKind::Forall {
                    params: params.clone(),
                    body: Box::new(self.apply(body)),
                })
            }
            TypeKind::Ownership { inner, ownership } => {
                Type::new(TypeKind::Ownership {
                    inner: Box::new(self.apply(inner)),
                    ownership: ownership.clone(),
                })
            }
        }
    }

    // --------------------------------------------------------
    // Unification
    // --------------------------------------------------------

    /// Unify two types, recording substitutions.
    ///
    /// Returns Ok(()) if unification succeeds, Err if types are incompatible.
    pub fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        // Resolve any existing substitutions first
        let t1 = self.resolve(t1);
        let t2 = self.resolve(t2);

        match (&t1.kind, &t2.kind) {
            // Same primitive types unify
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                if self.primitive_eq(p1, p2) {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }

            // Never type unifies with anything (bottom type)
            (TypeKind::Never, _) => Ok(()),
            (_, TypeKind::Never) => Ok(()),

            // Error type unifies with anything (for error recovery)
            (TypeKind::Error, _) => Ok(()),
            (_, TypeKind::Error) => Ok(()),

            // Unit type equivalence: Primitive(Unit) == Tuple([])
            // The unit type can be represented as either:
            // - PrimitiveTy::Unit (from parsing `unit` keyword)
            // - Tuple([]) (from parsing `()` or Type::unit())
            // These should unify successfully.
            (TypeKind::Primitive(PrimitiveTy::Unit), TypeKind::Tuple(ts)) => {
                if ts.len() == 0 {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }
            (TypeKind::Tuple(ts), TypeKind::Primitive(PrimitiveTy::Unit)) => {
                if ts.len() == 0 {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }

            // Tuples with same length
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() != ts2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < ts1.len() {
                    self.unify(&ts1[i], &ts2[i], span)?;
                    i = i + 1;
                };
                Ok(())
            }

            // Arrays with same size
            (TypeKind::Array { element: e1, size: s1 }, TypeKind::Array { element: e2, size: s2 }) => {
                if s1 != s2 {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(e1, e2, span);
            }

            // Slices
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.unify(e1, e2, span);
            }

            // Array to slice coercion: [T; N] coerces to [T]
            // This allows passing arrays where slices are expected.
            // The element types must unify, but the size is discarded.
            (TypeKind::Array { element: e1, size: _ }, TypeKind::Slice { element: e2 }) => {
                self.unify(e1, e2, span);
            }
            (TypeKind::Slice { element: e1 }, TypeKind::Array { element: e2, size: _ }) => {
                self.unify(e1, e2, span);
            }

            // References with same mutability
            (TypeKind::Ref { inner: i1, mutability: m1 }, TypeKind::Ref { inner: i2, mutability: m2 }) => {
                if !self.mutability_eq(m1, m2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(i1, i2, span);
            }

            // Pointers with same mutability
            (TypeKind::Ptr { inner: i1, mutability: m1 }, TypeKind::Ptr { inner: i2, mutability: m2 }) => {
                if !self.mutability_eq(m1, m2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(i1, i2, span);
            }

            // Function types
            (TypeKind::Fn { params: p1, ret: r1, effect: e1 }, TypeKind::Fn { params: p2, ret: r2, effect: e2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                self.unify_effects(e1, e2, span);
            }

            // Closure types
            (TypeKind::Closure { params: p1, ret: r1, effect: e1, captures: c1 },
             TypeKind::Closure { params: p2, ret: r2, effect: e2, captures: c2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                if c1.len() != c2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                i = 0;
                while i < c1.len() {
                    self.unify(&c1[i], &c2[i], span)?;
                    i = i + 1;
                };
                self.unify_effects(e1, e2, span);
            }

            // Closure can unify with compatible function type
            // This allows passing closures where function types are expected and vice versa.
            // The parameter count and types must match, and return types must unify.
            // Note: captures are ignored when unifying with a function type.
            (TypeKind::Closure { params: p1, ret: r1, effect: e1, captures: _ },
             TypeKind::Fn { params: p2, ret: r2, effect: e2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                self.unify_effects(e1, e2, span);
            }
            (TypeKind::Fn { params: p1, ret: r1, effect: e1 },
             TypeKind::Closure { params: p2, ret: r2, effect: e2, captures: _ }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                self.unify_effects(e1, e2, span);
            }

            // ADTs with same def_id and unifiable type args
            (TypeKind::Adt { def_id: d1, type_args: a1 }, TypeKind::Adt { def_id: d2, type_args: a2 }) => {
                if !d1.eq(d2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                if a1.len() != a2.len() {
                    return Err(TypeError::wrong_arity(a1.len() as u32, a2.len() as u32, span));
                };
                let mut i: usize = 0;
                while i < a1.len() {
                    self.unify(&a1[i], &a2[i], span)?;
                    i = i + 1;
                };
                Ok(())
            }

            // Range types
            (TypeKind::Range { element: e1, inclusive: i1 }, TypeKind::Range { element: e2, inclusive: i2 }) => {
                if i1 != i2 {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(e1, e2, span);
            }

            // DynTrait types
            (TypeKind::DynTrait { trait_id: t1_id }, TypeKind::DynTrait { trait_id: t2_id }) => {
                if !t1_id.eq(t2_id) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                Ok(())
            }

            // Record types (row polymorphism)
            // Row polymorphism allows records with extra fields to match:
            // - {x: i32, y: bool} matches {x: i32, y: bool}
            // - {x: i32 | R} matches {x: i32, y: bool} (R binds to {y: bool})
            (TypeKind::Record { fields: f1, row_var: r1 }, TypeKind::Record { fields: f2, row_var: r2 }) => {
                self.unify_records(f1, r1, f2, r2, span);
            }

            // Forall types (parametric polymorphism)
            // Two forall types unify if they have the same number of params
            // and their bodies unify under alpha-renaming.
            (TypeKind::Forall { params: p1, body: b1 }, TypeKind::Forall { params: p2, body: b2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                // For alpha-equivalence, we instantiate both with the same fresh variables
                // and check if the bodies unify.
                let fresh_vars = self.fresh_vars(p1.len() as u32);

                // Build substitution maps
                let mut subst1: HashMap<u32, Type> = HashMap::new();
                let mut i: usize = 0;
                while i < p1.len() {
                    subst1.insert(p1[i].id(), fresh_vars[i].clone());
                    i = i + 1;
                };

                let mut subst2: HashMap<u32, Type> = HashMap::new();
                i = 0;
                while i < p2.len() {
                    subst2.insert(p2[i].id(), fresh_vars[i].clone());
                    i = i + 1;
                };

                // Substitute and unify
                let b1_inst = self.substitute_forall_params(b1, &subst1);
                let b2_inst = self.substitute_forall_params(b2, &subst2);
                self.unify(&b1_inst, &b2_inst, span);
            }

            // When unifying a forall with a non-forall on the right, instantiate the forall.
            // This handles cases like: forall<T>. T -> T  vs  i32 -> i32
            (TypeKind::Forall { params, body }, _) => {
                // Instantiate with fresh inference variables
                let fresh_vars = self.fresh_vars(params.len() as u32);

                let mut subst: HashMap<u32, Type> = HashMap::new();
                let mut i: usize = 0;
                while i < params.len() {
                    subst.insert(params[i].id(), fresh_vars[i].clone());
                    i = i + 1;
                };

                let body_inst = self.substitute_forall_params(body, &subst);
                self.unify(&body_inst, &t2, span);
            }

            // When unifying a non-forall with a forall on the right
            (_, TypeKind::Forall { params, body }) => {
                // Instantiate with fresh inference variables
                let fresh_vars = self.fresh_vars(params.len() as u32);

                let mut subst: HashMap<u32, Type> = HashMap::new();
                let mut i: usize = 0;
                while i < params.len() {
                    subst.insert(params[i].id(), fresh_vars[i].clone());
                    i = i + 1;
                };

                let body_inst = self.substitute_forall_params(body, &subst);
                self.unify(&t1, &body_inst, span);
            }

            // Type variable on left - bind it
            (TypeKind::Infer(id), _) => {
                if self.occurs_in(id, &t2) {
                    return Err(TypeError::occurs_check(id.clone(), t2.clone(), span));
                };
                self.substitutions.insert(id.id(), t2.clone());
                Ok(())
            }

            // Type variable on right - bind it
            (_, TypeKind::Infer(id)) => {
                if self.occurs_in(id, &t1) {
                    return Err(TypeError::occurs_check(id.clone(), t1.clone(), span));
                };
                self.substitutions.insert(id.id(), t1.clone());
                Ok(())
            }

            // Type parameters (bound by forall)
            (TypeKind::Param(p1), TypeKind::Param(p2)) => {
                if p1.eq(p2) {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }

            // Ownership-qualified types with same qualifier
            (TypeKind::Ownership { inner: i1, ownership: o1 }, TypeKind::Ownership { inner: i2, ownership: o2 }) => {
                // Same qualifier - just unify inner types
                if self.ownership_eq(o1, o2) {
                    return self.unify(i1, i2, span);
                };
                // Coercion: linear T -> affine T
                // Linear is stricter than affine, so we can relax linear to affine.
                // (Linear: must use exactly once, Affine: can use at most once)
                match (o1, o2) {
                    (Ownership::Affine, Ownership::Linear) => self.unify(i1, i2, span),
                    // No other coercions between ownership qualifiers
                    (Ownership::Linear, Ownership::Affine) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    (Ownership::Linear, Ownership::Default) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    (Ownership::Affine, Ownership::Default) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    (Ownership::Default, Ownership::Linear) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    (Ownership::Default, Ownership::Affine) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    // Same qualifier cases already handled above
                    (Ownership::Linear, Ownership::Linear) => self.unify(i1, i2, span),
                    (Ownership::Affine, Ownership::Affine) => self.unify(i1, i2, span),
                    (Ownership::Default, Ownership::Default) => self.unify(i1, i2, span),
                }
            }

            // Coercion: T -> linear T or T -> affine T
            // A plain type can be promoted to an ownership-qualified type.
            // This allows passing unqualified types where ownership-qualified types are expected.
            (TypeKind::Ownership { inner, ownership: _ }, _) => {
                // Check that the found type is NOT an ownership type
                match &t2.kind {
                    TypeKind::Ownership { inner: _, ownership: _ } => {
                        // Both are ownership types but with different qualifiers
                        // This case is handled above
                        Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                    }
                    _ => {
                        // Plain type found, ownership expected - promote
                        self.unify(inner, &t2, span)
                    }
                }
            }

            // Explicit non-matching cases
            (TypeKind::Primitive(_), TypeKind::Never) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Primitive-Forall: handled by Forall instantiation above
            (TypeKind::Primitive(_), TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Tuple(_), TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Tuple-Forall: handled by Forall instantiation above
            (TypeKind::Tuple(_), TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Array { element: _, size: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Array-Slice coercion is now handled above - removed error case
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Array-Forall: handled by Forall instantiation above
            (TypeKind::Array { element: _, size: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Slice { element: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Slice-Array coercion is now handled above - removed error case
            (TypeKind::Slice { element: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Slice-Forall: handled by Forall instantiation above
            (TypeKind::Slice { element: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Ref-Forall: handled by Forall instantiation above
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Ptr-Forall: handled by Forall instantiation above
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Fn-Closure unification is now handled above - removed error case
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Fn-Forall: handled by Forall instantiation above
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Closure-Fn unification is now handled above - removed error case
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Closure-Forall: handled by Forall instantiation above
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Adt-Forall: handled by Forall instantiation above
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Range-Forall: handled by Forall instantiation above
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // DynTrait-Forall: handled by Forall instantiation above
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Record-Forall: handled by Forall instantiation above
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            // Forall-* cases are now handled by the instantiation logic above.
            // The catch-all cases (TypeKind::Forall { params, body }, _) and
            // (_, TypeKind::Forall { params, body }) handle all Forall instantiation.

            (TypeKind::Param(_), TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            // Param-Forall: handled by Forall instantiation above
            (TypeKind::Param(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            // Ownership-* cases are now handled by the coercion logic above
            // The coercion case (TypeKind::Ownership { inner, ownership: _ }, _) catches all
            // remaining cases and either promotes plain types or returns a mismatch error.
        }
    }

    // --------------------------------------------------------
    // Occurs Check
    // --------------------------------------------------------

    /// Check if a type variable occurs in a type (prevents infinite types).
    fn occurs_in(&self, var: &TyVarId, ty: &Type) -> bool {
        let ty = self.resolve(ty);
        match &ty.kind {
            TypeKind::Infer(id) => id.eq(var),
            TypeKind::Param(id) => id.eq(var),
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Error => false,
            TypeKind::Tuple(tys) => {
                let mut i: usize = 0;
                while i < tys.len() {
                    if self.occurs_in(var, &tys[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Array { element, size: _ } => self.occurs_in(var, element),
            TypeKind::Slice { element } => self.occurs_in(var, element),
            TypeKind::Ref { inner, mutability: _ } => self.occurs_in(var, inner),
            TypeKind::Ptr { inner, mutability: _ } => self.occurs_in(var, inner),
            TypeKind::Fn { params, ret, effect: _ } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    };
                    i = i + 1;
                };
                self.occurs_in(var, ret);
            }
            TypeKind::Closure { params, ret, effect: _, captures } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    };
                    i = i + 1;
                };
                if self.occurs_in(var, ret) {
                    return true;
                };
                i = 0;
                while i < captures.len() {
                    if self.occurs_in(var, &captures[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Adt { def_id: _, type_args } => {
                let mut i: usize = 0;
                while i < type_args.len() {
                    if self.occurs_in(var, &type_args[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Range { element, inclusive: _ } => self.occurs_in(var, element),
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields, row_var: _ } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    if self.occurs_in(var, &fields[i].ty) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Forall { params: _, body } => self.occurs_in(var, body),
            TypeKind::Ownership { inner, ownership: _ } => self.occurs_in(var, inner),
        }
    }

    // --------------------------------------------------------
    // Primitive Type Equality
    // --------------------------------------------------------

    /// Check if two primitive types are equal.
    fn primitive_eq(&self, p1: &PrimitiveTy, p2: &PrimitiveTy) -> bool {
        match (p1, p2) {
            (PrimitiveTy::I8, PrimitiveTy::I8) => true,
            (PrimitiveTy::I16, PrimitiveTy::I16) => true,
            (PrimitiveTy::I32, PrimitiveTy::I32) => true,
            (PrimitiveTy::I64, PrimitiveTy::I64) => true,
            (PrimitiveTy::I128, PrimitiveTy::I128) => true,
            (PrimitiveTy::Isize, PrimitiveTy::Isize) => true,
            (PrimitiveTy::U8, PrimitiveTy::U8) => true,
            (PrimitiveTy::U16, PrimitiveTy::U16) => true,
            (PrimitiveTy::U32, PrimitiveTy::U32) => true,
            (PrimitiveTy::U64, PrimitiveTy::U64) => true,
            (PrimitiveTy::U128, PrimitiveTy::U128) => true,
            (PrimitiveTy::Usize, PrimitiveTy::Usize) => true,
            (PrimitiveTy::F32, PrimitiveTy::F32) => true,
            (PrimitiveTy::F64, PrimitiveTy::F64) => true,
            (PrimitiveTy::Bool, PrimitiveTy::Bool) => true,
            (PrimitiveTy::Char, PrimitiveTy::Char) => true,
            (PrimitiveTy::Str, PrimitiveTy::Str) => true,
            (PrimitiveTy::Unit, PrimitiveTy::Unit) => true,
            // Explicit non-matching cases
            (PrimitiveTy::I8, PrimitiveTy::I16) => false,
            (PrimitiveTy::I8, PrimitiveTy::I32) => false,
            (PrimitiveTy::I8, PrimitiveTy::I64) => false,
            (PrimitiveTy::I8, PrimitiveTy::I128) => false,
            (PrimitiveTy::I8, PrimitiveTy::Isize) => false,
            (PrimitiveTy::I8, PrimitiveTy::U8) => false,
            (PrimitiveTy::I8, PrimitiveTy::U16) => false,
            (PrimitiveTy::I8, PrimitiveTy::U32) => false,
            (PrimitiveTy::I8, PrimitiveTy::U64) => false,
            (PrimitiveTy::I8, PrimitiveTy::U128) => false,
            (PrimitiveTy::I8, PrimitiveTy::Usize) => false,
            (PrimitiveTy::I8, PrimitiveTy::F32) => false,
            (PrimitiveTy::I8, PrimitiveTy::F64) => false,
            (PrimitiveTy::I8, PrimitiveTy::Bool) => false,
            (PrimitiveTy::I8, PrimitiveTy::Char) => false,
            (PrimitiveTy::I8, PrimitiveTy::Str) => false,
            (PrimitiveTy::I8, PrimitiveTy::Unit) => false,
            // For brevity, using negation for remaining cases
            // The types module has PartialEq implemented properly
            (PrimitiveTy::I16, _) => false,
            (PrimitiveTy::I32, _) => false,
            (PrimitiveTy::I64, _) => false,
            (PrimitiveTy::I128, _) => false,
            (PrimitiveTy::Isize, _) => false,
            (PrimitiveTy::U8, _) => false,
            (PrimitiveTy::U16, _) => false,
            (PrimitiveTy::U32, _) => false,
            (PrimitiveTy::U64, _) => false,
            (PrimitiveTy::U128, _) => false,
            (PrimitiveTy::Usize, _) => false,
            (PrimitiveTy::F32, _) => false,
            (PrimitiveTy::F64, _) => false,
            (PrimitiveTy::Bool, _) => false,
            (PrimitiveTy::Char, _) => false,
            (PrimitiveTy::Str, _) => false,
            (PrimitiveTy::Unit, _) => false,
        }
    }

    /// Check if two mutability values are equal.
    fn mutability_eq(&self, m1: &Mutability, m2: &Mutability) -> bool {
        match (m1, m2) {
            (Mutability::Immutable, Mutability::Immutable) => true,
            (Mutability::Mutable, Mutability::Mutable) => true,
            (Mutability::Immutable, Mutability::Mutable) => false,
            (Mutability::Mutable, Mutability::Immutable) => false,
        }
    }

    /// Check if two ownership values are equal.
    fn ownership_eq(&self, o1: &Ownership, o2: &Ownership) -> bool {
        match (o1, o2) {
            (Ownership::Linear, Ownership::Linear) => true,
            (Ownership::Affine, Ownership::Affine) => true,
            (Ownership::Default, Ownership::Default) => true,
            (Ownership::Linear, Ownership::Affine) => false,
            (Ownership::Linear, Ownership::Default) => false,
            (Ownership::Affine, Ownership::Linear) => false,
            (Ownership::Affine, Ownership::Default) => false,
            (Ownership::Default, Ownership::Linear) => false,
            (Ownership::Default, Ownership::Affine) => false,
        }
    }

    // --------------------------------------------------------
    // Record Row Polymorphism
    // --------------------------------------------------------

    /// Unify two record types with row polymorphism.
    ///
    /// Row polymorphism allows records with extra fields to match:
    /// - `{x: i32, y: bool}` matches `{x: i32, y: bool}`
    /// - `{x: i32 | R}` matches `{x: i32, y: bool}` (R binds to `{y: bool}`)
    fn unify_records(
        &mut self,
        fields1: &[RecordField],
        row_var1: &Option<RecordRowVarId>,
        fields2: &[RecordField],
        row_var2: &Option<RecordRowVarId>,
        span: Span,
    ) -> Result<(), TypeError> {
        // Build maps of field name -> (index, type) for both records
        let mut map1: HashMap<String, (usize, Type)> = HashMap::new();
        let mut i: usize = 0;
        while i < fields1.len() {
            map1.insert(fields1[i].name.clone(), (i, fields1[i].ty.clone()));
            i = i + 1;
        };

        let mut map2: HashMap<String, (usize, Type)> = HashMap::new();
        i = 0;
        while i < fields2.len() {
            map2.insert(fields2[i].name.clone(), (i, fields2[i].ty.clone()));
            i = i + 1;
        };

        // Find common fields and unify their types
        i = 0;
        while i < fields1.len() {
            let name = &fields1[i].name;
            match map2.get(name) {
                Some((_, ty2)) => {
                    self.unify(&fields1[i].ty, ty2, span)?;
                }
                None => {
                    // Field only in record 1 - handled below
                }
            };
            i = i + 1;
        };

        // Find fields only in record 1
        let mut only_in_1: [RecordField] = vec![];
        i = 0;
        while i < fields1.len() {
            if !map2.contains_key(&fields1[i].name) {
                only_in_1.push(fields1[i].clone());
            };
            i = i + 1;
        };

        // Find fields only in record 2
        let mut only_in_2: [RecordField] = vec![];
        i = 0;
        while i < fields2.len() {
            if !map1.contains_key(&fields2[i].name) {
                only_in_2.push(fields2[i].clone());
            };
            i = i + 1;
        };

        // Handle row polymorphism based on the 4 cases
        let has_extra_1 = only_in_1.len() > 0;
        let has_extra_2 = only_in_2.len() > 0;

        match (row_var1, row_var2) {
            // Both closed (no row vars): must have exact same fields
            (None, None) => {
                if has_extra_1 || has_extra_2 {
                    // Field mismatch - closed records must have identical fields
                    Err(TypeError::mismatch(
                        Type::new(TypeKind::Record {
                            fields: fields1.to_vec(),
                            row_var: row_var1.clone(),
                        }),
                        Type::new(TypeKind::Record {
                            fields: fields2.to_vec(),
                            row_var: row_var2.clone(),
                        }),
                        span,
                    ))
                } else {
                    Ok(())
                }
            }

            // Record 1 is open - bind its row var to record 2's extra fields
            (Some(rv1), None) => {
                if has_extra_1 {
                    // Record 2 is missing fields that record 1 has
                    return Err(TypeError::mismatch(
                        Type::new(TypeKind::Record {
                            fields: fields1.to_vec(),
                            row_var: row_var1.clone(),
                        }),
                        Type::new(TypeKind::Record {
                            fields: fields2.to_vec(),
                            row_var: row_var2.clone(),
                        }),
                        span,
                    ));
                };
                // Bind rv1 to the extra fields from record 2
                self.row_substitutions.insert(rv1.id(), (only_in_2, None));
                Ok(())
            }

            // Record 2 is open - bind its row var to record 1's extra fields
            (None, Some(rv2)) => {
                if has_extra_2 {
                    // Record 1 is missing fields that record 2 has
                    return Err(TypeError::mismatch(
                        Type::new(TypeKind::Record {
                            fields: fields1.to_vec(),
                            row_var: row_var1.clone(),
                        }),
                        Type::new(TypeKind::Record {
                            fields: fields2.to_vec(),
                            row_var: row_var2.clone(),
                        }),
                        span,
                    ));
                };
                // Bind rv2 to the extra fields from record 1
                self.row_substitutions.insert(rv2.id(), (only_in_1, None));
                Ok(())
            }

            // Both open - create a fresh row variable for the union
            (Some(rv1), Some(rv2)) => {
                // Combine extra fields from both records
                let mut combined: [RecordField] = only_in_1.clone();
                i = 0;
                while i < only_in_2.len() {
                    combined.push(only_in_2[i].clone());
                    i = i + 1;
                };

                if combined.len() == 0 {
                    // Same row variables can unify
                    if rv1.id() == rv2.id() {
                        return Ok(());
                    };
                    // Bind rv1 to rv2
                    self.row_substitutions.insert(rv1.id(), (vec![], Some(rv2.clone())));
                } else {
                    // Create a fresh row variable for the remainder
                    let fresh_rv = self.fresh_row_var();
                    self.row_substitutions.insert(rv1.id(), (combined.clone(), Some(fresh_rv.clone())));
                    self.row_substitutions.insert(rv2.id(), (combined, Some(fresh_rv)));
                };
                Ok(())
            }
        }
    }

    // --------------------------------------------------------
    // Forall Parameter Substitution
    // --------------------------------------------------------

    /// Substitute forall-bound type parameters with given types.
    /// Used during instantiation of polymorphic types for alpha-renaming.
    fn substitute_forall_params(&self, ty: &Type, subst: &HashMap<u32, Type>) -> Type {
        match &ty.kind {
            TypeKind::Param(id) => {
                match subst.get(&id.id()) {
                    Some(replacement) => replacement.clone(),
                    None => ty.clone(),
                }
            }
            TypeKind::Infer(id) => {
                // Also resolve inference variables through our substitution chain
                match self.substitutions.get(&id.id()) {
                    Some(substituted) => self.substitute_forall_params(substituted, subst),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Error => ty.clone(),
            TypeKind::Tuple(tys) => {
                let mut result: [Type] = vec![];
                let mut i: usize = 0;
                while i < tys.len() {
                    result.push(self.substitute_forall_params(&tys[i], subst));
                    i = i + 1;
                };
                Type::new(TypeKind::Tuple(result))
            }
            TypeKind::Array { element, size } => {
                Type::new(TypeKind::Array {
                    element: Box::new(self.substitute_forall_params(element, subst)),
                    size: *size,
                })
            }
            TypeKind::Slice { element } => {
                Type::new(TypeKind::Slice {
                    element: Box::new(self.substitute_forall_params(element, subst)),
                })
            }
            TypeKind::Ref { inner, mutability } => {
                Type::new(TypeKind::Ref {
                    inner: Box::new(self.substitute_forall_params(inner, subst)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Ptr { inner, mutability } => {
                Type::new(TypeKind::Ptr {
                    inner: Box::new(self.substitute_forall_params(inner, subst)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Fn { params, ret, effect } => {
                let mut result_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    result_params.push(self.substitute_forall_params(&params[i], subst));
                    i = i + 1;
                };
                Type::new(TypeKind::Fn {
                    params: result_params,
                    ret: Box::new(self.substitute_forall_params(ret, subst)),
                    effect: effect.clone(),
                })
            }
            TypeKind::Closure { params, ret, effect, captures } => {
                let mut result_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    result_params.push(self.substitute_forall_params(&params[i], subst));
                    i = i + 1;
                };
                let mut result_captures: [Type] = vec![];
                i = 0;
                while i < captures.len() {
                    result_captures.push(self.substitute_forall_params(&captures[i], subst));
                    i = i + 1;
                };
                Type::new(TypeKind::Closure {
                    params: result_params,
                    ret: Box::new(self.substitute_forall_params(ret, subst)),
                    effect: effect.clone(),
                    captures: result_captures,
                })
            }
            TypeKind::Adt { def_id, type_args } => {
                let mut result_args: [Type] = vec![];
                let mut i: usize = 0;
                while i < type_args.len() {
                    result_args.push(self.substitute_forall_params(&type_args[i], subst));
                    i = i + 1;
                };
                Type::new(TypeKind::Adt {
                    def_id: def_id.clone(),
                    type_args: result_args,
                })
            }
            TypeKind::Range { element, inclusive } => {
                Type::new(TypeKind::Range {
                    element: Box::new(self.substitute_forall_params(element, subst)),
                    inclusive: *inclusive,
                })
            }
            TypeKind::DynTrait { trait_id } => {
                Type::new(TypeKind::DynTrait {
                    trait_id: trait_id.clone(),
                })
            }
            TypeKind::Record { fields, row_var } => {
                let mut result_fields: [RecordField] = vec![];
                let mut i: usize = 0;
                while i < fields.len() {
                    result_fields.push(RecordField {
                        name: fields[i].name.clone(),
                        ty: self.substitute_forall_params(&fields[i].ty, subst),
                    });
                    i = i + 1;
                };
                Type::new(TypeKind::Record {
                    fields: result_fields,
                    row_var: row_var.clone(),
                })
            }
            TypeKind::Forall { params: inner_params, body } => {
                // Avoid capturing: skip substitution for inner-bound params
                // Build a filtered substitution that excludes inner-bound params
                let mut filtered_subst: HashMap<u32, Type> = HashMap::new();
                // Copy over substitutions that don't conflict with inner params
                // For simplicity, we check if each key is in inner_params
                // This is O(n*m) but typically small
                for (key, value) in subst.iter() {
                    let mut is_bound = false;
                    let mut i: usize = 0;
                    while i < inner_params.len() {
                        if inner_params[i].id() == *key {
                            is_bound = true;
                        };
                        i = i + 1;
                    };
                    if !is_bound {
                        filtered_subst.insert(*key, value.clone());
                    };
                };
                Type::new(TypeKind::Forall {
                    params: inner_params.clone(),
                    body: Box::new(self.substitute_forall_params(body, &filtered_subst)),
                })
            }
            TypeKind::Ownership { inner, ownership } => {
                Type::new(TypeKind::Ownership {
                    inner: Box::new(self.substitute_forall_params(inner, subst)),
                    ownership: ownership.clone(),
                })
            }
        }
    }

    // --------------------------------------------------------
    // Effect Unification
    // --------------------------------------------------------

    /// Unify two effect rows.
    fn unify_effects(&mut self, e1: &Option<EffectRow>, e2: &Option<EffectRow>, span: Span) -> Result<(), TypeError> {
        match (e1, e2) {
            (None, None) => Ok(()),
            (Some(r1), Some(r2)) => self.unify_effect_rows(r1, r2, span),
            (None, Some(r2)) => {
                if r2.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::effect_mismatch(true, span))
                }
            }
            (Some(r1), None) => {
                if r1.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::effect_mismatch(false, span))
                }
            }
        }
    }

    /// Unify two effect rows.
    fn unify_effect_rows(&mut self, r1: &EffectRow, r2: &EffectRow, span: Span) -> Result<(), TypeError> {
        // Simple structural check for now
        // Full row polymorphism would need more sophisticated handling
        if r1.effects().len() != r2.effects().len() {
            return Err(TypeError::effect_row_mismatch(
                r1.effects().len() as u32,
                r2.effects().len() as u32,
                span,
            ));
        };

        // Check that all effects in r1 are in r2
        let mut i: usize = 0;
        while i < r1.effects().len() {
            if !self.effect_in_row(&r1.effects()[i], r2) {
                return Err(TypeError::effect_not_in_row(
                    format!("effect#{}", r1.effects()[i].def_id.id()),
                    span,
                ));
            };
            i = i + 1;
        };

        Ok(())
    }

    /// Check if an effect instance is in an effect row.
    ///
    /// # Limitation
    ///
    /// Currently only checks effect def_id match. For full correctness,
    /// should also verify that type arguments are compatible. For example:
    /// ```
    /// // These should NOT be considered equal:
    /// Error<String>  vs  Error<i32>
    /// ```
    /// This is a known simplification - see COMPILER_NOTES.md.
    fn effect_in_row(&self, effect: &EffectInstance, row: &EffectRow) -> bool {
        let mut i: usize = 0;
        while i < row.effects().len() {
            if row.effects()[i].def_id.eq(&effect.def_id) {
                // LIMITATION: For full correctness, should also check type args match.
                // Example: Error<String> should not unify with Error<i32>.
                // Currently treats them as equal if def_id matches.
                return true;
            };
            i = i + 1;
        }
        false
    }
}
