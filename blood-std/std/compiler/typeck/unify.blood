/// Type Unification for Blood Type Checker
///
/// This module implements Hindley-Milner style type unification.
/// Unification is the process of making two types equal by finding
/// substitutions for type variables.
///
/// # Design Principles
///
/// 1. **Explicit patterns**: Every TypeKind variant is explicitly handled
/// 2. **Occurs check**: Prevents infinite types
/// 3. **Effect unification**: Supports row polymorphism for effects
/// 4. **Error recovery**: Error types unify with anything

use std.collections::{HashMap};
use std.compiler.parser::{Span};
use super.types::{
    Type, TypeKind, TyVarId, DefId, PrimitiveTy, Mutability, Ownership,
    EffectRow, EffectInstance, EffectRowVarId, RecordField, RecordRowVarId,
};
use super.errors::{TypeError, TypeErrorKind};

// ============================================================
// Unifier
// ============================================================

/// The unifier maintains type variable substitutions.
///
/// During type inference, the unifier records how type variables
/// map to concrete types, allowing unresolved types to be filled in.
pub struct Unifier {
    /// Type variable substitutions: id -> resolved type
    substitutions: HashMap<u32, Type>,
    /// The next type variable ID to assign
    next_var: u32,
    /// Row variable substitutions for record types
    row_substitutions: HashMap<u32, ([RecordField], Option<RecordRowVarId>)>,
    /// The next row variable ID
    next_row_var: u32,
    /// Effect row variable substitutions
    effect_row_substitutions: HashMap<u32, EffectRow>,
    /// The next effect row variable ID
    next_effect_row_var: u32,
}

impl Unifier {
    /// Create a new empty unifier.
    pub fn new() -> Unifier {
        Unifier {
            substitutions: HashMap::new(),
            next_var: 0,
            row_substitutions: HashMap::new(),
            next_row_var: 0,
            effect_row_substitutions: HashMap::new(),
            next_effect_row_var: 0,
        }
    }

    // --------------------------------------------------------
    // Fresh Variable Generation
    // --------------------------------------------------------

    /// Create a fresh type variable.
    pub fn fresh_var(&mut self) -> Type {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        Type::infer(id)
    }

    /// Create multiple fresh type variables.
    pub fn fresh_vars(&mut self, count: u32) -> [Type] {
        let mut vars: [Type] = vec![];
        let mut i: u32 = 0;
        while i < count {
            vars.push(self.fresh_var());
            i = i + 1;
        }
        vars
    }

    /// Create a fresh type variable ID for forall-bound parameters.
    pub fn fresh_forall_var(&mut self) -> TyVarId {
        let id = TyVarId::new(self.next_var);
        self.next_var = self.next_var + 1;
        id
    }

    /// Create a fresh row variable for record types.
    pub fn fresh_row_var(&mut self) -> RecordRowVarId {
        let id = RecordRowVarId::new(self.next_row_var);
        self.next_row_var = self.next_row_var + 1;
        id
    }

    /// Create a fresh effect row variable.
    pub fn fresh_effect_row_var(&mut self) -> EffectRowVarId {
        let id = EffectRowVarId::new(self.next_effect_row_var);
        self.next_effect_row_var = self.next_effect_row_var + 1;
        id
    }

    // --------------------------------------------------------
    // Type Resolution
    // --------------------------------------------------------

    /// Resolve a type by following substitutions.
    ///
    /// If the type is an inference variable that has been substituted,
    /// recursively resolve to find the final type.
    pub fn resolve(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id()) {
                    Some(resolved) => self.resolve(resolved),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Tuple(_) => ty.clone(),
            TypeKind::Array { element: _, size: _ } => ty.clone(),
            TypeKind::Slice { element: _ } => ty.clone(),
            TypeKind::Ref { inner: _, mutability: _ } => ty.clone(),
            TypeKind::Ptr { inner: _, mutability: _ } => ty.clone(),
            TypeKind::Fn { params: _, ret: _, effect: _ } => ty.clone(),
            TypeKind::Closure { params: _, ret: _, effect: _, captures: _ } => ty.clone(),
            TypeKind::Adt { def_id: _, type_args: _ } => ty.clone(),
            TypeKind::Range { element: _, inclusive: _ } => ty.clone(),
            TypeKind::DynTrait { trait_id: _ } => ty.clone(),
            TypeKind::Record { fields: _, row_var: _ } => ty.clone(),
            TypeKind::Forall { params: _, body: _ } => ty.clone(),
            TypeKind::Param(_) => ty.clone(),
            TypeKind::Ownership { inner: _, ownership: _ } => ty.clone(),
            TypeKind::Error => ty.clone(),
        }
    }

    /// Apply substitutions recursively to get a fully resolved type.
    pub fn apply(&self, ty: &Type) -> Type {
        match &ty.kind {
            TypeKind::Infer(id) => {
                match self.substitutions.get(&id.id()) {
                    Some(resolved) => self.apply(resolved),
                    None => ty.clone(),
                }
            }
            TypeKind::Primitive(_) => ty.clone(),
            TypeKind::Never => ty.clone(),
            TypeKind::Error => ty.clone(),
            TypeKind::Param(_) => ty.clone(),
            TypeKind::Tuple(tys) => {
                let mut applied: [Type] = vec![];
                let mut i: usize = 0;
                while i < tys.len() {
                    applied.push(self.apply(&tys[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Tuple(applied))
            }
            TypeKind::Array { element, size } => {
                Type::new(TypeKind::Array {
                    element: Box::new(self.apply(element)),
                    size: *size,
                })
            }
            TypeKind::Slice { element } => {
                Type::new(TypeKind::Slice {
                    element: Box::new(self.apply(element)),
                })
            }
            TypeKind::Ref { inner, mutability } => {
                Type::new(TypeKind::Ref {
                    inner: Box::new(self.apply(inner)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Ptr { inner, mutability } => {
                Type::new(TypeKind::Ptr {
                    inner: Box::new(self.apply(inner)),
                    mutability: mutability.clone(),
                })
            }
            TypeKind::Fn { params, ret, effect } => {
                let mut applied_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    applied_params.push(self.apply(&params[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Fn {
                    params: applied_params,
                    ret: Box::new(self.apply(ret)),
                    effect: effect.clone(),
                })
            }
            TypeKind::Closure { params, ret, effect, captures } => {
                let mut applied_params: [Type] = vec![];
                let mut i: usize = 0;
                while i < params.len() {
                    applied_params.push(self.apply(&params[i]));
                    i = i + 1;
                };
                let mut applied_captures: [Type] = vec![];
                i = 0;
                while i < captures.len() {
                    applied_captures.push(self.apply(&captures[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Closure {
                    params: applied_params,
                    ret: Box::new(self.apply(ret)),
                    effect: effect.clone(),
                    captures: applied_captures,
                })
            }
            TypeKind::Adt { def_id, type_args } => {
                let mut applied_args: [Type] = vec![];
                let mut i: usize = 0;
                while i < type_args.len() {
                    applied_args.push(self.apply(&type_args[i]));
                    i = i + 1;
                }
                Type::new(TypeKind::Adt {
                    def_id: def_id.clone(),
                    type_args: applied_args,
                })
            }
            TypeKind::Range { element, inclusive } => {
                Type::new(TypeKind::Range {
                    element: Box::new(self.apply(element)),
                    inclusive: *inclusive,
                })
            }
            TypeKind::DynTrait { trait_id } => {
                Type::new(TypeKind::DynTrait {
                    trait_id: trait_id.clone(),
                })
            }
            TypeKind::Record { fields, row_var } => {
                let mut applied_fields: [RecordField] = vec![];
                let mut i: usize = 0;
                while i < fields.len() {
                    applied_fields.push(RecordField {
                        name: fields[i].name.clone(),
                        ty: self.apply(&fields[i].ty),
                    });
                    i = i + 1;
                }
                Type::new(TypeKind::Record {
                    fields: applied_fields,
                    row_var: row_var.clone(),
                })
            }
            TypeKind::Forall { params, body } => {
                Type::new(TypeKind::Forall {
                    params: params.clone(),
                    body: Box::new(self.apply(body)),
                })
            }
            TypeKind::Ownership { inner, ownership } => {
                Type::new(TypeKind::Ownership {
                    inner: Box::new(self.apply(inner)),
                    ownership: ownership.clone(),
                })
            }
        }
    }

    // --------------------------------------------------------
    // Unification
    // --------------------------------------------------------

    /// Unify two types, recording substitutions.
    ///
    /// Returns Ok(()) if unification succeeds, Err if types are incompatible.
    pub fn unify(&mut self, t1: &Type, t2: &Type, span: Span) -> Result<(), TypeError> {
        // Resolve any existing substitutions first
        let t1 = self.resolve(t1);
        let t2 = self.resolve(t2);

        match (&t1.kind, &t2.kind) {
            // Same primitive types unify
            (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) => {
                if self.primitive_eq(p1, p2) {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }

            // Never type unifies with anything (bottom type)
            (TypeKind::Never, _) => Ok(()),
            (_, TypeKind::Never) => Ok(()),

            // Error type unifies with anything (for error recovery)
            (TypeKind::Error, _) => Ok(()),
            (_, TypeKind::Error) => Ok(()),

            // Tuples with same length
            (TypeKind::Tuple(ts1), TypeKind::Tuple(ts2)) => {
                if ts1.len() != ts2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < ts1.len() {
                    self.unify(&ts1[i], &ts2[i], span)?;
                    i = i + 1;
                };
                Ok(())
            }

            // Arrays with same size
            (TypeKind::Array { element: e1, size: s1 }, TypeKind::Array { element: e2, size: s2 }) => {
                if s1 != s2 {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(e1, e2, span);
            }

            // Slices
            (TypeKind::Slice { element: e1 }, TypeKind::Slice { element: e2 }) => {
                self.unify(e1, e2, span);
            }

            // References with same mutability
            (TypeKind::Ref { inner: i1, mutability: m1 }, TypeKind::Ref { inner: i2, mutability: m2 }) => {
                if !self.mutability_eq(m1, m2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(i1, i2, span);
            }

            // Pointers with same mutability
            (TypeKind::Ptr { inner: i1, mutability: m1 }, TypeKind::Ptr { inner: i2, mutability: m2 }) => {
                if !self.mutability_eq(m1, m2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(i1, i2, span);
            }

            // Function types
            (TypeKind::Fn { params: p1, ret: r1, effect: e1 }, TypeKind::Fn { params: p2, ret: r2, effect: e2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                self.unify_effects(e1, e2, span);
            }

            // Closure types
            (TypeKind::Closure { params: p1, ret: r1, effect: e1, captures: c1 },
             TypeKind::Closure { params: p2, ret: r2, effect: e2, captures: c2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                if c1.len() != c2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < p1.len() {
                    self.unify(&p1[i], &p2[i], span)?;
                    i = i + 1;
                };
                self.unify(r1, r2, span)?;
                i = 0;
                while i < c1.len() {
                    self.unify(&c1[i], &c2[i], span)?;
                    i = i + 1;
                };
                self.unify_effects(e1, e2, span);
            }

            // ADTs with same def_id and unifiable type args
            (TypeKind::Adt { def_id: d1, type_args: a1 }, TypeKind::Adt { def_id: d2, type_args: a2 }) => {
                if !d1.eq(d2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                if a1.len() != a2.len() {
                    return Err(TypeError::wrong_arity(a1.len() as u32, a2.len() as u32, span));
                };
                let mut i: usize = 0;
                while i < a1.len() {
                    self.unify(&a1[i], &a2[i], span)?;
                    i = i + 1;
                };
                Ok(())
            }

            // Range types
            (TypeKind::Range { element: e1, inclusive: i1 }, TypeKind::Range { element: e2, inclusive: i2 }) => {
                if i1 != i2 {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(e1, e2, span);
            }

            // DynTrait types
            (TypeKind::DynTrait { trait_id: t1_id }, TypeKind::DynTrait { trait_id: t2_id }) => {
                if !t1_id.eq(t2_id) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                Ok(())
            }

            // Record types (row polymorphism)
            (TypeKind::Record { fields: f1, row_var: r1 }, TypeKind::Record { fields: f2, row_var: r2 }) => {
                // Simple structural check for now
                // Full row polymorphism would need more sophisticated handling
                if f1.len() != f2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                let mut i: usize = 0;
                while i < f1.len() {
                    if f1[i].name != f2[i].name {
                        return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                    };
                    self.unify(&f1[i].ty, &f2[i].ty, span)?;
                    i = i + 1;
                };
                // Row variables would need unification here
                match (r1, r2) {
                    (None, None) => Ok(()),
                    (Some(_), Some(_)) => Ok(()), // Simplified: assume compatible
                    (Some(_), None) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                    (None, Some(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
                }
            }

            // Forall types (parametric polymorphism)
            (TypeKind::Forall { params: p1, body: b1 }, TypeKind::Forall { params: p2, body: b2 }) => {
                if p1.len() != p2.len() {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                // Would need alpha-renaming for proper comparison
                self.unify(b1, b2, span);
            }

            // Type variable on left - bind it
            (TypeKind::Infer(id), _) => {
                if self.occurs_in(id, &t2) {
                    return Err(TypeError::occurs_check(id.clone(), t2.clone(), span));
                };
                self.substitutions.insert(id.id(), t2.clone());
                Ok(())
            }

            // Type variable on right - bind it
            (_, TypeKind::Infer(id)) => {
                if self.occurs_in(id, &t1) {
                    return Err(TypeError::occurs_check(id.clone(), t1.clone(), span));
                };
                self.substitutions.insert(id.id(), t1.clone());
                Ok(())
            }

            // Type parameters (bound by forall)
            (TypeKind::Param(p1), TypeKind::Param(p2)) => {
                if p1.eq(p2) {
                    Ok(())
                } else {
                    Err(TypeError::mismatch(t1.clone(), t2.clone(), span))
                }
            }

            // Ownership-qualified types
            (TypeKind::Ownership { inner: i1, ownership: o1 }, TypeKind::Ownership { inner: i2, ownership: o2 }) => {
                if !self.ownership_eq(o1, o2) {
                    return Err(TypeError::mismatch(t1.clone(), t2.clone(), span));
                };
                self.unify(i1, i2, span);
            }

            // Explicit non-matching cases
            (TypeKind::Primitive(_), TypeKind::Never) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Primitive(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Tuple(_), TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Tuple(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Array { element: _, size: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Array { element: _, size: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Slice { element: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Slice { element: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ref { inner: _, mutability: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ptr { inner: _, mutability: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Fn { params: _, ret: _, effect: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Adt { def_id: _, type_args: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Range { element: _, inclusive: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::DynTrait { trait_id: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Record { fields: _, row_var: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Forall { params: _, body: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Forall { params: _, body: _ }, TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Param(_), TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Param(_), TypeKind::Ownership { inner: _, ownership: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),

            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Primitive(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Tuple(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Array { element: _, size: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Slice { element: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Ref { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Ptr { inner: _, mutability: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Fn { params: _, ret: _, effect: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Closure { params: _, ret: _, effect: _, captures: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Adt { def_id: _, type_args: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Range { element: _, inclusive: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::DynTrait { trait_id: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Record { fields: _, row_var: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Forall { params: _, body: _ }) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
            (TypeKind::Ownership { inner: _, ownership: _ }, TypeKind::Param(_)) => Err(TypeError::mismatch(t1.clone(), t2.clone(), span)),
        }
    }

    // --------------------------------------------------------
    // Occurs Check
    // --------------------------------------------------------

    /// Check if a type variable occurs in a type (prevents infinite types).
    fn occurs_in(&self, var: &TyVarId, ty: &Type) -> bool {
        let ty = self.resolve(ty);
        match &ty.kind {
            TypeKind::Infer(id) => id.eq(var),
            TypeKind::Param(id) => id.eq(var),
            TypeKind::Primitive(_) => false,
            TypeKind::Never => false,
            TypeKind::Error => false,
            TypeKind::Tuple(tys) => {
                let mut i: usize = 0;
                while i < tys.len() {
                    if self.occurs_in(var, &tys[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Array { element, size: _ } => self.occurs_in(var, element),
            TypeKind::Slice { element } => self.occurs_in(var, element),
            TypeKind::Ref { inner, mutability: _ } => self.occurs_in(var, inner),
            TypeKind::Ptr { inner, mutability: _ } => self.occurs_in(var, inner),
            TypeKind::Fn { params, ret, effect: _ } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    };
                    i = i + 1;
                };
                self.occurs_in(var, ret);
            }
            TypeKind::Closure { params, ret, effect: _, captures } => {
                let mut i: usize = 0;
                while i < params.len() {
                    if self.occurs_in(var, &params[i]) {
                        return true;
                    };
                    i = i + 1;
                };
                if self.occurs_in(var, ret) {
                    return true;
                };
                i = 0;
                while i < captures.len() {
                    if self.occurs_in(var, &captures[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Adt { def_id: _, type_args } => {
                let mut i: usize = 0;
                while i < type_args.len() {
                    if self.occurs_in(var, &type_args[i]) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Range { element, inclusive: _ } => self.occurs_in(var, element),
            TypeKind::DynTrait { trait_id: _ } => false,
            TypeKind::Record { fields, row_var: _ } => {
                let mut i: usize = 0;
                while i < fields.len() {
                    if self.occurs_in(var, &fields[i].ty) {
                        return true;
                    };
                    i = i + 1;
                }
                false
            }
            TypeKind::Forall { params: _, body } => self.occurs_in(var, body),
            TypeKind::Ownership { inner, ownership: _ } => self.occurs_in(var, inner),
        }
    }

    // --------------------------------------------------------
    // Primitive Type Equality
    // --------------------------------------------------------

    /// Check if two primitive types are equal.
    fn primitive_eq(&self, p1: &PrimitiveTy, p2: &PrimitiveTy) -> bool {
        match (p1, p2) {
            (PrimitiveTy::I8, PrimitiveTy::I8) => true,
            (PrimitiveTy::I16, PrimitiveTy::I16) => true,
            (PrimitiveTy::I32, PrimitiveTy::I32) => true,
            (PrimitiveTy::I64, PrimitiveTy::I64) => true,
            (PrimitiveTy::I128, PrimitiveTy::I128) => true,
            (PrimitiveTy::Isize, PrimitiveTy::Isize) => true,
            (PrimitiveTy::U8, PrimitiveTy::U8) => true,
            (PrimitiveTy::U16, PrimitiveTy::U16) => true,
            (PrimitiveTy::U32, PrimitiveTy::U32) => true,
            (PrimitiveTy::U64, PrimitiveTy::U64) => true,
            (PrimitiveTy::U128, PrimitiveTy::U128) => true,
            (PrimitiveTy::Usize, PrimitiveTy::Usize) => true,
            (PrimitiveTy::F32, PrimitiveTy::F32) => true,
            (PrimitiveTy::F64, PrimitiveTy::F64) => true,
            (PrimitiveTy::Bool, PrimitiveTy::Bool) => true,
            (PrimitiveTy::Char, PrimitiveTy::Char) => true,
            (PrimitiveTy::Str, PrimitiveTy::Str) => true,
            (PrimitiveTy::Unit, PrimitiveTy::Unit) => true,
            // Explicit non-matching cases
            (PrimitiveTy::I8, PrimitiveTy::I16) => false,
            (PrimitiveTy::I8, PrimitiveTy::I32) => false,
            (PrimitiveTy::I8, PrimitiveTy::I64) => false,
            (PrimitiveTy::I8, PrimitiveTy::I128) => false,
            (PrimitiveTy::I8, PrimitiveTy::Isize) => false,
            (PrimitiveTy::I8, PrimitiveTy::U8) => false,
            (PrimitiveTy::I8, PrimitiveTy::U16) => false,
            (PrimitiveTy::I8, PrimitiveTy::U32) => false,
            (PrimitiveTy::I8, PrimitiveTy::U64) => false,
            (PrimitiveTy::I8, PrimitiveTy::U128) => false,
            (PrimitiveTy::I8, PrimitiveTy::Usize) => false,
            (PrimitiveTy::I8, PrimitiveTy::F32) => false,
            (PrimitiveTy::I8, PrimitiveTy::F64) => false,
            (PrimitiveTy::I8, PrimitiveTy::Bool) => false,
            (PrimitiveTy::I8, PrimitiveTy::Char) => false,
            (PrimitiveTy::I8, PrimitiveTy::Str) => false,
            (PrimitiveTy::I8, PrimitiveTy::Unit) => false,
            // For brevity, using negation for remaining cases
            // The types module has PartialEq implemented properly
            (PrimitiveTy::I16, _) => false,
            (PrimitiveTy::I32, _) => false,
            (PrimitiveTy::I64, _) => false,
            (PrimitiveTy::I128, _) => false,
            (PrimitiveTy::Isize, _) => false,
            (PrimitiveTy::U8, _) => false,
            (PrimitiveTy::U16, _) => false,
            (PrimitiveTy::U32, _) => false,
            (PrimitiveTy::U64, _) => false,
            (PrimitiveTy::U128, _) => false,
            (PrimitiveTy::Usize, _) => false,
            (PrimitiveTy::F32, _) => false,
            (PrimitiveTy::F64, _) => false,
            (PrimitiveTy::Bool, _) => false,
            (PrimitiveTy::Char, _) => false,
            (PrimitiveTy::Str, _) => false,
            (PrimitiveTy::Unit, _) => false,
        }
    }

    /// Check if two mutability values are equal.
    fn mutability_eq(&self, m1: &Mutability, m2: &Mutability) -> bool {
        match (m1, m2) {
            (Mutability::Immutable, Mutability::Immutable) => true,
            (Mutability::Mutable, Mutability::Mutable) => true,
            (Mutability::Immutable, Mutability::Mutable) => false,
            (Mutability::Mutable, Mutability::Immutable) => false,
        }
    }

    /// Check if two ownership values are equal.
    fn ownership_eq(&self, o1: &Ownership, o2: &Ownership) -> bool {
        match (o1, o2) {
            (Ownership::Linear, Ownership::Linear) => true,
            (Ownership::Affine, Ownership::Affine) => true,
            (Ownership::Default, Ownership::Default) => true,
            (Ownership::Linear, Ownership::Affine) => false,
            (Ownership::Linear, Ownership::Default) => false,
            (Ownership::Affine, Ownership::Linear) => false,
            (Ownership::Affine, Ownership::Default) => false,
            (Ownership::Default, Ownership::Linear) => false,
            (Ownership::Default, Ownership::Affine) => false,
        }
    }

    // --------------------------------------------------------
    // Effect Unification
    // --------------------------------------------------------

    /// Unify two effect rows.
    fn unify_effects(&mut self, e1: &Option<EffectRow>, e2: &Option<EffectRow>, span: Span) -> Result<(), TypeError> {
        match (e1, e2) {
            (None, None) => Ok(()),
            (Some(r1), Some(r2)) => self.unify_effect_rows(r1, r2, span),
            (None, Some(r2)) => {
                if r2.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::effect_mismatch(true, span))
                }
            }
            (Some(r1), None) => {
                if r1.is_pure() {
                    Ok(())
                } else {
                    Err(TypeError::effect_mismatch(false, span))
                }
            }
        }
    }

    /// Unify two effect rows.
    fn unify_effect_rows(&mut self, r1: &EffectRow, r2: &EffectRow, span: Span) -> Result<(), TypeError> {
        // Simple structural check for now
        // Full row polymorphism would need more sophisticated handling
        if r1.effects().len() != r2.effects().len() {
            return Err(TypeError::effect_row_mismatch(
                r1.effects().len() as u32,
                r2.effects().len() as u32,
                span,
            ));
        };

        // Check that all effects in r1 are in r2
        let mut i: usize = 0;
        while i < r1.effects().len() {
            if !self.effect_in_row(&r1.effects()[i], r2) {
                return Err(TypeError::effect_not_in_row(
                    format!("effect#{}", r1.effects()[i].def_id.id()),
                    span,
                ));
            };
            i = i + 1;
        };

        Ok(())
    }

    /// Check if an effect instance is in an effect row.
    fn effect_in_row(&self, effect: &EffectInstance, row: &EffectRow) -> bool {
        let mut i: usize = 0;
        while i < row.effects().len() {
            if row.effects()[i].def_id.eq(&effect.def_id) {
                // For full correctness, should also check type args match
                // but simplified for now
                return true;
            };
            i = i + 1;
        }
        false
    }
}
