// Blood Self-Hosted Compiler - HIR Expression Lowering
//
// This module handles lowering AST expressions to HIR expressions:
// - Expression lowering (all AST expression kinds)
// - Pattern lowering (for match arms, let bindings)
// - Statement lowering (for blocks)
// - Body lowering (for functions)
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod hir_item;
mod hir;
mod hir_lower_ctx;
mod hir_lower_type;
mod const_eval;

// ============================================================
// Expression Lowering
// ============================================================

/// Lower an AST expression to an HIR expression.
pub fn lower_expr(ctx: &mut hir_lower_ctx::LoweringCtx, expr: &ast::Expr) -> hir_expr::Expr {
    let span = expr.span;

    match &expr.kind {
        &ast::ExprKind::Literal(ref lit) => {
            lower_literal_expr(ctx, lit, span)
        }
        &ast::ExprKind::Path(ref path) => {
            lower_path_expr(ctx, path, span)
        }
        &ast::ExprKind::Binary { op: bin_op, ref left, ref right } => {
            let left_hir = lower_expr(ctx, left.as_ref());
            let right_hir = lower_expr(ctx, right.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Binary {
                    op: bin_op,
                    left: Box::new(left_hir),
                    right: Box::new(right_hir),
                },
                ty,
                span,
            )
        }
        &ast::ExprKind::Unary { op: unary_op, ref operand } => {
            let operand_hir = lower_expr(ctx, operand.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Unary {
                    op: unary_op,
                    operand: Box::new(operand_hir),
                },
                ty,
                span,
            )
        }
        &ast::ExprKind::Call { ref callee, ref args } => {
            lower_call_expr(ctx, callee.as_ref(), args, span)
        }
        &ast::ExprKind::MethodCall { ref receiver, ref method, ref type_args, ref args } => {
            lower_method_call_expr(ctx, receiver.as_ref(), method, type_args, args, span)
        }
        &ast::ExprKind::Field { ref base, ref field } => {
            lower_field_expr(ctx, base.as_ref(), field, span)
        }
        &ast::ExprKind::Index { ref base, ref idx } => {
            let base_hir = lower_expr(ctx, base.as_ref());
            let idx_hir = lower_expr(ctx, idx.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Index {
                    base: Box::new(base_hir),
                    idx: Box::new(idx_hir),
                },
                ty,
                span,
            )
        }
        &ast::ExprKind::Tuple(ref elems) => {
            lower_tuple_expr(ctx, elems, span)
        }
        &ast::ExprKind::Array(ref arr) => {
            lower_array_expr(ctx, arr, span)
        }
        &ast::ExprKind::Record { ref path, ref fields, ref base } => {
            lower_record_expr(ctx, path, fields, base, span)
        }
        &ast::ExprKind::Range { ref start, ref end_val, inclusive } => {
            let start_hir = match start {
                &Some(ref e) => Some(Box::new(lower_expr(ctx, e.as_ref()))),
                &None => Option::None,
            };
            let end_hir = match end_val {
                &Some(ref e) => Some(Box::new(lower_expr(ctx, e.as_ref()))),
                &None => Option::None,
            };
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Range {
                    start: start_hir,
                    end_val: end_hir,
                    inclusive: inclusive,
                },
                ty,
                span,
            )
        }
        &ast::ExprKind::Cast { ref expr, ref ty } => {
            let expr_hir = lower_expr(ctx, expr.as_ref());
            let cast_ty = hir_lower_type::lower_type(ctx, ty);
            hir_expr::Expr::new(
                hir_expr::ExprKind::Cast {
                    expr: Box::new(expr_hir),
                    ty: cast_ty,
                },
                hir_ty::Type::infer(ctx.alloc_ty_var()),
                span,
            )
        }
        &ast::ExprKind::Assign { ref target, ref val } => {
            let target_hir = lower_expr(ctx, target.as_ref());
            let val_hir = lower_expr(ctx, val.as_ref());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Assign {
                    target: Box::new(target_hir),
                    val: Box::new(val_hir),
                },
                hir_ty::Type::unit(),
                span,
            )
        }
        &ast::ExprKind::AssignOp { op: assign_op, ref target, ref val } => {
            let target_hir = lower_expr(ctx, target.as_ref());
            let val_hir = lower_expr(ctx, val.as_ref());
            hir_expr::Expr::new(
                hir_expr::ExprKind::AssignOp {
                    op: assign_op,
                    target: Box::new(target_hir),
                    val: Box::new(val_hir),
                },
                hir_ty::Type::unit(),
                span,
            )
        }
        &ast::ExprKind::Block(ref block) => {
            lower_block_expr(ctx, block, span)
        }
        &ast::ExprKind::If { ref condition, ref then_branch, ref else_branch } => {
            lower_if_expr(ctx, condition.as_ref(), then_branch, else_branch, span)
        }
        &ast::ExprKind::IfLet { ref pattern, ref scrutinee, ref then_branch, ref else_branch } => {
            lower_if_let_expr(ctx, pattern, scrutinee.as_ref(), then_branch, else_branch, span)
        }
        &ast::ExprKind::Match { ref scrutinee, ref arms } => {
            lower_match_expr(ctx, scrutinee.as_ref(), arms, span)
        }
        &ast::ExprKind::Loop { ref label, ref body } => {
            lower_loop_expr(ctx, label, body, span)
        }
        &ast::ExprKind::While { ref label, ref condition, ref body } => {
            lower_while_expr(ctx, label, condition.as_ref(), body, span)
        }
        &ast::ExprKind::WhileLet { ref label, ref pattern, ref scrutinee, ref body } => {
            lower_while_let_expr(ctx, label, pattern, scrutinee.as_ref(), body, span)
        }
        &ast::ExprKind::For { ref label, ref pattern, ref iter, ref body } => {
            lower_for_expr(ctx, label, pattern, iter.as_ref(), body, span)
        }
        &ast::ExprKind::Return(ref val) => {
            let val_hir = match val {
                &Some(ref e) => Some(Box::new(lower_expr(ctx, e.as_ref()))),
                &None => Option::None,
            };
            hir_expr::Expr::new(
                hir_expr::ExprKind::Return(val_hir),
                hir_ty::Type::never(),
                span,
            )
        }
        &ast::ExprKind::Break { ref label, ref val } => {
            let label_sym = match label {
                &Some(ref l) => Some(l.symbol),
                &None => Option::None,
            };
            let val_hir = match val {
                &Some(ref e) => Some(Box::new(lower_expr(ctx, e.as_ref()))),
                &None => Option::None,
            };
            hir_expr::Expr::new(
                hir_expr::ExprKind::Break {
                    label: label_sym,
                    val: val_hir,
                },
                hir_ty::Type::never(),
                span,
            )
        }
        &ast::ExprKind::Continue { ref label } => {
            let label_sym = match label {
                &Some(ref l) => Some(l.symbol),
                &None => Option::None,
            };
            hir_expr::Expr::new(
                hir_expr::ExprKind::Continue {
                    label: label_sym,
                },
                hir_ty::Type::never(),
                span,
            )
        }
        &ast::ExprKind::Closure { is_move: _, ref params, ref return_type, ref effects, ref body } => {
            lower_closure_expr(ctx, params, return_type, effects, body.as_ref(), span)
        }
        &ast::ExprKind::WithHandle { handler: ref handler_expr, body: ref body_expr } => {
            let handler_hir = lower_expr(ctx, handler_expr.as_ref());
            let body_hir = lower_expr(ctx, body_expr.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::WithHandle {
                    handler: Box::new(handler_hir),
                    body: Box::new(body_hir),
                },
                ty,
                span,
            )
        }
        &ast::ExprKind::Perform { effect: ref eff_path, ref operation, ref args } => {
            lower_perform_expr(ctx, eff_path, operation, args, span)
        }
        &ast::ExprKind::Resume(ref val) => {
            let val_hir = lower_expr(ctx, val.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Resume(Box::new(val_hir)),
                ty,
                span,
            )
        }
        &ast::ExprKind::Try(ref inner) => {
            let inner_hir = lower_expr(ctx, inner.as_ref());
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Try(Box::new(inner_hir)),
                ty,
                span,
            )
        }
        &ast::ExprKind::TryWith { ref body, handlers: _ } => {
            // Desugar try-with to regular error handling
            let body_hir = lower_block_to_expr(ctx, body);
            body_hir
        }
        &ast::ExprKind::Unsafe(ref block) => {
            let block_hir = lower_block_to_expr(ctx, block);
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(
                hir_expr::ExprKind::Unsafe(Box::new(block_hir)),
                ty,
                span,
            )
        }
        &ast::ExprKind::Region { name: _, ref body } => {
            // Regions lower to regular blocks for now
            lower_block_expr(ctx, body, span)
        }
        &ast::ExprKind::Paren(ref inner) => {
            // Parentheses are purely syntactic
            lower_expr(ctx, inner.as_ref())
        }
        &ast::ExprKind::Default => {
            // Default expression - type will be inferred from context during type checking
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            hir_expr::Expr::new(hir_expr::ExprKind::Default, ty, span)
        }
        &ast::ExprKind::MacroCall { path: _, ref kind } => {
            lower_macro_call_expr(ctx, kind, span)
        }
    }
}

// ============================================================
// Literal Lowering
// ============================================================

/// Lower a literal expression.
fn lower_literal_expr(ctx: &mut hir_lower_ctx::LoweringCtx, lit: &ast::Literal, span: common::Span) -> hir_expr::Expr {
    let (kind, ty) = match &lit.kind {
        &ast::LiteralKind::Int { val, ref suffix } => {
            let prim_ty = match suffix {
                &Some(ref s) => int_suffix_to_prim(s),
                &None => Option::None,
            };
            (
                hir_expr::LiteralKind::Int { val: val, ty: prim_ty },
                match prim_ty {
                    Some(p) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(p)),
                    Option::None => hir_ty::Type::infer(ctx.alloc_ty_var()),
                },
            )
        }
        &ast::LiteralKind::Float { bits, ref suffix } => {
            let prim_ty = match suffix {
                &Some(ref s) => float_suffix_to_prim(s),
                &None => Option::None,
            };
            (
                hir_expr::LiteralKind::Float { bits: bits, ty: prim_ty },
                match prim_ty {
                    Some(p) => hir_ty::Type::new(hir_ty::TypeKind::Primitive(p)),
                    Option::None => hir_ty::Type::infer(ctx.alloc_ty_var()),
                },
            )
        }
        &ast::LiteralKind::Str(ref s) => {
            // Clone the string
            let mut s_copy = String::new();
            s_copy.push_str(s.as_str());
            (
                hir_expr::LiteralKind::Str(s_copy),
                hir_ty::Type::new(hir_ty::TypeKind::Ref { inner: Box::new(hir_ty::Type::str_ty()), mutable: false }),
            )
        }
        &ast::LiteralKind::ByteStr(ref bytes) => {
            // Copy the bytes
            let mut bytes_copy: Vec<u8> = Vec::new();
            let mut i: usize = 0;
            while i < bytes.len() {
                bytes_copy.push(bytes[i]);
                i = i + 1;
            }
            (
                hir_expr::LiteralKind::ByteStr(bytes_copy),
                hir_ty::Type::infer(ctx.alloc_ty_var()), // &[u8; N]
            )
        }
        &ast::LiteralKind::Char(c) => {
            (
                hir_expr::LiteralKind::Char(c),
                hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Char)),
            )
        }
        &ast::LiteralKind::Bool(b) => {
            (
                hir_expr::LiteralKind::Bool(b),
                hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)),
            )
        }
    };

    let hir_lit = hir_expr::Literal::new(kind, lit.span);
    hir_expr::Expr::new(
        hir_expr::ExprKind::Literal(hir_lit),
        ty,
        span,
    )
}

/// Convert an integer suffix to a primitive type.
fn int_suffix_to_prim(suffix: &ast::IntSuffix) -> Option<hir_ty::PrimitiveTy> {
    match suffix {
        &ast::IntSuffix::I8 => Some(hir_ty::PrimitiveTy::I8),
        &ast::IntSuffix::I16 => Some(hir_ty::PrimitiveTy::I16),
        &ast::IntSuffix::I32 => Some(hir_ty::PrimitiveTy::I32),
        &ast::IntSuffix::I64 => Some(hir_ty::PrimitiveTy::I64),
        &ast::IntSuffix::I128 => Some(hir_ty::PrimitiveTy::I128),
        &ast::IntSuffix::Isize => Some(hir_ty::PrimitiveTy::Isize),
        &ast::IntSuffix::U8 => Some(hir_ty::PrimitiveTy::U8),
        &ast::IntSuffix::U16 => Some(hir_ty::PrimitiveTy::U16),
        &ast::IntSuffix::U32 => Some(hir_ty::PrimitiveTy::U32),
        &ast::IntSuffix::U64 => Some(hir_ty::PrimitiveTy::U64),
        &ast::IntSuffix::U128 => Some(hir_ty::PrimitiveTy::U128),
        &ast::IntSuffix::Usize => Some(hir_ty::PrimitiveTy::Usize),
    }
}

/// Convert a float suffix to a primitive type.
fn float_suffix_to_prim(suffix: &ast::FloatSuffix) -> Option<hir_ty::PrimitiveTy> {
    match suffix {
        &ast::FloatSuffix::F32 => Some(hir_ty::PrimitiveTy::F32),
        &ast::FloatSuffix::F64 => Some(hir_ty::PrimitiveTy::F64),
    }
}

// ============================================================
// Path Expression Lowering
// ============================================================

/// Lower a path expression to HIR.
fn lower_path_expr(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::ExprPath, span: common::Span) -> hir_expr::Expr {
    // Single-segment paths: could be local variable or global definition
    if path.segments.len() == 1 {
        let seg = &path.segments[0];

        // Re-intern the symbol from the span to ensure consistent symbol indices
        // The parser uses a separate interner, so we need to re-intern using
        // the same interner that was used during parameter registration
        let name_str = ctx.span_to_string(seg.name.span);
        let lookup_symbol = ctx.intern(name_str.as_str());

        // Try to look up as a local or global
        let lookup = ctx.resolver.lookup(lookup_symbol);
        if lookup.is_some() {
            let result = lookup.unwrap();
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);

            // Check if this is a local variable binding (parameter, let, etc.)
            // Local bindings must produce ExprKind::Local, not ExprKind::Path,
            // because their def_id is a dummy value (0xFFFFFFFF).
            if binding.is_local() {
                let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                return hir_expr::Expr::new(
                    hir_expr::ExprKind::Local(binding.local_id),
                    ty,
                    span,
                );
            }

            // Lower type arguments if present
            let type_args = match &seg.args {
                &Some(ref args) => hir_lower_type::lower_type_args(ctx, args),
                &None => Vec::new(),
            };
            let type_arg_count = type_args.len() as u32;

            // Check if the resolved def is a variant - set variant_index if so
            let def_info = ctx.resolver.get_def_info(binding.def_id);
            let resolved = match def_info {
                Option::Some(info) => {
                    match info.variant_index {
                        Option::Some(vi) => {
                            hir_def::ResolvedPath::variant(binding.def_id, span, vi)
                        }
                        Option::None => {
                            hir_def::ResolvedPath::new(binding.def_id, type_arg_count, span)
                        }
                    }
                }
                Option::None => {
                    hir_def::ResolvedPath::new(binding.def_id, type_arg_count, span)
                }
            };
            let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            return hir_expr::Expr::new(
                hir_expr::ExprKind::Path(resolved),
                ty,
                span,
            );
        }

        // Not found
        ctx.error(
            hir::DiagnosticCode::E0102,
            common::make_string("undefined name"),
            seg.name.span,
        );
        return hir_expr::Expr::error(span);
    }

    // Multi-segment paths (e.g., module::item or Type::method)
    // Extract the names from path segments, re-interning for consistent indices
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let name_str = ctx.span_to_string(seg.name.span);
        let re_interned = ctx.intern(name_str.as_str());
        names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
        i = i + 1;
    }

    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_args = match &last_seg.args {
            &Some(ref args) => hir_lower_type::lower_type_args(ctx, args),
            &None => Vec::new(),
        };
        let type_arg_count = type_args.len() as u32;

        // Check if the resolved def is a variant - set variant_index if so
        let def_info = ctx.resolver.get_def_info(result.def_id);
        let resolved_path = match def_info {
            Option::Some(info) => {
                match info.variant_index {
                    Option::Some(vi) => {
                        hir_def::ResolvedPath::variant(result.def_id, span, vi)
                    }
                    Option::None => {
                        hir_def::ResolvedPath::new(result.def_id, type_arg_count, span)
                    }
                }
            }
            Option::None => {
                hir_def::ResolvedPath::new(result.def_id, type_arg_count, span)
            }
        };
        let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
        return hir_expr::Expr::new(
            hir_expr::ExprKind::Path(resolved_path),
            ty,
            span,
        );
    }

    // Not found - report with full path text for diagnostics
    let mut msg = common::make_string("undefined qualified path: ");
    let mut j: usize = 0;
    while j < names.len() {
        if j > 0 {
            msg.push_str("::");
        }
        let seg_str = ctx.span_to_string(names[j].span);
        msg.push_str(seg_str.as_str());
        j = j + 1;
    }
    ctx.error(
        hir::DiagnosticCode::E0102,
        msg,
        span,
    );
    hir_expr::Expr::error(span)
}

// ============================================================
// Call Expression Lowering
// ============================================================

/// Lower a call expression.
fn lower_call_expr(ctx: &mut hir_lower_ctx::LoweringCtx, callee: &ast::Expr, args: &Vec<ast::CallArg>, span: common::Span) -> hir_expr::Expr {
    let callee_hir = lower_expr(ctx, callee);

    let mut args_hir: Vec<hir_expr::Expr> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg_hir = lower_expr(ctx, &args[i].val);
        args_hir.push(arg_hir);
        i = i + 1;
    }

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Call {
            callee: Box::new(callee_hir),
            args: args_hir,
        },
        ty,
        span,
    )
}

/// Lower a method call expression.
fn lower_method_call_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    receiver: &ast::Expr,
    method: &common::SpannedSymbol,
    type_args: &Option<ast::TypeArgs>,
    args: &Vec<ast::CallArg>,
    span: common::Span,
) -> hir_expr::Expr {
    let receiver_hir = lower_expr(ctx, receiver);

    let type_args_hir = match type_args {
        &Some(ref ta) => hir_lower_type::lower_type_args(ctx, ta),
        &None => Vec::new(),
    };

    let mut args_hir: Vec<hir_expr::Expr> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg_hir = lower_expr(ctx, &args[i].val);
        args_hir.push(arg_hir);
        i = i + 1;
    }

    // Re-intern the method name through ctx.interner so it shares indices
    // with the builtin method names registered by typeck_driver.
    // (Parser has its own span-based interning producing different symbol indices.)
    let method_str = ctx.span_to_string(method.span);
    let method_sym = ctx.intern(method_str.as_str());
    let re_method = common::SpannedSymbol { symbol: method_sym, span: method.span };

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::MethodCall {
            receiver: Box::new(receiver_hir),
            method: re_method,
            method_def: Option::None, // Resolved during type checking
            type_args: type_args_hir,
            args: args_hir,
        },
        ty,
        span,
    )
}

// ============================================================
// Field and Tuple Lowering
// ============================================================

/// Lower a field access expression.
fn lower_field_expr(ctx: &mut hir_lower_ctx::LoweringCtx, base: &ast::Expr, field: &ast::FieldAccess, span: common::Span) -> hir_expr::Expr {
    let base_hir = lower_expr(ctx, base);

    let field_hir = match field {
        &ast::FieldAccess::Named(ref name) => {
            // Re-intern field name for cross-module consistency
            let fname_str = ctx.span_to_string(name.span);
            let fname_sym = ctx.intern(fname_str.as_str());
            let re_name = common::SpannedSymbol { symbol: fname_sym, span: name.span };
            hir_expr::FieldAccess::Named {
                name: re_name,
                field_idx: Option::None, // Resolved during type checking
            }
        }
        &ast::FieldAccess::Index(idx, _) => {
            hir_expr::FieldAccess::Index(idx)
        }
    };

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Field {
            base: Box::new(base_hir),
            field: field_hir,
        },
        ty,
        span,
    )
}

/// Lower a tuple expression.
fn lower_tuple_expr(ctx: &mut hir_lower_ctx::LoweringCtx, elems: &Vec<ast::Expr>, span: common::Span) -> hir_expr::Expr {
    let mut elems_hir: Vec<hir_expr::Expr> = Vec::new();
    let mut i: usize = 0;
    while i < elems.len() {
        let elem_hir = lower_expr(ctx, &elems[i]);
        elems_hir.push(elem_hir);
        i = i + 1;
    }

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Tuple(elems_hir),
        ty,
        span,
    )
}

/// Lower an array expression.
fn lower_array_expr(ctx: &mut hir_lower_ctx::LoweringCtx, arr: &ast::ArrayExpr, span: common::Span) -> hir_expr::Expr {
    let arr_hir = match arr {
        &ast::ArrayExpr::List(ref elems) => {
            let mut elems_hir: Vec<hir_expr::Expr> = Vec::new();
            let mut i: usize = 0;
            while i < elems.len() {
                let elem_hir = lower_expr(ctx, &elems[i]);
                elems_hir.push(elem_hir);
                i = i + 1;
            }
            hir_expr::ArrayExpr::List(elems_hir)
        }
        &ast::ArrayExpr::Repeat { ref val, ref count } => {
            let val_hir = lower_expr(ctx, val.as_ref());
            let repeat_count = const_eval::eval_array_size_u64(count.as_ref());
            hir_expr::ArrayExpr::Repeat {
                val: Box::new(val_hir),
                count: repeat_count,
            }
        }
    };

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Array(arr_hir),
        ty,
        span,
    )
}

// ============================================================
// Record/Struct Expression Lowering
// ============================================================

/// Lower a record/struct expression.
fn lower_record_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    path: &Option<ast::TypePath>,
    fields: &Vec<ast::RecordExprField>,
    base: &Option<Box<ast::Expr>>,
    span: common::Span,
) -> hir_expr::Expr {
    // Resolve the struct type path
    let p = match path {
        &Some(ref p) => p,
        &None => {
            // Anonymous record expression: { field: value, ... }
            return lower_anon_record_expr(ctx, fields, span);
        }
    };

    // Resolve the struct path (handles both single and multi-segment paths)
    let (def_id, type_args) = if p.segments.len() == 1 {
        // Single-segment path: use direct lookup
        let seg = &p.segments[0];
        // Re-intern the symbol from span to ensure consistent symbol indices
        let name_str = ctx.span_to_string(seg.name.span);
        let lookup_symbol = ctx.intern(name_str.as_str());
        let lookup = ctx.resolver.lookup(lookup_symbol);

        if lookup.is_none() {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown struct type"),
                p.span,
            );
            return hir_expr::Expr::error(span);
        }

        let result = lookup.unwrap();
        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
        let args = match &seg.args {
            &Some(ref args) => hir_lower_type::lower_type_args(ctx, args),
            &None => Vec::new(),
        };

        (binding.def_id, args)
    } else {
        // Multi-segment path (e.g., module::StructName): use qualified path resolution
        // Re-intern all segment names from their spans
        let mut names: Vec<common::SpannedSymbol> = Vec::new();
        let mut i: usize = 0;
        while i < p.segments.len() {
            let seg = &p.segments[i];
            let name_str = ctx.span_to_string(seg.name.span);
            let re_interned = ctx.intern(name_str.as_str());
            names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
            i = i + 1;
        }

        let resolved = ctx.resolver.resolve_qualified_path(&names);
        if resolved.is_none() {
            ctx.error(
                hir::DiagnosticCode::E0102,
                common::make_string("unknown qualified struct path"),
                p.span,
            );
            return hir_expr::Expr::error(span);
        }

        let result = resolved.unwrap();
        // Get type args from last segment
        let last_seg = &p.segments[p.segments.len() - 1];
        let args = match &last_seg.args {
            &Some(ref args) => hir_lower_type::lower_type_args(ctx, args),
            &None => Vec::new(),
        };
        (result.def_id, args)
    };

    let type_arg_count = type_args.len() as u32;
    let resolved_path = hir_def::ResolvedPath::new(def_id, type_arg_count, p.span);

    // Lower fields
    let mut fields_hir: Vec<hir_expr::FieldExpr> = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let f = &fields[i];
        // Handle shorthand fields (e.g., `Foo { bar }` where bar is a variable)
        let val_hir = match &f.val {
            &Some(ref e) => lower_expr(ctx, e),
            &None => {
                // Shorthand: field name is also the variable name
                // Create a path expression for the variable
                // Re-intern from span for consistent symbol indices
                let name_str = ctx.span_to_string(f.name.span);
                let lookup_symbol = ctx.intern(name_str.as_str());
                let lookup = ctx.resolver.lookup(lookup_symbol);
                if lookup.is_some() {
                    let result = lookup.unwrap();
                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                    // Local bindings must produce ExprKind::Local, not ExprKind::Path,
                    // because their def_id is a dummy value (0xFFFFFFFF).
                    if binding.is_local() {
                        let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                        hir_expr::Expr::new(
                            hir_expr::ExprKind::Local(binding.local_id),
                            ty,
                            f.name.span,
                        )
                    } else {
                        let resolved = hir_def::ResolvedPath::new(binding.def_id, 0, f.name.span);
                        let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                        hir_expr::Expr::new(
                            hir_expr::ExprKind::Path(resolved),
                            ty,
                            f.name.span,
                        )
                    }
                } else {
                    ctx.error(
                        hir::DiagnosticCode::E0102,
                        common::make_string("undefined field variable"),
                        f.name.span,
                    );
                    hir_expr::Expr::error(f.name.span)
                }
            }
        };
        // Re-intern field name for cross-module consistency
        let flit_name_str = ctx.span_to_string(f.name.span);
        let flit_name_sym = ctx.intern(flit_name_str.as_str());
        let re_flit_name = common::SpannedSymbol { symbol: flit_name_sym, span: f.name.span };
        let field_hir = hir_expr::FieldExpr::new(
            re_flit_name,
            Option::None, // Field index resolved during type checking
            val_hir,
            f.span,
        );
        fields_hir.push(field_hir);
        i = i + 1;
    }

    // Lower base expression if present
    let base_hir = match base {
        &Some(ref b) => Some(Box::new(lower_expr(ctx, b.as_ref()))),
        &None => Option::None,
    };

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Struct {
            path: resolved_path,
            fields: fields_hir,
            base: base_hir,
        },
        ty,
        span,
    )
}

/// Lower an anonymous record expression: { field: value, ... }
fn lower_anon_record_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    fields: &Vec<ast::RecordExprField>,
    span: common::Span,
) -> hir_expr::Expr {
    let mut fields_hir: Vec<hir_expr::AnonRecordField> = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let f = &fields[i];
        let val_hir = match &f.val {
            &Some(ref v) => lower_expr(ctx, v),
            &None => {
                // Shorthand: { name } means { name: name }
                // Re-intern from span for consistent symbol indices
                let name_str = ctx.span_to_string(f.name.span);
                let lookup_symbol = ctx.intern(name_str.as_str());
                let local = ctx.resolver.lookup(lookup_symbol);
                match local {
                    Option::Some(result) => {
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                        hir_expr::Expr::new(
                            hir_expr::ExprKind::Local(binding.local_id),
                            ty,
                            f.name.span,
                        )
                    }
                    Option::None => {
                        ctx.error(
                            hir::DiagnosticCode::E0101,
                            common::make_string("cannot use shorthand for unresolved field"),
                            f.name.span,
                        );
                        hir_expr::Expr::error(f.name.span)
                    }
                }
            }
        };
        let field_hir = hir_expr::AnonRecordField::new(
            f.name,
            val_hir,
            f.span,
        );
        fields_hir.push(field_hir);
        i = i + 1;
    }

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::AnonRecord { fields: fields_hir },
        ty,
        span,
    )
}

// ============================================================
// Block and Statement Lowering
// ============================================================

/// Lower a block expression.
fn lower_block_expr(ctx: &mut hir_lower_ctx::LoweringCtx, block: &ast::Block, span: common::Span) -> hir_expr::Expr {
    let block_hir = lower_block(ctx, block);
    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Block(block_hir),
        ty,
        span,
    )
}

/// Lower a block to HIR Block.
pub fn lower_block(ctx: &mut hir_lower_ctx::LoweringCtx, block: &ast::Block) -> hir_expr::Block {
    ctx.resolver.push_scope(resolve::ScopeKind::Block);

    let mut stmts_hir: Vec<hir_expr::Stmt> = Vec::new();
    let mut i: usize = 0;
    while i < block.statements.len() {
        let stmt_hir = lower_stmt(ctx, &block.statements[i]);
        stmts_hir.push(stmt_hir);
        i = i + 1;
    }

    let expr_hir = match &block.expr {
        &Some(ref e) => {
            Some(Box::new(lower_expr(ctx, e.as_ref())))
        }
        &None => {
            Option::None
        }
    };

    ctx.resolver.pop_scope();
    hir_expr::Block::new(stmts_hir, expr_hir, block.span)
}

/// Lower a block to an expression.
pub fn lower_block_to_expr(ctx: &mut hir_lower_ctx::LoweringCtx, block: &ast::Block) -> hir_expr::Expr {
    let block_hir = lower_block(ctx, block);
    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Block(block_hir),
        ty,
        block.span,
    )
}

/// Lower a statement.
fn lower_stmt(ctx: &mut hir_lower_ctx::LoweringCtx, stmt: &ast::Statement) -> hir_expr::Stmt {
    match stmt {
        &ast::Statement::Let { ref pattern, ref ty, ref init_val, span } => {
            // Lower the type annotation first (does not introduce bindings)
            let ty_hir = match ty {
                &Some(ref t) => Some(hir_lower_type::lower_type(ctx, t)),
                &None => Option::None,
            };
            // Lower the init expression BEFORE the pattern, so the RHS is
            // resolved in the scope without the new local binding. This prevents
            // `let lexer = lexer::Lexer::new(...)` from shadowing the module.
            let init_hir = match init_val {
                &Some(ref e) => Some(lower_expr(ctx, e)),
                &None => Option::None,
            };
            // Now lower the pattern (which registers bindings in scope)
            let pattern_hir = lower_pattern(ctx, pattern);
            hir_expr::Stmt::Let {
                pattern: pattern_hir,
                ty: ty_hir,
                init: init_hir,
                span: span,
            }
        }
        &ast::Statement::Expr { ref expr, has_semi } => {
            let expr_hir = lower_expr(ctx, expr);
            hir_expr::Stmt::Expr {
                expr: expr_hir,
                has_semi: has_semi,
            }
        }
        &ast::Statement::Item(ref decl) => {
            // Local items: register and lower inline
            // 1. Extract the name from the declaration
            // 2. Allocate a DefId
            // 3. Register in current scope
            // 4. Lower the declaration
            let def_id = lower_local_item(ctx, decl);
            hir_expr::Stmt::Item(def_id)
        }
    }
}

// ============================================================
// Local Item Lowering
// ============================================================

/// Lower a local item declaration (item inside a function body).
///
/// This registers the item in the current scope so it can be referenced
/// by name within the enclosing function. The item is registered with
/// the resolver but is NOT fully lowered here to avoid circular dependency.
///
/// Note: Local items currently register for name resolution but their
/// bodies are not lowered. Full local item support would require
/// collecting local items and lowering them in a separate pass.
fn lower_local_item(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) -> hir_def::DefId {
    // Extract name and span from the declaration
    let (name, span) = match decl {
        &ast::Declaration::Function(ref f) => (f.name, f.span),
        &ast::Declaration::Struct(ref s) => (s.name, s.span),
        &ast::Declaration::Enum(ref e) => (e.name, e.span),
        &ast::Declaration::TypeAlias(ref t) => (t.name, t.span),
        &ast::Declaration::Const(ref c) => (c.name, c.span),
        &ast::Declaration::Static(ref s) => (s.name, s.span),
        &ast::Declaration::Trait(ref t) => (t.name, t.span),
        &ast::Declaration::Effect(ref e) => (e.name, e.span),
        &ast::Declaration::Handler(ref h) => (h.name, h.span),
        &ast::Declaration::Impl(_) => {
            // Impl blocks don't have a name, allocate anonymous DefId
            return ctx.alloc_def_id();
        }
        &ast::Declaration::Bridge(_) => {
            // Not yet supported
            return ctx.alloc_def_id();
        }
        &ast::Declaration::Module(_) => {
            // Not yet supported in local scope
            return ctx.alloc_def_id();
        }
        &ast::Declaration::Macro(_) => {
            // Not yet supported
            return ctx.alloc_def_id();
        }
        &ast::Declaration::Use(_) => {
            // Not applicable in local scope
            return ctx.alloc_def_id();
        }
    };

    // Allocate a DefId
    let def_id = ctx.alloc_def_id();

    // Register in current scope (not global)
    let success = ctx.resolver.define_local_item(name.symbol, def_id);
    if !success {
        ctx.error(
            hir::DiagnosticCode::E0102,
            common::make_string("duplicate local item definition"),
            span,
        );
    }

    // Register DefInfo with the enclosing function as parent
    let def_kind = match decl {
        &ast::Declaration::Function(_) => hir_def::DefKind::Fn,
        &ast::Declaration::Struct(_) => hir_def::DefKind::Struct,
        &ast::Declaration::Enum(_) => hir_def::DefKind::Enum,
        &ast::Declaration::TypeAlias(_) => hir_def::DefKind::TypeAlias,
        &ast::Declaration::Const(_) => hir_def::DefKind::Const,
        &ast::Declaration::Static(_) => hir_def::DefKind::Static,
        &ast::Declaration::Trait(_) => hir_def::DefKind::Trait,
        &ast::Declaration::Effect(_) => hir_def::DefKind::Effect,
        &ast::Declaration::Handler(_) => hir_def::DefKind::Handler,
        _ => hir_def::DefKind::Fn, // Fallback
    };
    ctx.resolver.register_def_info(def_id, def_kind, name.symbol, span, Option::None);

    // Note: Full lowering of local item bodies is deferred.
    // To fully support local items, we would need to collect them
    // during body lowering and process them in a separate pass.

    def_id
}

// ============================================================
// Pattern Lowering
// ============================================================

/// Lower a pattern.
pub fn lower_pattern(ctx: &mut hir_lower_ctx::LoweringCtx, pattern: &ast::Pattern) -> hir_expr::Pattern {
    let span = pattern.span;
    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());

    let kind = match &pattern.kind {
        &ast::PatternKind::Wildcard => {
            hir_expr::PatternKind::Wildcard
        }
        &ast::PatternKind::Rest => {
            hir_expr::PatternKind::Rest
        }
        &ast::PatternKind::Literal(ref lit) => {
            let lit_hir = lower_pattern_literal(ctx, lit);
            hir_expr::PatternKind::Literal(lit_hir)
        }
        &ast::PatternKind::Ident { by_ref, is_mut, ref name, ref subpattern } => {
            // Allocate a local ID for this binding
            let local_id = ctx.alloc_local_id();

            // Re-intern the name from the span to ensure consistent symbol indices.
            // The parser uses a separate interner, so we need to re-intern using
            // the global interner that's used during lookup.
            let name_str = ctx.span_to_string(name.span);
            let re_interned_symbol = ctx.intern(name_str.as_str());

            // Register the local variable in the resolver scope
            let _success = ctx.resolver.define_local(re_interned_symbol, local_id, is_mut, name.span);

            let mode = if by_ref {
                if is_mut {
                    hir_expr::BindingMode::ByMutRef
                } else {
                    hir_expr::BindingMode::ByRef
                }
            } else {
                hir_expr::BindingMode::ByValue
            };

            let subpat_hir = match subpattern {
                &Some(ref sp) => Some(Box::new(lower_pattern(ctx, sp.as_ref()))),
                &None => Option::None,
            };

            // Create SpannedSymbol with the re-interned symbol
            let hir_name = common::SpannedSymbol {
                symbol: re_interned_symbol,
                span: name.span,
            };

            // Build the local's type based on binding mode:
            // - ByValue: local type = pattern type (T)
            // - ByRef: local type = &T (reference to matched value)
            // - ByMutRef: local type = &mut T
            let local_ty = if by_ref {
                if is_mut {
                    hir_ty::Type::new(hir_ty::TypeKind::Ref {
                        inner: Box::new(hir_ty::copy_type(&ty)),
                        mutable: true,
                    })
                } else {
                    hir_ty::Type::new(hir_ty::TypeKind::Ref {
                        inner: Box::new(hir_ty::copy_type(&ty)),
                        mutable: false,
                    })
                }
            } else {
                hir_ty::copy_type(&ty)
            };

            // Add this binding to the body_locals accumulator so it gets
            // included in the Body's locals Vec. Without this, the type
            // checker cannot find the local's type.
            let body_local = hir_expr::Local::new(
                local_id,
                hir_name,
                local_ty,
                is_mut,
                span,
            );
            ctx.body_locals.push(body_local);

            hir_expr::PatternKind::Binding {
                local_id: local_id,
                name: hir_name,
                mode: mode,
                subpattern: subpat_hir,
            }
        }
        &ast::PatternKind::Ref { is_mut, ref inner } => {
            let inner_hir = lower_pattern(ctx, inner.as_ref());
            hir_expr::PatternKind::Ref {
                mutable: is_mut,
                inner: Box::new(inner_hir),
            }
        }
        &ast::PatternKind::Struct { ref path, ref fields, has_rest } => {
            lower_struct_pattern(ctx, path, fields, has_rest, span)
        }
        &ast::PatternKind::TupleStruct { ref path, ref fields, rest_pos: _ } => {
            lower_tuple_struct_pattern(ctx, path, fields, span)
        }
        &ast::PatternKind::Tuple { ref fields, rest_pos: _ } => {
            let mut fields_hir: Vec<hir_expr::Pattern> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let f_hir = lower_pattern(ctx, &fields[i]);
                fields_hir.push(f_hir);
                i = i + 1;
            }
            hir_expr::PatternKind::Tuple(fields_hir)
        }
        &ast::PatternKind::Slice { ref elements, rest_pos: _ } => {
            let mut elements_hir: Vec<hir_expr::Pattern> = Vec::new();
            let mut i: usize = 0;
            while i < elements.len() {
                elements_hir.push(lower_pattern(ctx, &elements[i]));
                i = i + 1;
            }

            // Simplified slice pattern - just convert all elements
            hir_expr::PatternKind::Slice {
                prefix: elements_hir,
                rest: Option::None,
                suffix: Vec::new(),
            }
        }
        &ast::PatternKind::Or(ref patterns) => {
            let mut pats_hir: Vec<hir_expr::Pattern> = Vec::new();
            let mut i: usize = 0;
            while i < patterns.len() {
                let p_hir = lower_pattern(ctx, &patterns[i]);
                pats_hir.push(p_hir);
                i = i + 1;
            }
            hir_expr::PatternKind::Or(pats_hir)
        }
        &ast::PatternKind::Range { ref start, ref end_val, inclusive } => {
            let start_hir = match start {
                &Some(ref s) => Some(Box::new(lower_pattern(ctx, s.as_ref()))),
                &None => Option::None,
            };
            let end_hir = match end_val {
                &Some(ref e) => Some(Box::new(lower_pattern(ctx, e.as_ref()))),
                &None => Option::None,
            };
            hir_expr::PatternKind::Range {
                start: start_hir,
                end_val: end_hir,
                inclusive: inclusive,
            }
        }
        &ast::PatternKind::Path(ref path) => {
            lower_path_pattern(ctx, path, span)
        }
        &ast::PatternKind::Paren(ref inner) => {
            // Parentheses are purely syntactic - recurse on inner pattern
            return lower_pattern(ctx, inner.as_ref());
        }
    };

    hir_expr::Pattern::new(kind, ty, span)
}

/// Lower a literal in a pattern context.
fn lower_pattern_literal(ctx: &mut hir_lower_ctx::LoweringCtx, lit: &ast::Literal) -> hir_expr::Literal {
    let kind = match &lit.kind {
        &ast::LiteralKind::Int { val, ref suffix } => {
            let prim_ty = match suffix {
                &Some(ref s) => int_suffix_to_prim(s),
                &None => Option::None,
            };
            hir_expr::LiteralKind::Int { val: val, ty: prim_ty }
        }
        &ast::LiteralKind::Float { bits, ref suffix } => {
            let prim_ty = match suffix {
                &Some(ref s) => float_suffix_to_prim(s),
                &None => Option::None,
            };
            hir_expr::LiteralKind::Float { bits: bits, ty: prim_ty }
        }
        &ast::LiteralKind::Str(ref s) => {
            let mut s_copy = String::new();
            s_copy.push_str(s.as_str());
            hir_expr::LiteralKind::Str(s_copy)
        }
        &ast::LiteralKind::ByteStr(ref bytes) => {
            let mut bytes_copy: Vec<u8> = Vec::new();
            let mut i: usize = 0;
            while i < bytes.len() {
                bytes_copy.push(bytes[i]);
                i = i + 1;
            }
            hir_expr::LiteralKind::ByteStr(bytes_copy)
        }
        &ast::LiteralKind::Char(c) => {
            hir_expr::LiteralKind::Char(c)
        }
        &ast::LiteralKind::Bool(b) => {
            hir_expr::LiteralKind::Bool(b)
        }
    };

    hir_expr::Literal::new(kind, lit.span)
}

/// Lower a struct pattern.
fn lower_struct_pattern(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    path: &ast::TypePath,
    fields: &Vec<ast::StructPatternField>,
    has_rest: bool,
    span: common::Span,
) -> hir_expr::PatternKind {
    // Resolve the path
    let resolved = resolve_type_path_for_pattern(ctx, path, span);

    // Lower field patterns
    let mut fields_hir: Vec<hir_expr::FieldPattern> = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let f = &fields[i];
        // Handle shorthand patterns (Foo { bar } binds to variable named bar)
        let pat_hir = match &f.pattern {
            &Some(ref p) => lower_pattern(ctx, p),
            &None => {
                // Shorthand: field name becomes binding name
                let local_id = ctx.alloc_local_id();
                let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                // Re-intern binding name for cross-module consistency
                let bind_name_str = ctx.span_to_string(f.name.span);
                let bind_name_sym = ctx.intern(bind_name_str.as_str());
                let re_bind_name = common::SpannedSymbol { symbol: bind_name_sym, span: f.name.span };
                hir_expr::Pattern::new(
                    hir_expr::PatternKind::Binding {
                        local_id: local_id,
                        name: re_bind_name,
                        mode: hir_expr::BindingMode::ByValue,
                        subpattern: Option::None,
                    },
                    ty,
                    f.span,
                )
            }
        };
        // Re-intern field pattern name for cross-module consistency
        let fpat_name_str = ctx.span_to_string(f.name.span);
        let fpat_name_sym = ctx.intern(fpat_name_str.as_str());
        let re_fpat_name = common::SpannedSymbol { symbol: fpat_name_sym, span: f.name.span };
        let field_hir = hir_expr::FieldPattern::new(
            re_fpat_name,
            Option::None, // Field index resolved during type checking
            pat_hir,
            f.span,
        );
        fields_hir.push(field_hir);
        i = i + 1;
    }

    hir_expr::PatternKind::Struct {
        path: resolved,
        fields: fields_hir,
        has_rest: has_rest,
    }
}

/// Lower a tuple struct pattern.
fn lower_tuple_struct_pattern(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    path: &ast::TypePath,
    fields: &Vec<ast::Pattern>,
    span: common::Span,
) -> hir_expr::PatternKind {
    let resolved = resolve_type_path_for_pattern(ctx, path, span);

    let mut fields_hir: Vec<hir_expr::Pattern> = Vec::new();
    let mut i: usize = 0;
    while i < fields.len() {
        let f_hir = lower_pattern(ctx, &fields[i]);
        fields_hir.push(f_hir);
        i = i + 1;
    }

    hir_expr::PatternKind::TupleStruct {
        path: resolved,
        fields: fields_hir,
    }
}

/// Lower a path pattern (unit variant or constant).
fn lower_path_pattern(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath, span: common::Span) -> hir_expr::PatternKind {
    let resolved = resolve_type_path_for_pattern(ctx, path, span);
    hir_expr::PatternKind::Path(resolved)
}

/// Resolve a type path for use in a pattern.
fn resolve_type_path_for_pattern(ctx: &mut hir_lower_ctx::LoweringCtx, path: &ast::TypePath, span: common::Span) -> hir_def::ResolvedPath {
    // Extract the names from path segments, re-interning for consistent indices
    let mut names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < path.segments.len() {
        let seg = &path.segments[i];
        let name_str = ctx.span_to_string(seg.name.span);
        let re_interned = ctx.intern(name_str.as_str());
        names.push(common::SpannedSymbol { symbol: re_interned, span: seg.name.span });
        i = i + 1;
    }

    // Try qualified path resolution
    let resolved = ctx.resolver.resolve_qualified_path(&names);
    if resolved.is_some() {
        let result = resolved.unwrap();
        let last_seg = &path.segments[path.segments.len() - 1];
        let type_args = match &last_seg.args {
            &Some(ref args) => hir_lower_type::lower_type_args(ctx, args),
            &None => Vec::new(),
        };
        let type_arg_count = type_args.len() as u32;
        // Check if the resolved def is a variant - set variant_index if so
        let def_info = ctx.resolver.get_def_info(result.def_id);
        match def_info {
            Option::Some(info) => {
                match info.variant_index {
                    Option::Some(vi) => {
                        return hir_def::ResolvedPath::variant(result.def_id, span, vi);
                    }
                    Option::None => {
                        return hir_def::ResolvedPath::new(result.def_id, type_arg_count, span);
                    }
                }
            }
            Option::None => {
                return hir_def::ResolvedPath::new(result.def_id, type_arg_count, span);
            }
        }
    }

    // Unresolved
    ctx.error(
        hir::DiagnosticCode::E0102,
        common::make_string("cannot resolve pattern path"),
        span,
    );

    // Return error path
    let error_def_id = hir_def::DefId::new(0);
    hir_def::ResolvedPath::new(error_def_id, 0, span)
}

// ============================================================
// Control Flow Lowering
// ============================================================

/// Lower an if expression.
fn lower_if_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    condition: &ast::Expr,
    then_branch: &ast::Block,
    else_branch: &Option<ast::ElseBranch>,
    span: common::Span,
) -> hir_expr::Expr {
    let cond_hir = lower_expr(ctx, condition);
    let then_hir = lower_block_to_expr(ctx, then_branch);

    let else_hir = match else_branch {
        &Some(ref eb) => {
            match eb {
                &ast::ElseBranch::Block(ref block) => {
                    Some(Box::new(lower_block_to_expr(ctx, block)))
                }
                &ast::ElseBranch::If(ref if_expr) => {
                    Some(Box::new(lower_expr(ctx, if_expr.as_ref())))
                }
            }
        }
        &None => Option::None,
    };

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::If {
            condition: Box::new(cond_hir),
            then_branch: Box::new(then_hir),
            else_branch: else_hir,
        },
        ty,
        span,
    )
}

/// Lower an if-let expression (desugar to match).
fn lower_if_let_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    pattern: &ast::Pattern,
    scrutinee: &ast::Expr,
    then_branch: &ast::Block,
    else_branch: &Option<ast::ElseBranch>,
    span: common::Span,
) -> hir_expr::Expr {
    // Desugar if let to match:
    // if let pat = expr { then } else { else }
    // becomes:
    // match expr { pat => then, _ => else }

    let scrutinee_hir = lower_expr(ctx, scrutinee);
    let pattern_hir = lower_pattern(ctx, pattern);
    let then_hir = lower_block_to_expr(ctx, then_branch);

    let then_arm = hir_expr::MatchArm::new(
        pattern_hir,
        Option::None,
        then_hir,
        then_branch.span,
    );

    let else_hir = match else_branch {
        &Some(ref eb) => {
            match eb {
                &ast::ElseBranch::Block(ref block) => {
                    lower_block_to_expr(ctx, block)
                }
                &ast::ElseBranch::If(ref if_expr) => {
                    lower_expr(ctx, if_expr.as_ref())
                }
            }
        }
        &None => {
            // No else branch, use unit
            hir_expr::Expr::new(
                hir_expr::ExprKind::Tuple(Vec::new()),
                hir_ty::Type::unit(),
                span,
            )
        }
    };

    let wildcard_ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    let wildcard_pat = hir_expr::Pattern::wildcard(wildcard_ty, span);
    let else_arm = hir_expr::MatchArm::new(
        wildcard_pat,
        Option::None,
        else_hir,
        span,
    );

    let mut arms: Vec<hir_expr::MatchArm> = Vec::new();
    arms.push(then_arm);
    arms.push(else_arm);

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Match {
            scrutinee: Box::new(scrutinee_hir),
            arms: arms,
        },
        ty,
        span,
    )
}

/// Lower a match expression.
fn lower_match_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    scrutinee: &ast::Expr,
    arms: &Vec<ast::MatchArm>,
    span: common::Span,
) -> hir_expr::Expr {
    let scrutinee_hir = lower_expr(ctx, scrutinee);

    let mut arms_hir: Vec<hir_expr::MatchArm> = Vec::new();
    let mut i: usize = 0;
    while i < arms.len() {
        let arm = &arms[i];
        ctx.resolver.push_scope(resolve::ScopeKind::MatchArm);
        let pattern_hir = lower_pattern(ctx, &arm.pattern);
        let guard_hir = match &arm.guard {
            &Some(ref g) => Some(lower_expr(ctx, g)),
            &None => Option::None,
        };
        let body_hir = lower_expr(ctx, &arm.body);
        ctx.resolver.pop_scope();
        let arm_hir = hir_expr::MatchArm::new(
            pattern_hir,
            guard_hir,
            body_hir,
            arm.span,
        );
        arms_hir.push(arm_hir);
        i = i + 1;
    }

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Match {
            scrutinee: Box::new(scrutinee_hir),
            arms: arms_hir,
        },
        ty,
        span,
    )
}

/// Lower a loop expression.
fn lower_loop_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    label: &Option<common::SpannedSymbol>,
    body: &ast::Block,
    span: common::Span,
) -> hir_expr::Expr {
    let label_sym = match label {
        &Some(ref l) => Some(l.symbol),
        &None => Option::None,
    };
    let body_hir = lower_block_to_expr(ctx, body);
    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Loop {
            label: label_sym,
            body: Box::new(body_hir),
        },
        ty,
        span,
    )
}

/// Lower a while expression (desugar to loop + if).
fn lower_while_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    label: &Option<common::SpannedSymbol>,
    condition: &ast::Expr,
    body: &ast::Block,
    span: common::Span,
) -> hir_expr::Expr {
    // Desugar: while cond { body }
    // to: loop { if cond { body } else { break } }

    let label_sym = match label {
        &Some(ref l) => Some(l.symbol),
        &None => Option::None,
    };

    let cond_hir = lower_expr(ctx, condition);
    let body_hir = lower_block_to_expr(ctx, body);

    let break_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Break {
            label: label_sym,
            val: Option::None,
        },
        hir_ty::Type::never(),
        span,
    );

    let if_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::If {
            condition: Box::new(cond_hir),
            then_branch: Box::new(body_hir),
            else_branch: Some(Box::new(break_expr)),
        },
        hir_ty::Type::unit(),
        span,
    );

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Loop {
            label: label_sym,
            body: Box::new(if_expr),
        },
        ty,
        span,
    )
}

/// Lower a while-let expression (desugar to loop + match).
fn lower_while_let_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    label: &Option<common::SpannedSymbol>,
    pattern: &ast::Pattern,
    scrutinee: &ast::Expr,
    body: &ast::Block,
    span: common::Span,
) -> hir_expr::Expr {
    // Desugar: while let pat = expr { body }
    // to: loop { match expr { pat => body, _ => break } }

    let label_sym = match label {
        &Some(ref l) => Some(l.symbol),
        &None => Option::None,
    };

    let scrutinee_hir = lower_expr(ctx, scrutinee);
    let pattern_hir = lower_pattern(ctx, pattern);
    let body_hir = lower_block_to_expr(ctx, body);

    let match_arm = hir_expr::MatchArm::new(
        pattern_hir,
        Option::None,
        body_hir,
        body.span,
    );

    let break_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Break {
            label: label_sym,
            val: Option::None,
        },
        hir_ty::Type::never(),
        span,
    );

    let wildcard_ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    let wildcard_pat = hir_expr::Pattern::wildcard(wildcard_ty, span);
    let break_arm = hir_expr::MatchArm::new(
        wildcard_pat,
        Option::None,
        break_expr,
        span,
    );

    let mut arms: Vec<hir_expr::MatchArm> = Vec::new();
    arms.push(match_arm);
    arms.push(break_arm);

    let match_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Match {
            scrutinee: Box::new(scrutinee_hir),
            arms: arms,
        },
        hir_ty::Type::unit(),
        span,
    );

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Loop {
            label: label_sym,
            body: Box::new(match_expr),
        },
        ty,
        span,
    )
}

/// Lower a for expression (desugar to loop + match over iterator).
/// Currently supports range iteration: for i in start..end { body }
fn lower_for_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    label: &Option<common::SpannedSymbol>,
    pattern: &ast::Pattern,
    iter: &ast::Expr,
    body: &ast::Block,
    span: common::Span,
) -> hir_expr::Expr {
    // Check if iter is a range expression
    match &iter.kind {
        &ast::ExprKind::Range { ref start, ref end_val, inclusive } => {
            // Desugar: for pattern in start..end { body }
            // to: { let mut pattern = start; loop { if pattern < end { body; pattern = pattern + 1; } else { break } } }
            lower_for_range(ctx, label, pattern, start, end_val, inclusive, body, span)
        }
        _ => {
            // For non-range iterators, emit an error
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("for loops currently only support range iteration (e.g., for i in 0..10)"),
                span,
            );
            // Return the body as a fallback
            lower_block_to_expr(ctx, body)
        }
    }
}

/// Lower a for loop over a range.
fn lower_for_range(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    label: &Option<common::SpannedSymbol>,
    pattern: &ast::Pattern,
    start: &Option<Box<ast::Expr>>,
    end_val: &Option<Box<ast::Expr>>,
    inclusive: bool,
    body: &ast::Block,
    span: common::Span,
) -> hir_expr::Expr {
    let label_sym = match label {
        &Some(ref l) => Some(l.symbol),
        &None => Option::None,
    };

    // Lower the pattern to get the loop variable
    let pattern_hir = lower_pattern(ctx, pattern);

    // Get the local_id from the pattern (should be a binding pattern)
    let loop_var_local_id = extract_binding_local_id(&pattern_hir);
    if loop_var_local_id.is_none() {
        ctx.error(
            hir::DiagnosticCode::E0104,
            common::make_string("for loop variable must be a simple identifier"),
            span,
        );
        return lower_block_to_expr(ctx, body);
    }
    let loop_var_id = loop_var_local_id.unwrap();

    // Lower start value (default to 0 if not provided)
    let start_expr = match start {
        &Some(ref e) => lower_expr(ctx, e.as_ref()),
        &None => {
            // Default to 0
            hir_expr::Expr::new(
                hir_expr::ExprKind::Literal(hir_expr::Literal::new(
                    hir_expr::LiteralKind::Int { val: 0, ty: Some(hir_ty::PrimitiveTy::I32) },
                    span,
                )),
                hir_ty::Type::i32_ty(),
                span,
            )
        }
    };

    // Lower end value
    let end_expr = match end_val {
        &Some(ref e) => lower_expr(ctx, e.as_ref()),
        &None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("for loop requires an end value"),
                span,
            );
            return lower_block_to_expr(ctx, body);
        }
    };

    // Get the type for the loop variable from start expression
    let loop_var_ty = hir_ty::copy_type(&start_expr.ty);

    // Create: let mut pattern = start;
    let init_let = hir_expr::Stmt::Let {
        pattern: pattern_hir,
        ty: Some(hir_ty::copy_type(&loop_var_ty)),
        init: Some(start_expr),
        span: span,
    };

    // Create condition: pattern < end (or pattern <= end for inclusive)
    let loop_var_ref = hir_expr::Expr::new(
        hir_expr::ExprKind::Local(loop_var_id),
        hir_ty::copy_type(&loop_var_ty),
        span,
    );

    let cmp_op = if inclusive {
        common::BinOp::Le
    } else {
        common::BinOp::Lt
    };

    let condition = hir_expr::Expr::new(
        hir_expr::ExprKind::Binary {
            op: cmp_op,
            left: Box::new(loop_var_ref),
            right: Box::new(end_expr),
        },
        hir_ty::Type::bool_ty(),
        span,
    );

    // Lower the body
    let body_hir = lower_block_to_expr(ctx, body);

    // Create increment: pattern = pattern + 1
    let loop_var_ref_for_add = hir_expr::Expr::new(
        hir_expr::ExprKind::Local(loop_var_id),
        hir_ty::copy_type(&loop_var_ty),
        span,
    );

    let one_lit = hir_expr::Expr::new(
        hir_expr::ExprKind::Literal(hir_expr::Literal::new(
            hir_expr::LiteralKind::Int { val: 1, ty: Some(hir_ty::PrimitiveTy::I32) },
            span,
        )),
        hir_ty::copy_type(&loop_var_ty),
        span,
    );

    let add_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Binary {
            op: common::BinOp::Add,
            left: Box::new(loop_var_ref_for_add),
            right: Box::new(one_lit),
        },
        hir_ty::copy_type(&loop_var_ty),
        span,
    );

    let loop_var_place = hir_expr::Expr::new(
        hir_expr::ExprKind::Local(loop_var_id),
        hir_ty::copy_type(&loop_var_ty),
        span,
    );

    let increment_assign = hir_expr::Expr::new(
        hir_expr::ExprKind::Assign {
            target: Box::new(loop_var_place),
            val: Box::new(add_expr),
        },
        hir_ty::Type::unit(),
        span,
    );

    // Create body block with increment at the end: { body; pattern = pattern + 1; }
    let mut body_with_increment_stmts: Vec<hir_expr::Stmt> = Vec::new();
    body_with_increment_stmts.push(hir_expr::Stmt::Expr { expr: body_hir, has_semi: true });
    body_with_increment_stmts.push(hir_expr::Stmt::Expr { expr: increment_assign, has_semi: true });
    let body_with_increment_block = hir_expr::Block::new(body_with_increment_stmts, Option::None, span);
    let body_with_increment = hir_expr::Expr::new(
        hir_expr::ExprKind::Block(body_with_increment_block),
        hir_ty::Type::unit(),
        span,
    );

    // Create break expression
    let break_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Break {
            label: label_sym,
            val: Option::None,
        },
        hir_ty::Type::never(),
        span,
    );

    // Create if expression: if condition { body; increment; } else { break }
    let if_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::If {
            condition: Box::new(condition),
            then_branch: Box::new(body_with_increment),
            else_branch: Some(Box::new(break_expr)),
        },
        hir_ty::Type::unit(),
        span,
    );

    // Create loop: loop { if_expr }
    let loop_expr = hir_expr::Expr::new(
        hir_expr::ExprKind::Loop {
            label: label_sym,
            body: Box::new(if_expr),
        },
        hir_ty::Type::infer(ctx.alloc_ty_var()),
        span,
    );

    // Wrap in block with init: { let mut pattern = start; loop { ... } }
    let mut outer_stmts: Vec<hir_expr::Stmt> = Vec::new();
    outer_stmts.push(init_let);
    let outer_block = hir_expr::Block::new(outer_stmts, Some(Box::new(loop_expr)), span);
    hir_expr::Expr::new(
        hir_expr::ExprKind::Block(outer_block),
        hir_ty::Type::infer(ctx.alloc_ty_var()),
        span,
    )
}

/// Extract the LocalId from a binding pattern.
fn extract_binding_local_id(pattern: &hir_expr::Pattern) -> Option<hir_def::LocalId> {
    match &pattern.kind {
        &hir_expr::PatternKind::Binding { local_id, name: _, mode: _, subpattern: _ } => {
            Some(local_id)
        }
        _ => Option::None
    }
}

// ============================================================
// Closure Lowering
// ============================================================

/// Lower a closure expression.
fn lower_closure_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    params: &Vec<ast::ClosureParam>,
    return_type: &Option<ast::Type>,
    effects: &Option<ast::EffectRow>,
    body: &ast::Expr,
    span: common::Span,
) -> hir_expr::Expr {
    // Allocate a BodyId for the closure
    let body_id = ctx.alloc_body_id();

    // Lower parameters
    let mut params_hir: Vec<hir_expr::ClosureParam> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() {
        let p = &params[i];
        let pattern_hir = lower_pattern(ctx, &p.pattern);
        let ty_hir = match &p.ty {
            &Some(ref t) => hir_lower_type::lower_type(ctx, t),
            &None => hir_ty::Type::infer(ctx.alloc_ty_var()),
        };
        let param_hir = hir_expr::ClosureParam::new(pattern_hir, ty_hir);
        params_hir.push(param_hir);
        i = i + 1;
    }

    // Lower return type
    let ret_ty = match return_type {
        &Some(ref t) => hir_lower_type::lower_type(ctx, t),
        &None => hir_ty::Type::infer(ctx.alloc_ty_var()),
    };

    // Lower effects
    let effects_hir = match effects {
        &Some(ref eff) => hir_lower_type::lower_effect_row(ctx, eff),
        &None => hir_ty::EffectRow::empty(),
    };

    // Lower body
    let body_hir = lower_expr(ctx, body);

    // Captures will be determined during type checking
    let captures: Vec<hir_expr::Capture> = Vec::new();

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Closure {
            captures: captures,
            params: params_hir,
            return_ty: ret_ty,
            effects: effects_hir,
            body: Box::new(body_hir),
            body_id: body_id,
        },
        ty,
        span,
    )
}

// ============================================================
// Effect Lowering
// ============================================================

/// Lower a perform expression.
fn lower_perform_expr(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    effect_path: &Option<ast::TypePath>,
    operation: &common::SpannedSymbol,
    args: &Vec<ast::Expr>,
    span: common::Span,
) -> hir_expr::Expr {
    // Resolve the effect
    let effect_def_id = match effect_path {
        &Some(ref path) => {
            if path.segments.len() >= 1 {
                let seg = &path.segments[0];
                // Re-intern from span for consistent symbol indices
                let name_str = ctx.span_to_string(seg.name.span);
                let lookup_symbol = ctx.intern(name_str.as_str());
                let lookup = ctx.resolver.lookup(lookup_symbol);
                if lookup.is_some() {
                    let result = lookup.unwrap();
                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                    binding.def_id
                } else {
                    ctx.error(
                        hir::DiagnosticCode::E0102,
                        common::make_string("unknown effect"),
                        path.span,
                    );
                    hir_def::DefId::new(0)
                }
            } else {
                ctx.error(
                    hir::DiagnosticCode::E0102,
                    common::make_string("invalid effect path"),
                    span,
                );
                hir_def::DefId::new(0)
            }
        }
        &None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("effect must be specified"),
                span,
            );
            hir_def::DefId::new(0)
        }
    };

    // Lower arguments
    let mut args_hir: Vec<hir_expr::Expr> = Vec::new();
    let mut i: usize = 0;
    while i < args.len() {
        let arg_hir = lower_expr(ctx, &args[i]);
        args_hir.push(arg_hir);
        i = i + 1;
    }

    // Operation DefId will be resolved during type checking
    let op_def_id = hir_def::DefId::new(0);

    // Re-intern operation name from span for consistent symbol indices
    let op_name_str = ctx.span_to_string(operation.span);
    let op_name_sym = ctx.intern(op_name_str.as_str());

    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
    hir_expr::Expr::new(
        hir_expr::ExprKind::Perform {
            effect_def: effect_def_id,
            op_def: op_def_id,
            op_name: op_name_sym,
            args: args_hir,
        },
        ty,
        span,
    )
}

// ============================================================
// Macro Call Lowering
// ============================================================

/// Lower a macro call expression.
fn lower_macro_call_expr(ctx: &mut hir_lower_ctx::LoweringCtx, kind: &ast::MacroCallKind, span: common::Span) -> hir_expr::Expr {
    match kind {
        &ast::MacroCallKind::Format { ref format_str, ref args } => {
            // Format strings need special handling
            // For now, just lower the args
            let mut args_hir: Vec<hir_expr::Expr> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                let arg_hir = lower_expr(ctx, &args[i]);
                args_hir.push(arg_hir);
                i = i + 1;
            }

            // Return a placeholder string expression
            let mut str_copy = String::new();
            str_copy.push_str(format_str.value.as_str());
            let lit = hir_expr::Literal::new(
                hir_expr::LiteralKind::Str(str_copy),
                format_str.span,
            );
            hir_expr::Expr::new(
                hir_expr::ExprKind::Literal(lit),
                hir_ty::Type::new(hir_ty::TypeKind::Ref { inner: Box::new(hir_ty::Type::str_ty()), mutable: false }),
                span,
            )
        }
        &ast::MacroCallKind::VecMacro(ref vec_args) => {
            match vec_args {
                &ast::VecMacroArgs::List(ref elems) => {
                    lower_array_expr(ctx, &ast::ArrayExpr::List(copy_expr_vec(elems)), span)
                }
                &ast::VecMacroArgs::Repeat { ref val, count: _ } => {
                    // vec![val; count] - need const evaluation for count
                    let val_hir = lower_expr(ctx, val.as_ref());
                    let arr = hir_expr::ArrayExpr::Repeat {
                        val: Box::new(val_hir),
                        count: 0,
                    };
                    let ty = hir_ty::Type::infer(ctx.alloc_ty_var());
                    hir_expr::Expr::new(
                        hir_expr::ExprKind::Array(arr),
                        ty,
                        span,
                    )
                }
            }
        }
        &ast::MacroCallKind::Assert { ref condition, message: _ } => {
            // Desugar assert! to if !cond { panic!(...) }
            let cond_hir = lower_expr(ctx, condition.as_ref());
            // For now, just return the condition (proper panic handling later)
            cond_hir
        }
        &ast::MacroCallKind::Dbg(ref expr) => {
            // dbg! just evaluates and returns the expression
            lower_expr(ctx, expr.as_ref())
        }
        &ast::MacroCallKind::Matches { ref expr, ref pattern } => {
            // matches!(expr, pattern) desugars to match expr { pattern => true, _ => false }
            let expr_hir = lower_expr(ctx, expr.as_ref());
            let pattern_hir = lower_pattern(ctx, pattern.as_ref());

            let true_lit = hir_expr::Literal::new(
                hir_expr::LiteralKind::Bool(true),
                span,
            );
            let true_expr = hir_expr::Expr::new(
                hir_expr::ExprKind::Literal(true_lit),
                hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)),
                span,
            );

            let false_lit = hir_expr::Literal::new(
                hir_expr::LiteralKind::Bool(false),
                span,
            );
            let false_expr = hir_expr::Expr::new(
                hir_expr::ExprKind::Literal(false_lit),
                hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)),
                span,
            );

            let match_arm = hir_expr::MatchArm::new(
                pattern_hir,
                Option::None,
                true_expr,
                span,
            );

            let wildcard_ty = hir_ty::Type::infer(ctx.alloc_ty_var());
            let wildcard_pat = hir_expr::Pattern::wildcard(wildcard_ty, span);
            let else_arm = hir_expr::MatchArm::new(
                wildcard_pat,
                Option::None,
                false_expr,
                span,
            );

            let mut arms: Vec<hir_expr::MatchArm> = Vec::new();
            arms.push(match_arm);
            arms.push(else_arm);

            hir_expr::Expr::new(
                hir_expr::ExprKind::Match {
                    scrutinee: Box::new(expr_hir),
                    arms: arms,
                },
                hir_ty::Type::new(hir_ty::TypeKind::Primitive(hir_ty::PrimitiveTy::Bool)),
                span,
            )
        }
        &ast::MacroCallKind::Custom { delim: _, content: _ } => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("custom macros not yet supported"),
                span,
            );
            hir_expr::Expr::error(span)
        }
    }
}

/// Copy a vector of expressions (shallow copy references).
fn copy_expr_vec(exprs: &Vec<ast::Expr>) -> Vec<ast::Expr> {
    // This is a workaround since Blood doesn't have clone
    // We can't actually copy AST nodes, so we'd need to re-parse
    // For now, return empty and handle specially
    Vec::new()
}


