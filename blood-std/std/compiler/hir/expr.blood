/// HIR Expressions and Function Bodies
///
/// This module defines the typed expression representation used after
/// type checking. All expressions have a resolved type attached.
///
/// # Key Types
///
/// - `Body` - A function or closure body
/// - `Expr` - A typed expression
/// - `ExprKind` - The kind of expression
/// - `Pattern` - A pattern for matching
/// - `Stmt` - A statement in a block

use crate.compiler.typeck.types.{DefId, Type}
use crate.compiler.hir.def.{LocalId, BodyId, LoopId}
use crate.compiler.hir.item.Span;

// ============================================================
// Function Bodies
// ============================================================

/// A function or closure body.
///
/// Bodies contain:
/// - A list of locals (parameters and temporaries)
/// - The number of parameters
/// - The body expression
pub struct Body {
    /// The parameters and local variables.
    pub locals: [Local],
    /// The number of parameters (first N locals after return place are params).
    pub param_count: usize,
    /// The body expression.
    pub expr: Expr,
    /// Source location.
    pub span: Span,
}

impl Body {
    /// Get the return type (type of local 0).
    pub fn return_type(&self) -> &Type {
        &self.locals[0].ty
    }

    /// Get the number of parameters.
    pub fn param_count(&self) -> usize {
        self.param_count
    }

    /// Get a local by ID.
    pub fn get_local(&self, id: &LocalId) -> Option<&Local> {
        let mut i: usize = 0;
        while i < self.locals.len() {
            if self.locals[i].id.eq(id) {
                return Some(&self.locals[i]);
            }
            i = i + 1;
        }
        None
    }
}

impl Clone for Body {
    fn clone(&self) -> Body {
        Body {
            locals: self.locals.clone(),
            param_count: self.param_count,
            expr: self.expr.clone(),
            span: self.span.clone(),
        }
    }
}

/// A local variable (parameter or temporary).
pub struct Local {
    /// The local ID.
    pub id: LocalId,
    /// The type of this local.
    pub ty: Type,
    /// Whether this local is mutable.
    pub mutable: bool,
    /// The name of this local (for debugging/errors).
    pub name: Option<String>,
    /// Source location where declared.
    pub span: Span,
}

impl Clone for Local {
    fn clone(&self) -> Local {
        Local {
            id: self.id.clone(),
            ty: self.ty.clone(),
            mutable: self.mutable,
            name: self.name.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// Expressions
// ============================================================

/// A typed expression.
pub struct Expr {
    /// The expression kind.
    pub kind: ExprKind,
    /// The type of this expression.
    pub ty: Type,
    /// Source location.
    pub span: Span,
}

impl Expr {
    /// Create a new expression.
    pub fn new(kind: ExprKind, ty: Type, span: Span) -> Expr {
        Expr { kind, ty, span }
    }

    /// Create an error expression.
    pub fn error(span: Span) -> Expr {
        Expr {
            kind: ExprKind::Error,
            ty: Type::error(),
            span,
        }
    }

    /// Check if this is an error expression.
    pub fn is_error(&self) -> bool {
        match &self.kind {
            ExprKind::Error => true,
            ExprKind::Literal(_) => false,
            ExprKind::Local(_) => false,
            ExprKind::Def(_) => false,
            ExprKind::Binary { op: _, left: _, right: _ } => false,
            ExprKind::Unary { op: _, operand: _ } => false,
            ExprKind::Call { callee: _, args: _ } => false,
            ExprKind::MethodCall { receiver: _, method: _, args: _ } => false,
            ExprKind::Field { base: _, field_idx: _ } => false,
            ExprKind::Index { base: _, index: _ } => false,
            ExprKind::Tuple(_) => false,
            ExprKind::Array(_) => false,
            ExprKind::Repeat { value: _, count: _ } => false,
            ExprKind::Struct { def_id: _, fields: _, base: _ } => false,
            ExprKind::Record { fields: _ } => false,
            ExprKind::Variant { def_id: _, variant_idx: _, fields: _ } => false,
            ExprKind::Cast { expr: _, target_ty: _ } => false,
            ExprKind::Assign { target: _, value: _ } => false,
            ExprKind::Block { stmts: _, expr: _ } => false,
            ExprKind::If { condition: _, then_branch: _, else_branch: _ } => false,
            ExprKind::Match { scrutinee: _, arms: _ } => false,
            ExprKind::Loop { body: _, label: _ } => false,
            ExprKind::While { condition: _, body: _, label: _ } => false,
            ExprKind::Return(_) => false,
            ExprKind::Break { label: _, value: _ } => false,
            ExprKind::Continue { label: _ } => false,
            ExprKind::Closure { body_id: _, captures: _ } => false,
            ExprKind::Borrow { expr: _, mutable: _ } => false,
            ExprKind::Deref(_) => false,
            ExprKind::AddrOf { expr: _, mutable: _ } => false,
            ExprKind::Let { pattern: _, init: _ } => false,
            ExprKind::Unsafe(_) => false,
            ExprKind::Perform { effect_id: _, op_index: _, args: _ } => false,
            ExprKind::Resume { value: _ } => false,
            ExprKind::Handle { body: _, handler_id: _, handler_instance: _ } => false,
            ExprKind::InlineHandle { body: _, handlers: _ } => false,
            ExprKind::Range { start: _, end: _, inclusive: _ } => false,
            ExprKind::Default => false,
        }
    }
}

impl Clone for Expr {
    fn clone(&self) -> Expr {
        Expr {
            kind: self.kind.clone(),
            ty: self.ty.clone(),
            span: self.span.clone(),
        }
    }
}

// ============================================================
// Expression Kinds
// ============================================================

/// The kind of an expression.
pub enum ExprKind {
    /// A literal value.
    Literal(LiteralValue),

    /// A local variable reference.
    Local(LocalId),

    /// A reference to a definition (function, constant, etc.).
    Def(DefId),

    /// Binary operation: `a + b`
    Binary {
        op: BinOp,
        left: Box<Expr>,
        right: Box<Expr>,
    },

    /// Unary operation: `-x`, `!x`, `*x`, `&x`
    Unary {
        op: UnaryOp,
        operand: Box<Expr>,
    },

    /// Function call: `f(x, y)`
    Call {
        callee: Box<Expr>,
        args: [Expr],
    },

    /// Method call: `x.method(y)`
    MethodCall {
        receiver: Box<Expr>,
        method: DefId,
        args: [Expr],
    },

    /// Field access: `x.field`
    Field {
        base: Box<Expr>,
        field_idx: u32,
    },

    /// Array/slice indexing: `x[i]`
    Index {
        base: Box<Expr>,
        index: Box<Expr>,
    },

    /// Tuple expression: `(a, b, c)`
    Tuple([Expr]),

    /// Array expression: `[a, b, c]`
    Array([Expr]),

    /// Array repeat: `[x; N]`
    Repeat {
        value: Box<Expr>,
        count: u64,
    },

    /// Struct construction: `Point { x: 1, y: 2 }`
    Struct {
        def_id: DefId,
        fields: [FieldExpr],
        base: Option<Box<Expr>>,
    },

    /// Anonymous record construction: `{ x: 1, y: 2 }`
    Record {
        fields: [RecordFieldExpr],
    },

    /// Enum variant construction: `Some(x)`
    Variant {
        def_id: DefId,
        variant_idx: u32,
        fields: [Expr],
    },

    /// Type cast: `x as T`
    Cast {
        expr: Box<Expr>,
        target_ty: Type,
    },

    /// Assignment: `x = y`
    Assign {
        target: Box<Expr>,
        value: Box<Expr>,
    },

    /// Block: `{ stmts; expr }`
    Block {
        stmts: [Stmt],
        expr: Option<Box<Expr>>,
    },

    /// If expression: `if cond { then } else { else }`
    If {
        condition: Box<Expr>,
        then_branch: Box<Expr>,
        else_branch: Option<Box<Expr>>,
    },

    /// Match expression: `match x { patterns }`
    Match {
        scrutinee: Box<Expr>,
        arms: [MatchArm],
    },

    /// Loop: `loop { body }`
    Loop {
        body: Box<Expr>,
        label: Option<LoopId>,
    },

    /// While loop: `while cond { body }`
    While {
        condition: Box<Expr>,
        body: Box<Expr>,
        label: Option<LoopId>,
    },

    /// Return: `return x`
    Return(Option<Box<Expr>>),

    /// Break: `break x`
    Break {
        label: Option<LoopId>,
        value: Option<Box<Expr>>,
    },

    /// Continue: `continue`
    Continue {
        label: Option<LoopId>,
    },

    /// Closure: `|x| x + 1`
    Closure {
        body_id: BodyId,
        captures: [Capture],
    },

    /// Borrow: `&x` or `&mut x`
    Borrow {
        expr: Box<Expr>,
        mutable: bool,
    },

    /// Dereference: `*x`
    Deref(Box<Expr>),

    /// Address of: for raw pointers
    AddrOf {
        expr: Box<Expr>,
        mutable: bool,
    },

    /// Let binding within an expression (let-else)
    Let {
        pattern: Pattern,
        init: Box<Expr>,
    },

    /// Unsafe block: `unsafe { ... }`
    Unsafe(Box<Expr>),

    /// Effect operation: `perform Effect.op(args)`
    Perform {
        effect_id: DefId,
        op_index: u32,
        args: [Expr],
    },

    /// Resume continuation in a handler: `resume(value)`
    Resume {
        value: Option<Box<Expr>>,
    },

    /// Handle expression: `handle { body } with handler`
    Handle {
        body: Box<Expr>,
        handler_id: DefId,
        handler_instance: Box<Expr>,
    },

    /// Inline handle expression: `try { body } with { handlers }`
    InlineHandle {
        body: Box<Expr>,
        handlers: [InlineOpHandler],
    },

    /// Range expression: `start..end` or `start..=end`
    Range {
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
        inclusive: bool,
    },

    /// Default value: `default`
    Default,

    /// Error placeholder (for error recovery).
    Error,
}

impl Clone for ExprKind {
    fn clone(&self) -> ExprKind {
        match self {
            ExprKind::Literal(lit) => ExprKind::Literal(lit.clone()),
            ExprKind::Local(id) => ExprKind::Local(id.clone()),
            ExprKind::Def(id) => ExprKind::Def(id.clone()),
            ExprKind::Binary { op, left, right } => ExprKind::Binary {
                op: op.clone(),
                left: left.clone(),
                right: right.clone(),
            },
            ExprKind::Unary { op, operand } => ExprKind::Unary {
                op: op.clone(),
                operand: operand.clone(),
            },
            ExprKind::Call { callee, args } => ExprKind::Call {
                callee: callee.clone(),
                args: args.clone(),
            },
            ExprKind::MethodCall { receiver, method, args } => ExprKind::MethodCall {
                receiver: receiver.clone(),
                method: method.clone(),
                args: args.clone(),
            },
            ExprKind::Field { base, field_idx } => ExprKind::Field {
                base: base.clone(),
                field_idx: *field_idx,
            },
            ExprKind::Index { base, index } => ExprKind::Index {
                base: base.clone(),
                index: index.clone(),
            },
            ExprKind::Tuple(exprs) => ExprKind::Tuple(exprs.clone()),
            ExprKind::Array(exprs) => ExprKind::Array(exprs.clone()),
            ExprKind::Repeat { value, count } => ExprKind::Repeat {
                value: value.clone(),
                count: *count,
            },
            ExprKind::Struct { def_id, fields, base } => ExprKind::Struct {
                def_id: def_id.clone(),
                fields: fields.clone(),
                base: base.clone(),
            },
            ExprKind::Record { fields } => ExprKind::Record {
                fields: fields.clone(),
            },
            ExprKind::Variant { def_id, variant_idx, fields } => ExprKind::Variant {
                def_id: def_id.clone(),
                variant_idx: *variant_idx,
                fields: fields.clone(),
            },
            ExprKind::Cast { expr, target_ty } => ExprKind::Cast {
                expr: expr.clone(),
                target_ty: target_ty.clone(),
            },
            ExprKind::Assign { target, value } => ExprKind::Assign {
                target: target.clone(),
                value: value.clone(),
            },
            ExprKind::Block { stmts, expr } => ExprKind::Block {
                stmts: stmts.clone(),
                expr: expr.clone(),
            },
            ExprKind::If { condition, then_branch, else_branch } => ExprKind::If {
                condition: condition.clone(),
                then_branch: then_branch.clone(),
                else_branch: else_branch.clone(),
            },
            ExprKind::Match { scrutinee, arms } => ExprKind::Match {
                scrutinee: scrutinee.clone(),
                arms: arms.clone(),
            },
            ExprKind::Loop { body, label } => ExprKind::Loop {
                body: body.clone(),
                label: label.clone(),
            },
            ExprKind::While { condition, body, label } => ExprKind::While {
                condition: condition.clone(),
                body: body.clone(),
                label: label.clone(),
            },
            ExprKind::Return(expr) => ExprKind::Return(expr.clone()),
            ExprKind::Break { label, value } => ExprKind::Break {
                label: label.clone(),
                value: value.clone(),
            },
            ExprKind::Continue { label } => ExprKind::Continue {
                label: label.clone(),
            },
            ExprKind::Closure { body_id, captures } => ExprKind::Closure {
                body_id: body_id.clone(),
                captures: captures.clone(),
            },
            ExprKind::Borrow { expr, mutable } => ExprKind::Borrow {
                expr: expr.clone(),
                mutable: *mutable,
            },
            ExprKind::Deref(expr) => ExprKind::Deref(expr.clone()),
            ExprKind::AddrOf { expr, mutable } => ExprKind::AddrOf {
                expr: expr.clone(),
                mutable: *mutable,
            },
            ExprKind::Let { pattern, init } => ExprKind::Let {
                pattern: pattern.clone(),
                init: init.clone(),
            },
            ExprKind::Unsafe(expr) => ExprKind::Unsafe(expr.clone()),
            ExprKind::Perform { effect_id, op_index, args } => ExprKind::Perform {
                effect_id: effect_id.clone(),
                op_index: *op_index,
                args: args.clone(),
            },
            ExprKind::Resume { value } => ExprKind::Resume {
                value: value.clone(),
            },
            ExprKind::Handle { body, handler_id, handler_instance } => ExprKind::Handle {
                body: body.clone(),
                handler_id: handler_id.clone(),
                handler_instance: handler_instance.clone(),
            },
            ExprKind::InlineHandle { body, handlers } => ExprKind::InlineHandle {
                body: body.clone(),
                handlers: handlers.clone(),
            },
            ExprKind::Range { start, end, inclusive } => ExprKind::Range {
                start: start.clone(),
                end: end.clone(),
                inclusive: *inclusive,
            },
            ExprKind::Default => ExprKind::Default,
            ExprKind::Error => ExprKind::Error,
        }
    }
}

// ============================================================
// Literals
// ============================================================

/// A literal value.
pub enum LiteralValue {
    /// Signed integer literal.
    Int(i128),
    /// Unsigned integer literal.
    Uint(u128),
    /// Floating-point literal.
    Float(f64),
    /// Boolean literal.
    Bool(bool),
    /// Character literal.
    Char(char),
    /// String literal.
    String(String),
    /// Byte string literal.
    ByteString([u8]),
}

impl Clone for LiteralValue {
    fn clone(&self) -> LiteralValue {
        match self {
            LiteralValue::Int(v) => LiteralValue::Int(*v),
            LiteralValue::Uint(v) => LiteralValue::Uint(*v),
            LiteralValue::Float(v) => LiteralValue::Float(*v),
            LiteralValue::Bool(v) => LiteralValue::Bool(*v),
            LiteralValue::Char(v) => LiteralValue::Char(*v),
            LiteralValue::String(s) => LiteralValue::String(s.clone()),
            LiteralValue::ByteString(b) => LiteralValue::ByteString(b.clone()),
        }
    }
}

impl PartialEq for LiteralValue {
    fn eq(&self, other: &LiteralValue) -> bool {
        match (self, other) {
            (LiteralValue::Int(a), LiteralValue::Int(b)) => *a == *b,
            (LiteralValue::Uint(a), LiteralValue::Uint(b)) => *a == *b,
            (LiteralValue::Float(a), LiteralValue::Float(b)) => *a == *b,
            (LiteralValue::Bool(a), LiteralValue::Bool(b)) => *a == *b,
            (LiteralValue::Char(a), LiteralValue::Char(b)) => *a == *b,
            (LiteralValue::String(a), LiteralValue::String(b)) => a.eq(b),
            (LiteralValue::ByteString(a), LiteralValue::ByteString(b)) => a.eq(b),
            (LiteralValue::Int(_), _) => false,
            (LiteralValue::Uint(_), _) => false,
            (LiteralValue::Float(_), _) => false,
            (LiteralValue::Bool(_), _) => false,
            (LiteralValue::Char(_), _) => false,
            (LiteralValue::String(_), _) => false,
            (LiteralValue::ByteString(_), _) => false,
        }
    }
}

// ============================================================
// Operators
// ============================================================

/// Binary operators.
pub enum BinOp {
    /// Addition: `+`
    Add,
    /// Subtraction: `-`
    Sub,
    /// Multiplication: `*`
    Mul,
    /// Division: `/`
    Div,
    /// Remainder: `%`
    Rem,
    /// Bitwise AND: `&`
    BitAnd,
    /// Bitwise OR: `|`
    BitOr,
    /// Bitwise XOR: `^`
    BitXor,
    /// Left shift: `<<`
    Shl,
    /// Right shift: `>>`
    Shr,
    /// Equality: `==`
    Eq,
    /// Not equal: `!=`
    Ne,
    /// Less than: `<`
    Lt,
    /// Less than or equal: `<=`
    Le,
    /// Greater than: `>`
    Gt,
    /// Greater than or equal: `>=`
    Ge,
    /// Logical AND: `&&`
    And,
    /// Logical OR: `||`
    Or,
}

impl Clone for BinOp {
    fn clone(&self) -> BinOp {
        match self {
            BinOp::Add => BinOp::Add,
            BinOp::Sub => BinOp::Sub,
            BinOp::Mul => BinOp::Mul,
            BinOp::Div => BinOp::Div,
            BinOp::Rem => BinOp::Rem,
            BinOp::BitAnd => BinOp::BitAnd,
            BinOp::BitOr => BinOp::BitOr,
            BinOp::BitXor => BinOp::BitXor,
            BinOp::Shl => BinOp::Shl,
            BinOp::Shr => BinOp::Shr,
            BinOp::Eq => BinOp::Eq,
            BinOp::Ne => BinOp::Ne,
            BinOp::Lt => BinOp::Lt,
            BinOp::Le => BinOp::Le,
            BinOp::Gt => BinOp::Gt,
            BinOp::Ge => BinOp::Ge,
            BinOp::And => BinOp::And,
            BinOp::Or => BinOp::Or,
        }
    }
}

impl PartialEq for BinOp {
    fn eq(&self, other: &BinOp) -> bool {
        match (self, other) {
            (BinOp::Add, BinOp::Add) => true,
            (BinOp::Sub, BinOp::Sub) => true,
            (BinOp::Mul, BinOp::Mul) => true,
            (BinOp::Div, BinOp::Div) => true,
            (BinOp::Rem, BinOp::Rem) => true,
            (BinOp::BitAnd, BinOp::BitAnd) => true,
            (BinOp::BitOr, BinOp::BitOr) => true,
            (BinOp::BitXor, BinOp::BitXor) => true,
            (BinOp::Shl, BinOp::Shl) => true,
            (BinOp::Shr, BinOp::Shr) => true,
            (BinOp::Eq, BinOp::Eq) => true,
            (BinOp::Ne, BinOp::Ne) => true,
            (BinOp::Lt, BinOp::Lt) => true,
            (BinOp::Le, BinOp::Le) => true,
            (BinOp::Gt, BinOp::Gt) => true,
            (BinOp::Ge, BinOp::Ge) => true,
            (BinOp::And, BinOp::And) => true,
            (BinOp::Or, BinOp::Or) => true,
            (BinOp::Add, _) => false,
            (BinOp::Sub, _) => false,
            (BinOp::Mul, _) => false,
            (BinOp::Div, _) => false,
            (BinOp::Rem, _) => false,
            (BinOp::BitAnd, _) => false,
            (BinOp::BitOr, _) => false,
            (BinOp::BitXor, _) => false,
            (BinOp::Shl, _) => false,
            (BinOp::Shr, _) => false,
            (BinOp::Eq, _) => false,
            (BinOp::Ne, _) => false,
            (BinOp::Lt, _) => false,
            (BinOp::Le, _) => false,
            (BinOp::Gt, _) => false,
            (BinOp::Ge, _) => false,
            (BinOp::And, _) => false,
            (BinOp::Or, _) => false,
        }
    }
}

/// Unary operators.
pub enum UnaryOp {
    /// Negation: `-`
    Neg,
    /// Logical NOT: `!`
    Not,
}

impl Clone for UnaryOp {
    fn clone(&self) -> UnaryOp {
        match self {
            UnaryOp::Neg => UnaryOp::Neg,
            UnaryOp::Not => UnaryOp::Not,
        }
    }
}

impl PartialEq for UnaryOp {
    fn eq(&self, other: &UnaryOp) -> bool {
        match (self, other) {
            (UnaryOp::Neg, UnaryOp::Neg) => true,
            (UnaryOp::Not, UnaryOp::Not) => true,
            (UnaryOp::Neg, UnaryOp::Not) => false,
            (UnaryOp::Not, UnaryOp::Neg) => false,
        }
    }
}

// ============================================================
// Field Expressions
// ============================================================

/// A field in a struct expression.
pub struct FieldExpr {
    /// Field index.
    pub field_idx: u32,
    /// Field value.
    pub value: Expr,
}

impl Clone for FieldExpr {
    fn clone(&self) -> FieldExpr {
        FieldExpr {
            field_idx: self.field_idx,
            value: self.value.clone(),
        }
    }
}

/// A field in an anonymous record expression.
pub struct RecordFieldExpr {
    /// Field name.
    pub name: String,
    /// Field value.
    pub value: Expr,
}

impl Clone for RecordFieldExpr {
    fn clone(&self) -> RecordFieldExpr {
        RecordFieldExpr {
            name: self.name.clone(),
            value: self.value.clone(),
        }
    }
}

// ============================================================
// Statements
// ============================================================

/// A statement in a block.
pub enum Stmt {
    /// Let binding: `let x = e;`
    Let {
        local_id: LocalId,
        init: Option<Expr>,
    },
    /// Expression statement: `e;`
    Expr(Expr),
    /// Item declaration (nested function, etc.)
    Item(DefId),
}

impl Clone for Stmt {
    fn clone(&self) -> Stmt {
        match self {
            Stmt::Let { local_id, init } => Stmt::Let {
                local_id: local_id.clone(),
                init: init.clone(),
            },
            Stmt::Expr(expr) => Stmt::Expr(expr.clone()),
            Stmt::Item(id) => Stmt::Item(id.clone()),
        }
    }
}

// ============================================================
// Match Arms
// ============================================================

/// A match arm.
pub struct MatchArm {
    /// The pattern to match.
    pub pattern: Pattern,
    /// Optional guard: `if cond`
    pub guard: Option<Expr>,
    /// The body expression.
    pub body: Expr,
}

impl Clone for MatchArm {
    fn clone(&self) -> MatchArm {
        MatchArm {
            pattern: self.pattern.clone(),
            guard: self.guard.clone(),
            body: self.body.clone(),
        }
    }
}

// ============================================================
// Patterns
// ============================================================

/// A pattern in HIR.
pub struct Pattern {
    /// The pattern kind.
    pub kind: PatternKind,
    /// The type this pattern matches.
    pub ty: Type,
    /// Source location.
    pub span: Span,
}

impl Clone for Pattern {
    fn clone(&self) -> Pattern {
        Pattern {
            kind: self.kind.clone(),
            ty: self.ty.clone(),
            span: self.span.clone(),
        }
    }
}

/// The kind of a pattern.
pub enum PatternKind {
    /// Wildcard: `_`
    Wildcard,

    /// Binding: `x` or `mut x`
    Binding {
        local_id: LocalId,
        mutable: bool,
        subpattern: Option<Box<Pattern>>,
    },

    /// Literal: `42`, `true`
    Literal(LiteralValue),

    /// Variant: `Some(x)`
    Variant {
        def_id: DefId,
        variant_idx: u32,
        fields: [Pattern],
    },

    /// Struct: `Point { x, y }`
    Struct {
        def_id: DefId,
        fields: [FieldPattern],
    },

    /// Tuple: `(a, b)`
    Tuple([Pattern]),

    /// Slice: `[first, .., last]`
    Slice {
        prefix: [Pattern],
        slice: Option<Box<Pattern>>,
        suffix: [Pattern],
    },

    /// Or pattern: `A | B`
    Or([Pattern]),

    /// Reference: `&x`
    Ref {
        mutable: bool,
        inner: Box<Pattern>,
    },

    /// Range: `0..10`, `'a'..='z'`
    Range {
        start: Option<Box<Pattern>>,
        end: Option<Box<Pattern>>,
        inclusive: bool,
    },
}

impl Clone for PatternKind {
    fn clone(&self) -> PatternKind {
        match self {
            PatternKind::Wildcard => PatternKind::Wildcard,
            PatternKind::Binding { local_id, mutable, subpattern } => PatternKind::Binding {
                local_id: local_id.clone(),
                mutable: *mutable,
                subpattern: subpattern.clone(),
            },
            PatternKind::Literal(lit) => PatternKind::Literal(lit.clone()),
            PatternKind::Variant { def_id, variant_idx, fields } => PatternKind::Variant {
                def_id: def_id.clone(),
                variant_idx: *variant_idx,
                fields: fields.clone(),
            },
            PatternKind::Struct { def_id, fields } => PatternKind::Struct {
                def_id: def_id.clone(),
                fields: fields.clone(),
            },
            PatternKind::Tuple(patterns) => PatternKind::Tuple(patterns.clone()),
            PatternKind::Slice { prefix, slice, suffix } => PatternKind::Slice {
                prefix: prefix.clone(),
                slice: slice.clone(),
                suffix: suffix.clone(),
            },
            PatternKind::Or(patterns) => PatternKind::Or(patterns.clone()),
            PatternKind::Ref { mutable, inner } => PatternKind::Ref {
                mutable: *mutable,
                inner: inner.clone(),
            },
            PatternKind::Range { start, end, inclusive } => PatternKind::Range {
                start: start.clone(),
                end: end.clone(),
                inclusive: *inclusive,
            },
        }
    }
}

/// A field pattern in a struct pattern.
pub struct FieldPattern {
    /// Field index.
    pub field_idx: u32,
    /// The pattern for this field.
    pub pattern: Pattern,
}

impl Clone for FieldPattern {
    fn clone(&self) -> FieldPattern {
        FieldPattern {
            field_idx: self.field_idx,
            pattern: self.pattern.clone(),
        }
    }
}

// ============================================================
// Captures
// ============================================================

/// A captured variable in a closure.
pub struct Capture {
    /// The local being captured.
    pub local_id: LocalId,
    /// Whether captured by move or by reference.
    pub by_move: bool,
}

impl Clone for Capture {
    fn clone(&self) -> Capture {
        Capture {
            local_id: self.local_id.clone(),
            by_move: self.by_move,
        }
    }
}

// ============================================================
// Inline Handler
// ============================================================

/// An inline operation handler clause.
///
/// Used in `try { ... } with { Effect::op(x) => { ... } }` expressions.
pub struct InlineOpHandler {
    /// The effect being handled.
    pub effect_id: DefId,
    /// The operation name.
    pub op_name: String,
    /// Parameter local IDs.
    pub params: [LocalId],
    /// Parameter types.
    pub param_types: [Type],
    /// Return type of the operation.
    pub return_type: Type,
    /// The handler body.
    pub body: Expr,
}

impl Clone for InlineOpHandler {
    fn clone(&self) -> InlineOpHandler {
        InlineOpHandler {
            effect_id: self.effect_id.clone(),
            op_name: self.op_name.clone(),
            params: self.params.clone(),
            param_types: self.param_types.clone(),
            return_type: self.return_type.clone(),
            body: self.body.clone(),
        }
    }
}

// ============================================================
// Tests
// ============================================================

#[test]
fn test_local_id() {
    let local = LocalId::new(5);
    assert!(local.index() == 5);
}

#[test]
fn test_literal_value() {
    let int_lit = LiteralValue::Int(42);
    let int_lit2 = LiteralValue::Int(42);
    let int_lit3 = LiteralValue::Int(99);

    assert!(int_lit.eq(&int_lit2));
    assert!(!int_lit.eq(&int_lit3));
}

#[test]
fn test_binop() {
    let add = BinOp::Add;
    let add2 = BinOp::Add;
    let sub = BinOp::Sub;

    assert!(add.eq(&add2));
    assert!(!add.eq(&sub));
}

#[test]
fn test_unary_op() {
    let neg = UnaryOp::Neg;
    let not = UnaryOp::Not;

    assert!(neg.eq(&UnaryOp::Neg));
    assert!(!neg.eq(&not));
}

#[test]
fn test_expr_error() {
    let span = Span::new(0, 10);
    let err = Expr::error(span);

    assert!(err.is_error());
}

#[test]
fn test_pattern_wildcard() {
    let span = Span::new(0, 1);
    let pat = Pattern {
        kind: PatternKind::Wildcard,
        ty: Type::i32(),
        span,
    };

    // Verify clone works
    let cloned = pat.clone();
    assert!(matches!(cloned.kind, PatternKind::Wildcard));
}
