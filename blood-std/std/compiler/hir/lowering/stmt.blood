//! Statement Lowering
//!
//! This module handles lowering AST statements to HIR statements.
//! Statements are the building blocks of blocks and function bodies.

module std.compiler.hir.lowering.stmt;

use std.result.Result;
use std.option.Option;

use crate.compiler.ast.{
    Stmt as AstStmt, StmtKind as AstStmtKind,
    Expr as AstExpr, Pattern as AstPattern,
    Ident, Span as AstSpan,
}

use crate.compiler.hir.{
    Stmt as HirStmt,
    Expr as HirExpr, Pattern as HirPattern,
    Local, LocalId, Span as HirSpan,
}

use crate.compiler.hir.lowering.{AstLowering, LoweringError}
use crate.compiler.hir.lowering.expr.lower_expr;
use crate.compiler.hir.lowering.pattern.lower_pattern;
use crate.compiler.hir.lowering.item.lower_type;
use crate.compiler.typeck.types.Type;

// ============================================================================
// Statement Lowering
// ============================================================================

/// Lower an AST statement to HIR statement.
pub fn lower_stmt(ctx: &mut AstLowering, stmt: &AstStmt) -> Result<HirStmt, LoweringError> {
    let span = ctx.lower_span(&stmt.span);

    match &stmt.kind {
        AstStmtKind::Let { pattern, ty, init } => {
            let hir_pattern = lower_pattern(ctx, pattern)?;

            let hir_ty = match ty {
                Some(t) => Some(lower_type(ctx, t)?),
                None => None,
            };

            // Let statements must have an initializer in HIR
            // (uninitialized bindings are handled differently)
            let hir_init = match init {
                Some(e) => lower_expr(ctx, e)?,
                None => {
                    // Create a default/undefined expression
                    HirExpr::new(
                        crate.compiler.hir::ExprKind::Default,
                        Type::infer(),
                        span.clone(),
                    )
                }
            };

            // Register bindings in the pattern as locals
            register_pattern_bindings(ctx, &hir_pattern, &hir_ty, &span)?;

            Ok(HirStmt::Let {
                pattern: hir_pattern,
                ty: hir_ty,
                init: hir_init,
            })
        }

        AstStmtKind::Expr(expr) => {
            let hir_expr = lower_expr(ctx, expr)?;
            Ok(HirStmt::Expr(hir_expr))
        }

        AstStmtKind::Semi(expr) => {
            let hir_expr = lower_expr(ctx, expr)?;
            Ok(HirStmt::Semi(hir_expr))
        }

        AstStmtKind::Item(decl) => {
            // Item declarations in blocks (local functions, structs, etc.)
            // These are lowered as items but scoped to the block
            // For now, error as unsupported
            Err(LoweringError::invalid_desugar(
                "local item".to_string(),
                "local item declarations not yet supported in HIR lowering".to_string(),
                span,
            ))
        }

        AstStmtKind::Empty => {
            // Empty statements become unit expressions
            Ok(HirStmt::Semi(HirExpr::new(
                crate.compiler.hir::ExprKind::Tuple([]),
                Type::unit(),
                span,
            )))
        }
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Register pattern bindings as locals in the current body.
fn register_pattern_bindings(
    ctx: &mut AstLowering,
    pattern: &HirPattern,
    ty: &Option<Type>,
    span: &HirSpan,
) -> Result<(), LoweringError> {
    match &pattern.kind {
        crate.compiler.hir::PatternKind::Binding { name, local_id, mutable, subpattern } => {
            // Local already allocated during pattern lowering
            // Add to current body's locals list
            let local_ty = match ty {
                Some(t) => t.clone(),
                None => Type::infer(),
            };

            // Note: The local was already registered in ctx.node_to_local
            // during pattern lowering. Here we just verify it exists.

            // Process subpattern if any
            if let Some(sub) = subpattern {
                register_pattern_bindings(ctx, sub, ty, span)?;
            }
        }

        crate.compiler.hir::PatternKind::Tuple(patterns) => {
            for p in patterns {
                register_pattern_bindings(ctx, p, &None, span)?;
            }
        }

        crate.compiler.hir::PatternKind::Struct { def_id: _, fields, rest: _ } => {
            for field in fields {
                register_pattern_bindings(ctx, &field.pattern, &None, span)?;
            }
        }

        crate.compiler.hir::PatternKind::Variant { def_id: _, variant_idx: _, fields } => {
            for p in fields {
                register_pattern_bindings(ctx, p, &None, span)?;
            }
        }

        crate.compiler.hir::PatternKind::Ref { mutable: _, pattern: inner } => {
            register_pattern_bindings(ctx, inner, &None, span)?;
        }

        crate.compiler.hir::PatternKind::Box(inner) => {
            register_pattern_bindings(ctx, inner, &None, span)?;
        }

        crate.compiler.hir::PatternKind::Slice { prefix, rest, suffix } => {
            for p in prefix {
                register_pattern_bindings(ctx, p, &None, span)?;
            }
            if let Some(r) = rest {
                register_pattern_bindings(ctx, r, &None, span)?;
            }
            for p in suffix {
                register_pattern_bindings(ctx, p, &None, span)?;
            }
        }

        crate.compiler.hir::PatternKind::Or(patterns) => {
            // All alternatives must bind the same names
            for p in patterns {
                register_pattern_bindings(ctx, p, &None, span)?;
            }
        }

        // These patterns don't introduce bindings
        crate.compiler.hir::PatternKind::Wildcard => {}
        crate.compiler.hir::PatternKind::Literal(_) => {}
        crate.compiler.hir::PatternKind::Constant(_) => {}
        crate.compiler.hir::PatternKind::Range { .. } => {}
        crate.compiler.hir::PatternKind::Rest => {}
        crate.compiler.hir::PatternKind::Error => {}
    }

    Ok(())
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_lower_expr_stmt() {
    use crate.compiler.typeck::TypeCheckResult;
    use crate.compiler.ast::{NodeId, Span};
    use std.collections.HashMap;

    let types = TypeCheckResult::success(HashMap::new());
    let mut ctx = AstLowering::new(types);

    // Create a simple expression statement: 42;
    let ast_stmt = AstStmt {
        id: NodeId::new(1),
        kind: AstStmtKind::Semi(AstExpr {
            id: NodeId::new(2),
            kind: crate.compiler.ast::ExprKind::Literal(
                crate.compiler.ast::Literal::Integer(42, None)
            ),
            span: Span::dummy(),
        }),
        span: Span::dummy(),
    };

    let result = lower_stmt(&mut ctx, &ast_stmt);
    assert(result.is_ok());

    let hir_stmt = result.unwrap();
    match hir_stmt {
        HirStmt::Semi(_) => assert(true),
        _ => assert(false),
    }
}

#[test]
fn test_lower_let_stmt() {
    use crate.compiler.typeck::TypeCheckResult;
    use crate.compiler.ast::{NodeId, Span, Ident, PatternKind};
    use std.collections.HashMap;

    let types = TypeCheckResult::success(HashMap::new());
    let mut ctx = AstLowering::new(types);

    // Create: let x = 42;
    let ast_stmt = AstStmt {
        id: NodeId::new(1),
        kind: AstStmtKind::Let {
            pattern: AstPattern {
                id: NodeId::new(2),
                kind: PatternKind::Binding {
                    name: Ident::new("x".to_string(), Span::dummy()),
                    mutable: false,
                    subpattern: None,
                },
                span: Span::dummy(),
            },
            ty: None,
            init: Some(AstExpr {
                id: NodeId::new(3),
                kind: crate.compiler.ast::ExprKind::Literal(
                    crate.compiler.ast::Literal::Integer(42, None)
                ),
                span: Span::dummy(),
            }),
        },
        span: Span::dummy(),
    };

    let result = lower_stmt(&mut ctx, &ast_stmt);
    assert(result.is_ok());

    let hir_stmt = result.unwrap();
    match hir_stmt {
        HirStmt::Let { pattern, ty: _, init: _ } => {
            // Verify pattern is a binding
            match pattern.kind {
                crate.compiler.hir::PatternKind::Binding { name, .. } => {
                    assert(name == "x");
                }
                _ => assert(false),
            }
        }
        _ => assert(false),
    }
}

#[test]
fn test_lower_empty_stmt() {
    use crate.compiler.typeck::TypeCheckResult;
    use crate.compiler.ast::{NodeId, Span};
    use std.collections.HashMap;

    let types = TypeCheckResult::success(HashMap::new());
    let mut ctx = AstLowering::new(types);

    let ast_stmt = AstStmt {
        id: NodeId::new(1),
        kind: AstStmtKind::Empty,
        span: Span::dummy(),
    };

    let result = lower_stmt(&mut ctx, &ast_stmt);
    assert(result.is_ok());

    // Empty statements become Semi with unit expression
    let hir_stmt = result.unwrap();
    match hir_stmt {
        HirStmt::Semi(_) => assert(true),
        _ => assert(false),
    }
}
