//! Expression Lowering
//!
//! This module handles lowering AST expressions to HIR expressions.
//! The key responsibilities are:
//!
//! 1. **Desugaring**: Transform syntactic sugar to core constructs
//! 2. **Type attachment**: Every HIR expression gets its resolved type
//! 3. **Name resolution**: Paths become Local or Def references
//!
//! # Desugaring Rules
//!
//! ## For Loops
//! ```text
//! for pat in iter { body }
//! ↓
//! {
//!     let mut __iter = iter.into_iter();
//!     loop {
//!         match __iter.next() {
//!             Some(pat) => body,
//!             None => break,
//!         }
//!     }
//! }
//! ```
//!
//! ## If Let
//! ```text
//! if let pat = expr { a } else { b }
//! ↓
//! match expr {
//!     pat => a,
//!     _ => b,
//! }
//! ```
//!
//! ## While Let
//! ```text
//! while let pat = expr { body }
//! ↓
//! loop {
//!     match expr {
//!         pat => body,
//!         _ => break,
//!     }
//! }
//! ```
//!
//! ## Compound Assignment
//! ```text
//! x += y
//! ↓
//! x = x + y
//! ```

module std.compiler.hir.lowering.expr;

use std.result.Result;
use std.option.Option;
use std.collections.HashMap;

use crate.compiler.ast.{
    Expr as AstExpr, ExprKind as AstExprKind,
    Block as AstBlock, Stmt as AstStmt, StmtKind as AstStmtKind,
    Literal, BinOp as AstBinOp, UnaryOp as AstUnaryOp,
    Pattern as AstPattern, PatternKind as AstPatternKind,
    MatchArm as AstMatchArm, ClosureParam, CallArg,
    ExprPath, FieldAccess, ArrayExpr, RecordExprField,
    TryWithHandler, Ident, NodeId, Span as AstSpan,
    FunctionDecl,
};

use crate.compiler.hir.{
    Body, Local, LocalId, BodyId, LoopId,
    Expr as HirExpr, ExprKind as HirExprKind,
    Stmt as HirStmt,
    Pattern as HirPattern, PatternKind as HirPatternKind,
    MatchArm as HirMatchArm,
    BinOp as HirBinOp, UnaryOp as HirUnaryOp,
    LiteralValue as HirLiteral, Span as HirSpan,
    FieldExpr, RecordFieldExpr, Capture, InlineOpHandler,
};

use crate.compiler.hir.lowering.{AstLowering, LoweringError};
use crate.compiler.hir.lowering.pattern;
use crate.compiler.hir.lowering.stmt;
use crate.compiler.hir.lowering.item.lower_type;
use crate.compiler.typeck.types.{DefId, Type};

// ============================================================================
// Function Body Lowering
// ============================================================================

/// Lower a function body to HIR Body.
pub fn lower_function_body(
    ctx: &mut AstLowering,
    func: &FunctionDecl,
    block: &AstBlock,
) -> Result<Body, LoweringError> {
    let mut locals: [Local] = [];

    // Local 0 is the return place
    let return_id = ctx.alloc_local_id();
    let return_ty = match &func.return_type {
        Some(ty) => lower_type(ctx, ty)?,
        None => Type::unit(),
    };
    locals.push(Local {
        id: return_id,
        ty: return_ty.clone(),
        mutable: true,
        name: None,
        span: ctx.lower_span(&func.span),
    });

    // Add parameters as locals
    let mut param_count: usize = 0;
    let mut i: usize = 0;
    while i < func.params.len() {
        let param = &func.params[i];
        let param_id = ctx.alloc_local_id();
        let param_ty = lower_type(ctx, &param.ty)?;

        // Register in node_to_local for name resolution
        ctx.node_to_local.insert(param.id.id(), param_id.clone());

        locals.push(Local {
            id: param_id,
            ty: param_ty,
            mutable: param.mutable,
            name: Some(param.name.name.clone()),
            span: ctx.lower_span(&param.span),
        });
        param_count = param_count + 1;
        i = i + 1;
    };

    // Lower the block expression
    let expr = lower_block(ctx, block)?;

    Ok(Body {
        locals,
        param_count,
        expr,
        span: ctx.lower_span(&func.span),
    })
}

/// Lower a const/static initializer to HIR Body.
pub fn lower_const_body(
    ctx: &mut AstLowering,
    init: &AstExpr,
    ty: &Type,
) -> Result<Body, LoweringError> {
    let mut locals: [Local] = [];

    // Local 0 is the return place
    let return_id = ctx.alloc_local_id();
    locals.push(Local {
        id: return_id,
        ty: ty.clone(),
        mutable: true,
        name: None,
        span: ctx.lower_span(&init.span),
    });

    // Lower the initializer expression
    let expr = lower_expr(ctx, init)?;

    Ok(Body {
        locals,
        param_count: 0,
        expr,
        span: ctx.lower_span(&init.span),
    })
}

/// Lower a handler operation body.
pub fn lower_handler_op_body(
    ctx: &mut AstLowering,
    op: &crate.compiler.ast::HandlerOp,
) -> Result<Body, LoweringError> {
    let mut locals: [Local] = [];

    // Local 0 is the return place
    let return_id = ctx.alloc_local_id();
    let return_ty = match &op.return_type {
        Some(ty) => lower_type(ctx, ty)?,
        None => Type::unit(),
    };
    locals.push(Local {
        id: return_id,
        ty: return_ty,
        mutable: true,
        name: None,
        span: ctx.lower_span(&op.span),
    });

    // Add parameters
    let mut param_count: usize = 0;
    let mut i: usize = 0;
    while i < op.params.len() {
        let param = &op.params[i];
        let param_id = ctx.alloc_local_id();
        let param_ty = lower_type(ctx, &param.ty)?;

        ctx.node_to_local.insert(param.id.id(), param_id.clone());

        locals.push(Local {
            id: param_id,
            ty: param_ty,
            mutable: false,
            name: Some(param.name.name.clone()),
            span: ctx.lower_span(&param.span),
        });
        param_count = param_count + 1;
        i = i + 1;
    };

    // Add resume continuation parameter
    let resume_id = ctx.alloc_local_id();
    locals.push(Local {
        id: resume_id,
        ty: Type::continuation(),
        mutable: false,
        name: Some("__resume".to_string()),
        span: ctx.lower_span(&op.span),
    });
    param_count = param_count + 1;

    // Lower body
    let expr = lower_block(ctx, &op.body)?;

    Ok(Body {
        locals,
        param_count,
        expr,
        span: ctx.lower_span(&op.span),
    })
}

/// Lower a return clause body.
pub fn lower_return_clause_body(
    ctx: &mut AstLowering,
    rc: &crate.compiler.ast::ReturnClause,
) -> Result<Body, LoweringError> {
    let mut locals: [Local] = [];

    // Local 0 is the return place
    let return_id = ctx.alloc_local_id();
    let return_ty = Type::infer(); // Return type determined by handler
    locals.push(Local {
        id: return_id,
        ty: return_ty,
        mutable: true,
        name: None,
        span: ctx.lower_span(&rc.span),
    });

    // Add the return value parameter
    let param_id = ctx.alloc_local_id();
    ctx.node_to_local.insert(rc.param.id.id(), param_id.clone());
    locals.push(Local {
        id: param_id,
        ty: Type::infer(),
        mutable: false,
        name: Some(rc.param.name.clone()),
        span: ctx.lower_span(&rc.span),
    });

    // Lower body
    let expr = lower_block(ctx, &rc.body)?;

    Ok(Body {
        locals,
        param_count: 1,
        expr,
        span: ctx.lower_span(&rc.span),
    })
}

// ============================================================================
// Expression Lowering
// ============================================================================

/// Lower an AST expression to HIR expression.
pub fn lower_expr(ctx: &mut AstLowering, expr: &AstExpr) -> Result<HirExpr, LoweringError> {
    let span = ctx.lower_span(&expr.span);

    // Get the type from type checking results
    let ty = get_expr_type(ctx, expr);

    let kind = match &expr.kind {
        AstExprKind::Literal(lit) => {
            HirExprKind::Literal(lower_literal(lit))
        }

        AstExprKind::Path(path) => {
            lower_path(ctx, path)?
        }

        AstExprKind::Binary { op, left, right } => {
            HirExprKind::Binary {
                op: lower_binop(op),
                left: Box::new(lower_expr(ctx, left)?),
                right: Box::new(lower_expr(ctx, right)?),
            }
        }

        AstExprKind::Unary { op, operand } => {
            HirExprKind::Unary {
                op: lower_unaryop(op),
                operand: Box::new(lower_expr(ctx, operand)?),
            }
        }

        AstExprKind::Call { callee, args } => {
            let hir_callee = lower_expr(ctx, callee)?;
            let mut hir_args: [HirExpr] = [];
            let mut i: usize = 0;
            while i < args.len() {
                let arg = lower_expr(ctx, &args[i].value)?;
                hir_args.push(arg);
                i = i + 1;
            }
            HirExprKind::Call {
                callee: Box::new(hir_callee),
                args: hir_args,
            }
        }

        AstExprKind::MethodCall { receiver, method, type_args: _, args } => {
            let hir_receiver = lower_expr(ctx, receiver)?;
            // Method resolution happens during type checking
            // For now, use a placeholder DefId
            let method_def_id = ctx.alloc_def_id();

            let mut hir_args: [HirExpr] = [];
            let mut i: usize = 0;
            while i < args.len() {
                let arg = lower_expr(ctx, &args[i].value)?;
                hir_args.push(arg);
                i = i + 1;
            }

            HirExprKind::MethodCall {
                receiver: Box::new(hir_receiver),
                method: method_def_id,
                args: hir_args,
            }
        }

        AstExprKind::Field { base, field } => {
            let hir_base = lower_expr(ctx, base)?;
            let field_idx = match field {
                FieldAccess::Named(name) => {
                    // Field resolution to index happens during type checking
                    // For now, use 0 as placeholder
                    0u32
                }
                FieldAccess::Tuple(idx) => *idx,
            };
            HirExprKind::Field {
                base: Box::new(hir_base),
                field_idx,
            }
        }

        AstExprKind::Index { base, index } => {
            HirExprKind::Index {
                base: Box::new(lower_expr(ctx, base)?),
                index: Box::new(lower_expr(ctx, index)?),
            }
        }

        AstExprKind::Tuple(elements) => {
            let mut hir_elements: [HirExpr] = [];
            let mut i: usize = 0;
            while i < elements.len() {
                let elem = lower_expr(ctx, &elements[i])?;
                hir_elements.push(elem);
                i = i + 1;
            }
            HirExprKind::Tuple(hir_elements)
        }

        AstExprKind::Array(arr) => {
            match arr {
                ArrayExpr::List(elements) => {
                    let mut hir_elements: [HirExpr] = [];
                    let mut i: usize = 0;
                    while i < elements.len() {
                        let elem = lower_expr(ctx, &elements[i])?;
                        hir_elements.push(elem);
                        i = i + 1;
                    }
                    HirExprKind::Array(hir_elements)
                }
                ArrayExpr::Repeat { value, count } => {
                    HirExprKind::Repeat {
                        value: Box::new(lower_expr(ctx, value)?),
                        count: *count,
                    }
                }
            }
        }

        AstExprKind::Record { path, fields, base } => {
            // Determine if this is a struct construction or anonymous record
            match path {
                Some(p) => {
                    let def_id = ctx.alloc_def_id(); // Placeholder
                    let hir_fields = lower_record_fields(ctx, fields)?;
                    let hir_base = match base {
                        Some(b) => Some(Box::new(lower_expr(ctx, b)?)),
                        None => None,
                    };
                    HirExprKind::Struct {
                        def_id,
                        fields: hir_fields,
                        base: hir_base,
                    }
                };
                None => {
                    let hir_fields = lower_anonymous_record_fields(ctx, fields)?;
                    HirExprKind::Record { fields: hir_fields }
                }
            }
        }

        AstExprKind::Range { start, end, inclusive } => {
            HirExprKind::Range {
                start: match start {
                    Some(s) => Some(Box::new(lower_expr(ctx, s)?)),
                    None => None,
                },
                end: match end {
                    Some(e) => Some(Box::new(lower_expr(ctx, e)?)),
                    None => None,
                },
                inclusive: *inclusive,
            }
        }

        AstExprKind::Cast { expr: inner, ty: target } => {
            let hir_inner = lower_expr(ctx, inner)?;
            let hir_ty = lower_type(ctx, target)?;
            HirExprKind::Cast {
                expr: Box::new(hir_inner),
                target_ty: hir_ty,
            }
        }

        AstExprKind::Assign { target, value } => {
            HirExprKind::Assign {
                target: Box::new(lower_expr(ctx, target)?),
                value: Box::new(lower_expr(ctx, value)?),
            }
        }

        // Desugar compound assignment: x += y -> x = x + y
        AstExprKind::AssignOp { op, target, value } => {
            let hir_target = lower_expr(ctx, target)?;
            let hir_value = lower_expr(ctx, value)?;
            let binary = HirExpr::new(
                HirExprKind::Binary {
                    op: lower_binop(op),
                    left: Box::new(hir_target.clone()),
                    right: Box::new(hir_value),
                },
                ty.clone(),
                span.clone(),
            );
            HirExprKind::Assign {
                target: Box::new(hir_target),
                value: Box::new(binary),
            }
        }

        AstExprKind::Block(block) => {
            return Ok(lower_block(ctx, block)?);
        }

        AstExprKind::If { condition, then_branch, else_branch } => {
            let hir_cond = lower_expr(ctx, condition)?;
            let hir_then = lower_block(ctx, then_branch)?;
            let hir_else = match else_branch {
                Some(eb) => Some(Box::new(lower_else_branch(ctx, eb)?)),
                None => None,
            };
            HirExprKind::If {
                condition: Box::new(hir_cond),
                then_branch: Box::new(hir_then),
                else_branch: hir_else,
            }
        }

        // Desugar if-let to match
        AstExprKind::IfLet { pattern, scrutinee, then_branch, else_branch } => {
            lower_if_let(ctx, pattern, scrutinee, then_branch, else_branch, &span)?
        }

        AstExprKind::Match { scrutinee, arms } => {
            let hir_scrutinee = lower_expr(ctx, scrutinee)?;
            let hir_arms = lower_match_arms(ctx, arms)?;
            HirExprKind::Match {
                scrutinee: Box::new(hir_scrutinee),
                arms: hir_arms,
            }
        }

        AstExprKind::Loop { label, body } => {
            let loop_id = ctx.next_loop_id;
            ctx.next_loop_id = ctx.next_loop_id + 1;
            ctx.loop_stack.push((label.as_ref().map(|l| l.name.clone()), loop_id));

            let hir_body = lower_block(ctx, body)?;
            ctx.loop_stack.pop();

            HirExprKind::Loop {
                body: Box::new(hir_body),
                label: Some(LoopId::new(loop_id)),
            }
        }

        AstExprKind::While { label, condition, body } => {
            let loop_id = ctx.next_loop_id;
            ctx.next_loop_id = ctx.next_loop_id + 1;
            ctx.loop_stack.push((label.as_ref().map(|l| l.name.clone()), loop_id));

            let hir_cond = lower_expr(ctx, condition)?;
            let hir_body = lower_block(ctx, body)?;
            ctx.loop_stack.pop();

            HirExprKind::While {
                condition: Box::new(hir_cond),
                body: Box::new(hir_body),
                label: Some(LoopId::new(loop_id)),
            }
        }

        // Desugar while-let to loop + match
        AstExprKind::WhileLet { label, pattern, scrutinee, body } => {
            lower_while_let(ctx, label, pattern, scrutinee, body, &span)?
        }

        // Desugar for loop
        AstExprKind::For { label, pattern, iter, body } => {
            lower_for_loop(ctx, label, pattern, iter, body, &span)?
        }

        AstExprKind::Return(value) => {
            let hir_value = match value {
                Some(v) => Some(Box::new(lower_expr(ctx, v)?)),
                None => None,
            };
            HirExprKind::Return(hir_value)
        }

        AstExprKind::Break { label, value } => {
            let loop_id = resolve_loop_label(ctx, label)?;
            let hir_value = match value {
                Some(v) => Some(Box::new(lower_expr(ctx, v)?)),
                None => None,
            };
            HirExprKind::Break {
                label: loop_id,
                value: hir_value,
            }
        }

        AstExprKind::Continue { label } => {
            let loop_id = resolve_loop_label(ctx, label)?;
            HirExprKind::Continue { label: loop_id }
        }

        AstExprKind::Closure { is_move: _, params, return_type, effects: _, body } => {
            // Create a new body for the closure
            let body_id = ctx.alloc_body_id();
            let closure_body = lower_closure_body(ctx, params, return_type, body)?;
            ctx.crate_.insert_body(body_id.clone(), closure_body);

            // Capture analysis happens during type checking
            // For now, use empty captures
            let captures: [Capture] = [];

            HirExprKind::Closure {
                body_id,
                captures,
            }
        }

        AstExprKind::WithHandle { handler, body } => {
            let hir_handler = lower_expr(ctx, handler)?;
            // Create a body for the handled expression
            let body_id = ctx.alloc_body_id();
            ctx.reset_local_ids();
            ctx.current_body_id = Some(body_id.clone());

            let hir_body = lower_expr(ctx, body)?;
            let body_struct = Body {
                locals: [],
                param_count: 0,
                expr: hir_body,
                span: ctx.lower_span(&body.span),
            };
            ctx.crate_.insert_body(body_id.clone(), body_struct);
            ctx.current_body_id = None;

            // Handler instance ID is resolved during type checking
            let handler_instance = ctx.alloc_def_id();

            HirExprKind::Handle {
                body: body_id,
                handler_id: ctx.alloc_def_id(),
                handler_instance,
            }
        }

        AstExprKind::Perform { effect, operation, args } => {
            // Effect and operation resolution happens during type checking
            let effect_id = ctx.alloc_def_id();
            let op_index = 0u32; // Placeholder

            let mut hir_args: [HirExpr] = [];
            let mut i: usize = 0;
            while i < args.len() {
                let arg = lower_expr(ctx, &args[i])?;
                hir_args.push(arg);
                i = i + 1;
            }

            HirExprKind::Perform {
                effect_id,
                op_index,
                args: hir_args,
            }
        }

        AstExprKind::Resume(value) => {
            HirExprKind::Resume {
                value: Box::new(lower_expr(ctx, value)?),
            }
        }

        AstExprKind::TryWith { body, handlers } => {
            lower_try_with(ctx, body, handlers, &span)?
        }

        AstExprKind::Unsafe(block) => {
            HirExprKind::Unsafe(Box::new(lower_block(ctx, block)?))
        }

        AstExprKind::Region { name: _, body } => {
            // Region desugaring - for now, just lower the body
            return Ok(lower_block(ctx, body)?);
        }

        // Remove parentheses (they don't affect semantics)
        AstExprKind::Paren(inner) => {
            return lower_expr(ctx, inner);
        }

        AstExprKind::Default => {
            HirExprKind::Default
        }

        AstExprKind::MacroCall { path: _, kind: _ } => {
            // Macro calls should be expanded before lowering
            return Err(LoweringError::invalid_desugar(
                "macro".to_string(),
                "macro calls should be expanded before HIR lowering".to_string(),
                span,
            ));
        }

        AstExprKind::Error => {
            HirExprKind::Error
        }
    };

    Ok(HirExpr::new(kind, ty, span))
}

// ============================================================================
// Block Lowering
// ============================================================================

/// Lower a block expression.
pub fn lower_block(ctx: &mut AstLowering, block: &AstBlock) -> Result<HirExpr, LoweringError> {
    let span = ctx.lower_span(&block.span);

    let mut stmts: [HirStmt] = [];
    let mut i: usize = 0;
    while i < block.stmts.len() {
        let hir_stmt = stmt::lower_stmt(ctx, &block.stmts[i])?;
        stmts.push(hir_stmt);
        i = i + 1;
    };

    let expr = match &block.expr {
        Some(e) => Some(Box::new(lower_expr(ctx, e)?)),
        None => None,
    };

    // Determine block type from expression or unit
    let ty = match &expr {
        Some(e) => e.ty.clone(),
        None => Type::unit(),
    };

    Ok(HirExpr::new(
        HirExprKind::Block { stmts, expr },
        ty,
        span,
    ))
}

// ============================================================================
// Desugaring Functions
// ============================================================================

/// Desugar if-let to match expression.
fn lower_if_let(
    ctx: &mut AstLowering,
    pattern: &AstPattern,
    scrutinee: &AstExpr,
    then_branch: &AstBlock,
    else_branch: &Option<crate.compiler.ast::ElseBranch>,
    span: &HirSpan,
) -> Result<HirExprKind, LoweringError> {
    // if let pat = scrutinee { then } else { else }
    // =>
    // match scrutinee {
    //     pat => then,
    //     _ => else,
    // }

    let hir_scrutinee = lower_expr(ctx, scrutinee)?;
    let hir_pattern = pattern::lower_pattern(ctx, pattern)?;
    let hir_then = lower_block(ctx, then_branch)?;

    let match_arm = HirMatchArm {
        pattern: hir_pattern,
        guard: None,
        body: hir_then,
        span: span.clone(),
    };

    let wildcard_arm = match else_branch {
        Some(eb) => {
            let else_body = lower_else_branch(ctx, eb)?;
            HirMatchArm {
                pattern: HirPattern::new(HirPatternKind::Wildcard, Type::infer(), span.clone()),
                guard: None,
                body: else_body,
                span: span.clone(),
            }
        };
        None => {
            // No else branch - wildcard returns unit
            HirMatchArm {
                pattern: HirPattern::new(HirPatternKind::Wildcard, Type::infer(), span.clone()),
                guard: None,
                body: HirExpr::new(HirExprKind::Tuple([]), Type::unit(), span.clone()),
                span: span.clone(),
            }
        }
    };

    Ok(HirExprKind::Match {
        scrutinee: Box::new(hir_scrutinee),
        arms: [match_arm, wildcard_arm],
    })
}

/// Desugar while-let to loop + match.
fn lower_while_let(
    ctx: &mut AstLowering,
    label: &Option<Ident>,
    pattern: &AstPattern,
    scrutinee: &AstExpr,
    body: &AstBlock,
    span: &HirSpan,
) -> Result<HirExprKind, LoweringError> {
    // while let pat = scrutinee { body }
    // =>
    // loop {
    //     match scrutinee {
    //         pat => body,
    //         _ => break,
    //     }
    // }

    let loop_id = ctx.next_loop_id;
    ctx.next_loop_id = ctx.next_loop_id + 1;
    ctx.loop_stack.push((label.as_ref().map(|l| l.name.clone()), loop_id));

    let hir_scrutinee = lower_expr(ctx, scrutinee)?;
    let hir_pattern = pattern::lower_pattern(ctx, pattern)?;
    let hir_body = lower_block(ctx, body)?;

    ctx.loop_stack.pop();

    let match_arm = HirMatchArm {
        pattern: hir_pattern,
        guard: None,
        body: hir_body,
        span: span.clone(),
    };

    let break_arm = HirMatchArm {
        pattern: HirPattern::new(HirPatternKind::Wildcard, Type::infer(), span.clone()),
        guard: None,
        body: HirExpr::new(
            HirExprKind::Break {
                label: Some(LoopId::new(loop_id)),
                value: None,
            },
            Type::never(),
            span.clone(),
        ),
        span: span.clone(),
    };

    let match_expr = HirExpr::new(
        HirExprKind::Match {
            scrutinee: Box::new(hir_scrutinee),
            arms: [match_arm, break_arm],
        },
        Type::unit(),
        span.clone(),
    );

    Ok(HirExprKind::Loop {
        body: Box::new(match_expr),
        label: Some(LoopId::new(loop_id)),
    })
}

/// Desugar for loop.
fn lower_for_loop(
    ctx: &mut AstLowering,
    label: &Option<Ident>,
    pattern: &AstPattern,
    iter: &AstExpr,
    body: &AstBlock,
    span: &HirSpan,
) -> Result<HirExprKind, LoweringError> {
    // for pat in iter { body }
    // =>
    // {
    //     let mut __iter = IntoIterator::into_iter(iter);
    //     loop {
    //         match Iterator::next(&mut __iter) {
    //             Some(pat) => body,
    //             None => break,
    //         }
    //     }
    // }

    let loop_id = ctx.next_loop_id;
    ctx.next_loop_id = ctx.next_loop_id + 1;
    ctx.loop_stack.push((label.as_ref().map(|l| l.name.clone()), loop_id));

    // Create iterator local
    let iter_local_id = ctx.alloc_local_id();

    // Lower the iterator expression
    let hir_iter = lower_expr(ctx, iter)?;

    // Lower pattern and body
    let hir_pattern = pattern::lower_pattern(ctx, pattern)?;
    let hir_body = lower_block(ctx, body)?;

    ctx.loop_stack.pop();

    // Build the Some(pat) arm
    let some_pattern = HirPattern::new(
        HirPatternKind::Variant {
            def_id: DefId::new(0), // Option::Some - placeholder
            variant_idx: 0,
            fields: [hir_pattern],
        },
        Type::infer(),
        span.clone(),
    );

    let some_arm = HirMatchArm {
        pattern: some_pattern,
        guard: None,
        body: hir_body,
        span: span.clone(),
    };

    // Build the None arm
    let none_pattern = HirPattern::new(
        HirPatternKind::Variant {
            def_id: DefId::new(0), // Option::None - placeholder
            variant_idx: 1,
            fields: [],
        },
        Type::infer(),
        span.clone(),
    );

    let break_arm = HirMatchArm {
        pattern: none_pattern,
        guard: None,
        body: HirExpr::new(
            HirExprKind::Break {
                label: Some(LoopId::new(loop_id)),
                value: None,
            },
            Type::never(),
            span.clone(),
        ),
        span: span.clone(),
    };

    // Build the __iter.next() call
    let iter_ref = HirExpr::new(
        HirExprKind::Local(iter_local_id.clone()),
        Type::infer(),
        span.clone(),
    );

    let next_call = HirExpr::new(
        HirExprKind::MethodCall {
            receiver: Box::new(iter_ref),
            method: DefId::new(0), // Iterator::next - placeholder
            args: [],
        },
        Type::infer(),
        span.clone(),
    );

    // Build match on next() result
    let match_expr = HirExpr::new(
        HirExprKind::Match {
            scrutinee: Box::new(next_call),
            arms: [some_arm, break_arm],
        },
        Type::unit(),
        span.clone(),
    );

    // Build the loop
    let loop_expr = HirExpr::new(
        HirExprKind::Loop {
            body: Box::new(match_expr),
            label: Some(LoopId::new(loop_id)),
        },
        Type::unit(),
        span.clone(),
    );

    // Build let __iter = into_iter(iter);
    let into_iter_call = HirExpr::new(
        HirExprKind::MethodCall {
            receiver: Box::new(hir_iter),
            method: DefId::new(0), // IntoIterator::into_iter - placeholder
            args: [],
        },
        Type::infer(),
        span.clone(),
    );

    let iter_pattern = HirPattern::new(
        HirPatternKind::Binding {
            name: "__iter".to_string(),
            local_id: iter_local_id,
            mutable: true,
            subpattern: None,
        },
        Type::infer(),
        span.clone(),
    );

    let let_stmt = HirStmt::Let {
        pattern: iter_pattern,
        ty: None,
        init: into_iter_call,
    };

    // Build the block
    Ok(HirExprKind::Block {
        stmts: [let_stmt],
        expr: Some(Box::new(loop_expr)),
    })
}

/// Lower try-with to inline handle.
fn lower_try_with(
    ctx: &mut AstLowering,
    body: &AstBlock,
    handlers: &[TryWithHandler],
    span: &HirSpan,
) -> Result<HirExprKind, LoweringError> {
    let hir_body = lower_block(ctx, body)?;

    let mut hir_handlers: [InlineOpHandler] = [];
    let mut i: usize = 0;
    while i < handlers.len() {
        let h = &handlers[i];

        // Create body for handler
        let body_id = ctx.alloc_body_id();
        ctx.reset_local_ids();
        ctx.current_body_id = Some(body_id.clone());

        let handler_body = lower_block(ctx, &h.body)?;
        let handler_body_struct = Body {
            locals: [], // TODO: add params
            param_count: 0,
            expr: handler_body,
            span: span.clone(),
        };
        ctx.crate_.insert_body(body_id.clone(), handler_body_struct);
        ctx.current_body_id = None;

        hir_handlers.push(InlineOpHandler {
            effect_id: ctx.alloc_def_id(), // Placeholder
            op_index: 0, // Placeholder
            params: [], // TODO: lower params
            body_id,
            span: span.clone(),
        });

        i = i + 1;
    };

    Ok(HirExprKind::InlineHandle {
        body: Box::new(hir_body),
        handlers: hir_handlers,
    })
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Get the type for an expression from type checking results.
fn get_expr_type(ctx: &AstLowering, _expr: &AstExpr) -> Type {
    // In a full implementation, this would look up the type in type check results
    // For now, return infer type to be filled in later
    Type::infer()
}

/// Lower a path expression to Local or Def.
fn lower_path(ctx: &mut AstLowering, path: &ExprPath) -> Result<HirExprKind, LoweringError> {
    if path.segments.len() == 1 {
        let name = &path.segments[0].ident.name;

        // Check if it's a local variable
        // In a full implementation, this would use proper name resolution
        // For now, check node_to_local
        for (node_id, local_id) in ctx.node_to_local.iter() {
            // Simplified: would need proper scope tracking
        }
    };

    // Assume it's a definition reference
    let def_id = ctx.alloc_def_id();
    Ok(HirExprKind::Def(def_id))
}

/// Lower a literal.
fn lower_literal(lit: &Literal) -> HirLiteral {
    match lit {
        Literal::Integer(v, suffix) => HirLiteral::Integer(*v, suffix.clone()),
        Literal::Float(v, suffix) => HirLiteral::Float(*v, suffix.clone()),
        Literal::String(s) => HirLiteral::String(s.clone()),
        Literal::Char(c) => HirLiteral::Char(*c),
        Literal::Bool(b) => HirLiteral::Bool(*b),
        Literal::Byte(b) => HirLiteral::Byte(*b),
        Literal::ByteString(bs) => HirLiteral::ByteString(bs.clone()),
    }
}

/// Lower a binary operator.
fn lower_binop(op: &AstBinOp) -> HirBinOp {
    match op {
        AstBinOp::Add => HirBinOp::Add,
        AstBinOp::Sub => HirBinOp::Sub,
        AstBinOp::Mul => HirBinOp::Mul,
        AstBinOp::Div => HirBinOp::Div,
        AstBinOp::Rem => HirBinOp::Rem,
        AstBinOp::And => HirBinOp::And,
        AstBinOp::Or => HirBinOp::Or,
        AstBinOp::BitAnd => HirBinOp::BitAnd,
        AstBinOp::BitOr => HirBinOp::BitOr,
        AstBinOp::BitXor => HirBinOp::BitXor,
        AstBinOp::Shl => HirBinOp::Shl,
        AstBinOp::Shr => HirBinOp::Shr,
        AstBinOp::Eq => HirBinOp::Eq,
        AstBinOp::Ne => HirBinOp::Ne,
        AstBinOp::Lt => HirBinOp::Lt,
        AstBinOp::Le => HirBinOp::Le,
        AstBinOp::Gt => HirBinOp::Gt,
        AstBinOp::Ge => HirBinOp::Ge,
    }
}

/// Lower a unary operator.
fn lower_unaryop(op: &AstUnaryOp) -> HirUnaryOp {
    match op {
        AstUnaryOp::Neg => HirUnaryOp::Neg,
        AstUnaryOp::Not => HirUnaryOp::Not,
        AstUnaryOp::Deref => HirUnaryOp::Deref,
        AstUnaryOp::Ref => HirUnaryOp::Ref,
        AstUnaryOp::RefMut => HirUnaryOp::RefMut,
    }
}

/// Lower an else branch.
fn lower_else_branch(
    ctx: &mut AstLowering,
    else_branch: &crate.compiler.ast::ElseBranch,
) -> Result<HirExpr, LoweringError> {
    match else_branch {
        crate.compiler.ast::ElseBranch::Block(block) => {
            lower_block(ctx, block)
        };
        crate.compiler.ast::ElseBranch::ElseIf(if_expr) => {
            lower_expr(ctx, if_expr)
        }
    }
}

/// Lower match arms.
fn lower_match_arms(
    ctx: &mut AstLowering,
    arms: &[AstMatchArm],
) -> Result<[HirMatchArm], LoweringError> {
    let mut result: [HirMatchArm] = [];
    let mut i: usize = 0;
    while i < arms.len() {
        let arm = &arms[i];
        let hir_pattern = pattern::lower_pattern(ctx, &arm.pattern)?;
        let hir_guard = match &arm.guard {
            Some(g) => Some(lower_expr(ctx, g)?),
            None => None,
        };
        let hir_body = lower_expr(ctx, &arm.body)?;

        result.push(HirMatchArm {
            pattern: hir_pattern,
            guard: hir_guard,
            body: hir_body,
            span: ctx.lower_span(&arm.span),
        });

        i = i + 1;
    };
    Ok(result)
}

/// Lower record fields for struct construction.
fn lower_record_fields(
    ctx: &mut AstLowering,
    fields: &[RecordExprField],
) -> Result<[FieldExpr], LoweringError> {
    let mut result: [FieldExpr] = [];
    let mut i: usize = 0;
    while i < fields.len() {
        let field = &fields[i];
        let hir_value = lower_expr(ctx, &field.value)?;
        result.push(FieldExpr {
            name: field.name.name.clone(),
            field_idx: i as u32, // Placeholder, resolved during type checking
            value: hir_value,
            span: ctx.lower_span(&field.span),
        });
        i = i + 1;
    };
    Ok(result)
}

/// Lower record fields for anonymous record.
fn lower_anonymous_record_fields(
    ctx: &mut AstLowering,
    fields: &[RecordExprField],
) -> Result<[RecordFieldExpr], LoweringError> {
    let mut result: [RecordFieldExpr] = [];
    let mut i: usize = 0;
    while i < fields.len() {
        let field = &fields[i];
        let hir_value = lower_expr(ctx, &field.value)?;
        result.push(RecordFieldExpr {
            name: field.name.name.clone(),
            value: hir_value,
            span: ctx.lower_span(&field.span),
        });
        i = i + 1;
    };
    Ok(result)
}

/// Resolve a loop label to its LoopId.
fn resolve_loop_label(
    ctx: &AstLowering,
    label: &Option<Ident>,
) -> Result<Option<LoopId>, LoweringError> {
    match label {
        Some(l) => {
            // Find loop with matching label
            let mut i: usize = ctx.loop_stack.len();
            while i > 0 {
                i = i - 1;
                match &ctx.loop_stack[i].0 {
                    Some(name) if *name == l.name => {
                        return Ok(Some(LoopId::new(ctx.loop_stack[i].1)));
                    }
                    _ => {}
                }
            };
            Err(LoweringError::unresolved(
                l.name.clone(),
                HirSpan::dummy(),
            ))
        };
        None => {
            // No label - use innermost loop
            if ctx.loop_stack.is_empty() {
                Err(LoweringError::invalid_desugar(
                    "break/continue".to_string(),
                    "not inside a loop".to_string(),
                    HirSpan::dummy(),
                ))
            } else {
                let (_, loop_id) = ctx.loop_stack.last().unwrap();
                Ok(Some(LoopId::new(*loop_id)))
            }
        }
    }
}

/// Lower a closure body.
fn lower_closure_body(
    ctx: &mut AstLowering,
    params: &[ClosureParam],
    return_type: &Option<crate.compiler.ast::Type>,
    body: &AstExpr,
) -> Result<Body, LoweringError> {
    ctx.reset_local_ids();

    let mut locals: [Local] = [];

    // Local 0 is the return place
    let return_id = ctx.alloc_local_id();
    let return_ty = match return_type {
        Some(ty) => lower_type(ctx, ty)?,
        None => Type::infer(),
    };
    locals.push(Local {
        id: return_id,
        ty: return_ty,
        mutable: true,
        name: None,
        span: ctx.lower_span(&body.span),
    });

    // Add parameters
    let mut param_count: usize = 0;
    let mut i: usize = 0;
    while i < params.len() {
        let param = &params[i];
        let param_id = ctx.alloc_local_id();
        let param_ty = match &param.ty {
            Some(ty) => lower_type(ctx, ty)?,
            None => Type::infer(),
        };

        ctx.node_to_local.insert(param.id.id(), param_id.clone());

        locals.push(Local {
            id: param_id,
            ty: param_ty,
            mutable: false,
            name: Some(param.name.name.clone()),
            span: ctx.lower_span(&param.span),
        });
        param_count = param_count + 1;
        i = i + 1;
    };

    // Lower body
    let expr = lower_expr(ctx, body)?;

    Ok(Body {
        locals,
        param_count,
        expr,
        span: ctx.lower_span(&body.span),
    })
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_lower_literal() {
    let lit = Literal::Integer(42, None);
    let hir_lit = lower_literal(&lit);
    match hir_lit {
        HirLiteral::Integer(v, _) => assert(v == 42),
        _ => assert(false),
    }
}

#[test]
fn test_lower_binop() {
    assert(matches!(lower_binop(&AstBinOp::Add), HirBinOp::Add));
    assert(matches!(lower_binop(&AstBinOp::Sub), HirBinOp::Sub));
    assert(matches!(lower_binop(&AstBinOp::Eq), HirBinOp::Eq));
}

#[test]
fn test_lower_unaryop() {
    assert(matches!(lower_unaryop(&AstUnaryOp::Neg), HirUnaryOp::Neg));
    assert(matches!(lower_unaryop(&AstUnaryOp::Not), HirUnaryOp::Not));
}
