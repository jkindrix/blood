// Test: compound assignment operators across all integer types
// This is a canary test for Phase 3a modernization.
// Verifies +=, -=, *=, /=, %= work correctly with i32, u32, usize.
fn main() -> i32 {
    // === i32 ===
    let mut a: i32 = 0;
    a += 10;
    a += 5;
    if a != 15 { return 1; }
    a -= 3;
    if a != 12 { return 2; }
    a *= 2;
    if a != 24 { return 3; }
    a /= 4;
    if a != 6 { return 4; }
    a %= 5;
    if a != 1 { return 5; }

    // === u32 ===
    let mut b: u32 = 0;
    b += 10;
    b += 5;
    if b != 15 { return 10; }
    b -= 3;
    if b != 12 { return 11; }
    b *= 2;
    if b != 24 { return 12; }
    b /= 4;
    if b != 6 { return 13; }
    b %= 5;
    if b != 1 { return 14; }

    // === usize ===
    let mut c: usize = 0;
    c += 10;
    c += 5;
    if c != 15 { return 20; }
    c -= 3;
    if c != 12 { return 21; }
    c *= 2;
    if c != 24 { return 22; }
    c /= 4;
    if c != 6 { return 23; }
    c %= 5;
    if c != 1 { return 24; }

    // === Loop counter pattern (the primary conversion target) ===
    // for-loop bodies commonly do: count += 1, sum += value
    let mut sum_i32: i32 = 0;
    for i in 0i32..10 {
        sum_i32 += i;
    }
    if sum_i32 != 45 { return 30; }

    let mut sum_u32: u32 = 0;
    for i in 0u32..10 {
        sum_u32 += i;
    }
    if sum_u32 != 45 { return 31; }

    let mut sum_usize: usize = 0;
    for i in 0usize..10 {
        sum_usize += i;
    }
    if sum_usize != 45 { return 32; }

    // === Compound assign in nested context ===
    let mut total: i32 = 0;
    for _outer in 0i32..3 {
        let mut inner_sum: i32 = 0;
        for j in 0i32..4 {
            inner_sum += j;
        }
        total += inner_sum;
    }
    // inner_sum = 0+1+2+3 = 6, total = 6*3 = 18
    if total != 18 { return 40; }

    // === Compound assign on struct field (via local) ===
    let mut x: i32 = 100;
    x -= 50;
    x *= 3;
    x /= 2;
    // (100-50)*3/2 = 75
    if x != 75 { return 50; }

    0
}
