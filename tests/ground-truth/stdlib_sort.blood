// Blood Standard Library - Sorting and Searching
//
// Provides quicksort (with insertion sort cutoff) and binary search
// for common primitive types: u64, i32, u32.
//
// All functions are self-contained with no cross-module imports.

// ============================================================
// u64 sorting
// ============================================================

/// Sort a Vec<u64> in ascending order (in-place).
pub fn sort_u64(v: &mut Vec<u64>) {
    let len = v.len();
    if len > 1 {
        quicksort_u64(v, 0, len - 1);
    }
}

/// Quicksort for u64 with insertion sort cutoff.
fn quicksort_u64(v: &mut Vec<u64>, low: usize, high: usize) {
    if high <= low {
        return;
    }
    if high - low < 16 {
        insertion_sort_u64(v, low, high);
        return;
    }
    let pivot_idx = partition_u64(v, low, high);
    if pivot_idx > 0 {
        quicksort_u64(v, low, pivot_idx - 1);
    }
    if pivot_idx < high {
        quicksort_u64(v, pivot_idx + 1, high);
    }
}

/// Partition for u64 quicksort using median-of-three pivot.
fn partition_u64(v: &mut Vec<u64>, low: usize, high: usize) -> usize {
    // Median-of-three pivot selection
    let mid = low + (high - low) / 2;
    if v[mid] < v[low] {
        swap_u64(v, low, mid);
    }
    if v[high] < v[low] {
        swap_u64(v, low, high);
    }
    if v[mid] < v[high] {
        swap_u64(v, mid, high);
    }
    // Pivot is now at v[high]
    let pivot = v[high];

    let mut i = low;
    let mut j = low;
    while j < high {
        if v[j] < pivot {
            swap_u64(v, i, j);
            i = i + 1;
        }
        j = j + 1;
    }
    swap_u64(v, i, high);
    i
}

/// Insertion sort for small u64 sub-arrays.
fn insertion_sort_u64(v: &mut Vec<u64>, low: usize, high: usize) {
    let mut i = low + 1;
    while i <= high {
        let key = v[i];
        let mut j = i;
        while j > low {
            if v[j - 1] > key {
                v[j] = v[j - 1];
                j = j - 1;
            } else {
                break;
            }
        }
        v[j] = key;
        i = i + 1;
    }
}

/// Swap two elements in a Vec<u64>.
fn swap_u64(v: &mut Vec<u64>, a: usize, b: usize) {
    let tmp = v[a];
    v[a] = v[b];
    v[b] = tmp;
}

// ============================================================
// i32 sorting
// ============================================================

/// Sort a Vec<i32> in ascending order (in-place).
pub fn sort_i32(v: &mut Vec<i32>) {
    let len = v.len();
    if len > 1 {
        quicksort_i32(v, 0, len - 1);
    }
}

/// Quicksort for i32 with insertion sort cutoff.
fn quicksort_i32(v: &mut Vec<i32>, low: usize, high: usize) {
    if high <= low {
        return;
    }
    if high - low < 16 {
        insertion_sort_i32(v, low, high);
        return;
    }
    let pivot_idx = partition_i32(v, low, high);
    if pivot_idx > 0 {
        quicksort_i32(v, low, pivot_idx - 1);
    }
    if pivot_idx < high {
        quicksort_i32(v, pivot_idx + 1, high);
    }
}

/// Partition for i32 quicksort using median-of-three pivot.
fn partition_i32(v: &mut Vec<i32>, low: usize, high: usize) -> usize {
    let mid = low + (high - low) / 2;
    if v[mid] < v[low] {
        swap_i32(v, low, mid);
    }
    if v[high] < v[low] {
        swap_i32(v, low, high);
    }
    if v[mid] < v[high] {
        swap_i32(v, mid, high);
    }
    let pivot = v[high];

    let mut i = low;
    let mut j = low;
    while j < high {
        if v[j] < pivot {
            swap_i32(v, i, j);
            i = i + 1;
        }
        j = j + 1;
    }
    swap_i32(v, i, high);
    i
}

/// Insertion sort for small i32 sub-arrays.
fn insertion_sort_i32(v: &mut Vec<i32>, low: usize, high: usize) {
    let mut i = low + 1;
    while i <= high {
        let key = v[i];
        let mut j = i;
        while j > low {
            if v[j - 1] > key {
                v[j] = v[j - 1];
                j = j - 1;
            } else {
                break;
            }
        }
        v[j] = key;
        i = i + 1;
    }
}

/// Swap two elements in a Vec<i32>.
fn swap_i32(v: &mut Vec<i32>, a: usize, b: usize) {
    let tmp = v[a];
    v[a] = v[b];
    v[b] = tmp;
}

// ============================================================
// u32 sorting
// ============================================================

/// Sort a Vec<u32> in ascending order (in-place).
pub fn sort_u32(v: &mut Vec<u32>) {
    let len = v.len();
    if len > 1 {
        quicksort_u32(v, 0, len - 1);
    }
}

/// Quicksort for u32 with insertion sort cutoff.
fn quicksort_u32(v: &mut Vec<u32>, low: usize, high: usize) {
    if high <= low {
        return;
    }
    if high - low < 16 {
        insertion_sort_u32(v, low, high);
        return;
    }
    let pivot_idx = partition_u32(v, low, high);
    if pivot_idx > 0 {
        quicksort_u32(v, low, pivot_idx - 1);
    }
    if pivot_idx < high {
        quicksort_u32(v, pivot_idx + 1, high);
    }
}

/// Partition for u32 quicksort using median-of-three pivot.
fn partition_u32(v: &mut Vec<u32>, low: usize, high: usize) -> usize {
    let mid = low + (high - low) / 2;
    if v[mid] < v[low] {
        swap_u32(v, low, mid);
    }
    if v[high] < v[low] {
        swap_u32(v, low, high);
    }
    if v[mid] < v[high] {
        swap_u32(v, mid, high);
    }
    let pivot = v[high];

    let mut i = low;
    let mut j = low;
    while j < high {
        if v[j] < pivot {
            swap_u32(v, i, j);
            i = i + 1;
        }
        j = j + 1;
    }
    swap_u32(v, i, high);
    i
}

/// Insertion sort for small u32 sub-arrays.
fn insertion_sort_u32(v: &mut Vec<u32>, low: usize, high: usize) {
    let mut i = low + 1;
    while i <= high {
        let key = v[i];
        let mut j = i;
        while j > low {
            if v[j - 1] > key {
                v[j] = v[j - 1];
                j = j - 1;
            } else {
                break;
            }
        }
        v[j] = key;
        i = i + 1;
    }
}

/// Swap two elements in a Vec<u32>.
fn swap_u32(v: &mut Vec<u32>, a: usize, b: usize) {
    let tmp = v[a];
    v[a] = v[b];
    v[b] = tmp;
}

// ============================================================
// Binary search
// ============================================================

/// Binary search for a u64 value in a sorted Vec. Returns the index if found.
pub fn binary_search_u64(v: &Vec<u64>, target: u64) -> Option<usize> {
    if v.len() == 0 {
        return Option.None;
    }
    let mut low: usize = 0;
    let mut high: usize = v.len() - 1;

    while low <= high {
        let mid = low + (high - low) / 2;
        if v[mid] == target {
            return Option.Some(mid);
        }
        if v[mid] < target {
            low = mid + 1;
        } else {
            if mid == 0 {
                return Option.None;
            }
            high = mid - 1;
        }
    }
    Option.None
}

/// Binary search for an i32 value in a sorted Vec. Returns the index if found.
pub fn binary_search_i32(v: &Vec<i32>, target: i32) -> Option<usize> {
    if v.len() == 0 {
        return Option.None;
    }
    let mut low: usize = 0;
    let mut high: usize = v.len() - 1;

    while low <= high {
        let mid = low + (high - low) / 2;
        if v[mid] == target {
            return Option.Some(mid);
        }
        if v[mid] < target {
            low = mid + 1;
        } else {
            if mid == 0 {
                return Option.None;
            }
            high = mid - 1;
        }
    }
    Option.None
}

/// Binary search for a u32 value in a sorted Vec. Returns the index if found.
pub fn binary_search_u32(v: &Vec<u32>, target: u32) -> Option<usize> {
    if v.len() == 0 {
        return Option.None;
    }
    let mut low: usize = 0;
    let mut high: usize = v.len() - 1;

    while low <= high {
        let mid = low + (high - low) / 2;
        if v[mid] == target {
            return Option.Some(mid);
        }
        if v[mid] < target {
            low = mid + 1;
        } else {
            if mid == 0 {
                return Option.None;
            }
            high = mid - 1;
        }
    }
    Option.None
}
