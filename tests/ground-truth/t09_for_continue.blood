// Test: continue in for-in loops across integer types
// Canary test for Phase 3b modernization.
fn main() -> i32 {
    // === continue in for-in with i32 ===
    let mut sum: i32 = 0;
    for i in 0i32..10 {
        if i % 2 == 0 {
            continue;
        }
        sum += i;
    }
    // 1+3+5+7+9 = 25
    if sum != 25 { return 1; }

    // === continue in for-in with u32 ===
    let mut sum2: u32 = 0;
    for i in 0u32..10 {
        if i % 2 == 0 {
            continue;
        }
        sum2 += i;
    }
    if sum2 != 25 { return 2; }

    // === continue in for-in with usize ===
    let mut sum3: usize = 0;
    for i in 0usize..10 {
        if i % 2 == 0 {
            continue;
        }
        sum3 += i;
    }
    if sum3 != 25 { return 3; }

    // === continue skipping first N iterations ===
    let mut sum4: i32 = 0;
    for i in 0i32..10 {
        if i < 5 {
            continue;
        }
        sum4 += i;
    }
    // 5+6+7+8+9 = 35
    if sum4 != 35 { return 4; }

    // === continue in nested for loops ===
    let mut count: i32 = 0;
    for i in 0i32..5 {
        for j in 0i32..5 {
            if j <= i {
                continue;
            }
            count += 1;
        }
    }
    // pairs where j > i: (0,1)(0,2)(0,3)(0,4)(1,2)(1,3)(1,4)(2,3)(2,4)(3,4) = 10
    if count != 10 { return 5; }

    // === continue with multiple conditions ===
    let mut sum5: i32 = 0;
    for i in 0i32..20 {
        if i % 3 == 0 {
            continue;
        }
        if i % 5 == 0 {
            continue;
        }
        sum5 += i;
    }
    // Skip multiples of 3 and 5: skip 0,3,5,6,9,10,12,15,18
    // Keep: 1,2,4,7,8,11,13,14,16,17,19 = 112
    if sum5 != 112 { return 6; }

    0
}
