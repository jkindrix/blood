// Test: stdlib sorting and binary search
// EXPECT: 1 2 3 4 5
// EXPECT: 10 20 30 40 50
// EXPECT: -5 -3 -1 0 2 4 7
// EXPECT: 1 1 2 3 3 5
// EXPECT: 3
// EXPECT: -1
// EXPECT: 0
// EXPECT: 2
// EXPECT: -1
// EXPECT: 0
mod stdlib_sort;

fn print_vec_u64(v: &Vec<u64>) {
    let mut i: usize = 0;
    while i < v.len() {
        if i > 0 {
            print_str(" ");
        }
        print_int(v[i] as i32);
        i = i + 1;
    }
    print_str("\n");
}

fn print_vec_u32(v: &Vec<u32>) {
    let mut i: usize = 0;
    while i < v.len() {
        if i > 0 {
            print_str(" ");
        }
        print_int(v[i] as i32);
        i = i + 1;
    }
    print_str("\n");
}

fn print_vec_i32(v: &Vec<i32>) {
    let mut i: usize = 0;
    while i < v.len() {
        if i > 0 {
            print_str(" ");
        }
        print_int(v[i]);
        i = i + 1;
    }
    print_str("\n");
}

fn test_sort_u64() -> i32 {
    // Reverse sorted
    let mut v: Vec<u64> = Vec::new();
    v.push(5);
    v.push(3);
    v.push(1);
    v.push(4);
    v.push(2);
    stdlib_sort::sort_u64(&mut v);
    print_vec_u64(&v); // 1 2 3 4 5

    // Already sorted
    let mut v2: Vec<u64> = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);
    v2.push(40);
    v2.push(50);
    stdlib_sort::sort_u64(&mut v2);
    print_vec_u64(&v2); // 10 20 30 40 50

    0
}

fn test_sort_i32() -> i32 {
    // Negative numbers
    let mut v: Vec<i32> = Vec::new();
    v.push(4);
    v.push(-1);
    v.push(7);
    v.push(-5);
    v.push(0);
    v.push(2);
    v.push(-3);
    stdlib_sort::sort_i32(&mut v);
    print_vec_i32(&v); // -5 -3 -1 0 2 4 7

    0
}

fn test_sort_u32() -> i32 {
    // Duplicates
    let mut v: Vec<u32> = Vec::new();
    v.push(3);
    v.push(1);
    v.push(3);
    v.push(5);
    v.push(2);
    v.push(1);
    stdlib_sort::sort_u32(&mut v);
    print_vec_u32(&v); // 1 1 2 3 3 5

    0
}

fn test_binary_search() -> i32 {
    // sorted u64
    let mut v: Vec<u64> = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    v.push(50);

    match stdlib_sort::binary_search_u64(&v, 40) {
        Option::Some(idx) => { println_int(idx as i32); } // 3
        Option::None => { println_int(-1); }
    }

    match stdlib_sort::binary_search_u64(&v, 25) {
        Option::Some(idx) => { println_int(idx as i32); }
        Option::None => { println_int(-1); } // -1
    }

    // sorted i32
    let mut vi: Vec<i32> = Vec::new();
    vi.push(-10);
    vi.push(-5);
    vi.push(0);
    vi.push(5);
    vi.push(10);

    match stdlib_sort::binary_search_i32(&vi, -10) {
        Option::Some(idx) => { println_int(idx as i32); } // 0
        Option::None => { println_int(-1); }
    }

    // sorted u32
    let mut vu: Vec<u32> = Vec::new();
    vu.push(1);
    vu.push(3);
    vu.push(5);
    vu.push(7);
    vu.push(9);

    match stdlib_sort::binary_search_u32(&vu, 5) {
        Option::Some(idx) => { println_int(idx as i32); } // 2
        Option::None => { println_int(-1); }
    }

    // search empty vec
    let empty: Vec<u64> = Vec::new();
    match stdlib_sort::binary_search_u64(&empty, 1) {
        Option::Some(idx) => { println_int(idx as i32); }
        Option::None => { println_int(-1); } // -1
    }

    // search single element vec
    let mut single: Vec<u64> = Vec::new();
    single.push(42);
    match stdlib_sort::binary_search_u64(&single, 42) {
        Option::Some(idx) => { println_int(idx as i32); }
        Option::None => { println_int(-1); }
    }

    0
}

fn main() -> i32 {
    let r1: i32 = test_sort_u64();
    if r1 != 0 { return 1; }

    let r2: i32 = test_sort_i32();
    if r2 != 0 { return 2; }

    let r3: i32 = test_sort_u32();
    if r3 != 0 { return 3; }

    let r4: i32 = test_binary_search();
    if r4 != 0 { return 4; }

    0
}
