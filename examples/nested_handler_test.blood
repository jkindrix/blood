// Test nested handlers

effect Counter {
    op inc() -> i32;
}

effect Doubler {
    op double(x: i32) -> i32;
}

deep handler BasicCounter for Counter {
    let mut count: i32

    return(x) { x }

    op inc() {
        count = count + 1;
        resume(count)
    }
}

deep handler BasicDoubler for Doubler {
    return(x) { x }

    op double(x) {
        resume(x * 2)
    }
}

fn main() -> i32 {
    with BasicCounter { count: 0 } handle {
        with BasicDoubler {} handle {
            let a = perform Counter.inc();  // returns 1
            let b = perform Doubler.double(a);  // returns 2
            let c = perform Counter.inc();  // returns 2
            a + b + c  // should return 5 (1 + 2 + 2)
        }
    }
}
