// Content-Addressed Code in Blood
// ==================================
//
// This example demonstrates Blood's content-addressed code identity system, where
// every function, type, and definition is identified by a cryptographic hash of its
// canonicalized AST rather than by name.
//
// Key Concepts:
// 1. Content-Based Identity - Same code always produces the same hash
// 2. Incremental Compilation - Only recompile when content actually changes
// 3. Code Deduplication - Identical functions across modules share storage
// 4. Reference by Hash - Dependencies reference content hashes, not names
//
// Blood uses BLAKE3-256 to hash canonicalized ASTs. The canonicalization process:
//   - Converts variable names to de Bruijn indices
//   - Resolves type references to their content hashes
//   - Strips comments, formatting, and source locations
//   - Normalizes AST structure for consistent hashing
//
// This means:
//   fn add(x: i32, y: i32) -> i32 { x + y }
//   fn add(a: i32, b: i32) -> i32 { a + b }
// Produce IDENTICAL hashes because they are semantically identical.

// ===========================================================================
// Part 1: Understanding Content Hashing
// ===========================================================================

// These two functions have the SAME hash because after canonicalization
// (replacing variable names with de Bruijn indices), they are identical:
//
// Canonicalized form: fn(#0: i32, #1: i32) -> i32 { #0 + #1 }

fn add_v1(x: i32, y: i32) -> i32 {
    x + y
}

fn add_v2(a: i32, b: i32) -> i32 {
    a + b
}

// This function has a DIFFERENT hash because the body is different
// (order of operands differs):
//
// Canonicalized form: fn(#0: i32, #1: i32) -> i32 { #1 + #0 }

fn add_reversed(x: i32, y: i32) -> i32 {
    y + x
}

// Demonstrate hash identity concept
fn demo_hash_identity() {
    println_str("=== Part 1: Content Hash Identity ===");
    println_str("");

    println_str("Three functions with similar names but different hashes:");
    println_str("  add_v1(x, y) = x + y");
    println_str("  add_v2(a, b) = a + b");
    println_str("  add_reversed(x, y) = y + x");
    println_str("");

    println_str("After de Bruijn canonicalization:");
    println_str("  add_v1: fn(#0, #1) = #0 + #1  ->  hash: #a7f2...");
    println_str("  add_v2: fn(#0, #1) = #0 + #1  ->  hash: #a7f2...  (SAME!)");
    println_str("  add_reversed: fn(#0, #1) = #1 + #0  ->  hash: #b3c1...  (different)");
    println_str("");

    // Verify they compute the same results
    let result1: i32 = add_v1(10, 20);
    let result2: i32 = add_v2(10, 20);
    let result3: i32 = add_reversed(10, 20);

    print_str("add_v1(10, 20) = ");
    println_int(result1);
    print_str("add_v2(10, 20) = ");
    println_int(result2);
    print_str("add_reversed(10, 20) = ");
    println_int(result3);
    println_str("");

    println_str("Key insight: add_v1 and add_v2 share the same compiled code!");
    println_str("The compiler stores ONE copy, referenced by hash.");
    println_str("");
}

// ===========================================================================
// Part 2: De Bruijn Indexing in Detail
// ===========================================================================

// De Bruijn indices replace named variables with position-based indices.
// This makes semantically equivalent code produce identical hashes.
//
// The index represents the number of binders between the variable use
// and its binding site.

// Simple example: nested functions
fn outer(x: i32) -> i32 {
    // Canonicalized: #0 refers to the innermost binding (x)
    x * 2
}

fn inner_example(a: i32) -> i32 {
    // Let binding introduces new scope
    // Canonicalized:
    //   let #0 = #1 + 1  (where #1 is parameter a)
    //   #0 * 2           (#0 is the let binding)
    let b: i32 = a + 1;
    b * 2
}

// Function with multiple let bindings
fn multi_let(n: i32) -> i32 {
    // Canonicalized indices:
    //   #0 = param n
    //   let #0 = #0 + 1  (first let, shadowing param)
    //   let #0 = #0 * 2  (second let, shadowing first)
    //   #0              (return second let value)
    let x: i32 = n + 1;
    let y: i32 = x * 2;
    y
}

fn demo_debruijn_indexing() {
    println_str("=== Part 2: De Bruijn Indexing ===");
    println_str("");

    println_str("De Bruijn indices replace variable names with positions:");
    println_str("");

    println_str("fn outer(x) { x * 2 }");
    println_str("  Canonicalized: fn(#0) { #0 * 2 }");
    println_str("  #0 refers to the parameter");
    println_str("");

    println_str("fn inner_example(a) { let b = a + 1; b * 2 }");
    println_str("  Canonicalized: fn(#0) { let #0 = #0 + 1; #0 * 2 }");
    println_str("  First #0: param, Second #0: let binding");
    println_str("");

    println_str("fn multi_let(n) { let x = n + 1; let y = x * 2; y }");
    println_str("  Each let introduces a new binding at index 0");
    println_str("  Previous bindings shift up");
    println_str("");

    // Demonstrate the functions work
    print_str("outer(5) = ");
    println_int(outer(5));
    print_str("inner_example(5) = ");
    println_int(inner_example(5));
    print_str("multi_let(5) = ");
    println_int(multi_let(5));
    println_str("");
}

// ===========================================================================
// Part 3: Incremental Compilation Benefits
// ===========================================================================

// With content-addressed code, the compiler can:
// 1. Hash each definition before compilation
// 2. Check if a compiled version with that hash exists in cache
// 3. Skip compilation if cache hit
// 4. Only recompile definitions whose hashes changed

// Simulated module hierarchy for demonstration
struct BuildStats {
    total_definitions: i32,
    cached_hits: i32,
    recompiled: i32,
    hash_computations: i32,
}

// Simulate checking build cache
fn simulate_incremental_build() -> BuildStats {
    // In a real build:
    // 1. Parse all source files
    // 2. Compute content hash for each definition
    // 3. Check build cache for each hash
    // 4. Compile only cache misses

    BuildStats {
        total_definitions: 100,
        cached_hits: 95,     // 95% cache hit rate typical for incremental
        recompiled: 5,       // Only 5 definitions changed
        hash_computations: 100,
    }
}

// Demonstrate cache lookup concept
fn lookup_cache_simulated(definition_hash: i32) -> bool {
    // Simulates: cache.get(hash) returns Some(compiled) or None
    // Real implementation uses BuildCache with BLAKE3 hashes

    // Simulate: even hashes are cached, odd are cache misses
    definition_hash % 2 == 0
}

fn demo_incremental_compilation() {
    println_str("=== Part 3: Incremental Compilation ===");
    println_str("");

    println_str("Content-addressed code enables perfect incremental builds:");
    println_str("");

    println_str("Traditional compilation:");
    println_str("  1. Check file modification times");
    println_str("  2. Recompile if file changed (even for comments!)");
    println_str("  3. Dependency tracking is coarse-grained");
    println_str("");

    println_str("Blood content-addressed compilation:");
    println_str("  1. Hash each definition's canonicalized AST");
    println_str("  2. Check build cache for existing compiled code");
    println_str("  3. Skip compilation if hash matches cache");
    println_str("  4. Only recompile when semantics actually change");
    println_str("");

    let stats: BuildStats = simulate_incremental_build();

    println_str("Simulated incremental build:");
    print_str("  Total definitions: ");
    println_int(stats.total_definitions);
    print_str("  Cache hits: ");
    println_int(stats.cached_hits);
    print_str("  Recompiled: ");
    println_int(stats.recompiled);
    println_str("");

    // Calculate percentage
    let hit_rate: i32 = (stats.cached_hits * 100) / stats.total_definitions;
    print_str("  Cache hit rate: ");
    print_int(hit_rate);
    println_str("%");
    println_str("");

    println_str("Benefits:");
    println_str("  - Comment changes don't trigger recompilation");
    println_str("  - Whitespace reformatting doesn't trigger recompilation");
    println_str("  - Variable renames don't trigger recompilation");
    println_str("  - Only semantic changes cause recompilation");
    println_str("");
}

// ===========================================================================
// Part 4: Code Deduplication Across Modules
// ===========================================================================

// When the same function logic appears in multiple modules,
// content-addressed storage stores only ONE copy.

// Module A's implementation
fn module_a_helper(x: i32) -> i32 {
    x * x
}

// Module B's identical implementation (different name, same logic)
fn module_b_square(n: i32) -> i32 {
    n * n
}

// Module C's identical implementation (yet another name)
fn module_c_pow2(value: i32) -> i32 {
    value * value
}

// All three functions above produce the SAME content hash:
// fn(#0: i32) -> i32 { #0 * #0 }
// Blood stores ONE compiled version, saving space and improving cache locality.

fn demo_deduplication() {
    println_str("=== Part 4: Code Deduplication ===");
    println_str("");

    println_str("Three 'different' functions that are actually identical:");
    println_str("");
    println_str("  module_a_helper(x) = x * x");
    println_str("  module_b_square(n) = n * n");
    println_str("  module_c_pow2(value) = value * value");
    println_str("");

    println_str("After canonicalization, all three become:");
    println_str("  fn(#0: i32) -> i32 { #0 * #0 }");
    println_str("");

    println_str("Content hash: #d4e5f6g7... (same for all three!)");
    println_str("");

    // Verify they compute the same
    let a: i32 = module_a_helper(7);
    let b: i32 = module_b_square(7);
    let c: i32 = module_c_pow2(7);

    print_str("module_a_helper(7) = ");
    println_int(a);
    print_str("module_b_square(7) = ");
    println_int(b);
    print_str("module_c_pow2(7) = ");
    println_int(c);
    println_str("");

    println_str("Storage benefits:");
    println_str("  - Only ONE copy of compiled code stored");
    println_str("  - Cross-module deduplication automatic");
    println_str("  - Better cache utilization");
    println_str("  - Smaller binary sizes");
    println_str("");
}

// ===========================================================================
// Part 5: Reference by Content Hash
// ===========================================================================

// In Blood, dependencies are tracked by content hash, not by name.
// This enables:
// - Multiple versions of same library coexisting
// - Safe refactoring (renames don't break code)
// - Reproducible builds

// Simulate function that depends on another
fn depends_on_helper(x: i32) -> i32 {
    // In the canonical AST, this call is:
    //   call(#hash_of_helper, #0)
    // where #hash_of_helper is the content hash of helper_function
    helper_function(x) + 1
}

fn helper_function(n: i32) -> i32 {
    n * 2
}

// Demonstrate version coexistence concept
struct DependencyInfo {
    name: i32,          // Symbolic representation
    hash_v1: i32,       // Hash of version 1
    hash_v2: i32,       // Hash of version 2
    both_available: bool,
}

fn demo_reference_by_hash() {
    println_str("=== Part 5: Reference by Content Hash ===");
    println_str("");

    println_str("Traditional dependency management:");
    println_str("  import math.add  // Which version?");
    println_str("  // Conflicts if two libraries need different versions!");
    println_str("");

    println_str("Blood dependency management:");
    println_str("  // Dependencies reference content hashes");
    println_str("  // call(#a7f2k9..., args)  // Specific implementation");
    println_str("");

    println_str("Benefits:");
    println_str("  1. No dependency hell - versions coexist by hash");
    println_str("  2. Safe refactoring - renames don't break references");
    println_str("  3. Reproducible builds - same hashes = same code");
    println_str("  4. Diamond dependencies resolved automatically");
    println_str("");

    // Demonstrate function dependency
    let result: i32 = depends_on_helper(5);
    print_str("depends_on_helper(5) = ");
    println_int(result);
    println_str("  (internally calls helper_function by its hash)");
    println_str("");

    // Simulate version coexistence
    let dep: DependencyInfo = DependencyInfo {
        name: 1,            // Represents "json_parser"
        hash_v1: 12345678,  // Hash of v1.0
        hash_v2: 87654321,  // Hash of v2.0 (different implementation)
        both_available: true,
    };

    println_str("Example: json_parser library");
    print_str("  Version 1.0 hash: #");
    println_int(dep.hash_v1);
    print_str("  Version 2.0 hash: #");
    println_int(dep.hash_v2);
    println_str("  Both versions available in same codebase!");
    println_str("");
}

// ===========================================================================
// Part 6: The Codebase Database
// ===========================================================================

// Blood stores all definitions in a content-addressed codebase:
//
// DefinitionRecord = {
//     hash: ContentHash,
//     canonical_ast: CanonicalAST,
//     compiled_code: Option<CompiledCode>,
//     metadata: Metadata,  // names, docs, source location
// }
//
// Codebase = HashMap<ContentHash, DefinitionRecord>

struct DefinitionRecord {
    hash_prefix: i32,      // First 32 bits of hash (simulated)
    has_compiled: bool,    // Whether compiled code exists
    name_count: i32,       // Number of names pointing to this hash
    ref_count: i32,        // Number of references from other definitions
}

fn create_definition_record(hash: i32, compiled: bool) -> DefinitionRecord {
    DefinitionRecord {
        hash_prefix: hash,
        has_compiled: compiled,
        name_count: 1,
        ref_count: 0,
    }
}

fn demo_codebase_structure() {
    println_str("=== Part 6: Codebase Database ===");
    println_str("");

    println_str("Blood's codebase structure:");
    println_str("");
    println_str("  Codebase {");
    println_str("    definitions: Map<ContentHash, DefinitionRecord>");
    println_str("    names: Map<Path, ContentHash>  // name -> hash lookup");
    println_str("    reverse_deps: Map<Hash, Set<Hash>>  // who uses what");
    println_str("  }");
    println_str("");

    println_str("DefinitionRecord {");
    println_str("  hash: ContentHash,           // BLAKE3-256");
    println_str("  canonical_ast: CanonicalAST, // De Bruijn indexed");
    println_str("  compiled: Option<MachineCode>,");
    println_str("  metadata: {");
    println_str("    names: Vec<String>,        // Human-readable aliases");
    println_str("    docs: Option<String>,");
    println_str("    source_location: Span,");
    println_str("  }");
    println_str("}");
    println_str("");

    // Create some simulated records
    let rec1: DefinitionRecord = create_definition_record(123456, true);
    let rec2: DefinitionRecord = create_definition_record(789012, true);
    let rec3: DefinitionRecord = create_definition_record(123456, true); // Same hash!

    println_str("Example codebase entries:");
    print_str("  #");
    print_int(rec1.hash_prefix);
    print_str(" -> DefinitionRecord { compiled: ");
    if rec1.has_compiled { println_str("yes }"); } else { println_str("no }"); }

    print_str("  #");
    print_int(rec2.hash_prefix);
    print_str(" -> DefinitionRecord { compiled: ");
    if rec2.has_compiled { println_str("yes }"); } else { println_str("no }"); }

    println_str("");
    println_str("Note: rec1 and rec3 have the same hash!");
    println_str("They reference the SAME DefinitionRecord.");
    println_str("");
}

// ===========================================================================
// Part 7: Hash Display and Lookup
// ===========================================================================

// Hashes are displayed in base32 for human readability:
//   Full: #a7f2k9m3xp5jht2ngqw4bc8rv6ys7dz1ef0il
//   Short: #a7f2k9m3xp (10 chars, usually unique)
//   Extended: #a7f2k9m3xp5j (12 chars, for disambiguation)

fn hash_to_display(hash: i32) -> i32 {
    // Real implementation converts 256-bit hash to base32
    // Here we just return a simulated display value
    hash % 10000
}

fn demo_hash_display() {
    println_str("=== Part 7: Hash Display and Lookup ===");
    println_str("");

    println_str("Base32 hash display (RFC 4648, lowercase):");
    println_str("  Alphabet: abcdefghijklmnopqrstuvwxyz234567");
    println_str("");

    println_str("Display formats:");
    println_str("  Full (52 chars): #a7f2k9m3xp5jht2ngqw4bc8rv6ys7dz1ef0il...");
    println_str("  Short (10 chars): #a7f2k9m3xp");
    println_str("  Extended (for disambiguation): #a7f2k9m3xp5j");
    println_str("");

    println_str("Usage in code:");
    println_str("  // Reference specific implementation by hash");
    println_str("  let result = #a7f2k9m3xp(10, 20);");
    println_str("");
    println_str("  // Disambiguate when short hash collides");
    println_str("  let v1_result = #a7f2k9m3xp5j(x);  // v1.0");
    println_str("  let v2_result = #a7f2k9m3xp7k(x);  // v2.0");
    println_str("");

    // Simulated hash lookup
    let simulated_hash: i32 = 987654321;
    let display: i32 = hash_to_display(simulated_hash);
    print_str("Simulated hash display: #");
    println_int(display);
    println_str("");
}

// ===========================================================================
// Part 8: Practical Benefits Summary
// ===========================================================================

fn demo_benefits_summary() {
    println_str("=== Part 8: Benefits Summary ===");
    println_str("");

    println_str("1. NO DEPENDENCY HELL");
    println_str("   Multiple versions of the same library coexist");
    println_str("   Each version has unique hash, no conflicts");
    println_str("");

    println_str("2. PERFECT INCREMENTAL COMPILATION");
    println_str("   Only recompile when content actually changes");
    println_str("   Comments, whitespace, renames -> no recompilation");
    println_str("");

    println_str("3. SAFE REFACTORING");
    println_str("   Rename anything - code references hashes, not names");
    println_str("   Names are just metadata for humans");
    println_str("");

    println_str("4. ZERO-DOWNTIME UPGRADES");
    println_str("   Hot-swap code by hash without restart");
    println_str("   Old and new versions run simultaneously");
    println_str("");

    println_str("5. DISTRIBUTED CACHING");
    println_str("   Share compiled artifacts globally by hash");
    println_str("   CI/CD cache sharing across teams");
    println_str("");

    println_str("6. REPRODUCIBLE BUILDS");
    println_str("   Same source -> same hash -> same binary");
    println_str("   Bit-for-bit reproducibility guaranteed");
    println_str("");

    println_str("7. AUTOMATIC DEDUPLICATION");
    println_str("   Identical code stored once, regardless of names");
    println_str("   Smaller binaries, better cache utilization");
    println_str("");
}

// ===========================================================================
// Part 9: Comparison with Traditional Systems
// ===========================================================================

fn demo_comparison() {
    println_str("=== Part 9: Comparison with Traditional Systems ===");
    println_str("");

    println_str("Traditional Name-Based Systems:");
    println_str("  + Familiar model");
    println_str("  - Name collisions require namespacing");
    println_str("  - Version conflicts (dependency hell)");
    println_str("  - Coarse incremental compilation");
    println_str("  - Renames break dependent code");
    println_str("");

    println_str("Blood Content-Addressed System:");
    println_str("  + No name collisions (identity by hash)");
    println_str("  + Multiple versions coexist naturally");
    println_str("  + Fine-grained incremental compilation");
    println_str("  + Renames never break code");
    println_str("  + Global caching by hash");
    println_str("  - Learning curve for hash-based thinking");
    println_str("  - Tooling required for hash management");
    println_str("");

    println_str("Inspired by Unison language, adapted for systems programming.");
    println_str("Blood uses BLAKE3-256 (faster than Unison's SHA3-512).");
    println_str("");
}

// ===========================================================================
// Main Entry Point
// ===========================================================================

fn main() {
    println_str("================================================================");
    println_str("     Blood Content-Addressed Code Demonstration");
    println_str("     Identity by Content Hash, Not by Name");
    println_str("================================================================");
    println_str("");

    demo_hash_identity();
    demo_debruijn_indexing();
    demo_incremental_compilation();
    demo_deduplication();
    demo_reference_by_hash();
    demo_codebase_structure();
    demo_hash_display();
    demo_benefits_summary();
    demo_comparison();

    println_str("================================================================");
    println_str("     Key Takeaways");
    println_str("================================================================");
    println_str("");
    println_str("1. Every definition is identified by BLAKE3-256 hash of its AST");
    println_str("2. Variable names are replaced with de Bruijn indices");
    println_str("3. Same semantics = same hash, regardless of naming");
    println_str("4. Incremental builds check hash before recompiling");
    println_str("5. Identical code across modules is stored once");
    println_str("6. Dependencies reference hashes, enabling version coexistence");
    println_str("7. Names are metadata for humans, not identity for the compiler");
    println_str("");
    println_str("================================================================");
    println_str("     Demonstration Complete");
    println_str("================================================================");
}
