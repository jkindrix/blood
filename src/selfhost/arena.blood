// Blood Standard Library - Arena Allocation
//
// Implements a simple bump allocator for batch allocation patterns.
// Allocations within an arena are very fast (bump a pointer).
// Deallocation is bulk â€” reset the entire arena at once.
//
// This is useful for AST/HIR nodes that are allocated during a
// compilation phase and freed together when the phase completes.

// ============================================================
// Arena
// ============================================================

/// A bump-allocation arena.
///
/// Allocates memory in large chunks and hands out sequential slices.
/// Individual allocations cannot be freed; only the entire arena
/// can be reset.
pub struct Arena {
    /// The chunks of allocated memory.
    /// Each chunk is a Vec<u8> used as a byte buffer.
    pub chunks: Vec<Vec<u8>>,
    /// Current offset within the active chunk.
    pub current_offset: usize,
    /// Size of each chunk in bytes.
    pub chunk_size: usize,
    /// Total bytes allocated (including unused space in chunks).
    pub total_allocated: usize,
    /// Total bytes used by allocations.
    pub total_used: usize,
}

impl Arena {
    /// Creates a new arena with the given chunk size.
    pub fn new(chunk_size: usize) -> Arena {
        let first_chunk = make_chunk(chunk_size);
        let mut chunks: Vec<Vec<u8>> = Vec.new();
        chunks.push(first_chunk);

        Arena {
            chunks: chunks,
            current_offset: 0,
            chunk_size: chunk_size,
            total_allocated: chunk_size,
            total_used: 0,
        }
    }

    /// Creates an arena with default chunk size (4 KB).
    pub fn default_arena() -> Arena {
        Arena.new(4096)
    }

    /// Creates a large arena for bulk allocations (64 KB chunks).
    pub fn large() -> Arena {
        Arena.new(65536)
    }

    /// Allocates `size` bytes with the given alignment.
    /// Returns the byte offset within the arena (not a real pointer).
    ///
    /// This offset can be used with `arena_read` to access the data.
    pub fn alloc(self: &mut Arena, size: usize, align: usize) -> usize {
        // Align the current offset
        let aligned = align_up(self.current_offset, align);

        // Check if it fits in the current chunk
        if aligned + size <= self.chunk_size {
            let offset = self.total_used;
            self.current_offset = aligned + size;
            self.total_used = self.total_used + size;
            return offset;
        }

        // Need a new chunk
        let new_chunk_size = if size > self.chunk_size {
            size // Oversized allocation gets its own chunk
        } else {
            self.chunk_size
        };

        let new_chunk = make_chunk(new_chunk_size);
        self.chunks.push(new_chunk);
        self.current_offset = size;
        self.total_allocated = self.total_allocated + new_chunk_size;

        let offset = self.total_used;
        self.total_used = self.total_used + size;
        offset
    }

    /// Allocates space for a single value of the given size.
    pub fn alloc_one(self: &mut Arena, size: usize) -> usize {
        self.alloc(size, 8) // Default to 8-byte alignment
    }

    /// Resets the arena, freeing all allocations but keeping chunks.
    pub fn reset(self: &mut Arena) {
        self.current_offset = 0;
        self.total_used = 0;
        // Keep the first chunk, discard the rest
        if self.chunks.len() > 1 {
            let first = make_chunk(self.chunk_size);
            self.chunks = Vec.new();
            self.chunks.push(first);
            self.total_allocated = self.chunk_size;
        }
    }

    /// Returns the number of chunks allocated.
    pub fn chunk_count(self: &Arena) -> usize {
        self.chunks.len()
    }

    /// Returns the total bytes allocated (including waste).
    pub fn allocated_bytes(self: &Arena) -> usize {
        self.total_allocated
    }

    /// Returns the total bytes actually used.
    pub fn used_bytes(self: &Arena) -> usize {
        self.total_used
    }

    /// Returns the utilization ratio (0.0 to 1.0 as percentage * 100).
    pub fn utilization_percent(self: &Arena) -> u32 {
        if self.total_allocated == 0 {
            return 0;
        }
        ((self.total_used * 100) / self.total_allocated) as u32
    }
}

// ============================================================
// Typed Arena
// ============================================================

/// An arena specialized for allocating objects of a single type.
///
/// Tracks the count of allocated objects and provides typed
/// access patterns.
pub struct TypedArena {
    /// The underlying byte arena.
    pub inner: Arena,
    /// Size of each element in bytes.
    pub element_size: usize,
    /// Number of elements allocated.
    pub count: usize,
}

impl TypedArena {
    /// Creates a new typed arena for elements of the given size.
    pub fn new(element_size: usize) -> TypedArena {
        // Calculate chunk size to hold ~64 elements
        let chunk_size = element_size * 64;
        TypedArena {
            inner: Arena.new(chunk_size),
            element_size: element_size,
            count: 0,
        }
    }

    /// Allocates space for one element. Returns the element index.
    pub fn alloc(self: &mut TypedArena) -> usize {
        let _ = self.inner.alloc(self.element_size, 8);
        let idx = self.count;
        self.count = self.count + 1;
        idx
    }

    /// Returns the number of allocated elements.
    pub fn len(self: &TypedArena) -> usize {
        self.count
    }

    /// Resets the arena, freeing all elements.
    pub fn reset(self: &mut TypedArena) {
        self.inner.reset();
        self.count = 0;
    }
}

// ============================================================
// Helpers
// ============================================================

/// Creates a new chunk (zero-initialized byte vector).
fn make_chunk(size: usize) -> Vec<u8> {
    let mut chunk: Vec<u8> = Vec.new();
    for i in 0usize..size {
        chunk.push(0);
    }
    chunk
}

/// Aligns a value up to the given alignment.
fn align_up(val: usize, align: usize) -> usize {
    if align == 0 {
        return val;
    }
    let mask = align - 1;
    (val + mask) & (!mask)
}
