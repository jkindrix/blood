// Blood Self-Hosted Compiler - HashMap
//
// A simple hash map implementation using open addressing with linear probing.
// Provides O(1) average-case lookup, replacing O(n) linear scans.
//
// This is a specialized implementation for the compiler's needs:
// - HashMap<u64, u32> for simple value lookups
// - HashMap<u64, DefId> for method resolution
// - Efficient hashing helpers for strings and key pairs

// ============================================================
// Bucket types
// ============================================================

/// Bucket state for u32 values
pub enum BucketU32 {
    Empty,
    Occupied { key: u64, value: u32 },
    Deleted,
}

/// Bucket state for u64 values
pub enum BucketU64 {
    Empty,
    Occupied { key: u64, value: u64 },
    Deleted,
}

// ============================================================
// HashMapU64U32 - Maps u64 keys to u32 values
// ============================================================

/// Hash map from u64 keys to u32 values.
/// Used for: interner (string hash → symbol index), field resolution (span → field_idx)
pub struct HashMapU64U32 {
    buckets: Vec<BucketU32>,
    len: usize,
    capacity: usize,
}

impl HashMapU64U32 {
    /// Create a new empty hash map.
    pub fn new() -> HashMapU64U32 {
        HashMapU64U32 {
            buckets: Vec::new(),
            len: 0,
            capacity: 0,
        }
    }

    /// Create a hash map with initial capacity.
    pub fn with_capacity(cap: usize) -> HashMapU64U32 {
        let actual_cap = if cap < 16 { 16 as usize } else { cap };
        let mut buckets: Vec<BucketU32> = Vec::new();
        let mut i: usize = 0;
        while i < actual_cap {
            buckets.push(BucketU32::Empty);
            i = i + 1;
        }
        HashMapU64U32 {
            buckets,
            len: 0,
            capacity: actual_cap,
        }
    }

    /// Number of entries.
    pub fn len(self: &Self) -> usize {
        self.len
    }

    /// Ensure capacity, resizing if needed.
    fn ensure_capacity(self: &mut Self) {
        if self.capacity == 0 {
            self.capacity = 16;
            let mut i: usize = 0;
            while i < self.capacity {
                self.buckets.push(BucketU32::Empty);
                i = i + 1;
            }
            return;
        }
        if self.len * 4 >= self.capacity * 3 {
            self.resize();
        }
    }

    /// Double capacity and rehash.
    fn resize(self: &mut Self) {
        let new_cap = self.capacity * 2;
        let mut new_buckets: Vec<BucketU32> = Vec::new();
        let mut i: usize = 0;
        while i < new_cap {
            new_buckets.push(BucketU32::Empty);
            i = i + 1;
        }

        i = 0;
        while i < self.capacity {
            match &self.buckets[i] {
                BucketU32::Occupied { key, value } => {
                    let hash = hash_u64(&key);
                    let mut idx = (hash as usize) % new_cap;
                    let mut found = false;
                    while !found {
                        match &new_buckets[idx] {
                            BucketU32::Empty => {
                                new_buckets[idx] = BucketU32::Occupied { key: key, value: value };
                                found = true;
                            }
                            _ => {
                                idx = (idx + 1) % new_cap;
                            }
                        }
                    }
                }
                _ => {}
            }
            i = i + 1;
        }
        self.buckets = new_buckets;
        self.capacity = new_cap;
    }

    /// Insert a key-value pair.
    pub fn insert(self: &mut Self, key: u64, value: u32) {
        self.ensure_capacity();
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        let mut probes: usize = 0;
        while probes < self.capacity {
            match &self.buckets[idx] {
                BucketU32::Empty => {
                    self.buckets[idx] = BucketU32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32::Deleted => {
                    self.buckets[idx] = BucketU32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU32::Occupied { key, value };
                        return;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
            probes = probes + 1;
        }
    }

    /// Get a value by key.
    pub fn get(self: &Self, key: u64) -> Option<u32> {
        if self.capacity == 0 {
            return Option::None;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        let mut probes: usize = 0;
        while probes < self.capacity {
            match &self.buckets[idx] {
                BucketU32::Empty => {
                    return Option::None;
                }
                BucketU32::Deleted => {}
                BucketU32::Occupied { key: existing_key, value } => {
                    if existing_key == key {
                        return Option::Some(value);
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
            probes = probes + 1;
        }
        Option::None
    }

    /// Check if key exists.
    pub fn contains_key(self: &Self, key: u64) -> bool {
        match self.get(key) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }
}

// ============================================================
// HashMapU64U64 - Maps u64 keys to u64 values
// ============================================================

/// Hash map from u64 keys to u64 values.
/// Used for: method resolution ((body_def_id, span_start) hash → def_id)
pub struct HashMapU64U64 {
    buckets: Vec<BucketU64>,
    len: usize,
    capacity: usize,
}

impl HashMapU64U64 {
    /// Create a new empty hash map.
    pub fn new() -> HashMapU64U64 {
        HashMapU64U64 {
            buckets: Vec::new(),
            len: 0,
            capacity: 0,
        }
    }

    /// Create a hash map with initial capacity.
    pub fn with_capacity(cap: usize) -> HashMapU64U64 {
        let actual_cap = if cap < 16 { 16 as usize } else { cap };
        let mut buckets: Vec<BucketU64> = Vec::new();
        let mut i: usize = 0;
        while i < actual_cap {
            buckets.push(BucketU64::Empty);
            i = i + 1;
        }
        HashMapU64U64 {
            buckets,
            len: 0,
            capacity: actual_cap,
        }
    }

    /// Number of entries.
    pub fn len(self: &Self) -> usize {
        self.len
    }

    /// Ensure capacity, resizing if needed.
    fn ensure_capacity(self: &mut Self) {
        if self.capacity == 0 {
            self.capacity = 16;
            let mut i: usize = 0;
            while i < self.capacity {
                self.buckets.push(BucketU64::Empty);
                i = i + 1;
            }
            return;
        }
        if self.len * 4 >= self.capacity * 3 {
            self.resize();
        }
    }

    /// Double capacity and rehash.
    fn resize(self: &mut Self) {
        let new_cap = self.capacity * 2;
        let mut new_buckets: Vec<BucketU64> = Vec::new();
        let mut i: usize = 0;
        while i < new_cap {
            new_buckets.push(BucketU64::Empty);
            i = i + 1;
        }

        i = 0;
        while i < self.capacity {
            match &self.buckets[i] {
                BucketU64::Occupied { key, value } => {
                    let hash = hash_u64(&key);
                    let mut idx = (hash as usize) % new_cap;
                    let mut found = false;
                    while !found {
                        match &new_buckets[idx] {
                            BucketU64::Empty => {
                                new_buckets[idx] = BucketU64::Occupied { key: key, value: value };
                                found = true;
                            }
                            _ => {
                                idx = (idx + 1) % new_cap;
                            }
                        }
                    }
                }
                _ => {}
            }
            i = i + 1;
        }
        self.buckets = new_buckets;
        self.capacity = new_cap;
    }

    /// Insert a key-value pair.
    pub fn insert(self: &mut Self, key: u64, value: u64) {
        self.ensure_capacity();
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        let mut probes: usize = 0;
        while probes < self.capacity {
            match &self.buckets[idx] {
                BucketU64::Empty => {
                    self.buckets[idx] = BucketU64::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU64::Deleted => {
                    self.buckets[idx] = BucketU64::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU64::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU64::Occupied { key, value };
                        return;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
            probes = probes + 1;
        }
    }

    /// Get a value by key.
    pub fn get(self: &Self, key: u64) -> Option<u64> {
        if self.capacity == 0 {
            return Option::None;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        let mut probes: usize = 0;
        while probes < self.capacity {
            match &self.buckets[idx] {
                BucketU64::Empty => {
                    return Option::None;
                }
                BucketU64::Deleted => {}
                BucketU64::Occupied { key: existing_key, value } => {
                    if existing_key == key {
                        return Option::Some(value);
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
            probes = probes + 1;
        }
        Option::None
    }

    /// Check if key exists.
    pub fn contains_key(self: &Self, key: u64) -> bool {
        match self.get(key) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }
}

// ============================================================
// Hash functions
// ============================================================

/// FNV-1a hash for u64.
pub fn hash_u64(v: &u64) -> u64 {
    let mut h: u64 = 14695981039346656037;
    let val = *v;
    let mut i: u32 = 0;
    while i < 8 {
        h = h ^ ((val >> (i * 8)) & 255);
        h = h * 1099511628211;
        i = i + 1;
    }
    h
}

/// FNV-1a hash for a byte slice (string).
pub fn hash_bytes(bytes: &Vec<u8>) -> u64 {
    let mut h: u64 = 14695981039346656037;
    let mut i: usize = 0;
    while i < bytes.len() {
        h = h ^ (bytes[i] as u64);
        h = h * 1099511628211;
        i = i + 1;
    }
    h
}

/// Hash a string by its bytes.
pub fn hash_str(s: &str) -> u64 {
    let bytes = s.as_bytes();
    let mut h: u64 = 14695981039346656037;
    let mut i: usize = 0;
    while i < bytes.len() {
        h = h ^ (bytes[i] as u64);
        h = h * 1099511628211;
        i = i + 1;
    }
    h
}

/// Hash a String by its bytes.
pub fn hash_string(s: &String) -> u64 {
    hash_str(s.as_str())
}

/// Combine two u32 values into a single u64 key for hashing.
/// Used for (body_def_id, span_start) pairs.
pub fn combine_u32_usize(a: u32, b: usize) -> u64 {
    ((a as u64) << 32) | ((b as u64) & 0xFFFFFFFF)
}
