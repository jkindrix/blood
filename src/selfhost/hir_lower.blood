// Blood Self-Hosted Compiler - HIR Lowering
//
// This module provides the AST-to-HIR lowering pipeline. It transforms
// a parsed AST into the High-level Intermediate Representation (HIR)
// with resolved names and semantic types.
//
// The lowering process:
// 1. Create LoweringCtx with a fresh Resolver
// 2. First pass: Register all type names (structs, enums, traits, effects)
// 3. Second pass: Register all other declarations (functions, consts, statics)
// 4. Third pass: Lower all declarations to HIR items
// 5. Fourth pass: Lower all function bodies to HIR bodies
// 6. Find entry point (main function)
// 7. Return HIR Crate or errors
//
// This module orchestrates the pipeline and handles registration phases.
// Type lowering is in hir_lower_type.blood.
// Item lowering is in hir_lower_item.blood.
// Context types are in hir_lower_ctx.blood.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod resolve;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_item;
mod hir_lower_expr;
mod hir_lower_body;
mod interner;
mod source;
mod parser;
mod type_intern;

// ============================================================
// Main Lowering Pipeline
// ============================================================

/// Lower an AST Program to an HIR Crate.
pub fn lower_program(program: &ast::Program, source: &str) -> hir_lower_ctx::LowerResult {
    lower_program_with_base_dir(program, common::make_string("."), source, Option::None)
}

/// Lower an AST Program to an HIR Crate with a specified base directory.
/// The base directory is used for resolving external module paths.
/// stdlib_path optionally overrides the path for `mod std;` resolution.
pub fn lower_program_with_base_dir(program: &ast::Program, base_dir: String, source: &str, stdlib_path: Option<String>) -> hir_lower_ctx::LowerResult {
    let mut ctx = hir_lower_ctx::LoweringCtx::with_base_dir(base_dir, common::make_string(source));
    ctx.stdlib_path = stdlib_path;

    // Allocate root module DefId
    let root_def_id = ctx.alloc_def_id();

    // Phase 1: Register type names (structs, enums, traits, effects)
    register_type_names(&mut ctx, &program.declarations);

    // Phase 1b: Register builtin stdlib types (String, Vec, Option, Box, HashMap)
    // Only registers names not already defined by user code
    register_builtin_types(&mut ctx);

    // Phase 2: Register other declarations (functions, consts, statics)
    register_declarations(&mut ctx, &program.declarations);

    // Phase 2b: Register builtin runtime functions (file I/O, args, print, etc.)
    // This runs AFTER Phase 2 so user-defined functions (e.g., a custom `panic`)
    // take priority — register_one_builtin silently skips names already defined.
    register_builtin_functions(&mut ctx);

    // Check for errors from registration
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 3a: Lower external module declarations first, so their enum
    // variants and impl methods are registered before the current file's
    // declarations reference them.
    // The cache stores parsed modules for reuse in Phase 4b.
    let mut parsed_module_cache: Vec<CachedParsedModule> = Vec::new();
    lower_external_module_declarations(&mut ctx, &mut parsed_module_cache);

    // Phase 3a.25: Auto-import stdlib prelude when --stdlib-path is set.
    // Injects prelude's public items into root scope so programs don't need
    // explicit `use std.prelude::*;` or individual imports for common items.
    inject_stdlib_prelude(&mut ctx);

    // Phase 3a.5: Resolve use imports (e.g., `use module::item;`)
    // This must run after external modules are loaded (Phase 3a) so that
    // lookup_in_parent can find re-exported items.
    resolve_imports(&mut ctx, &program.imports);

    // Phase 3b: Lower current file's declarations to HIR items
    hir_lower_item::lower_declarations(&mut ctx, &program.declarations);

    // Check for errors from item lowering
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Phase 4: Lower function bodies to HIR bodies
    lower_fn_bodies(&mut ctx, &program.declarations);

    // Record how many bodies are from the main file before adding external module bodies.
    // The type checker should only check these bodies; external module bodies may have
    // unresolved cross-module paths that produce false errors.
    let main_body_count = ctx.bodies.len();

    // Phase 4b: Lower external module function bodies (reuses cached parses)
    lower_external_module_fn_bodies(&mut ctx, &parsed_module_cache);

    // Check for errors from body lowering
    if ctx.has_errors() {
        return hir_lower_ctx::LowerResult::failure(ctx.diagnostics);
    }

    // Build the Crate
    let crate_data = hir::Crate {
        entry: ctx.entry_point,
        root_module: root_def_id,
        item_count: ctx.items.len() as u32,
        body_count: ctx.bodies.len() as u32,
    };

    // Collect all function-like DefIds from the resolver for codegen name registration.
    // This catches functions that are registered in the resolver but may not appear
    // as top-level items (e.g., builtin children, struct fields used as constructors,
    // or functions from modules whose items aren't fully traversed).
    collect_resolver_fn_defs(&mut ctx);

    // Transfer items, item_index, and bodies to the result
    let next_ty_var = ctx.next_ty_var;
    let next_def_id = ctx.next_def_id;
    let turbofish_entries = ctx.turbofish_const_entries;
    let mut result = hir_lower_ctx::LowerResult::success_with_data(
        crate_data,
        ctx.items,
        ctx.item_index,
        ctx.bodies,
        main_body_count,
        next_ty_var,
        next_def_id,
        ctx.builtin_string_def,
        ctx.builtin_vec_def,
        ctx.builtin_option_def,
        ctx.builtin_box_def,
        ctx.builtin_hashmap_def,
        ctx.builtin_result_def,
        ctx.builtin_option_some_def,
        ctx.builtin_option_none_def,
        ctx.builtin_result_ok_def,
        ctx.builtin_result_err_def,
        ctx.interner,
        ctx.builtin_fn_defs,
    );
    result.turbofish_const_entries = turbofish_entries;
    result
}

// ============================================================
// Import Resolution
// ============================================================

/// Resolve `use module::item;` imports by creating local scope bindings.
/// For `Import::Simple { path: [module, item] }`, look up `module` then
/// find `item` as a child and bind it in the current scope.
fn resolve_imports(ctx: &mut hir_lower_ctx::LoweringCtx, imports: &Vec<ast::Import>) {
    for i in 0usize..imports.len() {
        resolve_import(ctx, &imports[i]);
    }
}

fn resolve_import(ctx: &mut hir_lower_ctx::LoweringCtx, imp: &ast::Import) {
    let dummy = hir_def::DefId::new(0);
    match imp {
        &ast::Import::Simple { ref path, ref alias, span: _ } => {
            if path.segments.len() < 2 {
                return;
            }
            let last_idx = path.segments.len() - 1;
            let resolved = resolve_module_path_segments(ctx, dummy, path, last_idx, true);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                let item_str = ctx.span_to_string(path.segments[last_idx].span);
                let item_sym = ctx.intern(item_str.as_str());
                let item_def = ctx.resolver.lookup_in_parent(mod_def_id, item_sym);
                if item_def.is_some() {
                    let item_def_id = item_def.unwrap();
                    let bind_sym = match alias {
                        &Option::Some(ref alias_name) => {
                            let alias_str = ctx.span_to_string(alias_name.span);
                            ctx.intern(alias_str.as_str())
                        }
                        &Option::None => {
                            item_sym
                        }
                    };
                    let binding = resolve::Binding::def(item_def_id);
                    ctx.resolver.define(bind_sym, binding);
                }
            }
        }
        &ast::Import::Group { ref path, ref items, span: _ } => {
            let resolved = resolve_module_path_segments(ctx, dummy, path, path.segments.len(), true);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                for gi in 0usize..items.len() {
                    let item_str = ctx.span_to_string(items[gi].name.span);
                    let item_sym = ctx.intern(item_str.as_str());
                    let item_def = ctx.resolver.lookup_in_parent(mod_def_id, item_sym);
                    if item_def.is_some() {
                        let item_def_id = item_def.unwrap();
                        let bind_sym = match &items[gi].alias {
                            &Option::Some(ref alias_name) => {
                                let alias_str = ctx.span_to_string(alias_name.span);
                                ctx.intern(alias_str.as_str())
                            }
                            &Option::None => {
                                item_sym
                            }
                        };
                        let binding = resolve::Binding::def(item_def_id);
                        ctx.resolver.define(bind_sym, binding);
                    }
                }
            }
        }
        &ast::Import::Glob { ref path, span: _ } => {
            let resolved = resolve_module_path_segments(ctx, dummy, path, path.segments.len(), true);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                let children = ctx.resolver.get_children_of_parent(mod_def_id);
                for ci in 0usize..children.len() {
                    let child_name = children[ci].name;
                    let child_def = children[ci].def_id;
                    let binding = resolve::Binding::def(child_def);
                    ctx.resolver.define(child_name, binding);
                }
            }
        }
    }
}

// ============================================================
// Phase 1: Register Type Names
// ============================================================

/// First pass: register all type names so they can be referenced.
fn register_type_names(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    for i in 0usize..decls.len() {
        register_type_name(ctx, &decls[i]);
    }
}

/// Register a single declaration's type name if applicable.
fn register_type_name(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Struct,
                    name_symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Enum(ref e) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(e.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    e.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Enum,
                    name_symbol,
                    e.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Trait(ref t) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(t.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    t.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Trait,
                    name_symbol,
                    t.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Effect(ref eff) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(eff.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    eff.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Effect,
                    name_symbol,
                    eff.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(ta.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    ta.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::TypeAlias,
                    name_symbol,
                    ta.name.span,
                    Option::None,
                );
            }
        }
        // Non-type declarations handled in phase 2
        &ast::Declaration::Function(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(ref b) => {
            // Register bridge name as a module-like namespace (e.g., "Libc")
            // so that qualified paths like Libc::abs resolve correctly.
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(b.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    b.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Module,
                    name_symbol,
                    b.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Inline module: register the module DefId and nested type names
                    let def_id = ctx.alloc_def_id();
                    // Re-intern the name from span to ensure consistent symbol indices
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_symbol = ctx.intern(name_str.as_str());
                    let success = ctx.resolver.define_global(name_symbol, def_id);
                    if !success {
                        ctx.error(
                            hir::DiagnosticCode::E0101,
                            common::make_string("duplicate definition"),
                            m.name.span,
                        );
                    } else {
                        ctx.resolver.register_def_info(
                            def_id,
                            hir_def::DefKind::Module,
                            name_symbol,
                            m.name.span,
                            Option::None,
                        );
                        // Recursively register nested type names
                        register_module_type_names(ctx, def_id, declarations);
                    }
                }
                &Option::None => {
                    // External module - load from file
                    load_external_module(ctx, m.name.symbol, m.name.span, m.vis, m.span);
                }
            }
        }
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(_) => {} // Handled in register_module_type_name
    }
}

// ============================================================
// Builtin Type Registration
// ============================================================

/// Registers builtin stdlib types (String, Vec, Option, Box, HashMap) in the
/// resolver so they can be found during type lowering. Only registers a name
/// if it has not already been defined by user code (Phase 1). This prevents
/// E0102 "unknown type" errors for common stdlib types.
///
/// These types are registered as ADTs with synthetic DefIds. Full method/field
/// support for these types requires additional work, but recognizing them in
/// type position allows the compiler to proceed past type resolution.
fn register_builtin_types(ctx: &mut hir_lower_ctx::LoweringCtx) {
    let dummy_span = common::Span::dummy();

    // String — struct-like owned string type
    ctx.builtin_string_def = Option::Some(register_one_builtin(ctx, "String", hir_def::DefKind::Struct, dummy_span));

    // Vec — struct-like growable array
    ctx.builtin_vec_def = Option::Some(register_one_builtin(ctx, "Vec", hir_def::DefKind::Struct, dummy_span));

    // Option — enum with Some/None variants
    ctx.builtin_option_def = Option::Some(register_one_builtin(ctx, "Option", hir_def::DefKind::Enum, dummy_span));

    // Box — struct-like heap-allocated pointer
    ctx.builtin_box_def = Option::Some(register_one_builtin(ctx, "Box", hir_def::DefKind::Struct, dummy_span));

    // HashMap — struct-like key-value map
    ctx.builtin_hashmap_def = Option::Some(register_one_builtin(ctx, "HashMap", hir_def::DefKind::Struct, dummy_span));

    // Result — enum with Ok/Err variants
    ctx.builtin_result_def = Option::Some(register_one_builtin(ctx, "Result", hir_def::DefKind::Enum, dummy_span));

    // Register associated functions and variant constructors
    register_builtin_children(ctx);
}

/// Registers a single builtin type if not already defined. Returns the DefId.
fn register_one_builtin(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    name: &str,
    kind: hir_def::DefKind,
    span: common::Span,
) -> hir_def::DefId {
    let sym = ctx.intern(name);
    let def_id = ctx.alloc_def_id();
    let success = ctx.resolver.define_global(sym, def_id);
    if success {
        ctx.resolver.register_def_info(def_id, kind, sym, span, Option::None);
    }
    def_id
}

/// Registers associated functions and variant constructors for builtin types.
fn register_builtin_children(ctx: &mut hir_lower_ctx::LoweringCtx) {
    let dummy_span = common::Span::dummy();

    // === String ===
    match ctx.builtin_string_def {
        Option::Some(parent) => {
            let d = register_builtin_child(ctx, parent, "new", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d.index, common::make_string("string_new")));
            let d2 = register_builtin_child(ctx, parent, "from", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d2.index, common::make_string("string_from")));
            let d3 = register_builtin_child(ctx, parent, "with_capacity", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d3.index, common::make_string("string_with_capacity")));
        }
        Option::None => {}
    }

    // === Vec ===
    match ctx.builtin_vec_def {
        Option::Some(parent) => {
            let d = register_builtin_child(ctx, parent, "new", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d.index, common::make_string("vec_new")));
            let d2 = register_builtin_child(ctx, parent, "with_capacity", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d2.index, common::make_string("vec_with_capacity")));
        }
        Option::None => {}
    }

    // === Option ===
    match ctx.builtin_option_def {
        Option::Some(parent) => {
            let none_def = register_builtin_variant(ctx, parent, "None", dummy_span, 0);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(none_def.index, common::make_string("option_none_ctor")));
            ctx.builtin_option_none_def = Option::Some(none_def);
            let some_def = register_builtin_variant(ctx, parent, "Some", dummy_span, 1);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(some_def.index, common::make_string("option_some_ctor")));
            ctx.builtin_option_some_def = Option::Some(some_def);
            // Also register as top-level names for bare Some/None usage
            let some_sym = ctx.intern("Some");
            ctx.resolver.define_global(some_sym, some_def);
            let none_sym = ctx.intern("None");
            ctx.resolver.define_global(none_sym, none_def);
        }
        Option::None => {}
    }

    // === Box ===
    match ctx.builtin_box_def {
        Option::Some(parent) => {
            let d = register_builtin_child(ctx, parent, "new", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d.index, common::make_string("box_new")));
        }
        Option::None => {}
    }

    // === HashMap ===
    match ctx.builtin_hashmap_def {
        Option::Some(parent) => {
            let d = register_builtin_child(ctx, parent, "new", hir_def::DefKind::Fn, dummy_span);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(d.index, common::make_string("hashmap_new")));
        }
        Option::None => {}
    }

    // === Result ===
    match ctx.builtin_result_def {
        Option::Some(parent) => {
            let ok_def = register_builtin_variant(ctx, parent, "Ok", dummy_span, 0);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(ok_def.index, common::make_string("result_ok_ctor")));
            ctx.builtin_result_ok_def = Option::Some(ok_def);
            let err_def = register_builtin_variant(ctx, parent, "Err", dummy_span, 1);
            ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(err_def.index, common::make_string("result_err_ctor")));
            ctx.builtin_result_err_def = Option::Some(err_def);
            // Also register as top-level names for bare Ok/Err usage
            let ok_sym = ctx.intern("Ok");
            ctx.resolver.define_global(ok_sym, ok_def);
            let err_sym = ctx.intern("Err");
            ctx.resolver.define_global(err_sym, err_def);
        }
        Option::None => {}
    }
}

/// Registers a child function or variant under a parent builtin type.
fn register_builtin_child(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent: hir_def::DefId,
    name: &str,
    kind: hir_def::DefKind,
    span: common::Span,
) -> hir_def::DefId {
    let sym = ctx.intern(name);
    let def_id = ctx.alloc_def_id();
    ctx.resolver.register_def_info(def_id, kind, sym, span, Option::Some(parent));
    def_id
}

/// Registers an enum variant under a parent builtin enum type.
/// Uses register_variant_def_info to set the variant_index in DefInfo.
fn register_builtin_variant(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent: hir_def::DefId,
    name: &str,
    span: common::Span,
    variant_index: u32,
) -> hir_def::DefId {
    let sym = ctx.intern(name);
    let def_id = ctx.alloc_def_id();
    ctx.resolver.register_variant_def_info(def_id, sym, span, parent, variant_index);
    def_id
}

// ============================================================
// Builtin Type Construction Helpers
// ============================================================

/// Constructs &str type for builtin signatures.
fn bi_ref_str() -> type_intern::TyId {
    type_intern::type_interner().mk_ref(type_intern::CommonTypes::str_ty(), false)
}

fn bi_i8() -> type_intern::TyId { type_intern::CommonTypes::i8_ty() }
fn bi_i16() -> type_intern::TyId { type_intern::CommonTypes::i16_ty() }
fn bi_i64() -> type_intern::TyId { type_intern::CommonTypes::i64_ty() }
fn bi_i128() -> type_intern::TyId { type_intern::CommonTypes::i128_ty() }
fn bi_u16() -> type_intern::TyId { type_intern::CommonTypes::u16_ty() }
fn bi_u32() -> type_intern::TyId { type_intern::CommonTypes::u32_ty() }
fn bi_u64() -> type_intern::TyId { type_intern::CommonTypes::u64_ty() }
fn bi_u128() -> type_intern::TyId { type_intern::CommonTypes::u128_ty() }
fn bi_f32() -> type_intern::TyId { type_intern::CommonTypes::f32_ty() }
fn bi_f64() -> type_intern::TyId { type_intern::CommonTypes::f64_ty() }
fn bi_char() -> type_intern::TyId { type_intern::CommonTypes::char_ty() }

/// Constructs an ADT type with no type arguments (e.g. String).
fn bi_adt(def_id: hir_def::DefId) -> type_intern::TyId {
    type_intern::type_interner().mk_adt(def_id, type_intern::CommonTyLists::empty())
}

// ============================================================
// Builtin Parameter List Helpers
// ============================================================

fn bi_params_0() -> Vec<type_intern::TyId> { Vec::new() }

fn bi_params_1(a: type_intern::TyId) -> Vec<type_intern::TyId> {
    let mut v: Vec<type_intern::TyId> = Vec::new();
    v.push(a);
    v
}

fn bi_params_2(a: type_intern::TyId, b: type_intern::TyId) -> Vec<type_intern::TyId> {
    let mut v: Vec<type_intern::TyId> = Vec::new();
    v.push(a);
    v.push(b);
    v
}

fn bi_params_3(a: type_intern::TyId, b: type_intern::TyId, c: type_intern::TyId) -> Vec<type_intern::TyId> {
    let mut v: Vec<type_intern::TyId> = Vec::new();
    v.push(a);
    v.push(b);
    v.push(c);
    v
}

// ============================================================
// Builtin Foreign Function Registration
// ============================================================

/// Registers a single builtin function as both a global name (for name resolution)
/// and a ForeignFn item (for type checking via the Foreign pipeline).
fn register_builtin_fn(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    foreign_items: &mut Vec<hir_item::ForeignItem>,
    name: &str,
    param_tys: Vec<type_intern::TyId>,
    return_ty: type_intern::TyId,
) {
    let sym = ctx.intern(name);
    let def_id = ctx.alloc_def_id();
    let success = ctx.resolver.define_global(sym, def_id);
    if success {
        let dummy_span = common::Span::dummy();
        ctx.resolver.register_def_info(def_id, hir_def::DefKind::Fn, sym, dummy_span, Option::None);
        let spanned_name = common::SpannedSymbol { symbol: sym, span: dummy_span };
        let foreign_fn = hir_item::ForeignFn::new(
            def_id, spanned_name, param_tys, return_ty, false, dummy_span,
        );
        foreign_items.push(hir_item::ForeignItem::Fn(foreign_fn));
        // Register in builtin_fn_defs so collect_resolver_fn_defs won't overwrite
        // with a mangled name. Standalone builtins use their bare name as the
        // runtime function name (e.g., "print", "panic", "file_read_to_string").
        ctx.builtin_fn_defs.push(hir_lower_ctx::BuiltinFnDef::new(def_id.index, common::make_string(name)));
    }
}

/// Registers all blood-rust runtime builtin functions.
///
/// Each builtin gets:
/// 1. A DefId and global name in the resolver (for name resolution)
/// 2. A ForeignFn item with typed signature (for type checking)
///
/// The ForeignFn items are wrapped in a ForeignDef and added to ctx.items,
/// where the type checker's collect_item_signatures will register their
/// signatures via the Foreign pipeline.
///
/// This matches all 101 free-standing builtins from blood-rust's builtins.rs.
/// When bridge block parsing is implemented, these registrations will be
/// replaced by parsed `bridge "C" runtime { ... }` declarations.
fn register_builtin_functions(ctx: &mut hir_lower_ctx::LoweringCtx) {
    let mut items: Vec<hir_item::ForeignItem> = Vec::new();

    // === Console Output ===
    register_builtin_fn(ctx, &mut items, "print", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_str", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_str", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "eprint", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "eprintln", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "eprint_str", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "eprintln_str", bi_params_1(bi_ref_str()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_int", bi_params_1(type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_int", bi_params_1(type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_i64", bi_params_1(bi_i64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_i64", bi_params_1(bi_i64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_u64", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_u64", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_f64", bi_params_1(bi_f64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_f64", bi_params_1(bi_f64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_f32", bi_params_1(bi_f32()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_f32", bi_params_1(bi_f32()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_bool", bi_params_1(type_intern::CommonTypes::bool_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_bool", bi_params_1(type_intern::CommonTypes::bool_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_char", bi_params_1(bi_char()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_char", bi_params_1(bi_char()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_newline", bi_params_0(), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_f64_prec", bi_params_2(bi_f64(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_f64_prec", bi_params_2(bi_f64(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_f32_prec", bi_params_2(bi_f32(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "println_f32_prec", bi_params_2(bi_f32(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());

    // === Control Flow / Assertions ===
    register_builtin_fn(ctx, &mut items, "panic", bi_params_1(bi_ref_str()), type_intern::CommonTypes::never());
    register_builtin_fn(ctx, &mut items, "assert", bi_params_1(type_intern::CommonTypes::bool_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "assert_eq_int", bi_params_2(type_intern::CommonTypes::i32_ty(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "assert_eq_bool", bi_params_2(type_intern::CommonTypes::bool_ty(), type_intern::CommonTypes::bool_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "unreachable", bi_params_0(), type_intern::CommonTypes::never());
    register_builtin_fn(ctx, &mut items, "todo", bi_params_0(), type_intern::CommonTypes::never());
    register_builtin_fn(ctx, &mut items, "process_exit", bi_params_1(type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::never());

    // === Memory ===
    register_builtin_fn(ctx, &mut items, "size_of_i32", bi_params_0(), bi_i64());
    register_builtin_fn(ctx, &mut items, "size_of_i64", bi_params_0(), bi_i64());
    register_builtin_fn(ctx, &mut items, "size_of_bool", bi_params_0(), bi_i64());
    register_builtin_fn(ctx, &mut items, "alloc", bi_params_1(bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc", bi_params_2(bi_u64(), bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "free", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "memcpy", bi_params_3(bi_u64(), bi_u64(), bi_u64()), bi_u64());

    // === Pointer Operations ===
    register_builtin_fn(ctx, &mut items, "ptr_read_i32", bi_params_1(bi_u64()), type_intern::CommonTypes::i32_ty());
    register_builtin_fn(ctx, &mut items, "ptr_write_i32", bi_params_2(bi_u64(), type_intern::CommonTypes::i32_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "ptr_read_i64", bi_params_1(bi_u64()), bi_i64());
    register_builtin_fn(ctx, &mut items, "ptr_write_i64", bi_params_2(bi_u64(), bi_i64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "ptr_read_u64", bi_params_1(bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "ptr_write_u64", bi_params_2(bi_u64(), bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "ptr_read_u8", bi_params_1(bi_u64()), type_intern::CommonTypes::u8_ty());
    register_builtin_fn(ctx, &mut items, "ptr_write_u8", bi_params_2(bi_u64(), type_intern::CommonTypes::u8_ty()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "ptr_read_f64", bi_params_1(bi_u64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "ptr_write_f64", bi_params_2(bi_u64(), bi_f64()), type_intern::CommonTypes::unit());

    // === String Operations ===
    register_builtin_fn(ctx, &mut items, "str_len", bi_params_1(bi_ref_str()), bi_i64());
    register_builtin_fn(ctx, &mut items, "str_eq", bi_params_2(bi_ref_str(), bi_ref_str()), type_intern::CommonTypes::bool_ty());
    register_builtin_fn(ctx, &mut items, "str_concat", bi_params_2(bi_ref_str(), bi_ref_str()), bi_ref_str());

    // === Input ===
    register_builtin_fn(ctx, &mut items, "read_int", bi_params_0(), type_intern::CommonTypes::i32_ty());

    // === Conversion ===
    register_builtin_fn(ctx, &mut items, "i8_to_string", bi_params_1(bi_i8()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "i16_to_string", bi_params_1(bi_i16()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "int_to_string", bi_params_1(type_intern::CommonTypes::i32_ty()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "i64_to_string", bi_params_1(bi_i64()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "i128_to_string", bi_params_1(bi_i128()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "u8_to_string", bi_params_1(type_intern::CommonTypes::u8_ty()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "u16_to_string", bi_params_1(bi_u16()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "u32_to_string", bi_params_1(bi_u32()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "u64_to_string", bi_params_1(bi_u64()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "u128_to_string", bi_params_1(bi_u128()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "bool_to_string", bi_params_1(type_intern::CommonTypes::bool_ty()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "char_to_string", bi_params_1(bi_char()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "f32_to_string", bi_params_1(bi_f32()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "f64_to_string", bi_params_1(bi_f64()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "i32_to_i64", bi_params_1(type_intern::CommonTypes::i32_ty()), bi_i64());
    register_builtin_fn(ctx, &mut items, "i64_to_i32", bi_params_1(bi_i64()), type_intern::CommonTypes::i32_ty());

    // === Math (LLVM Intrinsics) ===
    register_builtin_fn(ctx, &mut items, "sqrt", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "sqrt_f32", bi_params_1(bi_f32()), bi_f32());
    register_builtin_fn(ctx, &mut items, "abs", bi_params_1(bi_f64()), bi_f64());
    // Rename runtime symbol from "abs" to "abs_f64" to avoid collision with C's abs(int)
    // when bridge FFI is used. The Blood-level name "abs" is preserved for user code.
    if ctx.builtin_fn_defs.len() > 0 {
        let abs_idx = ctx.builtin_fn_defs.len() - 1;
        ctx.builtin_fn_defs[abs_idx].runtime_name = common::make_string("abs_f64");
    }
    register_builtin_fn(ctx, &mut items, "abs_f32", bi_params_1(bi_f32()), bi_f32());
    register_builtin_fn(ctx, &mut items, "floor", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "ceil", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "sin", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "cos", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "exp", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "log", bi_params_1(bi_f64()), bi_f64());
    register_builtin_fn(ctx, &mut items, "pow", bi_params_2(bi_f64(), bi_f64()), bi_f64());

    // === File I/O ===
    register_builtin_fn(ctx, &mut items, "file_open", bi_params_2(bi_ref_str(), bi_ref_str()), bi_i64());
    register_builtin_fn(ctx, &mut items, "file_read", bi_params_3(bi_i64(), bi_u64(), bi_u64()), bi_i64());
    register_builtin_fn(ctx, &mut items, "file_write", bi_params_3(bi_i64(), bi_u64(), bi_u64()), bi_i64());
    register_builtin_fn(ctx, &mut items, "file_close", bi_params_1(bi_i64()), type_intern::CommonTypes::i32_ty());
    register_builtin_fn(ctx, &mut items, "file_read_to_string", bi_params_1(bi_ref_str()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "file_write_string", bi_params_2(bi_ref_str(), bi_ref_str()), type_intern::CommonTypes::bool_ty());
    register_builtin_fn(ctx, &mut items, "file_append_string", bi_params_2(bi_ref_str(), bi_ref_str()), type_intern::CommonTypes::bool_ty());
    register_builtin_fn(ctx, &mut items, "file_exists", bi_params_1(bi_ref_str()), type_intern::CommonTypes::bool_ty());
    register_builtin_fn(ctx, &mut items, "file_delete", bi_params_1(bi_ref_str()), type_intern::CommonTypes::bool_ty());
    register_builtin_fn(ctx, &mut items, "file_size", bi_params_1(bi_ref_str()), bi_i64());

    // === System ===
    register_builtin_fn(ctx, &mut items, "system", bi_params_1(bi_ref_str()), type_intern::CommonTypes::i32_ty());

    // === Environment ===
    register_builtin_fn(ctx, &mut items, "env_get", bi_params_1(bi_ref_str()), bi_ref_str());

    // === Timing ===
    register_builtin_fn(ctx, &mut items, "blood_clock_millis", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "blood_clock_nanos", bi_params_0(), bi_u64());

    // === Bit Reinterpretation ===
    register_builtin_fn(ctx, &mut items, "blood_float64_to_bits", bi_params_1(bi_f64()), bi_u64());

    // === Command-line Arguments ===
    register_builtin_fn(ctx, &mut items, "args_count", bi_params_0(), type_intern::CommonTypes::i32_ty());
    register_builtin_fn(ctx, &mut items, "args_get", bi_params_1(type_intern::CommonTypes::i32_ty()), bi_ref_str());
    register_builtin_fn(ctx, &mut items, "args_join", bi_params_0(), bi_ref_str());

    // === Builtins requiring String type ===
    match ctx.builtin_string_def {
        Option::Some(string_def) => {
            register_builtin_fn(ctx, &mut items, "read_line", bi_params_0(), bi_adt(string_def));
        }
        Option::None => {}
    }

    // === Region Memory Management ===
    register_builtin_fn(ctx, &mut items, "region_create", bi_params_2(bi_u64(), bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "region_destroy", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "region_reset", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "region_activate", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "region_deactivate", bi_params_0(), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "region_alloc", bi_params_3(bi_u64(), bi_u64(), bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "region_exit_scope", bi_params_1(bi_u64()), type_intern::CommonTypes::i32_ty());
    register_builtin_fn(ctx, &mut items, "region_used", bi_params_1(bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "region_trim", bi_params_1(bi_u64()), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "region_committed", bi_params_1(bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "region_alloc_count", bi_params_1(bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "system_alloc_live_bytes", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_diag_count", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_diag_wasted", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_diag_inplace", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_diag_inplace_bytes", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_diag_offset_delta", bi_params_0(), bi_u64());
    register_builtin_fn(ctx, &mut items, "realloc_stats_reset", bi_params_0(), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "print_alloc_hist", bi_params_0(), type_intern::CommonTypes::unit());
    register_builtin_fn(ctx, &mut items, "alloc_hist_reset", bi_params_0(), type_intern::CommonTypes::unit());

    // === Parse/char builtins (return unwrapped values, matching blood-rust ABI) ===
    register_builtin_fn(ctx, &mut items, "parse_f64", bi_params_1(bi_ref_str()), bi_f64());
    register_builtin_fn(ctx, &mut items, "parse_i64_radix", bi_params_2(bi_ref_str(), bi_u32()), bi_i64());
    register_builtin_fn(ctx, &mut items, "parse_u8_radix", bi_params_2(bi_ref_str(), bi_u32()), type_intern::CommonTypes::u8_ty());
    register_builtin_fn(ctx, &mut items, "parse_u32_radix", bi_params_2(bi_ref_str(), bi_u32()), bi_u32());
    register_builtin_fn(ctx, &mut items, "char_from_u32", bi_params_1(bi_u32()), bi_char());

    // === Threading ===
    register_builtin_fn(ctx, &mut items, "thread_spawn", bi_params_2(bi_u64(), bi_u64()), bi_u64());
    register_builtin_fn(ctx, &mut items, "thread_join", bi_params_1(bi_u64()), bi_u64());

    // Wrap all builtins in a single ForeignDef item for the type checker.
    // The typeck_driver's collect_item_signatures will process this via
    // the Foreign pipeline, registering FnSig for each ForeignFn.
    if items.len() > 0 {
        let dummy_span = common::Span::dummy();
        let container_def_id = ctx.alloc_def_id();
        let name_sym = ctx.intern("__builtins");
        let spanned_name = common::SpannedSymbol { symbol: name_sym, span: dummy_span };
        let foreign_def = hir_item::ForeignDef::new(hir_item::Abi::Rust, items);
        let item = hir_item::Item::new(
            container_def_id,
            spanned_name,
            hir_item::ItemKind::Foreign(foreign_def),
            common::Visibility::Public,
            dummy_span,
        );
        ctx.items.push(hir_lower_ctx::ItemEntry::new(container_def_id, item));
    }
}

// ============================================================
// Bridge FFI Registration
// ============================================================

/// Registers all functions from a bridge declaration.
///
/// For a bridge like `bridge "C" Libc { fn abs(x: i32) -> i32; }`:
/// 1. Look up the bridge module DefId (registered in Phase 1)
/// 2. For each function: allocate DefId, register as child, convert types
/// 3. Create ForeignFn items for type checking
/// 4. Register in builtin_fn_defs with C function name for codegen
fn register_bridge_functions(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    bdecl: &ast::BridgeDecl,
) {
    // Look up the bridge's module DefId from Phase 1
    let name_str = ctx.span_to_string(bdecl.name.span);
    let name_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(name_symbol);
    let bridge_def_id = match lookup {
        Option::Some(result) => {
            let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
            hir_def::DefId::new(binding.def_id.index)
        }
        Option::None => { return; }
    };

    let mut foreign_items: Vec<hir_item::ForeignItem> = Vec::new();

    for i in 0usize..bdecl.items.len() {
        match &bdecl.items[i] {
            &ast::BridgeItem::Function(ref f) => {
                let fn_def_id = ctx.alloc_def_id();
                let fn_name_str = ctx.span_to_string(f.name.span);
                let fn_name_symbol = ctx.intern(fn_name_str.as_str());

                // Register as child of the bridge module for Libc::abs resolution
                ctx.resolver.register_def_info(
                    fn_def_id,
                    hir_def::DefKind::Fn,
                    fn_name_symbol,
                    f.name.span,
                    Option::Some(bridge_def_id),
                );

                // Convert parameter types to TyId
                let mut param_tys: Vec<type_intern::TyId> = Vec::new();
                for pi in 0usize..f.params.len() {
                    let param_ty = hir_lower_type::lower_type_id(ctx, &f.params[pi].ty);
                    param_tys.push(param_ty);
                }

                // Convert return type to TyId
                let return_ty = match &f.return_type {
                    &Option::Some(ref rt) => hir_lower_type::lower_type_id(ctx, rt),
                    &Option::None => type_intern::CommonTypes::unit(),
                };

                // Create ForeignFn for type checking
                let spanned_name = common::SpannedSymbol { symbol: fn_name_symbol, span: f.name.span };
                let foreign_fn = hir_item::ForeignFn::new(
                    fn_def_id, spanned_name, param_tys, return_ty, f.is_variadic, f.span,
                );
                foreign_items.push(hir_item::ForeignItem::Fn(foreign_fn));

                // Register in builtin_fn_defs with the C function name
                // so codegen resolves this DefId to the bare C name (e.g., "abs")
                ctx.builtin_fn_defs.push(
                    hir_lower_ctx::BuiltinFnDef::new(fn_def_id.index, common::make_string(fn_name_str.as_str())),
                );
            }
            &ast::BridgeItem::Const(ref _c) => {
                // Bridge constants: not yet implemented
            }
            &ast::BridgeItem::OpaqueType(ref _ot) => {
                // Bridge opaque types: not yet implemented
            }
            &ast::BridgeItem::TypeAlias(ref _ta) => {
                // Bridge type aliases: not yet implemented
            }
            &ast::BridgeItem::Struct(ref _s) => {
                // Bridge structs: not yet implemented
            }
            &ast::BridgeItem::Enum(ref _e) => {
                // Bridge enums: not yet implemented
            }
            &ast::BridgeItem::Union(ref _u) => {
                // Bridge unions: not yet implemented
            }
            &ast::BridgeItem::Callback(ref _cb) => {
                // Bridge callbacks: not yet implemented
            }
            &ast::BridgeItem::Link(ref _ls) => {
                // Link specifications: not yet implemented
            }
        }
    }

    // Wrap in ForeignDef and add to ctx.items for the type checker
    if foreign_items.len() > 0 {
        let container_def_id = ctx.alloc_def_id();
        let bridge_sym = ctx.intern(name_str.as_str());
        let spanned_name = common::SpannedSymbol { symbol: bridge_sym, span: bdecl.name.span };
        let foreign_def = hir_item::ForeignDef::new(hir_item::Abi::C, foreign_items);
        let item = hir_item::Item::new(
            container_def_id,
            spanned_name,
            hir_item::ItemKind::Foreign(foreign_def),
            common::Visibility::Public,
            bdecl.span,
        );
        ctx.items.push(hir_lower_ctx::ItemEntry::new(container_def_id, item));
    }
}

// ============================================================
// Use Declaration Resolution (Import-aware)
// ============================================================

/// Resolve a ModulePath's first N segments. When use_global is true, the first
/// segment is resolved via global scope lookup; otherwise via lookup_in_parent.
fn resolve_module_path_segments(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    path: &ast::ModulePath,
    num_segments: usize,
    use_global: bool,
) -> Option<hir_def::DefId> {
    if num_segments == 0 || path.segments.len() == 0 {
        return Option::None;
    }
    let first_str = ctx.span_to_string(path.segments[0].span);
    let first_sym = ctx.intern(first_str.as_str());
    let mut current_def = if use_global {
        let first_lookup = ctx.resolver.lookup(first_sym);
        if !first_lookup.is_some() {
            return Option::None;
        }
        let first_result = first_lookup.unwrap();
        let first_binding = ctx.resolver.scope_binding(first_result.scope_index, first_result.binding_index);
        first_binding.def_id
    } else {
        let first_lookup = ctx.resolver.lookup_in_parent(parent_def_id, first_sym);
        if !first_lookup.is_some() {
            return Option::None;
        }
        first_lookup.unwrap()
    };
    for seg_idx in 1usize..num_segments {
        let seg_str = ctx.span_to_string(path.segments[seg_idx].span);
        let seg_sym = ctx.intern(seg_str.as_str());
        let child = ctx.resolver.lookup_in_parent(current_def, seg_sym);
        if !child.is_some() {
            return Option::None;
        }
        current_def = child.unwrap();
    }
    Option::Some(current_def)
}

/// Resolve a declaration-level use import and re-export items as children of parent_def_id.
/// When use_global is true, resolves module path via global scope lookup.
/// When use_global is false, resolves via parent-based lookup.
fn resolve_use_decl_module_reexport(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    imp: &ast::Import,
    use_global: bool,
) {
    match imp {
        &ast::Import::Simple { ref path, ref alias, span: _ } => {
            if path.segments.len() < 2 {
                return;
            }
            let last_idx = path.segments.len() - 1;
            let resolved = resolve_module_path_segments(ctx, parent_def_id, path, last_idx, use_global);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                let item_str = ctx.span_to_string(path.segments[last_idx].span);
                let item_sym = ctx.intern(item_str.as_str());
                let item_def = ctx.resolver.lookup_in_parent(mod_def_id, item_sym);
                if item_def.is_some() {
                    let existing_def_id = item_def.unwrap();
                    let existing_info = ctx.resolver.get_def_info(existing_def_id);
                    if existing_info.is_some() {
                        let info = existing_info.unwrap();
                        ctx.resolver.register_def_info(
                            existing_def_id,
                            info.kind,
                            item_sym,
                            info.span,
                            Option::Some(parent_def_id),
                        );
                    }
                }
            }
        }
        &ast::Import::Group { ref path, ref items, span: _ } => {
            let resolved = resolve_module_path_segments(ctx, parent_def_id, path, path.segments.len(), use_global);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                for gi in 0usize..items.len() {
                    let item_str = ctx.span_to_string(items[gi].name.span);
                    let item_sym = ctx.intern(item_str.as_str());
                    let item_def = ctx.resolver.lookup_in_parent(mod_def_id, item_sym);
                    if item_def.is_some() {
                        let existing_def_id = item_def.unwrap();
                        let existing_info = ctx.resolver.get_def_info(existing_def_id);
                        if existing_info.is_some() {
                            let info = existing_info.unwrap();
                            ctx.resolver.register_def_info(
                                existing_def_id,
                                info.kind,
                                item_sym,
                                info.span,
                                Option::Some(parent_def_id),
                            );
                        }
                    }
                }
            }
        }
        &ast::Import::Glob { ref path, span: _ } => {
            let resolved = resolve_module_path_segments(ctx, parent_def_id, path, path.segments.len(), use_global);
            if resolved.is_some() {
                let mod_def_id = resolved.unwrap();
                let children = ctx.resolver.get_children_of_parent(mod_def_id);
                for ci in 0usize..children.len() {
                    let child_name = children[ci].name;
                    let child_def = children[ci].def_id;
                    let existing_info = ctx.resolver.get_def_info(child_def);
                    if existing_info.is_some() {
                        let info = existing_info.unwrap();
                        let child_vis = info.visibility;
                        ctx.resolver.register_def_info(
                            child_def,
                            info.kind,
                            child_name,
                            info.span,
                            Option::Some(parent_def_id),
                        );
                        // Preserve the original visibility on the re-exported entry
                        ctx.resolver.set_def_visibility(child_def, child_vis);
                    }
                }
            }
        }
    }
}

// ============================================================
// Stdlib Prelude Auto-Import
// ============================================================

/// Auto-imports stdlib prelude items into root scope when --stdlib-path is set.
/// Primary path: if `mod std;` is loaded, finds the prelude sub-module and
/// glob-imports its public children. Fallback: loads prelude.blood directly
/// from stdlib_path. Silently returns if prelude doesn't exist.
fn inject_stdlib_prelude(ctx: &mut hir_lower_ctx::LoweringCtx) {
    // Only inject when stdlib_path is set
    if ctx.stdlib_path.is_none() {
        return;
    }

    // Primary path: std module is loaded, prelude is a child module
    let std_sym = ctx.intern("std");
    let std_lookup = ctx.resolver.lookup(std_sym);
    if std_lookup.is_some() {
        let std_result = std_lookup.unwrap();
        let std_binding = ctx.resolver.scope_binding(std_result.scope_index, std_result.binding_index);
        let std_def_id = std_binding.def_id;
        let prelude_sym = ctx.intern("prelude");
        let prelude_def = ctx.resolver.lookup_in_parent(std_def_id, prelude_sym);
        if prelude_def.is_some() {
            let prelude_def_id = prelude_def.unwrap();
            let children = ctx.resolver.get_children_of_parent(prelude_def_id);
            for ci in 0usize..children.len() {
                let child_name = children[ci].name;
                let child_def = children[ci].def_id;
                let binding = resolve::Binding::def(child_def);
                ctx.resolver.define(child_name, binding);
            }
            return;
        }
    }

    // No fallback: prelude requires `mod std;` to be loaded. Without std,
    // the prelude module isn't part of the module tree and can't be processed
    // through the normal pipeline (declaration lowering + body lowering).
}

// ============================================================
// External Module Loading
// ============================================================

/// Loads an external module from a file.
/// Builds the file path, reads, parses, and registers the module's contents.
fn load_external_module(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    name: common::Symbol,
    name_span: common::Span,
    vis: common::Visibility,
    span: common::Span,
) {
    // Build the file path: base_dir/module_name.blood
    // Use span_to_string instead of resolve_symbol_to_string because the symbol
    // came from the parser's interner, which is separate from the lowering context's
    // interner. Span extraction always works regardless of interner state.
    let module_name = ctx.span_to_string(name_span);
    // When stdlib_path is set and module name is "std", resolve to stdlib_path/mod.blood
    // instead of base_dir/std.blood. This allows the compiler to find stdlib modules.
    let mut file_path = if str_eq_lit(&module_name, "std") {
        match &ctx.stdlib_path {
            &Option::Some(ref sp) => {
                // Strip trailing slash from stdlib_path to avoid double-slash
                let sp_bytes = sp.as_bytes();
                let sp_len = sp_bytes.len();
                let mut p = String::new();
                let end = if sp_len > 0 && sp_bytes[sp_len - 1] == 47 {
                    sp_len - 1
                } else {
                    sp_len
                };
                for ci in 0usize..end {
                    p.push(sp_bytes[ci] as char);
                }
                p.push_str("/mod.blood");
                p
            }
            &Option::None => {
                let mut p = common::make_string(ctx.get_base_dir().as_str());
                p.push('/');
                append_string(&mut p, &module_name);
                p.push_str(".blood");
                p
            }
        }
    } else {
        let mut p = common::make_string(ctx.get_base_dir().as_str());
        p.push('/');
        append_string(&mut p, &module_name);
        p.push_str(".blood");
        p
    };

    // Re-intern the module name for consistent symbol indices
    let re_interned_name = ctx.intern(module_name.as_str());

    // Check if module is already loaded (imported by another file)
    let existing = ctx.find_loaded_module(&file_path);
    if existing.is_some() {
        // Module already loaded — types and declarations already registered globally.
        // No need to re-register; all scopes share the global namespace.
        return;
    }

    // Check if module is currently being loaded (circular import detection)
    if ctx.is_path_loading(&file_path) {
        let mut msg = common::make_string("circular import detected for module '");
        append_string(&mut msg, &module_name);
        msg.push_str("'");
        ctx.error(hir::DiagnosticCode::E0104, msg, span);
        return;
    }

    // Read the file; if not found, try directory module: base_dir/name/mod.blood
    let read_result = source::read_file_string(&file_path);
    let read_result = if !read_result.success {
        // Fallback: try base_dir/name/mod.blood (directory module)
        let mut dir_path = common::make_string(ctx.get_base_dir().as_str());
        dir_path.push('/');
        append_string(&mut dir_path, &module_name);
        dir_path.push_str("/mod.blood");
        let dir_result = source::read_file_string(&dir_path);
        if dir_result.success {
            // Update file_path to the directory module path for base_dir tracking
            file_path = dir_path;
            dir_result
        } else {
            // Neither file found — return original error
            read_result
        }
    } else {
        read_result
    };
    if !read_result.success {
        let mut msg = common::make_string("failed to load module '");
        append_string(&mut msg, &module_name);
        msg.push_str("': ");
        match &read_result.error {
            &Option::Some(ref e) => msg.push_str(e.as_str()),
            &Option::None => msg.push_str("unknown error"),
        }
        ctx.error(hir::DiagnosticCode::E0104, msg, span);
        return;
    }

    let content = match &read_result.content {
        &Option::Some(ref c) => c,
        &Option::None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("module file has no content"),
                span,
            );
            return;
        }
    };

    // Parse the file
    let parse_result = parser::parse_file(content.as_str());
    if parse_result.errors.len() > 0 {
        let mut msg = common::make_string("parse error in module '");
        append_string(&mut msg, &module_name);
        msg.push_str("'");
        ctx.error(hir::DiagnosticCode::E0104, msg, span);
        return;
    }

    let program = match &parse_result.program {
        &Option::Some(ref p) => p,
        &Option::None => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("no program produced from module file"),
                span,
            );
            return;
        }
    };

    // Allocate DefId for the module
    let def_id = ctx.alloc_def_id();
    let success = ctx.resolver.define_global(re_interned_name, def_id);
    if !success {
        ctx.error(
            hir::DiagnosticCode::E0101,
            common::make_string("duplicate definition"),
            name_span,
        );
        return;
    }

    ctx.resolver.register_def_info(
        def_id,
        hir_def::DefKind::Module,
        re_interned_name,
        name_span,
        Option::None,
    );

    // Mark path as loading for circular import detection
    ctx.loading_paths.push(common::make_string(file_path.as_str()));

    // Save current source and base_dir, switch to the external module's context
    // so that span_to_string() works correctly and sub-module resolution uses
    // the correct directory.
    let saved_source = ctx.source;
    let saved_base_dir = common::make_string(ctx.base_dir.as_str());
    ctx.source = common::make_string(content.as_str());
    // Update base_dir to the directory of the loaded module file
    ctx.base_dir = dir_of_path(&file_path);

    // Phase 1: Register nested type names from the loaded module
    // This recursively loads sub-modules, which will be added to loaded_modules
    // BEFORE this module (post-order), ensuring dependencies are processed first in Phase 3a.
    register_module_type_names(ctx, def_id, &program.declarations);

    // Phase 2: Register declarations (functions, consts, statics) from the loaded module
    register_module_declarations(ctx, def_id, &program.declarations);

    // Restore the original source text and base_dir
    ctx.source = saved_source;
    ctx.base_dir = saved_base_dir;

    // Add to loaded_modules AFTER sub-modules have been loaded (post-order).
    // This ensures Phase 3a processes dependencies before dependents.
    ctx.add_loaded_module(re_interned_name, def_id, common::make_string(file_path.as_str()));
}

/// Resolves a symbol to a string for file path construction.
fn resolve_symbol_to_string(ctx: &mut hir_lower_ctx::LoweringCtx, symbol: common::Symbol) -> String {
    ctx.resolve_symbol(symbol)
}

/// Appends a String to another String.
fn append_string(dest: &mut String, src: &String) {
    dest.push_str(src.as_str());
}

/// Extracts the directory portion of a file path.
/// e.g., "/foo/bar/baz.blood" → "/foo/bar"
fn dir_of_path(path: &String) -> String {
    let bytes = path.as_bytes();
    let len = bytes.len();
    // Find the last '/' character
    let mut last_slash: i64 = -1;
    for i in 0usize..len {
        if bytes[i] == 47 { // '/'
            last_slash = i as i64;
        }
    }
    if last_slash < 0 {
        // No slash found — current directory
        return common::make_string(".");
    }
    let end = last_slash as usize;
    let mut result = String::new();
    for j in 0usize..end {
        result.push(bytes[j] as char);
    }
    result
}

/// Compares a String to a string literal.
fn str_eq_lit(s: &String, lit: &str) -> bool {
    let a = s.as_bytes();
    let b = lit.as_bytes();
    if a.len() != b.len() {
        return false;
    }
    for i in 0usize..a.len() {
        if a[i] != b[i] {
            return false;
        }
    }
    true
}

// ============================================================
// External Module Processing (Phase 3b and 4b)
// ============================================================

/// Collects external module info (path, def_id) to avoid borrow conflicts.
struct ExternalModuleInfo {
    path: String,
    def_id: hir_def::DefId,
}

impl ExternalModuleInfo {
    fn new(path: String, def_id: hir_def::DefId) -> ExternalModuleInfo {
        ExternalModuleInfo { path, def_id }
    }
}

/// Cached parse result for an external module, to avoid double-parsing.
struct CachedParsedModule {
    module_index: usize,
    content: String,
    parse: parser::ParseResult,
    def_id: hir_def::DefId,
}

/// Collects info about all external modules.
fn collect_external_modules(ctx: &mut hir_lower_ctx::LoweringCtx) -> Vec<ExternalModuleInfo> {
    let mut result: Vec<ExternalModuleInfo> = Vec::new();
    for i in 0usize..ctx.loaded_modules.len() {
        let path = common::make_string(ctx.loaded_modules[i].path.as_str());
        let def_id = hir_def::DefId::new(ctx.loaded_modules[i].def_id.index);
        result.push(ExternalModuleInfo::new(path, def_id));
    }
    result
}

/// Phase 3b: Lower declarations from external modules.
/// Populates the cache with parsed modules for reuse in Phase 4b.
fn lower_external_module_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, cache: &mut Vec<CachedParsedModule>) {
    // Collect module info first to avoid borrow conflicts
    let modules = collect_external_modules(ctx);

    for i in 0usize..modules.len() {
        let path = &modules[i].path;
        let def_id = modules[i].def_id;

        // Parse the external module (cached for Phase 4b reuse)
        let read_result = source::read_file_string(path);
        if !read_result.success {
            // Skip - error should have been reported in Phase 1
            continue;
        }

        let content = match read_result.content {
            Option::Some(c) => c,
            Option::None => {
                continue;
            }
        };

        let parse_result = parser::parse_file(content.as_str());
        if parse_result.errors.len() > 0 {
            // Skip - error should have been reported in Phase 1
            continue;
        }

        let has_program = match &parse_result.program {
            &Option::Some(ref _p) => true,
            &Option::None => false,
        };

        if !has_program {
            continue;
        }

        // Save current source (struct copy — no heap allocation) and switch
        let saved_source = ctx.source;
        ctx.source = common::make_string(content.as_str());

        let program = match &parse_result.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                ctx.source = saved_source;
                continue;
            }
        };

        // Lower the module's declarations as if they're inside the module
        hir_lower_item::lower_module_contents(ctx, def_id, &program.declarations);

        // Restore source
        ctx.source = saved_source;

        // Cache the parsed module for Phase 4b
        cache.push(CachedParsedModule {
            module_index: i,
            content: content,
            parse: parse_result,
            def_id: def_id,
        });

    }
}

/// Phase 4b: Lower function bodies from external modules.
/// Uses cached parse results from Phase 3a to avoid re-reading and re-parsing.
fn lower_external_module_fn_bodies(ctx: &mut hir_lower_ctx::LoweringCtx, cache: &Vec<CachedParsedModule>) {
    for i in 0usize..cache.len() {
        let cached = &cache[i];

        let program = match &cached.parse.program {
            &Option::Some(ref p) => p,
            &Option::None => {
                continue;
            }
        };

        // Save current source (struct copy — no heap allocation) and switch
        let saved_source = ctx.source;
        ctx.source = common::make_string(cached.content.as_str());

        // Push a Module scope so unqualified names within the module
        // (e.g. SubstTable inside unify.blood) resolve correctly.
        let def_id = cached.def_id;
        ctx.resolver.push_scope(resolve::ScopeKind::Module);
        hir_lower_item::add_module_items_to_scope(ctx, def_id, &program.declarations);

        // Lower the module's function bodies
        lower_fn_bodies(ctx, &program.declarations);

        // Pop the Module scope
        ctx.resolver.pop_scope();

        // Restore source
        ctx.source = saved_source;

    }
}

/// Appends a u32 as decimal to a string.
fn append_u32(s: &mut String, n: u32) {
    if n == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<char> = Vec::new();
    let mut val = n;
    while val > 0 {
        let digit = (val % 10) as u8;
        digits.push((48u8 + digit) as char);
        val /= 10;
    }
    let len = digits.len();
    for i in 0usize..len {
        s.push(digits[len - 1 - i]);
    }
}

// ============================================================
// Helper: Register Module Type Names (Phase 1 recursive)
// ============================================================

/// Recursively register type names within a module.
fn register_module_type_names(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decls: &Vec<ast::Declaration>,
) {
    for i in 0usize..decls.len() {
        register_module_type_name(ctx, parent_def_id, &decls[i]);
    }
}

/// Register a single type name within a module.
/// Note: Nested items are NOT added to any scope - they're only accessible via qualified paths.
/// We just register them in def_info with the correct parent for lookup_in_parent to find.
fn register_module_type_name(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern from span for consistent symbol indices across modules
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Struct,
                name_symbol,
                s.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, s.vis);
        }
        &ast::Declaration::Enum(ref e) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(e.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Enum,
                name_symbol,
                e.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, e.vis);
        }
        &ast::Declaration::Trait(ref t) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(t.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Trait,
                name_symbol,
                t.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, t.vis);
        }
        &ast::Declaration::Effect(ref eff) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(eff.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Effect,
                name_symbol,
                eff.name.span,
                Option::Some(parent_def_id),
            );
            // EffectDecl doesn't have visibility in the AST — default Private
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(ta.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::TypeAlias,
                name_symbol,
                ta.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, ta.vis);
        }
        &ast::Declaration::Module(ref m) => {
            // Nested module
            match &m.body {
                &Option::Some(ref nested_decls) => {
                    let def_id = ctx.alloc_def_id();
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_symbol = ctx.intern(name_str.as_str());
                    ctx.resolver.register_def_info(
                        def_id,
                        hir_def::DefKind::Module,
                        name_symbol,
                        m.name.span,
                        Option::Some(parent_def_id),
                    );
                    ctx.resolver.set_def_visibility(def_id, m.vis);
                    // Recursively register nested module's type names
                    register_module_type_names(ctx, def_id, nested_decls);
                }
                &Option::None => {
                    // Nested external module - load recursively
                    load_external_module(ctx, m.name.symbol, m.name.span, m.vis, m.span);
                    // Also register as a child of the parent module so that
                    // chained paths like parent::submodule::Type work.
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_sym = ctx.intern(name_str.as_str());
                    let lookup = ctx.resolver.lookup(name_sym);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        ctx.resolver.register_def_info(
                            binding.def_id,
                            hir_def::DefKind::Module,
                            name_sym,
                            m.name.span,
                            Option::Some(parent_def_id),
                        );
                        ctx.resolver.set_def_visibility(binding.def_id, m.vis);
                    }
                }
            }
        }
        // Non-type declarations handled in phase 2
        &ast::Declaration::Function(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(ref u) => {
            resolve_use_decl_module_reexport(ctx, parent_def_id, &u.import, true);
        }
    }
}

// ============================================================
// Phase 2: Register Other Declarations
// ============================================================

/// Second pass: register functions, consts, statics.
fn register_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    for i in 0usize..decls.len() {
        register_declaration(ctx, &decls[i]);
    }
}

/// Register a single non-type declaration.
fn register_declaration(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(f.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    f.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Fn,
                    name_symbol,
                    f.name.span,
                    Option::None,
                );
                // Check if this is the main function
                if name_symbol.index == interner::SpecialIdents::main_sym().index {
                    ctx.entry_point = Option::Some(def_id);
                }
            }
        }
        &ast::Declaration::Const(ref c) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(c.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    c.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Const,
                    name_symbol,
                    c.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Static(ref s) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    s.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Static,
                    name_symbol,
                    s.name.span,
                    Option::None,
                );
            }
        }
        &ast::Declaration::Handler(ref h) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern the name from span to ensure consistent symbol indices
            let name_str = ctx.span_to_string(h.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            let success = ctx.resolver.define_global(name_symbol, def_id);
            if !success {
                ctx.error(
                    hir::DiagnosticCode::E0101,
                    common::make_string("duplicate definition"),
                    h.name.span,
                );
            } else {
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Handler,
                    name_symbol,
                    h.name.span,
                    Option::None,
                );
            }
        }
        // Types already registered in phase 1
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        // Impl blocks: register methods as children of the target type
        &ast::Declaration::Impl(ref impl_block) => {
            match &impl_block.self_ty.kind {
                &ast::TypeKind::Path(ref type_path) => {
                    if type_path.segments.len() > 0 {
                        // Resolve the full qualified path (e.g., mir_types::Place)
                        // to get the actual TYPE's DefId, not just the first segment.
                        // Using only segments[0] would resolve to the module for
                        // qualified paths, causing method name collisions when two
                        // types in the same module have methods with the same name.
                        let mut seg_names: Vec<common::SpannedSymbol> = Vec::new();
                        for si in 0usize..type_path.segments.len() {
                            let seg_str = ctx.span_to_string(type_path.segments[si].name.span);
                            let seg_sym = ctx.intern(seg_str.as_str());
                            seg_names.push(common::SpannedSymbol { symbol: seg_sym, span: type_path.segments[si].name.span });
                        }
                        let path_result = ctx.resolver.resolve_qualified_path(&seg_names);
                        match path_result {
                            Option::Some(result) => {
                                register_impl_items(ctx, result.def_id, &impl_block.items);
                            }
                            Option::None => {}
                        }
                    }
                }
                &ast::TypeKind::Reference { ref inner, lifetime: _, is_mut: _ } => {
                    // impl &Type or impl &mut Type — skip for now
                }
                &ast::TypeKind::Pointer { ref inner, is_mut: _ } => {}
                &ast::TypeKind::Array { ref element, ref size } => {}
                &ast::TypeKind::Slice { ref element } => {}
                &ast::TypeKind::Tuple(ref elems) => {}
                &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {}
                &ast::TypeKind::Record { ref fields, ref rest } => {}
                &ast::TypeKind::Ownership { ref qualifier, ref inner } => {}
                &ast::TypeKind::Forall { ref params, ref body } => {}
                &ast::TypeKind::Never => {}
                &ast::TypeKind::Infer => {}
                &ast::TypeKind::Paren(ref inner) => {}
            }
        }
        // Bridge: register bridge function children and create ForeignFn items
        &ast::Declaration::Bridge(ref b) => {
            register_bridge_functions(ctx, b);
        }
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Look up the module's DefId from Phase 1
                    // Re-intern from span for consistent symbol indices
                    let name_str = ctx.span_to_string(m.name.span);
                    let lookup_symbol = ctx.intern(name_str.as_str());
                    let lookup = ctx.resolver.lookup(lookup_symbol);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let mod_def_id = hir_def::DefId::new(binding.def_id.index);
                        // Recursively register nested declarations
                        register_module_declarations(ctx, mod_def_id, declarations);
                    }
                }
                &Option::None => {} // Already errored in Phase 1
            }
        }
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(ref u) => {
            // Reuse program-level resolve_import — it handles Simple, Group, and Glob
            resolve_import(ctx, &u.import);
        }
    }
}

// ============================================================
// Helper: Register Module Declarations (Phase 2 recursive)
// ============================================================

/// Recursively register declarations (functions, consts, statics) within a module.
fn register_module_declarations(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decls: &Vec<ast::Declaration>,
) {
    for i in 0usize..decls.len() {
        register_module_declaration(ctx, parent_def_id, &decls[i]);
    }
}

/// Register a single declaration within a module.
fn register_module_declaration(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            let def_id = ctx.alloc_def_id();
            // Re-intern from span for consistent symbol indices across modules
            let name_str = ctx.span_to_string(f.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Fn,
                name_symbol,
                f.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, f.vis);
        }
        &ast::Declaration::Const(ref c) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(c.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Const,
                name_symbol,
                c.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, c.vis);
        }
        &ast::Declaration::Static(ref s) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(s.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Static,
                name_symbol,
                s.name.span,
                Option::Some(parent_def_id),
            );
            ctx.resolver.set_def_visibility(def_id, s.vis);
        }
        &ast::Declaration::Handler(ref h) => {
            let def_id = ctx.alloc_def_id();
            let name_str = ctx.span_to_string(h.name.span);
            let name_symbol = ctx.intern(name_str.as_str());
            ctx.resolver.register_def_info(
                def_id,
                hir_def::DefKind::Handler,
                name_symbol,
                h.name.span,
                Option::Some(parent_def_id),
            );
            // Handlers don't have visibility in the AST — default Private
        }
        &ast::Declaration::Module(ref m) => {
            // Nested module - look up its DefId and recurse
            match &m.body {
                &Option::Some(ref nested_decls) => {
                    // Find the nested module's DefId (registered in Phase 1)
                    // Re-intern from span for consistent lookup
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_symbol = ctx.intern(name_str.as_str());
                    let nested_mod_def = ctx.resolver.lookup_in_parent(parent_def_id, name_symbol);
                    if nested_mod_def.is_some() {
                        let nested_def_id = nested_mod_def.unwrap();
                        register_module_declarations(ctx, nested_def_id, nested_decls);
                    }
                }
                &Option::None => {} // Handled by load_external_module in Phase 1
            }
        }
        // Types already registered in Phase 1
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        // Impl blocks: register methods as children of the target type
        &ast::Declaration::Impl(ref impl_block) => {
            match &impl_block.self_ty.kind {
                &ast::TypeKind::Path(ref type_path) => {
                    if type_path.segments.len() > 0 {
                        // Resolve the full qualified path to get the actual type's
                        // DefId. For multi-segment paths (e.g., mir_types::Place),
                        // using only segments[0] would resolve to the module,
                        // causing method name collisions.
                        let type_def_id_opt: Option<hir_def::DefId> = if type_path.segments.len() == 1 {
                            // Single-segment: look up in parent module first, then global
                            let seg_str = ctx.span_to_string(type_path.segments[0].name.span);
                            let seg_sym = ctx.intern(seg_str.as_str());
                            let type_def_opt = ctx.resolver.lookup_in_parent(parent_def_id, seg_sym);
                            if type_def_opt.is_some() {
                                Option::Some(type_def_opt.unwrap())
                            } else {
                                let global_lookup = ctx.resolver.lookup(seg_sym);
                                if global_lookup.is_some() {
                                    let result = global_lookup.unwrap();
                                    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                                    Option::Some(hir_def::DefId::new(binding.def_id.index))
                                } else {
                                    Option::None
                                }
                            }
                        } else {
                            // Multi-segment: resolve full qualified path
                            let mut seg_names: Vec<common::SpannedSymbol> = Vec::new();
                            for si in 0usize..type_path.segments.len() {
                                let s_str = ctx.span_to_string(type_path.segments[si].name.span);
                                let s_sym = ctx.intern(s_str.as_str());
                                seg_names.push(common::SpannedSymbol { symbol: s_sym, span: type_path.segments[si].name.span });
                            }
                            let path_result = ctx.resolver.resolve_qualified_path(&seg_names);
                            match path_result {
                                Option::Some(result) => Option::Some(result.def_id),
                                Option::None => Option::None,
                            }
                        };
                        if type_def_id_opt.is_some() {
                            let type_def_id = type_def_id_opt.unwrap();
                            register_impl_items(ctx, type_def_id, &impl_block.items);
                        }
                    }
                }
                &ast::TypeKind::Reference { ref inner, lifetime: _, is_mut: _ } => {}
                &ast::TypeKind::Pointer { ref inner, is_mut: _ } => {}
                &ast::TypeKind::Array { ref element, ref size } => {}
                &ast::TypeKind::Slice { ref element } => {}
                &ast::TypeKind::Tuple(ref elems) => {}
                &ast::TypeKind::Function { ref params, ref return_type, ref effects } => {}
                &ast::TypeKind::Record { ref fields, ref rest } => {}
                &ast::TypeKind::Ownership { ref qualifier, ref inner } => {}
                &ast::TypeKind::Forall { ref params, ref body } => {}
                &ast::TypeKind::Never => {}
                &ast::TypeKind::Infer => {}
                &ast::TypeKind::Paren(ref inner) => {}
            }
        }
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(ref u) => {
            resolve_use_decl_module_reexport(ctx, parent_def_id, &u.import, false);
        }
    }
}

// ============================================================
// Helper: Register Impl Block Items
// ============================================================

/// Register all items in an impl block as children of the target type.
fn register_impl_items(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    type_def_id: hir_def::DefId,
    items: &Vec<ast::ImplItem>,
) {
    for j in 0usize..items.len() {
        match &items[j] {
            &ast::ImplItem::Function(ref f) => {
                let def_id = ctx.alloc_def_id();
                let fn_name_str = ctx.span_to_string(f.name.span);
                let fn_name_sym = ctx.intern(fn_name_str.as_str());
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Fn,
                    fn_name_sym,
                    f.name.span,
                    Option::Some(type_def_id),
                );
            }
            &ast::ImplItem::TypeAlias(ref ta) => {
                let def_id = ctx.alloc_def_id();
                let ta_name_str = ctx.span_to_string(ta.name.span);
                let ta_name_sym = ctx.intern(ta_name_str.as_str());
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::TypeAlias,
                    ta_name_sym,
                    ta.name.span,
                    Option::Some(type_def_id),
                );
            }
            &ast::ImplItem::Const(ref c) => {
                let def_id = ctx.alloc_def_id();
                let c_name_str = ctx.span_to_string(c.name.span);
                let c_name_sym = ctx.intern(c_name_str.as_str());
                ctx.resolver.register_def_info(
                    def_id,
                    hir_def::DefKind::Const,
                    c_name_sym,
                    c.name.span,
                    Option::Some(type_def_id),
                );
            }
        }
    }
}

// ============================================================
// Phase 4: Lower Function Bodies
// ============================================================

/// Fourth pass: lower function bodies to HIR bodies.
fn lower_fn_bodies(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    for i in 0usize..decls.len() {
        lower_fn_body_if_present(ctx, &decls[i]);
    }
}

/// Lower a function body if the declaration is a function with a body.
fn lower_fn_body_if_present(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            // Only lower if there's a body
            if f.body.is_some() {
                lower_single_fn_body(ctx, f);
            }
        }
        // Other declarations don't have bodies (in this phase)
        &ast::Declaration::Struct(_) => {}
        &ast::Declaration::Enum(_) => {}
        &ast::Declaration::Trait(_) => {}
        &ast::Declaration::Effect(_) => {}
        &ast::Declaration::TypeAlias(_) => {}
        &ast::Declaration::Const(_) => {}
        &ast::Declaration::Static(_) => {}
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Handler(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    // Look up the module's DefId so we can push its scope
                    let name_str = ctx.span_to_string(m.name.span);
                    let lookup_symbol = ctx.intern(name_str.as_str());
                    let lookup = ctx.resolver.lookup(lookup_symbol);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let mod_def_id = hir_def::DefId::new(binding.def_id.index);
                        // Push a Module scope and add items so lower_single_fn_body
                        // can resolve function names within the module
                        ctx.resolver.push_scope(resolve::ScopeKind::Module);
                        hir_lower_item::add_module_items_to_scope(ctx, mod_def_id, declarations);
                        lower_fn_bodies(ctx, declarations);
                        ctx.resolver.pop_scope();
                    }
                }
                &Option::None => {} // External module - already handled
            }
        }
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(_) => {}
    }
}

/// Lower a single function's body.
fn lower_single_fn_body(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl) {
    // Look up the function's DefId using the same name resolution as Phase 3.
    // This lets us find the Item and its pre-allocated body_id.
    let name_str = ctx.span_to_string(f.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() {
        // If lookup fails, skip this body (should not happen)
        return;
    }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Look up the Item to get the pre-allocated body_id from Phase 3
    let body_id_opt = match ctx.get_item(def_id) {
        Option::Some(entry) => {
            match &entry.item.kind {
                &hir_item::ItemKind::Fn(ref fn_def) => {
                    match &fn_def.body_id {
                        &Option::Some(ref bid) => Option::Some(hir_def::BodyId::new(bid.index)),
                        &Option::None => Option::None,
                    }
                }
                _ => Option::None,
            }
        }
        Option::None => Option::None,
    };

    let body_id = match body_id_opt {
        Option::Some(bid) => bid,
        Option::None => {
            // Fallback: allocate a new body_id (should not reach here)
            ctx.alloc_body_id()
        }
    };

    // Clear const param tracking before lowering this function's generics.
    ctx.const_param_defs = Vec::new();

    // Re-establish TypeParams scope for body lowering.
    // Phase 3 (lower_function_decl) popped the scope after lowering the signature.
    // Phase 4 needs it active for re-lowering parameter types and any type
    // annotations within the body.
    let _generics = hir_lower_type::lower_generics(ctx, &f.type_params, &f.where_clause);

    // Lower the function parameters (for creating locals)
    let params = hir_lower_item::lower_fn_params(ctx, &f.params);

    // Lower the body
    let body = hir_lower_body::lower_fn_body(
        ctx,
        body_id,
        &params,
        &f.params,      // AST params for complex pattern destructuring
        &Option::None,  // No expression body (Blood uses block bodies)
        &f.body,
    );

    // Pop the TypeParams scope pushed by lower_generics
    ctx.resolver.pop_scope();

    // Extract const param DefIds before clearing (for monomorphization)
    let mut cp_def_ids: Vec<u32> = Vec::new();
    {
        for cpi in 0usize..ctx.const_param_defs.len() {
            cp_def_ids.push(ctx.const_param_defs[cpi].def_id.index);
        }
    }

    // Clear const param tracking after body lowering
    ctx.const_param_defs = Vec::new();

    // Store the body with const param DefIds
    let mut body_entry = hir_lower_ctx::BodyEntry::new(body_id, body);
    body_entry.const_param_def_ids = cp_def_ids;
    ctx.bodies.push(body_entry);
}

// ============================================================
// Catch-All: Collect Resolver DefIds for Codegen
// ============================================================

/// Collects all DefIds from the resolver's def_info and registers them
/// with generic mangled names (def{N}_{name}) in builtin_fn_defs.
///
/// This acts as a catch-all: any DefId that appears as FnDef in MIR
/// will get a name. DefIds that already have a runtime name registered
/// (from register_builtin_fn or register_builtin_children) are skipped
/// to preserve their correct runtime names (e.g., "vec_new", "print").
fn collect_resolver_fn_defs(ctx: &mut hir_lower_ctx::LoweringCtx) {
    for i in 0usize..ctx.resolver.def_info.len() {
        let def_id_index = ctx.resolver.def_info[i].def_id.index;

        // Check if this DefId already has a runtime name registered.
        // If so, skip it to preserve the correct name (e.g., "vec_new", "print").
        let mut already_registered: bool = false;
        let mut j: usize = 0;
        while j < ctx.builtin_fn_defs.len() {
            if ctx.builtin_fn_defs[j].def_id_index == def_id_index {
                already_registered = true;
                j = ctx.builtin_fn_defs.len(); // break
            }
            j += 1;
        }

        if already_registered {
            continue;
        }

        let name_opt = ctx.interner.resolve(ctx.resolver.def_info[i].info.name);
        match name_opt {
            Option::Some(name_str) => {
                let mut mangled = String::new();
                mangled.push_str("def");
                hir_lower_ctx::append_u32_to_string(&mut mangled, def_id_index);
                mangled.push(95 as char); // '_'
                mangled.push_str(name_str.as_str());
                ctx.builtin_fn_defs.push(
                    hir_lower_ctx::BuiltinFnDef::new(def_id_index, mangled),
                );
            }
            Option::None => {}
        }
    }
}
