// Blood Self-Hosted Compiler - MIR Pretty Printer
//
// This module formats MIR bodies as human-readable text for debugging.
// Modeled on rustc's `-Z dump-mir` output format.
//
// All format functions return a String. Every enum match is exhaustive
// with explicit handling per variant (zero shortcuts).

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod type_intern;

// ============================================================
// Top-Level: Full MIR Body
// ============================================================

/// Formats a complete MIR body as human-readable text.
pub fn format_mir_body(body: &mir_body::MirBody, fn_name: &str) -> String {
    let mut out = String::new();

    // Function header
    out.push_str("fn ");
    out.push_str(fn_name);
    out.push_str("(");

    // Parameter list
    let param_count = body.param_count as usize;
    let mut pi: usize = 1;  // skip _0 (return place)
    while pi <= param_count {
        if pi > 1 {
            out.push_str(", ");
        }
        let local = &body.locals[pi];
        out.push('_');
        push_u32(&mut out, local.id.index);
        out.push_str(": ");
        let param_hir_ty = type_intern::ty_id_to_type(local.ty);
        let ty_str = format_type(&param_hir_ty);
        out.push_str(ty_str.as_str());
        pi = pi + 1;
    }
    out.push_str(") -> ");
    let ret_hir_ty = type_intern::ty_id_to_type(body.locals[0].ty);
    let ret_ty_str = format_type(&ret_hir_ty);
    out.push_str(ret_ty_str.as_str());
    out.push_str(" {\n");

    // Local declarations
    let mut li: usize = 0;
    while li < body.locals.len() {
        let local = &body.locals[li];
        let local_str = format_local(local, li, body.param_count);
        out.push_str("    ");
        out.push_str(local_str.as_str());
        out.push('\n');
        li = li + 1;
    }
    out.push('\n');

    // Basic blocks
    let mut bi: usize = 0;
    while bi < body.basic_blocks.len() {
        let block = &body.basic_blocks[bi];
        out.push_str("    bb");
        push_u32(&mut out, bi as u32);
        out.push_str(": {\n");

        // Statements
        let mut si: usize = 0;
        while si < block.statements.len() {
            let stmt = &block.statements[si];
            let stmt_str = format_statement(stmt);
            out.push_str("        ");
            out.push_str(stmt_str.as_str());
            out.push('\n');
            si = si + 1;
        }

        // Terminator
        match &block.terminator {
            &Option::Some(ref term) => {
                let term_str = format_terminator(term);
                out.push_str("        ");
                out.push_str(term_str.as_str());
                out.push('\n');
            }
            &Option::None => {
                out.push_str("        // <no terminator>\n");
            }
        }

        out.push_str("    }\n");
        if bi + 1 < body.basic_blocks.len() {
            out.push('\n');
        }
        bi = bi + 1;
    }

    out.push_str("}\n");
    out
}

// ============================================================
// Local Variable Formatting
// ============================================================

/// Formats a local variable declaration.
/// Output: `_N: Type  // kind [name]`
pub fn format_local(local: &mir_body::MirLocal, index: usize, param_count: u32) -> String {
    let mut out = String::new();
    out.push('_');
    push_u32(&mut out, index as u32);
    out.push_str(": ");
    let local_hir_ty = type_intern::ty_id_to_type(local.ty);
    let ty_str = format_type(&local_hir_ty);
    out.push_str(ty_str.as_str());

    // Comment with kind and optional name
    out.push_str("  // ");
    match &local.kind {
        &mir_def::LocalKind::ReturnPlace => {
            out.push_str("return");
        }
        &mir_def::LocalKind::Arg => {
            out.push_str("arg");
        }
        &mir_def::LocalKind::Var => {
            out.push_str("var");
        }
        &mir_def::LocalKind::Temp => {
            out.push_str("temp");
        }
    }

    match &local.name {
        &Option::Some(ref name) => {
            out.push_str(": ");
            out.push_str(name.as_str());
        }
        &Option::None => {}
    }

    out
}

// ============================================================
// Type Formatting
// ============================================================

/// Formats a HIR type as a human-readable string.
pub fn format_type(ty: &hir_ty::Type) -> String {
    match &ty.kind {
        &hir_ty::TypeKind::Primitive(ref prim) => format_prim(prim),
        &hir_ty::TypeKind::Tuple(ref elems) => {
            let mut out = String::new();
            out.push('(');
            let mut i: usize = 0;
            while i < elems.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let elem_str = format_type(&elems[i]);
                out.push_str(elem_str.as_str());
                i = i + 1;
            }
            out.push(')');
            out
        }
        &hir_ty::TypeKind::Array { ref element, size } => {
            let mut out = String::new();
            out.push('[');
            let inner = format_type(element.as_ref());
            out.push_str(inner.as_str());
            out.push_str("; ");
            push_u64(&mut out, size);
            out.push(']');
            out
        }
        &hir_ty::TypeKind::Slice { ref element } => {
            let mut out = String::new();
            out.push('[');
            let inner = format_type(element.as_ref());
            out.push_str(inner.as_str());
            out.push(']');
            out
        }
        &hir_ty::TypeKind::Ref { ref inner, mutable } => {
            let mut out = String::new();
            out.push('&');
            if mutable {
                out.push_str("mut ");
            }
            let inner_str = format_type(inner.as_ref());
            out.push_str(inner_str.as_str());
            out
        }
        &hir_ty::TypeKind::Ptr { ref inner, mutable } => {
            let mut out = String::new();
            out.push('*');
            if mutable {
                out.push_str("mut ");
            } else {
                out.push_str("const ");
            }
            let inner_str = format_type(inner.as_ref());
            out.push_str(inner_str.as_str());
            out
        }
        &hir_ty::TypeKind::Fn { ref params, ref ret, ref effects } => {
            let mut out = String::new();
            out.push_str("fn(");
            let mut i: usize = 0;
            while i < params.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let p = format_type(&params[i]);
                out.push_str(p.as_str());
                i = i + 1;
            }
            out.push_str(") -> ");
            let ret_str = format_type(ret.as_ref());
            out.push_str(ret_str.as_str());
            out
        }
        &hir_ty::TypeKind::Closure { def_id, ref params, ref ret } => {
            let mut out = String::new();
            out.push_str("closure[def");
            push_u32(&mut out, def_id.index);
            out.push_str("](");
            let mut i: usize = 0;
            while i < params.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let p = format_type(&params[i]);
                out.push_str(p.as_str());
                i = i + 1;
            }
            out.push_str(") -> ");
            let ret_str = format_type(ret.as_ref());
            out.push_str(ret_str.as_str());
            out
        }
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut out = String::new();
            out.push_str("Adt(def");
            push_u32(&mut out, def_id.index);
            if args.len() > 0 {
                out.push('<');
                let mut i: usize = 0;
                while i < args.len() {
                    if i > 0 {
                        out.push_str(", ");
                    }
                    let a = format_type(&args[i]);
                    out.push_str(a.as_str());
                    i = i + 1;
                }
                out.push('>');
            }
            out.push(')');
            out
        }
        &hir_ty::TypeKind::Infer(ref var_id) => {
            let mut out = String::new();
            out.push('?');
            push_u32(&mut out, var_id.index);
            out
        }
        &hir_ty::TypeKind::Param(ref var_id) => {
            let mut out = String::new();
            out.push_str("T");
            push_u32(&mut out, var_id.index);
            out
        }
        &hir_ty::TypeKind::Record { ref fields, ref row_var } => {
            let mut out = String::new();
            out.push_str("{ ");
            let mut i: usize = 0;
            while i < fields.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                out.push_str("field: ");
                let f = format_type(&fields[i].ty);
                out.push_str(f.as_str());
                i = i + 1;
            }
            out.push_str(" }");
            out
        }
        &hir_ty::TypeKind::Forall { ref params, ref body } => {
            let mut out = String::new();
            out.push_str("forall<");
            let mut i: usize = 0;
            while i < params.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                out.push('T');
                push_u32(&mut out, params[i].index);
                i = i + 1;
            }
            out.push_str("> ");
            let body_str = format_type(body.as_ref());
            out.push_str(body_str.as_str());
            out
        }
        &hir_ty::TypeKind::Range { ref element, inclusive } => {
            let mut out = String::new();
            if inclusive {
                out.push_str("RangeInclusive<");
            } else {
                out.push_str("Range<");
            }
            let elem_str = format_type(element.as_ref());
            out.push_str(elem_str.as_str());
            out.push('>');
            out
        }
        &hir_ty::TypeKind::DynTrait { trait_id, ref auto_traits } => {
            let mut out = String::new();
            out.push_str("dyn Trait(def");
            push_u32(&mut out, trait_id.index);
            out.push(')');
            out
        }
        &hir_ty::TypeKind::Never => common::make_string("!"),
        &hir_ty::TypeKind::Error => common::make_string("{error}"),
        &hir_ty::TypeKind::Ownership { ref qualifier, ref inner } => {
            let mut out = String::new();
            match qualifier {
                &hir_ty::OwnershipQualifier::Linear => out.push_str("linear "),
                &hir_ty::OwnershipQualifier::Affine => out.push_str("affine "),
            }
            let inner_str = format_type(inner.as_ref());
            out.push_str(inner_str.as_str());
            out
        }
    }
}

/// Formats a primitive type name.
pub fn format_prim(prim: &hir_ty::PrimitiveTy) -> String {
    match prim {
        &hir_ty::PrimitiveTy::Bool => common::make_string("bool"),
        &hir_ty::PrimitiveTy::I8 => common::make_string("i8"),
        &hir_ty::PrimitiveTy::I16 => common::make_string("i16"),
        &hir_ty::PrimitiveTy::I32 => common::make_string("i32"),
        &hir_ty::PrimitiveTy::I64 => common::make_string("i64"),
        &hir_ty::PrimitiveTy::I128 => common::make_string("i128"),
        &hir_ty::PrimitiveTy::Isize => common::make_string("isize"),
        &hir_ty::PrimitiveTy::U8 => common::make_string("u8"),
        &hir_ty::PrimitiveTy::U16 => common::make_string("u16"),
        &hir_ty::PrimitiveTy::U32 => common::make_string("u32"),
        &hir_ty::PrimitiveTy::U64 => common::make_string("u64"),
        &hir_ty::PrimitiveTy::U128 => common::make_string("u128"),
        &hir_ty::PrimitiveTy::Usize => common::make_string("usize"),
        &hir_ty::PrimitiveTy::F32 => common::make_string("f32"),
        &hir_ty::PrimitiveTy::F64 => common::make_string("f64"),
        &hir_ty::PrimitiveTy::Char => common::make_string("char"),
        &hir_ty::PrimitiveTy::Str => common::make_string("str"),
    }
}

// ============================================================
// Place Formatting
// ============================================================

/// Formats a place (memory location).
/// Output examples: `_1`, `_1.2`, `(*_1)`, `(_1 as 3)`, `_1[_2]`
pub fn format_place(place: &mir_types::Place) -> String {
    // Check for static place first
    match &place.static_def_id {
        &Option::Some(ref def_id) => {
            let mut out = String::new();
            out.push_str("static(def");
            push_u32(&mut out, def_id.index);
            out.push(')');
            // Apply projections
            let mut pi: usize = 0;
            while pi < place.projection.len() {
                let proj = format_projection(&place.projection[pi]);
                out.push_str(proj.as_str());
                pi = pi + 1;
            }
            return out;
        }
        &Option::None => {}
    }

    let mut out = String::new();
    out.push('_');
    push_u32(&mut out, place.local.index);

    // Apply projections
    let mut i: usize = 0;
    while i < place.projection.len() {
        let proj = format_projection(&place.projection[i]);
        out.push_str(proj.as_str());
        i = i + 1;
    }

    out
}

/// Formats a single projection element.
pub fn format_projection(elem: &mir_types::PlaceElem) -> String {
    match elem {
        &mir_types::PlaceElem::Deref => common::make_string(".*"),
        &mir_types::PlaceElem::Field(idx) => {
            let mut out = String::new();
            out.push('.');
            push_u32(&mut out, idx);
            out
        }
        &mir_types::PlaceElem::Index(ref local_id) => {
            let mut out = String::new();
            out.push_str("[_");
            push_u32(&mut out, local_id.index);
            out.push(']');
            out
        }
        &mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end } => {
            let mut out = String::new();
            out.push('[');
            if from_end {
                out.push_str("-");
            }
            push_u64(&mut out, offset);
            out.push_str(" of ");
            push_u64(&mut out, min_length);
            out.push(']');
            out
        }
        &mir_types::PlaceElem::Subslice { from, to, from_end } => {
            let mut out = String::new();
            out.push('[');
            push_u64(&mut out, from);
            out.push_str("..");
            if from_end {
                out.push('-');
            }
            push_u64(&mut out, to);
            out.push(']');
            out
        }
        &mir_types::PlaceElem::Downcast(variant_idx) => {
            let mut out = String::new();
            out.push_str(" as variant#");
            push_u32(&mut out, variant_idx);
            out
        }
    }
}

// ============================================================
// Operand Formatting
// ============================================================

/// Formats an operand.
pub fn format_operand(operand: &mir_types::Operand) -> String {
    match operand {
        &mir_types::Operand::Copy(ref place) => {
            let mut out = String::new();
            out.push_str("Copy(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Operand::Move(ref place) => {
            let mut out = String::new();
            out.push_str("Move(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Operand::Constant(ref constant) => {
            format_constant(constant)
        }
    }
}

/// Formats a constant.
pub fn format_constant(c: &mir_types::Constant) -> String {
    let mut out = String::new();
    out.push_str("const ");
    let kind_str = format_constant_kind(&c.kind);
    out.push_str(kind_str.as_str());
    out.push_str(": ");
    let c_hir_ty = type_intern::ty_id_to_type(c.ty);
    let ty_str = format_type(&c_hir_ty);
    out.push_str(ty_str.as_str());
    out
}

/// Formats a constant kind value.
pub fn format_constant_kind(kind: &mir_types::ConstantKind) -> String {
    match kind {
        &mir_types::ConstantKind::Int(val) => {
            let mut out = String::new();
            // i128 value â€” print as i64 for readability
            let v = val as i64;
            let zero: i64 = 0;
            if v < zero {
                out.push('-');
                let neg = zero - v;
                push_u64(&mut out, neg as u64);
            } else {
                push_u64(&mut out, v as u64);
            }
            out
        }
        &mir_types::ConstantKind::Uint(val) => {
            let mut out = String::new();
            push_u64(&mut out, val as u64);
            out
        }
        &mir_types::ConstantKind::Float(bits) => {
            let mut out = String::new();
            out.push_str("float(0x");
            push_hex_u64(&mut out, bits);
            out.push(')');
            out
        }
        &mir_types::ConstantKind::Bool(val) => {
            if val {
                common::make_string("true")
            } else {
                common::make_string("false")
            }
        }
        &mir_types::ConstantKind::Char(val) => {
            let mut out = String::new();
            out.push('\'');
            out.push(val);
            out.push('\'');
            out
        }
        &mir_types::ConstantKind::String(ref val) => {
            let mut out = String::new();
            out.push('"');
            // Truncate very long strings for readability
            let bytes = val.as_bytes();
            let limit: usize = if bytes.len() > 60 { 60 } else { bytes.len() };
            let mut i: usize = 0;
            while i < limit {
                let b = bytes[i];
                if b == 10 { // '\n'
                    out.push_str("\\n");
                } else if b == 13 { // '\r'
                    out.push_str("\\r");
                } else if b == 9 { // '\t'
                    out.push_str("\\t");
                } else if b == 34 { // '"'
                    out.push_str("\\\"");
                } else if b == 92 { // '\'
                    out.push_str("\\\\");
                } else if b >= 32 && b < 127 {
                    out.push(b as char);
                } else {
                    out.push_str("\\x");
                    push_hex_u8(&mut out, b);
                }
                i = i + 1;
            }
            if bytes.len() > 60 {
                out.push_str("...");
            }
            out.push('"');
            out
        }
        &mir_types::ConstantKind::ByteString(ref val) => {
            let mut out = String::new();
            out.push_str("b\"<");
            push_u64(&mut out, val.len() as u64);
            out.push_str(" bytes>\"");
            out
        }
        &mir_types::ConstantKind::Unit => common::make_string("()"),
        &mir_types::ConstantKind::FnDef(ref def_id) => {
            let mut out = String::new();
            out.push_str("fn(def");
            push_u32(&mut out, def_id.index);
            out.push(')');
            out
        }
        &mir_types::ConstantKind::ConstDef(ref def_id) => {
            let mut out = String::new();
            out.push_str("const(def");
            push_u32(&mut out, def_id.index);
            out.push(')');
            out
        }
        &mir_types::ConstantKind::StaticDef(ref def_id) => {
            let mut out = String::new();
            out.push_str("static(def");
            push_u32(&mut out, def_id.index);
            out.push(')');
            out
        }
        &mir_types::ConstantKind::ZeroSized => common::make_string("zst"),
    }
}

// ============================================================
// Operator Formatting
// ============================================================

/// Formats a binary operator.
pub fn format_binop(binop: &mir_types::MirBinOp) -> String {
    match binop {
        &mir_types::MirBinOp::Add => common::make_string("Add"),
        &mir_types::MirBinOp::Sub => common::make_string("Sub"),
        &mir_types::MirBinOp::Mul => common::make_string("Mul"),
        &mir_types::MirBinOp::Div => common::make_string("Div"),
        &mir_types::MirBinOp::Rem => common::make_string("Rem"),
        &mir_types::MirBinOp::Eq => common::make_string("Eq"),
        &mir_types::MirBinOp::Ne => common::make_string("Ne"),
        &mir_types::MirBinOp::Lt => common::make_string("Lt"),
        &mir_types::MirBinOp::Le => common::make_string("Le"),
        &mir_types::MirBinOp::Gt => common::make_string("Gt"),
        &mir_types::MirBinOp::Ge => common::make_string("Ge"),
        &mir_types::MirBinOp::BitAnd => common::make_string("BitAnd"),
        &mir_types::MirBinOp::BitOr => common::make_string("BitOr"),
        &mir_types::MirBinOp::BitXor => common::make_string("BitXor"),
        &mir_types::MirBinOp::Shl => common::make_string("Shl"),
        &mir_types::MirBinOp::Shr => common::make_string("Shr"),
        &mir_types::MirBinOp::AddChecked => common::make_string("AddChecked"),
        &mir_types::MirBinOp::SubChecked => common::make_string("SubChecked"),
        &mir_types::MirBinOp::MulChecked => common::make_string("MulChecked"),
    }
}

/// Formats a unary operator.
pub fn format_unop(unop: &mir_types::MirUnOp) -> String {
    match unop {
        &mir_types::MirUnOp::Neg => common::make_string("Neg"),
        &mir_types::MirUnOp::Not => common::make_string("Not"),
    }
}

/// Formats an aggregate kind.
pub fn format_aggregate_kind(kind: &mir_types::AggregateKind) -> String {
    match kind {
        &mir_types::AggregateKind::Tuple => common::make_string("Tuple"),
        &mir_types::AggregateKind::Array(ref elem_ty) => {
            let mut out = String::new();
            out.push_str("Array(");
            let elem_hir_ty = type_intern::ty_id_to_type(*elem_ty);
            let ty_str = format_type(&elem_hir_ty);
            out.push_str(ty_str.as_str());
            out.push(')');
            out
        }
        &mir_types::AggregateKind::Adt { def_id, variant_idx, ref type_args } => {
            let mut out = String::new();
            out.push_str("Adt(def");
            push_u32(&mut out, def_id.index);
            out.push_str(", variant=");
            push_u32(&mut out, variant_idx);
            if type_args.len() > 0 {
                out.push_str(", args=<");
                let mut i: usize = 0;
                while i < type_args.len() {
                    if i > 0 {
                        out.push_str(", ");
                    }
                    let ta_hir_ty = type_intern::ty_id_to_type(type_args[i]);
                    let a = format_type(&ta_hir_ty);
                    out.push_str(a.as_str());
                    i = i + 1;
                }
                out.push('>');
            }
            out.push(')');
            out
        }
        &mir_types::AggregateKind::Record => common::make_string("Record"),
        &mir_types::AggregateKind::Closure { def_id } => {
            let mut out = String::new();
            out.push_str("Closure(def");
            push_u32(&mut out, def_id.index);
            out.push(')');
            out
        }
        &mir_types::AggregateKind::Range { ref element, inclusive } => {
            let mut out = String::new();
            if inclusive {
                out.push_str("RangeInclusive(");
            } else {
                out.push_str("Range(");
            }
            let elem_hir_ty = type_intern::ty_id_to_type(*element);
            let ty_str = format_type(&elem_hir_ty);
            out.push_str(ty_str.as_str());
            out.push(')');
            out
        }
    }
}

// ============================================================
// Rvalue Formatting
// ============================================================

/// Formats an rvalue (right-hand side of an assignment).
pub fn format_rvalue(rv: &mir_types::Rvalue) -> String {
    match rv {
        &mir_types::Rvalue::Use(ref operand) => {
            let mut out = String::new();
            out.push_str("Use(");
            let op_str = format_operand(operand);
            out.push_str(op_str.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::Ref { ref place, mutable } => {
            let mut out = String::new();
            if mutable {
                out.push_str("Ref(&mut ");
            } else {
                out.push_str("Ref(&");
            }
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::AddressOf { ref place, mutable } => {
            let mut out = String::new();
            if mutable {
                out.push_str("AddressOf(*mut ");
            } else {
                out.push_str("AddressOf(*const ");
            }
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::BinaryOp { op: ref bin_op, ref left, ref right } => {
            let mut out = String::new();
            out.push_str("BinaryOp(");
            let op_str = format_binop(bin_op);
            out.push_str(op_str.as_str());
            out.push_str(", ");
            let l = format_operand(left);
            out.push_str(l.as_str());
            out.push_str(", ");
            let r = format_operand(right);
            out.push_str(r.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::UnaryOp { op: ref un_op, ref operand } => {
            let mut out = String::new();
            out.push_str("UnaryOp(");
            let op_str = format_unop(un_op);
            out.push_str(op_str.as_str());
            out.push_str(", ");
            let operand_str = format_operand(operand);
            out.push_str(operand_str.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::Cast { ref operand, ref target_ty } => {
            let mut out = String::new();
            out.push_str("Cast(");
            let operand_str = format_operand(operand);
            out.push_str(operand_str.as_str());
            out.push_str(" as ");
            let target_hir_ty = type_intern::ty_id_to_type(*target_ty);
            let ty_str = format_type(&target_hir_ty);
            out.push_str(ty_str.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::Aggregate { ref kind, ref operands } => {
            let mut out = String::new();
            out.push_str("Aggregate(");
            let kind_str = format_aggregate_kind(kind);
            out.push_str(kind_str.as_str());
            out.push_str(", [");
            let mut i: usize = 0;
            while i < operands.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let op_str = format_operand(&operands[i]);
                out.push_str(op_str.as_str());
                i = i + 1;
            }
            out.push_str("])");
            out
        }
        &mir_types::Rvalue::Discriminant(ref place) => {
            let mut out = String::new();
            out.push_str("Discriminant(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::Len(ref place) => {
            let mut out = String::new();
            out.push_str("Len(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_types::Rvalue::ArrayToSlice { ref array_ref, array_len } => {
            let mut out = String::new();
            out.push_str("ArrayToSlice(");
            let arr_op = format_operand(array_ref);
            out.push_str(arr_op.as_str());
            out.push_str(", len=");
            push_u64(&mut out, array_len);
            out.push(')');
            out
        }
        &mir_types::Rvalue::ZeroInit(ref ty) => {
            let mut out = String::new();
            out.push_str("ZeroInit(");
            let zi_hir_ty = type_intern::ty_id_to_type(*ty);
            let ty_str = format_type(&zi_hir_ty);
            out.push_str(ty_str.as_str());
            out.push(')');
            out
        }
    }
}

// ============================================================
// Statement Formatting
// ============================================================

/// Formats a statement.
pub fn format_statement(stmt: &mir_stmt::Statement) -> String {
    match &stmt.kind {
        &mir_stmt::StatementKind::Assign { ref place, ref rvalue } => {
            let mut out = String::new();
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push_str(" = ");
            let rv = format_rvalue(rvalue);
            out.push_str(rv.as_str());
            out
        }
        &mir_stmt::StatementKind::StorageLive(ref local) => {
            let mut out = String::new();
            out.push_str("StorageLive(_");
            push_u32(&mut out, local.index);
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::StorageDead(ref local) => {
            let mut out = String::new();
            out.push_str("StorageDead(_");
            push_u32(&mut out, local.index);
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::Drop(ref place) => {
            let mut out = String::new();
            out.push_str("Drop(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::PushHandler { handler_id, ref state_place, ref state_kind } => {
            let mut out = String::new();
            out.push_str("PushHandler(def");
            push_u32(&mut out, handler_id.index);
            out.push_str(", state=");
            let sp = format_place(state_place);
            out.push_str(sp.as_str());
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::PopHandler => {
            common::make_string("PopHandler")
        }
        &mir_stmt::StatementKind::PushInlineHandler { effect_id, ref operations } => {
            let mut out = String::new();
            out.push_str("PushInlineHandler(def");
            push_u32(&mut out, effect_id.index);
            out.push_str(", ops=");
            push_u32(&mut out, operations.len() as u32);
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::CallReturnClause { handler_id, ref handler_name, ref body_result, ref state_place, ref destination } => {
            let mut out = String::new();
            out.push_str("CallReturnClause(");
            out.push_str(handler_name.as_str());
            out.push_str(", result=");
            let br = format_operand(body_result);
            out.push_str(br.as_str());
            out.push_str(", dest=");
            let d = format_place(destination);
            out.push_str(d.as_str());
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::Deinit(ref place) => {
            let mut out = String::new();
            out.push_str("Deinit(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::SetDiscriminant { ref place, variant_idx } => {
            let mut out = String::new();
            out.push_str("SetDiscriminant(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push_str(", variant=");
            push_u32(&mut out, variant_idx);
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::CopyNonOverlapping { ref src, ref dst, ref count } => {
            let mut out = String::new();
            out.push_str("CopyNonOverlapping(src=");
            let s = format_operand(src);
            out.push_str(s.as_str());
            out.push_str(", dst=");
            let d = format_operand(dst);
            out.push_str(d.as_str());
            out.push_str(", count=");
            let c = format_operand(count);
            out.push_str(c.as_str());
            out.push(')');
            out
        }
        &mir_stmt::StatementKind::Nop => common::make_string("Nop"),
    }
}

// ============================================================
// Terminator Formatting
// ============================================================

/// Formats a terminator.
pub fn format_terminator(term: &mir_term::Terminator) -> String {
    match &term.kind {
        &mir_term::TerminatorKind::Goto { target } => {
            let mut out = String::new();
            out.push_str("goto -> bb");
            push_u32(&mut out, target.index);
            out
        }
        &mir_term::TerminatorKind::SwitchInt { ref discr, ref targets } => {
            let mut out = String::new();
            out.push_str("switchInt(");
            let d = format_operand(discr);
            out.push_str(d.as_str());
            out.push_str(") [");
            let mut i: usize = 0;
            while i < targets.targets.len() {
                let t = &targets.targets[i];
                if i > 0 {
                    out.push_str(", ");
                }
                push_u64(&mut out, t.value as u64);
                out.push_str(" -> bb");
                push_u32(&mut out, t.target.index);
                i = i + 1;
            }
            out.push_str(", otherwise -> bb");
            push_u32(&mut out, targets.otherwise.index);
            out.push(']');
            out
        }
        &mir_term::TerminatorKind::Return => {
            common::make_string("return")
        }
        &mir_term::TerminatorKind::Call { ref func, ref args, ref destination, ref target, ref unwind } => {
            let mut out = String::new();
            let dest = format_place(destination);
            out.push_str(dest.as_str());
            out.push_str(" = call ");
            let f = format_operand(func);
            out.push_str(f.as_str());
            out.push('(');
            let mut i: usize = 0;
            while i < args.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let a = format_operand(&args[i]);
                out.push_str(a.as_str());
                i = i + 1;
            }
            out.push_str(") -> ");
            match target {
                &Option::Some(ref t) => {
                    out.push_str("bb");
                    push_u32(&mut out, t.index);
                }
                &Option::None => {
                    out.push_str("diverge");
                }
            }
            out
        }
        &mir_term::TerminatorKind::Assert { ref cond, expected, ref msg, target, ref unwind } => {
            let mut out = String::new();
            out.push_str("assert(");
            let c = format_operand(cond);
            out.push_str(c.as_str());
            out.push_str(", expected=");
            if expected {
                out.push_str("true");
            } else {
                out.push_str("false");
            }
            out.push_str(", \"");
            out.push_str(msg.as_str());
            out.push_str("\") -> bb");
            push_u32(&mut out, target.index);
            out
        }
        &mir_term::TerminatorKind::Perform { effect_id, op_index, ref args, ref destination, ref target, is_tail_resumptive } => {
            let mut out = String::new();
            let dest = format_place(destination);
            out.push_str(dest.as_str());
            out.push_str(" = perform def");
            push_u32(&mut out, effect_id.index);
            out.push_str(".op");
            push_u32(&mut out, op_index);
            out.push('(');
            let mut i: usize = 0;
            while i < args.len() {
                if i > 0 {
                    out.push_str(", ");
                }
                let a = format_operand(&args[i]);
                out.push_str(a.as_str());
                i = i + 1;
            }
            out.push_str(") -> ");
            match target {
                &Option::Some(ref t) => {
                    out.push_str("bb");
                    push_u32(&mut out, t.index);
                }
                &Option::None => {
                    out.push_str("diverge");
                }
            }
            if is_tail_resumptive {
                out.push_str(" [tail-resumptive]");
            }
            out
        }
        &mir_term::TerminatorKind::Resume { ref value } => {
            let mut out = String::new();
            out.push_str("resume");
            match value {
                &Option::Some(ref v) => {
                    out.push('(');
                    let val = format_operand(v);
                    out.push_str(val.as_str());
                    out.push(')');
                }
                &Option::None => {}
            }
            out
        }
        &mir_term::TerminatorKind::Unreachable => {
            common::make_string("unreachable")
        }
        &mir_term::TerminatorKind::Drop { ref place, target, ref unwind } => {
            let mut out = String::new();
            out.push_str("drop(");
            let p = format_place(place);
            out.push_str(p.as_str());
            out.push_str(") -> bb");
            push_u32(&mut out, target.index);
            out
        }
    }
}

// ============================================================
// Number Formatting Helpers
// ============================================================

/// Pushes a u32 as decimal digits into a string.
fn push_u32(s: &mut String, val: u32) {
    if val == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}

/// Pushes a u64 as decimal digits into a string.
fn push_u64(s: &mut String, val: u64) {
    if val == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 10) as u8;
        digits.push(digit + 48);
        n = n / 10;
    }
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}

/// Pushes a u64 as hexadecimal digits into a string.
fn push_hex_u64(s: &mut String, val: u64) {
    if val == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        let digit = (n % 16) as u8;
        if digit < 10 {
            digits.push(digit + 48);
        } else {
            digits.push(digit - 10 + 97); // 'a'
        }
        n = n / 16;
    }
    let mut i = digits.len();
    while i > 0 {
        i = i - 1;
        s.push(digits[i] as char);
    }
}

/// Pushes a u8 as two-digit hex into a string.
fn push_hex_u8(s: &mut String, val: u8) {
    let hi = val / 16;
    let lo = val % 16;
    if hi < 10 {
        s.push((hi + 48) as char);
    } else {
        s.push((hi - 10 + 97) as char);
    }
    if lo < 10 {
        s.push((lo + 48) as char);
    } else {
        s.push((lo - 10 + 97) as char);
    }
}
