// Blood Self-Hosted Compiler - Abstract Syntax Tree
//
// This module defines the AST data structures that represent parsed Blood
// programs. The AST closely mirrors the surface syntax.

mod common;

// ============================================================
// Program
// ============================================================

/// A program is a compilation unit.
pub struct Program {
    /// Optional module declaration.
    pub mod_decl: Option<ModuleDecl>,
    /// Import statements.
    pub imports: Vec<Import>,
    /// Top-level declarations.
    pub declarations: Vec<Declaration>,
    /// The span of the entire program.
    pub span: common::Span,
}

/// Module declaration: `module std.collections.vec;`
pub struct ModuleDecl {
    pub path: ModulePath,
    pub span: common::Span,
}

/// A module path like `std.collections.vec`.
pub struct ModulePath {
    pub segments: Vec<common::SpannedSymbol>,
    pub span: common::Span,
}

// ============================================================
// Imports
// ============================================================

/// Import statement.
pub enum Import {
    /// `use std.mem.allocate;`
    Simple {
        path: ModulePath,
        alias: Option<common::SpannedSymbol>,
        span: common::Span,
    },
    /// `use std.iter::{Iterator, IntoIterator};`
    Group {
        path: ModulePath,
        items: Vec<ImportItem>,
        span: common::Span,
    },
    /// `use std.ops::*;`
    Glob {
        path: ModulePath,
        span: common::Span,
    },
}

pub struct ImportItem {
    pub name: common::SpannedSymbol,
    pub alias: Option<common::SpannedSymbol>,
}

// ============================================================
// Declarations
// ============================================================

/// Top-level declarations.
pub enum Declaration {
    Function(FnDecl),
    TypeAlias(TypeAliasDecl),
    Struct(StructDecl),
    Enum(EnumDecl),
    Effect(EffectDecl),
    Handler(HandlerDecl),
    Const(ConstDecl),
    Static(StaticDecl),
    Impl(ImplBlock),
    Trait(TraitDecl),
    Bridge(BridgeDecl),
    Module(ModItemDecl),
    Macro(MacroDecl),
    Use(UseDecl),
}

/// Use re-export declaration: `pub use module::Item;`
pub struct UseDecl {
    pub vis: common::Visibility,
    pub module_name: common::SpannedSymbol,
    pub item_name: common::SpannedSymbol,
    pub span: common::Span,
}

/// Module item declaration: `mod foo;` or `mod foo { ... }`
pub struct ModItemDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub body: Option<Vec<Declaration>>,
    pub span: common::Span,
}

// ============================================================
// Attributes
// ============================================================

pub struct Attribute {
    pub is_inner: bool,
    pub path: Vec<common::SpannedSymbol>,
    pub args: Option<AttributeArgs>,
    pub span: common::Span,
}

pub enum AttributeArgs {
    Eq(Literal),
    List(Vec<AttributeArg>),
}

pub enum AttributeArg {
    Ident(common::SpannedSymbol),
    KeyValue { key: common::SpannedSymbol, val: Literal },
    Lit(Literal),
    Call { name: common::SpannedSymbol, arg: Literal },
}

// ============================================================
// Function Declaration
// ============================================================

pub struct FnDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub qualifiers: common::FnQualifiers,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub params: Vec<Param>,
    pub return_type: Option<Type>,
    pub effects: Option<EffectRow>,
    pub where_clause: Option<WhereClause>,
    pub body: Option<Block>,
    pub span: common::Span,
}

pub struct Param {
    pub qualifier: Option<ParamQualifier>,
    pub pattern: Pattern,
    pub ty: Type,
    pub span: common::Span,
}

pub enum ParamQualifier {
    Linear,
    Affine,
    Mut,
}

// ============================================================
// Type Declarations
// ============================================================

pub struct TypeAliasDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub ty: Type,
    pub span: common::Span,
}

pub struct StructDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub body: StructBody,
    pub span: common::Span,
}

pub enum StructBody {
    Record(Vec<StructField>),
    Tuple(Vec<Type>),
    Unit,
}

pub struct StructField {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub span: common::Span,
}

pub struct EnumDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub variants: Vec<EnumVariant>,
    pub span: common::Span,
}

pub struct EnumVariant {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub body: StructBody,
    pub span: common::Span,
}

// ============================================================
// Effect and Handler Declarations
// ============================================================

pub struct EffectDecl {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub parent_effects: Vec<Type>,
    pub operations: Vec<OperationDecl>,
    pub span: common::Span,
}

pub struct OperationDecl {
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub params: Vec<Param>,
    pub return_type: Type,
    pub span: common::Span,
}

pub struct HandlerDecl {
    pub attrs: Vec<Attribute>,
    pub kind: common::HandlerKind,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub effect: Type,
    pub where_clause: Option<WhereClause>,
    pub state: Vec<HandlerState>,
    pub return_clause: Option<ReturnClause>,
    pub operations: Vec<OperationImpl>,
    pub span: common::Span,
}

pub struct HandlerState {
    pub is_mut: bool,
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub default_val: Option<Expr>,
    pub span: common::Span,
}

pub struct ReturnClause {
    pub param: common::SpannedSymbol,
    pub body: Block,
    pub span: common::Span,
}

pub struct OperationImpl {
    pub name: common::SpannedSymbol,
    pub params: Vec<Pattern>,
    pub body: Block,
    pub span: common::Span,
}

pub struct TryWithHandler {
    pub effect: TypePath,
    pub operation: common::SpannedSymbol,
    pub params: Vec<Pattern>,
    pub body: Block,
    pub span: common::Span,
}

// ============================================================
// Trait and Implementation
// ============================================================

pub struct TraitDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub type_params: Option<TypeParams>,
    pub supertraits: Vec<Type>,
    pub where_clause: Option<WhereClause>,
    pub items: Vec<TraitItem>,
    pub span: common::Span,
}

pub enum TraitItem {
    Function(FnDecl),
    TypeAlias(TypeAliasDecl),
    Const(ConstDecl),
}

pub struct ImplBlock {
    pub attrs: Vec<Attribute>,
    pub type_params: Option<TypeParams>,
    pub trait_ty: Option<Type>,
    pub self_ty: Type,
    pub where_clause: Option<WhereClause>,
    pub items: Vec<ImplItem>,
    pub span: common::Span,
}

pub enum ImplItem {
    Function(FnDecl),
    TypeAlias(TypeAliasDecl),
    Const(ConstDecl),
}

// ============================================================
// Constants and Statics
// ============================================================

pub struct ConstDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub init_value: Expr,
    pub span: common::Span,
}

pub struct StaticDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub is_mut: bool,
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub init_value: Expr,
    pub span: common::Span,
}

// ============================================================
// Bridge Declaration (FFI)
// ============================================================

pub struct BridgeDecl {
    pub attrs: Vec<Attribute>,
    pub language: common::SpannedString,
    pub name: common::SpannedSymbol,
    pub items: Vec<BridgeItem>,
    pub span: common::Span,
}

pub enum BridgeItem {
    Link(LinkSpec),
    Function(BridgeFn),
    Const(BridgeConst),
    OpaqueType(BridgeOpaqueType),
    TypeAlias(BridgeTypeAlias),
    Struct(BridgeStruct),
    Enum(BridgeEnum),
    Union(BridgeUnion),
    Callback(BridgeCallback),
}

pub struct LinkSpec {
    pub name: String,
    pub kind: Option<LinkKind>,
    pub wasm_import_module: Option<String>,
    pub span: common::Span,
}

pub enum LinkKind {
    Dylib,
    Static,
    Framework,
}

pub struct BridgeFn {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub params: Vec<BridgeParam>,
    pub is_variadic: bool,
    pub return_type: Option<Type>,
    pub span: common::Span,
}

pub struct BridgeParam {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub ownership: Option<BridgeOwnership>,
    pub span: common::Span,
}

pub enum BridgeOwnership {
    Borrow,
    Transfer,
    Acquire,
}

pub struct BridgeConst {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub init_value: Literal,
    pub span: common::Span,
}

pub struct BridgeOpaqueType {
    pub name: common::SpannedSymbol,
    pub span: common::Span,
}

pub struct BridgeTypeAlias {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub span: common::Span,
}

pub struct BridgeStruct {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub fields: Vec<BridgeField>,
    pub span: common::Span,
}

pub struct BridgeField {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub span: common::Span,
}

pub struct BridgeEnum {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub variants: Vec<BridgeEnumVariant>,
    pub span: common::Span,
}

pub struct BridgeEnumVariant {
    pub name: common::SpannedSymbol,
    pub discriminant: Option<Literal>,
    pub span: common::Span,
}

pub struct BridgeUnion {
    pub attrs: Vec<Attribute>,
    pub name: common::SpannedSymbol,
    pub fields: Vec<BridgeField>,
    pub span: common::Span,
}

pub struct BridgeCallback {
    pub name: common::SpannedSymbol,
    pub params: Vec<Type>,
    pub return_type: Option<Type>,
    pub span: common::Span,
}

// ============================================================
// Type Parameters and Constraints
// ============================================================

pub struct TypeParams {
    pub params: Vec<GenericParam>,
    pub span: common::Span,
}

pub enum GenericParam {
    Type(TypeParam),
    Lifetime(LifetimeParam),
    Const(ConstGenericParam),
}

pub struct TypeParam {
    pub name: common::SpannedSymbol,
    pub bounds: Vec<Type>,
    pub span: common::Span,
}

pub struct LifetimeParam {
    pub name: common::SpannedSymbol,
    pub bounds: Vec<common::SpannedSymbol>,
    pub span: common::Span,
}

pub struct ConstGenericParam {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub span: common::Span,
}

pub struct WhereClause {
    pub predicates: Vec<WherePredicate>,
    pub span: common::Span,
}

pub enum WherePredicate {
    TypeBound {
        ty: Type,
        bounds: Vec<Type>,
        span: common::Span,
    },
    Lifetime {
        lifetime: common::SpannedSymbol,
        bound: common::SpannedSymbol,
        span: common::Span,
    },
}

// ============================================================
// Types
// ============================================================

pub struct Type {
    pub kind: TypeKind,
    pub span: common::Span,
}

pub enum TypeKind {
    Path(TypePath),
    Reference {
        lifetime: Option<common::SpannedSymbol>,
        is_mut: bool,
        inner: Box<Type>,
    },
    Pointer {
        is_mut: bool,
        inner: Box<Type>,
    },
    Array {
        element: Box<Type>,
        size: Box<Expr>,
    },
    Slice {
        element: Box<Type>,
    },
    Tuple(Vec<Type>),
    Function {
        params: Vec<Type>,
        return_type: Box<Type>,
        effects: Option<EffectRow>,
    },
    Record {
        fields: Vec<RecordTypeField>,
        rest: Option<common::SpannedSymbol>,
    },
    Ownership {
        qualifier: OwnershipQualifier,
        inner: Box<Type>,
    },
    Forall {
        params: Vec<common::SpannedSymbol>,
        body: Box<Type>,
    },
    Never,
    Infer,
    Paren(Box<Type>),
}

pub struct TypePath {
    pub segments: Vec<TypePathSegment>,
    pub span: common::Span,
}

pub struct TypePathSegment {
    pub name: common::SpannedSymbol,
    pub args: Option<TypeArgs>,
}

pub struct TypeArgs {
    pub args: Vec<TypeArg>,
    pub span: common::Span,
}

pub enum TypeArg {
    Type(Type),
    Lifetime(common::SpannedSymbol),
    Const(Expr),
}

pub struct RecordTypeField {
    pub name: common::SpannedSymbol,
    pub ty: Type,
    pub span: common::Span,
}

pub enum OwnershipQualifier {
    Linear,
    Affine,
}

// ============================================================
// Effect Rows
// ============================================================

pub struct EffectRow {
    pub kind: EffectRowKind,
    pub span: common::Span,
}

pub enum EffectRowKind {
    Pure,
    Effects {
        effects: Vec<Type>,
        rest: Option<common::SpannedSymbol>,
    },
    Var(common::SpannedSymbol),
}

// ============================================================
// Expressions
// ============================================================

pub struct Expr {
    pub kind: ExprKind,
    pub span: common::Span,
}

pub enum ExprKind {
    Literal(Literal),
    Path(ExprPath),
    Binary {
        op: common::BinOp,
        left: Box<Expr>,
        right: Box<Expr>,
    },
    Unary {
        op: common::UnaryOp,
        operand: Box<Expr>,
    },
    Call {
        callee: Box<Expr>,
        args: Vec<CallArg>,
    },
    MethodCall {
        receiver: Box<Expr>,
        method: common::SpannedSymbol,
        type_args: Option<TypeArgs>,
        args: Vec<CallArg>,
    },
    Field {
        base: Box<Expr>,
        field: FieldAccess,
    },
    Index {
        base: Box<Expr>,
        idx: Box<Expr>,
    },
    Tuple(Vec<Expr>),
    Array(ArrayExpr),
    Record {
        path: Option<TypePath>,
        fields: Vec<RecordExprField>,
        base: Option<Box<Expr>>,
    },
    Range {
        start: Option<Box<Expr>>,
        end_val: Option<Box<Expr>>,
        inclusive: bool,
    },
    Cast {
        expr: Box<Expr>,
        ty: Type,
    },
    Assign {
        target: Box<Expr>,
        val: Box<Expr>,
    },
    AssignOp {
        op: common::BinOp,
        target: Box<Expr>,
        val: Box<Expr>,
    },
    Block(Block),
    If {
        condition: Box<Expr>,
        then_branch: Block,
        else_branch: Option<ElseBranch>,
    },
    IfLet {
        pattern: Pattern,
        scrutinee: Box<Expr>,
        then_branch: Block,
        else_branch: Option<ElseBranch>,
    },
    Match {
        scrutinee: Box<Expr>,
        arms: Vec<MatchArm>,
    },
    Loop {
        label: Option<common::SpannedSymbol>,
        body: Block,
    },
    While {
        label: Option<common::SpannedSymbol>,
        condition: Box<Expr>,
        body: Block,
    },
    WhileLet {
        label: Option<common::SpannedSymbol>,
        pattern: Pattern,
        scrutinee: Box<Expr>,
        body: Block,
    },
    For {
        label: Option<common::SpannedSymbol>,
        pattern: Pattern,
        iter: Box<Expr>,
        body: Block,
    },
    Return(Option<Box<Expr>>),
    Break {
        label: Option<common::SpannedSymbol>,
        val: Option<Box<Expr>>,
    },
    Continue {
        label: Option<common::SpannedSymbol>,
    },
    Closure {
        is_move: bool,
        params: Vec<ClosureParam>,
        return_type: Option<Type>,
        effects: Option<EffectRow>,
        body: Box<Expr>,
    },
    WithHandle {
        handler: Box<Expr>,
        body: Box<Expr>,
    },
    Perform {
        effect: Option<TypePath>,
        operation: common::SpannedSymbol,
        args: Vec<Expr>,
    },
    Resume(Box<Expr>),
    Try(Box<Expr>),
    TryWith {
        body: Block,
        handlers: Vec<TryWithHandler>,
    },
    Unsafe(Block),
    Region {
        name: Option<common::SpannedSymbol>,
        body: Block,
    },
    Paren(Box<Expr>),
    Default,
    MacroCall {
        path: ExprPath,
        kind: MacroCallKind,
    },
}

/// A named format argument: name = expr
pub struct NamedFormatArg {
    pub name: common::SpannedSymbol,
    pub val: Expr,
}

pub enum MacroCallKind {
    Format {
        format_str: common::SpannedString,
        args: Vec<Expr>,
        named_args: Vec<NamedFormatArg>,
    },
    VecMacro(VecMacroArgs),
    Assert {
        condition: Box<Expr>,
        message: Option<Box<Expr>>,
    },
    Dbg(Box<Expr>),
    Matches {
        expr: Box<Expr>,
        pattern: Box<Pattern>,
    },
    Custom {
        delim: MacroDelimiter,
        content: String,
    },
}

pub enum MacroDelimiter {
    Paren,
    Bracket,
    Brace,
}

pub enum VecMacroArgs {
    List(Vec<Expr>),
    Repeat {
        val: Box<Expr>,
        count: Box<Expr>,
    },
}

pub struct ExprPath {
    pub segments: Vec<ExprPathSegment>,
    pub span: common::Span,
}

pub struct ExprPathSegment {
    pub name: common::SpannedSymbol,
    pub args: Option<TypeArgs>,
}

pub struct CallArg {
    pub name: Option<common::SpannedSymbol>,
    pub val: Expr,
    pub span: common::Span,
}

pub enum FieldAccess {
    Named(common::SpannedSymbol),
    Index(u32, common::Span),
}

pub enum ArrayExpr {
    List(Vec<Expr>),
    Repeat {
        val: Box<Expr>,
        count: Box<Expr>,
    },
}

pub struct RecordExprField {
    pub name: common::SpannedSymbol,
    pub val: Option<Expr>,
    pub span: common::Span,
}

pub enum ElseBranch {
    Block(Block),
    If(Box<Expr>),
}

pub struct MatchArm {
    pub pattern: Pattern,
    pub guard: Option<Expr>,
    pub body: Expr,
    pub span: common::Span,
}

pub struct ClosureParam {
    pub pattern: Pattern,
    pub ty: Option<Type>,
    pub span: common::Span,
}

// ============================================================
// Literals
// ============================================================

pub struct Literal {
    pub kind: LiteralKind,
    pub span: common::Span,
}

pub enum LiteralKind {
    Int {
        val: u128,
        suffix: Option<IntSuffix>,
    },
    Float {
        bits: u64,
        suffix: Option<FloatSuffix>,
    },
    Str(String),
    ByteStr(Vec<u8>),
    Char(char),
    Bool(bool),
}

pub enum IntSuffix {
    I8,
    I16,
    I32,
    I64,
    I128,
    Isize,
    U8,
    U16,
    U32,
    U64,
    U128,
    Usize,
}

pub enum FloatSuffix {
    F32,
    F64,
}

// ============================================================
// Patterns
// ============================================================

pub struct Pattern {
    pub kind: PatternKind,
    pub span: common::Span,
}

pub enum PatternKind {
    Wildcard,
    Rest,
    Literal(Literal),
    Ident {
        by_ref: bool,
        is_mut: bool,
        name: common::SpannedSymbol,
        subpattern: Option<Box<Pattern>>,
    },
    Ref {
        is_mut: bool,
        inner: Box<Pattern>,
    },
    Struct {
        path: TypePath,
        fields: Vec<StructPatternField>,
        has_rest: bool,
    },
    TupleStruct {
        path: TypePath,
        fields: Vec<Pattern>,
        rest_pos: Option<usize>,
    },
    Tuple {
        fields: Vec<Pattern>,
        rest_pos: Option<usize>,
    },
    Slice {
        elements: Vec<Pattern>,
        rest_pos: Option<usize>,
    },
    Or(Vec<Pattern>),
    Range {
        start: Option<Box<Pattern>>,
        end_val: Option<Box<Pattern>>,
        inclusive: bool,
    },
    Path(TypePath),
    Paren(Box<Pattern>),
}

pub struct StructPatternField {
    pub name: common::SpannedSymbol,
    pub pattern: Option<Pattern>,
    pub span: common::Span,
}

// ============================================================
// Statements and Blocks
// ============================================================

pub struct Block {
    pub statements: Vec<Statement>,
    pub expr: Option<Box<Expr>>,
    pub span: common::Span,
}

pub enum Statement {
    Let {
        pattern: Pattern,
        ty: Option<Type>,
        init_val: Option<Expr>,
        span: common::Span,
    },
    Expr {
        expr: Expr,
        has_semi: bool,
    },
    Item(Declaration),
}

// ============================================================
// Macro System Types
// ============================================================

pub struct HygieneId {
    pub id: u32,
}

pub struct MacroDecl {
    pub attrs: Vec<Attribute>,
    pub vis: common::Visibility,
    pub name: common::SpannedSymbol,
    pub rules: Vec<MacroRule>,
    pub span: common::Span,
}

pub struct MacroRule {
    pub pattern: MacroPattern,
    pub expansion: MacroExpansion,
    pub span: common::Span,
}

pub struct MacroPattern {
    pub parts: Vec<MacroPatternPart>,
    pub span: common::Span,
}

pub enum MacroPatternPart {
    Token {
        kind: MacroTokenKind,
        span: common::Span,
    },
    Capture {
        name: common::SpannedSymbol,
        fragment: FragmentKind,
        span: common::Span,
    },
    Repetition {
        pattern: Vec<MacroPatternPart>,
        separator: Option<MacroTokenKind>,
        kind: RepetitionKind,
        span: common::Span,
    },
    Group {
        delimiter: MacroDelimiter,
        pattern: Vec<MacroPatternPart>,
        span: common::Span,
    },
}

// Simplified token kind for macro patterns
pub enum MacroTokenKind {
    Ident,
    IntLit,
    FloatLit,
    StringLit,
    CharLit,
    Lifetime,
    Keyword(u32),
    Punct(u32),
}

pub enum FragmentKind {
    Expr,
    Ty,
    Pat,
    Ident,
    Literal,
    Block,
    Stmt,
    Item,
    TokenTree,
}

pub enum RepetitionKind {
    ZeroOrMore,
    OneOrMore,
    ZeroOrOne,
}

pub struct MacroExpansion {
    pub parts: Vec<MacroExpansionPart>,
    pub span: common::Span,
}

pub enum MacroExpansionPart {
    Tokens(Vec<MacroToken>),
    Substitution {
        name: common::SpannedSymbol,
        span: common::Span,
    },
    Repetition {
        parts: Vec<MacroExpansionPart>,
        separator: Option<MacroToken>,
        span: common::Span,
    },
    Group {
        delimiter: MacroDelimiter,
        parts: Vec<MacroExpansionPart>,
        span: common::Span,
    },
}

pub struct MacroToken {
    pub kind: MacroTokenKind,
    pub span: common::Span,
    pub hygiene: HygieneId,
}

pub struct TokenStream {
    pub tokens: Vec<TokenTree>,
}

pub enum TokenTree {
    Token(MacroToken),
    Group {
        delimiter: MacroDelimiter,
        stream: TokenStream,
        span: common::Span,
    },
}
