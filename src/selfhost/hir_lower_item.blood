// Blood Self-Hosted Compiler - HIR Item Lowering
//
// This module handles lowering AST declarations to HIR items:
// - Function parameter lowering
// - Struct body and field lowering
// - Enum variant lowering
// - Declaration lowering (function, struct, enum, etc.)
//
// Functions in this module take &mut LoweringCtx from hir_lower_ctx.

mod common;
mod ast;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod hir_lower_ctx;
mod hir_lower_type;
mod hir_lower_expr;
mod hir_lower_body;
mod resolve;
mod type_intern;

// ============================================================
// Function Parameter Lowering
// ============================================================

/// Lower function parameters.
pub fn lower_fn_params(ctx: &mut hir_lower_ctx::LoweringCtx, params: &Vec<ast::Param>) -> Vec<hir_item::FnParam> {
    let mut result: Vec<hir_item::FnParam> = Vec::new();
    let mut i: usize = 0;
    while i < params.len() {
        let param = lower_fn_param(ctx, &params[i], i as u32);
        result.push(param);
        i = i + 1;
    }
    result
}

/// Lower a single function parameter.
/// param_index is used for generating synthetic names for complex patterns.
fn lower_fn_param(ctx: &mut hir_lower_ctx::LoweringCtx, param: &ast::Param, param_index: u32) -> hir_item::FnParam {
    let ty = hir_lower_type::lower_type_id(ctx, &param.ty);

    // Extract the parameter name from the pattern
    // For complex patterns, this generates a synthetic name
    let (name, is_mut, _needs_destructure) = extract_param_name(&param.pattern, param_index);

    // Allocate a DefId for the parameter
    let def_id = ctx.alloc_def_id();

    // Check for qualifier-based mutability
    let mutable = is_mut || match &param.qualifier {
        &Some(ast::ParamQualifier::Mut) => true,
        _ => false,
    };

    // Check if this is a self parameter by checking the name
    let is_self = is_self_param_name(name.symbol);

    hir_item::FnParam::new(def_id, name, ty, mutable, is_self, param.span)
}

/// Checks if a parameter name symbol represents "self".
/// "self" is pre-interned at index 19 in the interner.
fn is_self_param_name(symbol: common::Symbol) -> bool {
    // "self" is pre-interned at index 19 (see interner.blood)
    symbol.index == 19
}

/// Extract the parameter name and mutability from a pattern.
/// Returns (name, is_mut, needs_destructuring) for all patterns.
/// For complex patterns, generates a synthetic name and signals that destructuring is needed.
fn extract_param_name(pattern: &ast::Pattern, param_index: u32) -> (common::SpannedSymbol, bool, bool) {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut, ref name, ref subpattern } => {
            // Simple ident without subpattern is trivial
            let needs_destructure = subpattern.is_some();
            (*name, is_mut, needs_destructure)
        }
        &ast::PatternKind::Wildcard => {
            // Create a synthetic name for wildcard parameters
            // Using symbol index 0 as a placeholder
            let span = pattern.span;
            let sym = common::Symbol::new(0);
            let spanned = common::SpannedSymbol { symbol: sym, span };
            (spanned, false, false)
        }
        &ast::PatternKind::Ref { is_mut: _, ref inner } => {
            // Look through reference patterns
            extract_param_name(inner.as_ref(), param_index)
        }
        _ => {
            // Complex pattern: generate synthetic name __param_N
            // The actual destructuring happens at the start of the function body
            let span = pattern.span;
            // Use a synthetic symbol. Symbol index encodes __param_N where N is param_index.
            // We'll use a high symbol index range (10000 + param_index) to avoid conflicts.
            let synthetic_index = 10000u32 + param_index;
            let sym = common::Symbol::new(synthetic_index);
            let spanned = common::SpannedSymbol { symbol: sym, span };
            (spanned, false, true)
        }
    }
}

/// Lower the return type, defaulting to unit if not specified.
pub fn lower_return_type(ctx: &mut hir_lower_ctx::LoweringCtx, return_type: &Option<ast::Type>) -> type_intern::TyId {
    match return_type {
        &Some(ref ty) => hir_lower_type::lower_type_id(ctx, ty),
        &None => type_intern::CommonTypes::unit(),
    }
}

/// Lower the effect row, defaulting to empty (pure) if not specified.
pub fn lower_effects(ctx: &mut hir_lower_ctx::LoweringCtx, effects: &Option<ast::EffectRow>) -> hir_ty::EffectRow {
    match effects {
        &Some(ref eff) => hir_lower_type::lower_effect_row(ctx, eff),
        &None => hir_ty::EffectRow::empty(),
    }
}

// ============================================================
// Struct Body Lowering
// ============================================================

/// Lower a struct body to HIR.
pub fn lower_struct_body(ctx: &mut hir_lower_ctx::LoweringCtx, body: &ast::StructBody) -> hir_item::StructBody {
    match body {
        &ast::StructBody::Unit => hir_item::StructBody::Unit,
        &ast::StructBody::Tuple(ref types) => {
            let mut lowered: Vec<type_intern::TyId> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let ty = hir_lower_type::lower_type_id(ctx, &types[i]);
                lowered.push(ty);
                i = i + 1;
            }
            hir_item::StructBody::Tuple(lowered)
        }
        &ast::StructBody::Record(ref fields) => {
            let mut lowered: Vec<hir_item::StructField> = Vec::new();
            // Check for duplicate field names using span bytes
            let mut i: usize = 0;
            while i < fields.len() {
                let mut j: usize = 0;
                while j < i {
                    if fields[j].name.span.start == fields[i].name.span.start {
                        // Same span start means same source text (can't happen for different fields)
                        j = j + 1;
                    } else {
                        // Compare field names by interning and checking symbol index
                        // NOTE: Avoid chained method calls (a.method1().method2()) to
                        // work around a first_gen codegen bug where .method2() is called
                        // on 'a' instead of on the result of method1().
                        let str_i = ctx.span_to_string(fields[i].name.span);
                        let ref_i = str_i.as_str();
                        let name_i = ctx.intern(ref_i);
                        let str_j = ctx.span_to_string(fields[j].name.span);
                        let ref_j = str_j.as_str();
                        let name_j = ctx.intern(ref_j);
                        if name_i.index == name_j.index {
                            let field_name = ctx.span_to_string(fields[i].name.span);
                            let field_name_str = field_name.as_str();
                            let mut msg = String::new();
                            msg.push_str("duplicate field name `");
                            msg.push_str(field_name_str);
                            msg.push_str("` in struct");
                            ctx.error(hir::DiagnosticCode::E0101, msg, fields[i].name.span);
                            break;
                        }
                        j = j + 1;
                    }
                }
                let field = lower_struct_field(ctx, &fields[i]);
                lowered.push(field);
                i = i + 1;
            }
            hir_item::StructBody::Record(lowered)
        }
    }
}

/// Lower a struct field to HIR.
pub fn lower_struct_field(ctx: &mut hir_lower_ctx::LoweringCtx, field: &ast::StructField) -> hir_item::StructField {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type_id(ctx, &field.ty);
    // Re-intern field name for cross-module consistency
    let name_str = ctx.span_to_string(field.name.span);
    let name_sym = ctx.intern(name_str.as_str());
    let re_name = common::SpannedSymbol { symbol: name_sym, span: field.name.span };
    hir_item::StructField::new(def_id, re_name, ty, field.vis, field.span)
}

// ============================================================
// Enum Variant Lowering
// ============================================================

/// Lower enum variants to HIR.
pub fn lower_enum_variants(ctx: &mut hir_lower_ctx::LoweringCtx, parent_def_id: hir_def::DefId, variants: &Vec<ast::EnumVariant>) -> Vec<hir_item::Variant> {
    let mut result: Vec<hir_item::Variant> = Vec::new();
    let mut i: usize = 0;
    while i < variants.len() {
        // Check for duplicate variant name using interned symbol index
        // NOTE: Avoid chained method calls to work around first_gen codegen bug
        let vi_str = ctx.span_to_string(variants[i].name.span);
        let vi_ref = vi_str.as_str();
        let name_i = ctx.intern(vi_ref);
        let mut j: usize = 0;
        while j < i {
            let vj_str = ctx.span_to_string(variants[j].name.span);
            let vj_ref = vj_str.as_str();
            let name_j = ctx.intern(vj_ref);
            if name_i.index == name_j.index {
                let variant_name = ctx.span_to_string(variants[i].name.span);
                let vn_ref = variant_name.as_str();
                let mut msg = String::new();
                msg.push_str("duplicate variant name `");
                msg.push_str(vn_ref);
                msg.push_str("` in enum");
                ctx.error(hir::DiagnosticCode::E0101, msg, variants[i].name.span);
                break;
            }
            j = j + 1;
        }
        let variant = lower_enum_variant(ctx, parent_def_id, &variants[i], i as u32);
        result.push(variant);
        i = i + 1;
    }
    result
}

/// Lower a single enum variant to HIR.
fn lower_enum_variant(ctx: &mut hir_lower_ctx::LoweringCtx, parent_def_id: hir_def::DefId, variant: &ast::EnumVariant, discriminant: u32) -> hir_item::Variant {
    let def_id = ctx.alloc_def_id();

    // Re-intern the variant name from span for consistent symbol indices
    let name_str = ctx.span_to_string(variant.name.span);
    let name_symbol = ctx.intern(name_str.as_str());

    // Register the variant def_info with the enum as its parent and variant index
    ctx.resolver.register_variant_def_info(
        def_id,
        name_symbol,
        variant.name.span,
        parent_def_id,
        discriminant,
    );

    // Create re-interned SpannedSymbol for the HIR variant
    let hir_name = common::SpannedSymbol {
        symbol: name_symbol,
        span: variant.name.span,
    };

    let kind = lower_variant_kind(ctx, &variant.body);
    hir_item::Variant::new(def_id, hir_name, discriminant, kind, variant.span)
}

/// Lower a variant body to a VariantKind.
fn lower_variant_kind(ctx: &mut hir_lower_ctx::LoweringCtx, body: &ast::StructBody) -> hir_item::VariantKind {
    match body {
        &ast::StructBody::Unit => {
            hir_item::VariantKind::Unit
        }
        &ast::StructBody::Tuple(ref types) => {
            let mut lowered: Vec<type_intern::TyId> = Vec::new();
            let mut i: usize = 0;
            while i < types.len() {
                let ty = hir_lower_type::lower_type_id(ctx, &types[i]);
                lowered.push(ty);
                i = i + 1;
            }
            hir_item::VariantKind::Tuple(lowered)
        }
        &ast::StructBody::Record(ref fields) => {
            let mut lowered: Vec<hir_item::StructField> = Vec::new();
            let mut i: usize = 0;
            while i < fields.len() {
                let field = lower_struct_field(ctx, &fields[i]);
                lowered.push(field);
                i = i + 1;
            }
            hir_item::VariantKind::Record(lowered)
        }
    }
}

// ============================================================
// Declaration Lowering
// ============================================================

/// Lower all declarations to HIR items.
pub fn lower_declarations(ctx: &mut hir_lower_ctx::LoweringCtx, decls: &Vec<ast::Declaration>) {
    // Two-pass lowering: first non-impl declarations (enums, structs, traits,
    // functions, etc.) to ensure all enum variants and type information is
    // registered, then impl blocks whose method bodies may reference them.
    // Without this, an `impl Type` block appearing before `enum TypeKind` in the
    // source would fail to resolve `TypeKind::Error` in method bodies.
    let mut i: usize = 0;
    while i < decls.len() {
        match &decls[i] {
            &ast::Declaration::Impl(_) => {}
            _ => {
                lower_declaration(ctx, &decls[i]);
            }
        }
        i = i + 1;
    }
    // Pass 2: lower impl blocks (method bodies can now reference all enum variants)
    i = 0;
    while i < decls.len() {
        match &decls[i] {
            &ast::Declaration::Impl(ref imp) => {
                lower_impl_decl(ctx, imp);
            }
            _ => {}
        }
        i = i + 1;
    }
}

/// Lower a single declaration to an HIR item.
pub fn lower_declaration(ctx: &mut hir_lower_ctx::LoweringCtx, decl: &ast::Declaration) {
    match decl {
        &ast::Declaration::Function(ref f) => {
            lower_function_decl(ctx, f);
        }
        &ast::Declaration::Struct(ref s) => {
            lower_struct_decl(ctx, s);
        }
        &ast::Declaration::Enum(ref e) => {
            lower_enum_decl(ctx, e);
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            lower_type_alias_decl(ctx, ta);
        }
        &ast::Declaration::Const(ref c) => {
            lower_const_decl(ctx, c);
        }
        &ast::Declaration::Static(ref s) => {
            lower_static_decl(ctx, s);
        }
        &ast::Declaration::Trait(ref t) => {
            lower_trait_decl(ctx, t);
        }
        &ast::Declaration::Effect(ref e) => {
            lower_effect_decl(ctx, e);
        }
        &ast::Declaration::Handler(ref h) => {
            lower_handler_decl(ctx, h);
        }
        &ast::Declaration::Impl(ref i) => {
            lower_impl_decl(ctx, i);
        }
        &ast::Declaration::Bridge(ref _b) => {
            // Bridge declarations and use-placeholder declarations are silently skipped.
        }
        &ast::Declaration::Module(ref m) => {
            match &m.body {
                &Option::Some(ref declarations) => {
                    lower_module_decl(ctx, m, declarations);
                }
                &Option::None => {} // External module - lowered in Phase 3b
            }
        }
        &ast::Declaration::Macro(ref m) => {
            ctx.error(
                hir::DiagnosticCode::E0104,
                common::make_string("macro declarations not yet supported"),
                m.span,
            );
        }
        &ast::Declaration::Use(_) => {} // Already handled in Phase 1
    }
}

/// Lower a function declaration.
fn lower_function_decl(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl) {
    // Look up the DefId we registered (re-intern from span for consistent indices)
    let name_str = ctx.span_to_string(f.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (pushes a TypeParams scope internally)
    let generics = hir_lower_type::lower_generics(ctx, &f.type_params, &f.where_clause);

    // Lower parameters
    let params = lower_fn_params(ctx, &f.params);

    // Check main function signature: must have no parameters
    let main_sym = ctx.intern("main");
    if lookup_symbol.index == main_sym.index && f.params.len() > 0 {
        ctx.error(hir::DiagnosticCode::E0300, common::make_string("main function must have no parameters"), f.span);
    }

    // Lower return type
    let return_ty = lower_return_type(ctx, &f.return_type);

    // Lower effects
    let effects = lower_effects(ctx, &f.effects);

    // Pop the TypeParams scope pushed by lower_generics
    ctx.resolver.pop_scope();

    // Create function signature
    let sig = hir_item::FnSig::new(
        generics,
        params,
        return_ty,
        effects,
        f.qualifiers,
        f.span,
    );

    // Pre-allocate body_id if function has a body (actual lowering in Phase 4)
    let body_id = if f.body.is_some() {
        let bid = ctx.alloc_body_id();
        Option::Some(bid)
    } else {
        // Standalone functions (not in trait) must have a body
        let fn_name_str = ctx.span_to_string(f.name.span);
        let mut msg = String::new();
        msg.push_str("function `");
        msg.push_str(fn_name_str.as_str());
        msg.push_str("` declared without a body");
        ctx.error(hir::DiagnosticCode::E0300, msg, f.span);
        Option::None
    };

    // Create function definition with pre-allocated body_id
    let fn_def = hir_item::FnDef::new(sig, body_id);
    let item_kind = hir_item::ItemKind::Fn(fn_def);

    // Create HIR name with re-interned symbol (not AST symbol) so it resolves correctly
    let hir_name = common::SpannedSymbol {
        symbol: lookup_symbol,
        span: f.name.span,
    };

    let item = hir_item::Item::new(
        def_id,
        hir_name,
        item_kind,
        f.vis,
        f.span,
    );
    ctx.add_item(def_id, item);
}

/// Checks if a type directly contains the given def_id (not behind Ref/Ptr/Box).
fn type_directly_contains(ty_id: type_intern::TyId, target_def_id: hir_def::DefId) -> bool {
    let ty = type_intern::ty_id_to_type(ty_id);
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, args: _ } => {
            def_id.index == target_def_id.index
        }
        _ => false,
    }
}

/// Check struct fields for direct recursion (infinite size).
fn check_recursive_struct_fields(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    struct_def_id: hir_def::DefId,
    body: &hir_item::StructBody,
    name: common::SpannedSymbol,
    span: common::Span,
) {
    match body {
        &hir_item::StructBody::Record(ref fields) => {
            let mut i: usize = 0;
            while i < fields.len() {
                if type_directly_contains(fields[i].ty, struct_def_id) {
                    let struct_name = ctx.span_to_string(name.span);
                    let mut msg = String::new();
                    msg.push_str("recursive type `");
                    msg.push_str(struct_name.as_str());
                    msg.push_str("` has infinite size");
                    ctx.error(hir::DiagnosticCode::E0100, msg, span);
                    return;
                }
                i = i + 1;
            }
        }
        &hir_item::StructBody::Tuple(ref types) => {
            let mut i: usize = 0;
            while i < types.len() {
                if type_directly_contains(types[i], struct_def_id) {
                    let struct_name = ctx.span_to_string(name.span);
                    let mut msg = String::new();
                    msg.push_str("recursive type `");
                    msg.push_str(struct_name.as_str());
                    msg.push_str("` has infinite size");
                    ctx.error(hir::DiagnosticCode::E0100, msg, span);
                    return;
                }
                i = i + 1;
            }
        }
        &hir_item::StructBody::Unit => {}
    }
}

/// Check enum variants for direct recursion (infinite size).
fn check_recursive_enum_variants(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    enum_def_id: hir_def::DefId,
    variants: &Vec<hir_item::Variant>,
    name: common::SpannedSymbol,
    span: common::Span,
) {
    let mut i: usize = 0;
    while i < variants.len() {
        match &variants[i].kind {
            &hir_item::VariantKind::Tuple(ref types) => {
                let mut j: usize = 0;
                while j < types.len() {
                    if type_directly_contains(types[j], enum_def_id) {
                        let enum_name = ctx.span_to_string(name.span);
                        let mut msg = String::new();
                        msg.push_str("recursive type `");
                        msg.push_str(enum_name.as_str());
                        msg.push_str("` has infinite size");
                        ctx.error(hir::DiagnosticCode::E0100, msg, span);
                        return;
                    }
                    j = j + 1;
                }
            }
            &hir_item::VariantKind::Record(ref fields) => {
                let mut j: usize = 0;
                while j < fields.len() {
                    if type_directly_contains(fields[j].ty, enum_def_id) {
                        let enum_name = ctx.span_to_string(name.span);
                        let mut msg = String::new();
                        msg.push_str("recursive type `");
                        msg.push_str(enum_name.as_str());
                        msg.push_str("` has infinite size");
                        ctx.error(hir::DiagnosticCode::E0100, msg, span);
                        return;
                    }
                    j = j + 1;
                }
            }
            &hir_item::VariantKind::Unit => {}
        }
        i = i + 1;
    }
}

/// Lower a struct declaration.
fn lower_struct_decl(ctx: &mut hir_lower_ctx::LoweringCtx, s: &ast::StructDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(s.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (structs don't have where_clause in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &s.type_params, &no_where);

    // Lower struct body (field types may reference generic params)
    let struct_body = lower_struct_body(ctx, &s.body);

    // Check for directly recursive struct (infinite size)
    check_recursive_struct_fields(ctx, def_id, &struct_body, s.name, s.span);

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let struct_def = hir_item::StructDef::new(generics, struct_body);
    let item_kind = hir_item::ItemKind::Struct(struct_def);
    let item = hir_item::Item::new(
        def_id,
        s.name,
        item_kind,
        s.vis,
        s.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an enum declaration.
fn lower_enum_decl(ctx: &mut hir_lower_ctx::LoweringCtx, e: &ast::EnumDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(e.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (enums don't have where_clause in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &e.type_params, &no_where);

    // Lower variants, passing the enum's DefId as parent
    let variants = lower_enum_variants(ctx, def_id, &e.variants);

    // Check for directly recursive enum variants (infinite size)
    check_recursive_enum_variants(ctx, def_id, &variants, e.name, e.span);

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let enum_def = hir_item::EnumDef::new(generics, variants);
    let item_kind = hir_item::ItemKind::Enum(enum_def);
    let item = hir_item::Item::new(
        def_id,
        e.name,
        item_kind,
        e.vis,
        e.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a type alias declaration.
fn lower_type_alias_decl(ctx: &mut hir_lower_ctx::LoweringCtx, ta: &ast::TypeAliasDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(ta.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &ta.type_params, &no_where);

    // Lower the aliased type (may reference generic params)
    let ty = hir_lower_type::lower_type_id(ctx, &ta.ty);

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let alias_def = hir_item::TypeAliasDef::new(generics, ty);
    let item_kind = hir_item::ItemKind::TypeAlias(alias_def);
    let item = hir_item::Item::new(
        def_id,
        ta.name,
        item_kind,
        ta.vis,
        ta.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a const declaration.
fn lower_const_decl(ctx: &mut hir_lower_ctx::LoweringCtx, c: &ast::ConstDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(c.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower the type
    let ty = hir_lower_type::lower_type_id(ctx, &c.ty);

    // Allocate a body for the initializer
    let body_id = ctx.alloc_body_id();

    // Lower the initializer expression to HIR
    let init_expr = hir_lower_expr::lower_expr(ctx, &c.init_value);

    // Create the body (consts have no parameters or locals)
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    let const_def = hir_item::ConstDef::new(ty, body_id);
    let item_kind = hir_item::ItemKind::Const(const_def);

    // Create HIR name with re-interned symbol (not AST symbol) so it resolves correctly
    let hir_name = common::SpannedSymbol {
        symbol: lookup_symbol,
        span: c.name.span,
    };

    let item = hir_item::Item::new(
        def_id,
        hir_name,
        item_kind,
        c.vis,
        c.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a static declaration.
fn lower_static_decl(ctx: &mut hir_lower_ctx::LoweringCtx, s: &ast::StaticDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(s.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower the type
    let ty = hir_lower_type::lower_type_id(ctx, &s.ty);

    // Allocate a body for the initializer
    let body_id = ctx.alloc_body_id();

    // Lower the initializer expression to HIR
    let init_expr = hir_lower_expr::lower_expr(ctx, &s.init_value);

    // Create the body (statics have no parameters or locals)
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    let static_def = hir_item::StaticDef::new(ty, s.is_mut, body_id);
    let item_kind = hir_item::ItemKind::Static(static_def);

    // Create HIR name with re-interned symbol (not AST symbol) so it resolves correctly
    let hir_name = common::SpannedSymbol {
        symbol: lookup_symbol,
        span: s.name.span,
    };

    let item = hir_item::Item::new(
        def_id,
        hir_name,
        item_kind,
        s.vis,
        s.span,
    );
    ctx.add_item(def_id, item);
}

// ============================================================
// Trait Declaration Lowering
// ============================================================

/// Lower a trait declaration.
fn lower_trait_decl(ctx: &mut hir_lower_ctx::LoweringCtx, t: &ast::TraitDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(t.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (pushes type param scope if generics exist)
    let generics = hir_lower_type::lower_generics(ctx, &t.type_params, &t.where_clause);

    // Lower supertraits
    let mut supertraits: Vec<hir_ty::TraitRef> = Vec::new();
    let mut i: usize = 0;
    while i < t.supertraits.len() {
        let supertrait_ty = hir_lower_type::lower_type(ctx, &t.supertraits[i]);
        let trait_ref = type_to_trait_ref(&supertrait_ty, t.supertraits[i].span);
        if trait_ref.is_some() {
            supertraits.push(trait_ref.unwrap());
        }
        i = i + 1;
    }

    // Set Self type for trait method signatures.
    // In a trait definition, Self refers to the trait's own type, analogous
    // to how impl blocks set Self to the concrete implementing type.
    let trait_self_ty_id = type_intern::type_interner().mk_adt(hir_def::DefId::new(def_id.index), type_intern::CommonTyLists::empty());
    ctx.current_self_type = Option::Some(trait_self_ty_id);

    // Lower associated items
    let mut items: Vec<hir_item::AssocItem> = Vec::new();
    let mut i: usize = 0;
    while i < t.items.len() {
        let assoc_item = lower_trait_item(ctx, &t.items[i]);
        if assoc_item.is_some() {
            items.push(assoc_item.unwrap());
        }
        i = i + 1;
    }

    // Clear Self type after trait lowering
    ctx.current_self_type = Option::None;

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let trait_def = hir_item::TraitDef::new(generics, supertraits, items);
    let item_kind = hir_item::ItemKind::Trait(trait_def);
    let item = hir_item::Item::new(
        def_id,
        t.name,
        item_kind,
        t.vis,
        t.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower a trait item to an AssocItem.
fn lower_trait_item(ctx: &mut hir_lower_ctx::LoweringCtx, item: &ast::TraitItem) -> Option<hir_item::AssocItem> {
    match item {
        &ast::TraitItem::Function(ref f) => {
            let assoc_fn = lower_assoc_fn(ctx, f, true, Option::None);
            Option::Some(hir_item::AssocItem::Fn(assoc_fn))
        }
        &ast::TraitItem::TypeAlias(ref ta) => {
            let assoc_ty = lower_assoc_type(ctx, ta);
            Option::Some(hir_item::AssocItem::Type(assoc_ty))
        }
        &ast::TraitItem::Const(ref c) => {
            let assoc_const = lower_assoc_const(ctx, c);
            Option::Some(hir_item::AssocItem::Const(assoc_const))
        }
    }
}

/// Lower an associated function.
/// When `impl_type_def_id` is Some, this is an impl method and we look up
/// the DefId that was pre-registered during phase 2 (register_impl_items)
/// instead of allocating a fresh one. This ensures call sites that resolve
/// through lookup_in_parent find the same DefId as the function body.
fn lower_assoc_fn(ctx: &mut hir_lower_ctx::LoweringCtx, f: &ast::FnDecl, is_trait_item: bool, impl_type_def_id: Option<hir_def::DefId>) -> hir_item::AssocFn {
    let def_id = match &impl_type_def_id {
        &Option::Some(ref type_def_id) => {
            // Look up the DefId registered in phase 2 for this method
            let fn_name_str = ctx.span_to_string(f.name.span);
            let fn_name_sym = ctx.intern(fn_name_str.as_str());
            let found = ctx.resolver.lookup_in_parent(hir_def::DefId::new(type_def_id.index), fn_name_sym);
            match found {
                Option::Some(id) => id,
                Option::None => ctx.alloc_def_id(),
            }
        }
        &Option::None => ctx.alloc_def_id(),
    };
    let generics = hir_lower_type::lower_generics(ctx, &f.type_params, &f.where_clause);
    let sig = hir_item::FnSig::new(
        generics,
        lower_fn_params(ctx, &f.params),
        lower_return_type(ctx, &f.return_type),
        lower_effects(ctx, &f.effects),
        f.qualifiers,
        f.span,
    );

    // Lower body if present (TypeParams scope still active for parameter type resolution)
    let body_id = if f.body.is_some() {
        let bid = ctx.alloc_body_id();
        let params = lower_fn_params(ctx, &f.params);
        let body = hir_lower_body::lower_fn_body(
            ctx,
            bid,
            &params,
            &f.params,      // AST params for complex pattern destructuring
            &Option::None,
            &f.body,
        );
        ctx.add_body(bid, body);
        Option::Some(bid)
    } else {
        Option::None
    };

    // Pop type param scope after lowering ALL types that reference generics,
    // including the body parameters and any type annotations within the body
    ctx.resolver.pop_scope();

    let has_default = body_id.is_some();
    // Re-intern the function name through ctx.interner so it shares indices
    // with the builtin method names registered by typeck_driver.
    // (Parser has its own span-based interning producing different symbol indices.)
    let fn_name_str = ctx.span_to_string(f.name.span);
    let fn_name_sym = ctx.intern(fn_name_str.as_str());
    let re_name = common::SpannedSymbol { symbol: fn_name_sym, span: f.name.span };
    hir_item::AssocFn::new(def_id, re_name, sig, body_id, has_default)
}

/// Lower an associated type.
fn lower_assoc_type(ctx: &mut hir_lower_ctx::LoweringCtx, ta: &ast::TypeAliasDecl) -> hir_item::AssocType {
    let def_id = ctx.alloc_def_id();
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &ta.type_params, &no_where);
    let ty = hir_lower_type::lower_type_id(ctx, &ta.ty);

    // Pop type param scope after lowering the aliased type
    ctx.resolver.pop_scope();

    let bounds: Vec<hir_ty::TraitRef> = Vec::new();
    hir_item::AssocType::new(def_id, ta.name, generics, bounds, Option::Some(ty))
}

/// Lower an associated constant.
fn lower_assoc_const(ctx: &mut hir_lower_ctx::LoweringCtx, c: &ast::ConstDecl) -> hir_item::AssocConst {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type_id(ctx, &c.ty);

    // Lower the initializer body
    let body_id = ctx.alloc_body_id();
    let init_expr = hir_lower_expr::lower_expr(ctx, &c.init_value);
    let locals: Vec<hir_expr::Local> = Vec::new();
    let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
    ctx.add_body(body_id, body);

    hir_item::AssocConst::new(def_id, c.name, ty, Option::Some(body_id))
}

/// Convert a type to a TraitRef.
fn type_to_trait_ref(ty: &hir_ty::Type, span: common::Span) -> Option<hir_ty::TraitRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            // Copy the args vector
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Option::Some(hir_ty::TraitRef::new(def_id, args_copy, span))
        }
        _ => Option::None
    }
}

// ============================================================
// Effect Declaration Lowering
// ============================================================

/// Lower an effect declaration.
fn lower_effect_decl(ctx: &mut hir_lower_ctx::LoweringCtx, e: &ast::EffectDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(e.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (effects don't have where clauses in AST)
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &e.type_params, &no_where);

    // Lower parent effects
    let mut parents: Vec<hir_ty::EffectRef> = Vec::new();
    let mut i: usize = 0;
    while i < e.parent_effects.len() {
        let parent_ty = hir_lower_type::lower_type(ctx, &e.parent_effects[i]);
        let effect_ref = type_to_effect_ref(&parent_ty);
        if effect_ref.is_some() {
            parents.push(effect_ref.unwrap());
        }
        i = i + 1;
    }

    // Lower operations
    let mut operations: Vec<hir_item::EffectOp> = Vec::new();
    let mut i: usize = 0;
    while i < e.operations.len() {
        let eff_op = lower_effect_op(ctx, &e.operations[i]);
        operations.push(eff_op);
        i = i + 1;
    }

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let effect_def = hir_item::EffectDef::new(generics, parents, operations);
    let item_kind = hir_item::ItemKind::Effect(effect_def);
    // Effects don't have visibility in the AST, use public
    let item = hir_item::Item::new(
        def_id,
        e.name,
        item_kind,
        common::Visibility::Public,
        e.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an effect operation.
fn lower_effect_op(ctx: &mut hir_lower_ctx::LoweringCtx, oper: &ast::OperationDecl) -> hir_item::EffectOp {
    let def_id = ctx.alloc_def_id();
    let no_where: Option<ast::WhereClause> = Option::None;
    let generics = hir_lower_type::lower_generics(ctx, &oper.type_params, &no_where);

    // Lower parameter types
    let mut param_tys: Vec<type_intern::TyId> = Vec::new();
    let mut i: usize = 0;
    while i < oper.params.len() {
        let ty = hir_lower_type::lower_type_id(ctx, &oper.params[i].ty);
        param_tys.push(ty);
        i = i + 1;
    }

    let return_ty = hir_lower_type::lower_type_id(ctx, &oper.return_type);

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    // Re-intern operation name for cross-module consistency
    let op_name_str = ctx.span_to_string(oper.name.span);
    let op_name_sym = ctx.intern(op_name_str.as_str());
    let re_op_name = common::SpannedSymbol { symbol: op_name_sym, span: oper.name.span };
    hir_item::EffectOp::new(def_id, re_op_name, generics, param_tys, return_ty, oper.span)
}

/// Convert a type to an EffectRef.
fn type_to_effect_ref(ty: &hir_ty::Type) -> Option<hir_ty::EffectRef> {
    match &ty.kind {
        &hir_ty::TypeKind::Adt { def_id, ref args } => {
            let mut args_copy: Vec<hir_ty::Type> = Vec::new();
            let mut i: usize = 0;
            while i < args.len() {
                args_copy.push(hir_ty::copy_type(&args[i]));
                i = i + 1;
            }
            Option::Some(hir_ty::EffectRef::new(def_id, args_copy))
        }
        _ => Option::None
    }
}

// ============================================================
// Handler Declaration Lowering
// ============================================================

/// Lower a handler declaration.
fn lower_handler_decl(ctx: &mut hir_lower_ctx::LoweringCtx, h: &ast::HandlerDecl) {
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(h.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() { return; }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = binding.def_id;

    // Lower generics (pushes type param scope if generics exist)
    let generics = hir_lower_type::lower_generics(ctx, &h.type_params, &h.where_clause);

    // Lower the handled effect
    let effect_ty = hir_lower_type::lower_type(ctx, &h.effect);
    let handled_effect = type_to_effect_ref(&effect_ty);
    if handled_effect.is_none() {
        // Pop scope before early return
        ctx.resolver.pop_scope();
        ctx.error(
            hir::DiagnosticCode::E0104,
            common::make_string("invalid effect type in handler"),
            h.span,
        );
        return;
    }

    // Lower state fields
    let mut state: Vec<hir_item::HandlerState> = Vec::new();
    let mut i: usize = 0;
    while i < h.state.len() {
        let hs = lower_handler_state(ctx, &h.state[i]);
        state.push(hs);
        i = i + 1;
    }

    // Lower return clause
    let return_clause = match &h.return_clause {
        &Some(ref rc) => {
            let hs = lower_handler_return(ctx, rc, &state);
            Option::Some(hs)
        }
        &None => Option::None,
    };

    // Lower operation implementations
    let mut op_impls: Vec<hir_item::OpImpl> = Vec::new();
    let mut i: usize = 0;
    while i < h.operations.len() {
        let oper_impl = lower_op_impl(ctx, &h.operations[i], &state);
        op_impls.push(oper_impl);
        i = i + 1;
    }

    // Validate handler operation names match effect definition
    let effect_ref = handled_effect.as_ref().unwrap();
    match ctx.get_item(effect_ref.def_id) {
        Option::Some(ref effect_entry) => {
            match &effect_entry.item.kind {
                &hir_item::ItemKind::Effect(ref effect_def) => {
                    let mut oi: usize = 0;
                    while oi < op_impls.len() {
                        let impl_op_s = ctx.span_to_string(op_impls[oi].name.span);
                        let impl_op_r = impl_op_s.as_str();
                        let impl_op_name = ctx.intern(impl_op_r);
                        let mut found: bool = false;
                        let mut ei: usize = 0;
                        while ei < effect_def.operations.len() {
                            let eff_op_s = ctx.span_to_string(effect_def.operations[ei].name.span);
                            let eff_op_r = eff_op_s.as_str();
                            let effect_op_name = ctx.intern(eff_op_r);
                            if impl_op_name.index == effect_op_name.index {
                                found = true;
                                // Link op impl to effect operation's DefId
                                op_impls[oi].op_def_id = effect_def.operations[ei].def_id;
                            }
                            ei = ei + 1;
                        }
                        if !found {
                            let op_name_str = ctx.span_to_string(op_impls[oi].name.span);
                            let mut msg = String::new();
                            msg.push_str("unknown operation `");
                            msg.push_str(op_name_str.as_str());
                            msg.push_str("` in handler");
                            ctx.error(hir::DiagnosticCode::E0305, msg, op_impls[oi].span);
                        }
                        oi = oi + 1;
                    }
                }
                _ => {}
            }
        }
        Option::None => {}
    }

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let handler_def = hir_item::HandlerDef::new(
        generics,
        handled_effect.unwrap(),
        h.kind,
        state,
        return_clause,
        op_impls,
    );
    let item_kind = hir_item::ItemKind::Handler(handler_def);
    // Handlers don't have visibility in AST, use public
    let item = hir_item::Item::new(
        def_id,
        h.name,
        item_kind,
        common::Visibility::Public,
        h.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower handler state field.
fn lower_handler_state(ctx: &mut hir_lower_ctx::LoweringCtx, hs: &ast::HandlerState) -> hir_item::HandlerState {
    let def_id = ctx.alloc_def_id();
    let ty = hir_lower_type::lower_type_id(ctx, &hs.ty);

    let default_body = match &hs.default_val {
        &Some(ref expr) => {
            let body_id = ctx.alloc_body_id();
            let init_expr = hir_lower_expr::lower_expr(ctx, expr);
            let locals: Vec<hir_expr::Local> = Vec::new();
            let body = hir_expr::Body::new(body_id, locals, 0, init_expr);
            ctx.add_body(body_id, body);
            Option::Some(body_id)
        }
        &None => Option::None,
    };

    hir_item::HandlerState::new(def_id, hs.name, ty, hs.is_mut, default_body)
}

/// Lower handler return clause.
/// The `state` parameter contains the already-lowered handler state fields,
/// which must be registered as locals in the return clause body scope.
fn lower_handler_return(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    rc: &ast::ReturnClause,
    state: &Vec<hir_item::HandlerState>,
) -> hir_item::HandlerReturn {
    let body_id = ctx.alloc_body_id();

    // Push function scope for handler return body
    ctx.resolver.push_scope(resolve::ScopeKind::Function);

    let mut locals: Vec<hir_expr::Local> = Vec::new();
    let mut next_idx: u32 = 0;

    // Register handler state fields as locals
    let mut i: usize = 0;
    while i < state.len() {
        let s = &state[i];
        let local_id = hir_def::LocalId::new(next_idx);
        let local = hir_expr::Local::new(
            local_id, s.name, s.ty, s.mutable, s.name.span,
        );
        locals.push(local);
        // Re-intern state name for consistent symbol
        let name_str = ctx.span_to_string(s.name.span);
        let sym = ctx.intern(name_str.as_str());
        ctx.resolver.define_local(sym, local_id, s.mutable, s.name.span);
        next_idx = next_idx + 1;
        i = i + 1;
    }

    // Register return parameter as a local
    let param_local_id = hir_def::LocalId::new(next_idx);
    let param_name_str = ctx.span_to_string(rc.param.span);
    let param_sym = ctx.intern(param_name_str.as_str());
    let param_ty = type_intern::type_interner().mk_infer(ctx.alloc_ty_var());
    let param_local = hir_expr::Local::new(
        param_local_id, rc.param, param_ty, false, rc.param.span,
    );
    locals.push(param_local);
    ctx.resolver.define_local(param_sym, param_local_id, false, rc.param.span);
    next_idx = next_idx + 1;

    let param_count = next_idx;
    if ctx.next_local_id < param_count {
        ctx.next_local_id = param_count;
    }

    // Clear body_locals, lower body, merge accumulated locals
    ctx.body_locals = Vec::new();
    let body_expr = hir_lower_expr::lower_block_to_expr(ctx, &rc.body);

    let mut bl_idx: usize = 0;
    while bl_idx < ctx.body_locals.len() {
        let bl = &ctx.body_locals[bl_idx];
        locals.push(hir_expr::Local::new(
            bl.id, bl.name, bl.ty, bl.mutable, bl.span,
        ));
        bl_idx = bl_idx + 1;
    }
    ctx.body_locals = Vec::new();

    ctx.resolver.pop_scope();

    let body = hir_expr::Body::new(body_id, locals, param_count, body_expr);
    ctx.add_body(body_id, body);

    hir_item::HandlerReturn::new(rc.param, body_id)
}

/// Lower operation implementation.
/// The `state` parameter contains the already-lowered handler state fields,
/// which must be registered as locals in the op body scope.
fn lower_op_impl(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    oper: &ast::OperationImpl,
    state: &Vec<hir_item::HandlerState>,
) -> hir_item::OpImpl {
    let def_id = ctx.alloc_def_id();

    // Push function scope for op body
    ctx.resolver.push_scope(resolve::ScopeKind::Function);

    let mut locals: Vec<hir_expr::Local> = Vec::new();
    let mut next_idx: u32 = 0;

    // Register handler state fields as locals
    let mut i: usize = 0;
    while i < state.len() {
        let s = &state[i];
        let local_id = hir_def::LocalId::new(next_idx);
        let local = hir_expr::Local::new(
            local_id, s.name, s.ty, s.mutable, s.name.span,
        );
        locals.push(local);
        let name_str = ctx.span_to_string(s.name.span);
        let sym = ctx.intern(name_str.as_str());
        ctx.resolver.define_local(sym, local_id, s.mutable, s.name.span);
        next_idx = next_idx + 1;
        i = i + 1;
    }

    // Lower parameter patterns to extract names and register as locals
    let mut param_names: Vec<common::SpannedSymbol> = Vec::new();
    let mut i: usize = 0;
    while i < oper.params.len() {
        let name = extract_pattern_name(&oper.params[i]);
        if name.is_some() {
            let pname = name.unwrap();
            param_names.push(pname);

            let local_id = hir_def::LocalId::new(next_idx);
            let param_name_str = ctx.span_to_string(pname.span);
            let param_sym = ctx.intern(param_name_str.as_str());
            let param_ty = type_intern::type_interner().mk_infer(ctx.alloc_ty_var());
            let param_local = hir_expr::Local::new(
                local_id, pname, param_ty, false, pname.span,
            );
            locals.push(param_local);
            ctx.resolver.define_local(param_sym, local_id, false, pname.span);
            next_idx = next_idx + 1;
        }
        i = i + 1;
    }

    let param_count = next_idx;
    if ctx.next_local_id < param_count {
        ctx.next_local_id = param_count;
    }

    // Clear body_locals, lower body, merge accumulated locals
    ctx.body_locals = Vec::new();
    let body_id = ctx.alloc_body_id();
    let body_expr = hir_lower_expr::lower_block_to_expr(ctx, &oper.body);

    let mut bl_idx: usize = 0;
    while bl_idx < ctx.body_locals.len() {
        let bl = &ctx.body_locals[bl_idx];
        locals.push(hir_expr::Local::new(
            bl.id, bl.name, bl.ty, bl.mutable, bl.span,
        ));
        bl_idx = bl_idx + 1;
    }
    ctx.body_locals = Vec::new();

    ctx.resolver.pop_scope();

    let body = hir_expr::Body::new(body_id, locals, param_count, body_expr);
    ctx.add_body(body_id, body);

    // Re-intern operation name for cross-module consistency
    let impl_name_str = ctx.span_to_string(oper.name.span);
    let impl_name_sym = ctx.intern(impl_name_str.as_str());
    let re_impl_name = common::SpannedSymbol { symbol: impl_name_sym, span: oper.name.span };
    hir_item::OpImpl::new(def_id, re_impl_name, param_names, body_id, oper.span)
}

/// Extract a name from a pattern (for parameter names).
fn extract_pattern_name(pattern: &ast::Pattern) -> Option<common::SpannedSymbol> {
    match &pattern.kind {
        &ast::PatternKind::Ident { by_ref: _, is_mut: _, ref name, subpattern: _ } => {
            Option::Some(*name)
        }
        &ast::PatternKind::Wildcard => {
            // Create a placeholder name for wildcard
            let sym = common::Symbol::new(0);
            let spanned = common::SpannedSymbol { symbol: sym, span: pattern.span };
            Option::Some(spanned)
        }
        _ => Option::None
    }
}

// ============================================================
// Impl Declaration Lowering
// ============================================================

/// Lower an impl block.
fn lower_impl_decl(ctx: &mut hir_lower_ctx::LoweringCtx, imp: &ast::ImplBlock) {
    // Impl blocks don't have names, so we allocate a fresh DefId
    let def_id = ctx.alloc_def_id();

    // Lower generics (pushes type param scope if generics exist)
    let generics = hir_lower_type::lower_generics(ctx, &imp.type_params, &imp.where_clause);

    // Lower trait ref if this is a trait impl
    let trait_ref = match &imp.trait_ty {
        &Some(ref trait_ty) => {
            let lowered_ty = hir_lower_type::lower_type(ctx, trait_ty);
            type_to_trait_ref(&lowered_ty, trait_ty.span)
        }
        &None => Option::None,
    };

    // Lower self type
    let self_ty_id = hir_lower_type::lower_type_id(ctx, &imp.self_ty);

    // Set the current Self type so that `Self` references resolve correctly
    ctx.current_self_type = Option::Some(self_ty_id);

    // Resolve the impl's target type DefId so we can look up pre-registered
    // method DefIds from phase 2 (register_impl_items). This ensures the
    // DefId used in the HIR matches the one resolved by lookup_in_parent.
    // Store as bool + u32 to reconstruct Option in loop (avoids ownership issues).
    let mut has_impl_type: bool = false;
    let mut impl_type_idx: u32 = 0;
    match &imp.self_ty.kind {
        &ast::TypeKind::Path(ref type_path) => {
            if type_path.segments.len() > 0 {
                let first_seg = &type_path.segments[0];
                let type_name_str = ctx.span_to_string(first_seg.name.span);
                let type_name_sym = ctx.intern(type_name_str.as_str());
                let type_lookup = ctx.resolver.lookup(type_name_sym);
                match type_lookup {
                    Option::Some(result) => {
                        let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        has_impl_type = true;
                        impl_type_idx = binding.def_id.index;
                    }
                    Option::None => {}
                }
            }
        }
        _ => {}
    }

    // Check for overlapping trait impls (same trait for same type)
    match &trait_ref {
        &Option::Some(ref tref) => {
            if has_impl_type {
                let trait_idx = tref.def_id.index as u64;
                let type_idx = impl_type_idx as u64;
                let key = (trait_idx << 32) | type_idx;
                let mut found_overlap: bool = false;
                let mut k: usize = 0;
                while k < ctx.seen_trait_impls.len() {
                    if ctx.seen_trait_impls[k] == key {
                        found_overlap = true;
                    }
                    k = k + 1;
                }
                if found_overlap {
                    let mut msg = String::new();
                    msg.push_str("conflicting implementations of trait for the same type");
                    ctx.error(hir::DiagnosticCode::E0101, msg, imp.span);
                } else {
                    ctx.seen_trait_impls.push(key);
                }
            }
        }
        &Option::None => {}
    }

    // Check for missing trait methods
    match &trait_ref {
        &Option::Some(ref tref) => {
            // Look up the trait definition to get required methods
            match ctx.get_item(tref.def_id) {
                Option::Some(ref trait_entry) => {
                    match &trait_entry.item.kind {
                        &hir_item::ItemKind::Trait(ref trait_def) => {
                            // Check each trait method is present in the impl
                            let mut ti: usize = 0;
                            while ti < trait_def.items.len() {
                                match &trait_def.items[ti] {
                                    &hir_item::AssocItem::Fn(ref trait_fn) => {
                                        let trait_method_name = trait_fn.name.symbol;
                                        let mut found_in_impl: bool = false;
                                        let mut ii: usize = 0;
                                        while ii < imp.items.len() {
                                            match &imp.items[ii] {
                                                &ast::ImplItem::Function(ref impl_fn) => {
                                                    let impl_name_s = ctx.span_to_string(impl_fn.name.span);
                                                    let impl_name_r = impl_name_s.as_str();
                                                    let impl_name = ctx.intern(impl_name_r);
                                                    if impl_name.index == trait_method_name.index {
                                                        found_in_impl = true;
                                                    }
                                                }
                                                &ast::ImplItem::TypeAlias(_) => {}
                                                &ast::ImplItem::Const(_) => {}
                                            }
                                            ii = ii + 1;
                                        }
                                        if !found_in_impl && !trait_fn.has_default && trait_fn.body_id.is_none() {
                                            let method_name_str = ctx.span_to_string(trait_fn.name.span);
                                            let mut msg = String::new();
                                            msg.push_str("not all trait items implemented, missing: `");
                                            msg.push_str(method_name_str.as_str());
                                            msg.push_str("`");
                                            ctx.error(hir::DiagnosticCode::E0300, msg, imp.span);
                                        }
                                    }
                                    &hir_item::AssocItem::Type(_) => {}
                                    &hir_item::AssocItem::Const(_) => {}
                                }
                                ti = ti + 1;
                            }
                        }
                        _ => {}
                    }
                }
                Option::None => {}
            }
        }
        &Option::None => {}
    }

    // Check for duplicate method names in impl block
    let mut mi: usize = 0;
    while mi < imp.items.len() {
        match &imp.items[mi] {
            &ast::ImplItem::Function(ref f) => {
                let fi_s = ctx.span_to_string(f.name.span);
                let fi_r = fi_s.as_str();
                let name_i = ctx.intern(fi_r);
                let mut mj: usize = 0;
                while mj < mi {
                    match &imp.items[mj] {
                        &ast::ImplItem::Function(ref g) => {
                            let gj_s = ctx.span_to_string(g.name.span);
                            let gj_r = gj_s.as_str();
                            let name_j = ctx.intern(gj_r);
                            if name_i.index == name_j.index {
                                let method_name = ctx.span_to_string(f.name.span);
                                let mn_r = method_name.as_str();
                                let mut msg = String::new();
                                msg.push_str("duplicate method `");
                                msg.push_str(mn_r);
                                msg.push_str("` in impl block");
                                ctx.error(hir::DiagnosticCode::E0101, msg, f.name.span);
                                break;
                            }
                        }
                        &ast::ImplItem::TypeAlias(_) => {}
                        &ast::ImplItem::Const(_) => {}
                    }
                    mj = mj + 1;
                }
            }
            &ast::ImplItem::TypeAlias(_) => {}
            &ast::ImplItem::Const(_) => {}
        }
        mi = mi + 1;
    }

    // Lower associated items
    let mut items: Vec<hir_item::AssocItem> = Vec::new();
    let mut i: usize = 0;
    while i < imp.items.len() {
        let type_id_opt: Option<hir_def::DefId> = if has_impl_type {
            Option::Some(hir_def::DefId::new(impl_type_idx))
        } else {
            Option::None
        };
        let assoc_item = lower_impl_item(ctx, &imp.items[i], type_id_opt);
        if assoc_item.is_some() {
            items.push(assoc_item.unwrap());
        }
        i = i + 1;
    }

    // Clear the Self type after processing the impl block
    ctx.current_self_type = Option::None;

    // Pop type param scope after lowering all types that reference generics
    ctx.resolver.pop_scope();

    let impl_def = hir_item::ImplDef::new(generics, trait_ref, self_ty_id, items);
    let item_kind = hir_item::ItemKind::Impl(impl_def);

    // Impl blocks don't have names - create a placeholder
    let placeholder_name = common::SpannedSymbol {
        symbol: common::Symbol::new(0),
        span: imp.span,
    };

    let item = hir_item::Item::new(
        def_id,
        placeholder_name,
        item_kind,
        common::Visibility::Private,
        imp.span,
    );
    ctx.add_item(def_id, item);
}

/// Lower an impl item to an AssocItem.
fn lower_impl_item(ctx: &mut hir_lower_ctx::LoweringCtx, item: &ast::ImplItem, impl_type_def_id: Option<hir_def::DefId>) -> Option<hir_item::AssocItem> {
    match item {
        &ast::ImplItem::Function(ref f) => {
            let assoc_fn = lower_assoc_fn(ctx, f, false, impl_type_def_id);
            Option::Some(hir_item::AssocItem::Fn(assoc_fn))
        }
        &ast::ImplItem::TypeAlias(ref ta) => {
            let assoc_ty = lower_assoc_type(ctx, ta);
            Option::Some(hir_item::AssocItem::Type(assoc_ty))
        }
        &ast::ImplItem::Const(ref c) => {
            let assoc_const = lower_assoc_const(ctx, c);
            Option::Some(hir_item::AssocItem::Const(assoc_const))
        }
    }
}

// ============================================================
// Module Declaration Lowering
// ============================================================

/// Lower a module declaration.
fn lower_module_decl(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    m: &ast::ModItemDecl,
    declarations: &Vec<ast::Declaration>,
) {
    // Look up the module's DefId from registration
    // Re-intern from span for consistent symbol indices
    let name_str = ctx.span_to_string(m.name.span);
    let lookup_symbol = ctx.intern(name_str.as_str());
    let lookup = ctx.resolver.lookup(lookup_symbol);
    if lookup.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let result = lookup.unwrap();
    let binding = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
    let def_id = hir_def::DefId::new(binding.def_id.index);

    // Push a Module scope for lowering nested items
    // This allows unqualified name resolution within the module
    ctx.resolver.push_scope(resolve::ScopeKind::Module);

    // Add all module items to the new scope for unqualified access within the module
    add_module_items_to_scope(ctx, def_id, declarations);

    // Lower all nested declarations
    lower_declarations(ctx, declarations);

    // Collect DefIds of the items we lowered
    let item_def_ids = collect_item_def_ids(ctx, def_id);

    // Pop the module scope
    ctx.resolver.pop_scope();

    // Create the ModuleDef
    let mod_def = hir_item::ModuleDef::new(item_def_ids);
    let item_kind = hir_item::ItemKind::Module(mod_def);

    // Create the Item
    let item = hir_item::Item::new(
        def_id,
        m.name,
        item_kind,
        m.vis,
        m.span,
    );
    ctx.add_item(def_id, item);
}

/// Add module items to the current scope for unqualified access.
pub fn add_module_items_to_scope(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    declarations: &Vec<ast::Declaration>,
) {
    let mut i: usize = 0;
    while i < declarations.len() {
        add_decl_to_scope(ctx, parent_def_id, &declarations[i]);
        i = i + 1;
    }
}

/// Add a single declaration to the current scope.
/// NOTE: We must re-intern names from spans because the AST comes from a
/// re-parsed external module whose parser has a different interner than
/// the lowering context. Using parser-originated symbols directly would
/// cause lookup_in_parent to fail due to mismatched symbol indices.
fn add_decl_to_scope(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
    decl: &ast::Declaration,
) {
    match decl {
        &ast::Declaration::Struct(ref s) => {
            let name_str = ctx.span_to_string(s.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Enum(ref e) => {
            let name_str = ctx.span_to_string(e.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Function(ref f) => {
            let name_str = ctx.span_to_string(f.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Const(ref c) => {
            let name_str = ctx.span_to_string(c.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Static(ref s) => {
            let name_str = ctx.span_to_string(s.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Trait(ref t) => {
            let name_str = ctx.span_to_string(t.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Effect(ref e) => {
            let name_str = ctx.span_to_string(e.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::TypeAlias(ref ta) => {
            let name_str = ctx.span_to_string(ta.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Handler(ref h) => {
            let name_str = ctx.span_to_string(h.name.span);
            let name_sym = ctx.intern(name_str.as_str());
            let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
            if def_id.is_some() {
                let binding = resolve::Binding::def(def_id.unwrap());
                ctx.resolver.define(name_sym, binding);
            }
        }
        &ast::Declaration::Module(ref m) => {
            // Nested modules are also added to scope
            match &m.body {
                &Option::Some(_) => {
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_sym = ctx.intern(name_str.as_str());
                    let def_id = ctx.resolver.lookup_in_parent(parent_def_id, name_sym);
                    if def_id.is_some() {
                        let binding = resolve::Binding::mod_binding(def_id.unwrap());
                        ctx.resolver.define(name_sym, binding);
                    }
                }
                &Option::None => {
                    // External module  needs to be added to scope for unqualified access
                    let name_str = ctx.span_to_string(m.name.span);
                    let name_sym = ctx.intern(name_str.as_str());
                    // External modules are registered as globals; look up there
                    let lookup = ctx.resolver.lookup(name_sym);
                    if lookup.is_some() {
                        let result = lookup.unwrap();
                        let existing = ctx.resolver.scope_binding(result.scope_index, result.binding_index);
                        let binding = resolve::Binding::mod_binding(existing.def_id);
                        ctx.resolver.define(name_sym, binding);
                    }
                }
            }
        }
        // Impl blocks don't have names - skip
        &ast::Declaration::Impl(_) => {}
        &ast::Declaration::Bridge(_) => {}
        &ast::Declaration::Macro(_) => {}
        &ast::Declaration::Use(ref u) => {
            // pub use module::Item  add the re-exported name to the current scope
            let item_name_str = ctx.span_to_string(u.item_name.span);
            let item_sym = ctx.intern(item_name_str.as_str());
            let item_def = ctx.resolver.lookup_in_parent(parent_def_id, item_sym);
            if item_def.is_some() {
                let binding = resolve::Binding::def(item_def.unwrap());
                ctx.resolver.define(item_sym, binding);
            }
        }
    }
}

/// Collect DefIds of items that belong to a module.
fn collect_item_def_ids(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    parent_def_id: hir_def::DefId,
) -> Vec<hir_def::DefId> {
    let mut result: Vec<hir_def::DefId> = Vec::new();

    // Search through def_info for items with this parent
    let mut i: usize = 0;
    while i < ctx.resolver.def_info.len() {
        let entry = &ctx.resolver.def_info[i];
        match &entry.info.parent {
            &Option::Some(p) => {
                if p.index == parent_def_id.index {
                    result.push(hir_def::DefId::new(entry.def_id.index));
                }
            }
            &Option::None => {}
        }
        i = i + 1;
    }

    result
}

/// Lower the contents of an external module.
/// Called during Phase 3b for external modules that were loaded in Phase 1.
/// This creates a Module item and lowers all declarations within the module scope.
pub fn lower_module_contents(
    ctx: &mut hir_lower_ctx::LoweringCtx,
    module_def_id: hir_def::DefId,
    declarations: &Vec<ast::Declaration>,
) {
    // Get the module's name from def_info
    let def_info = ctx.resolver.get_def_info(module_def_id);
    if def_info.is_none() {
        // Should not happen if registration succeeded
        return;
    }
    let info = def_info.unwrap();
    let name_symbol = info.name;
    let name_span = info.span;

    // Create a SpannedSymbol for the module name
    let name = common::SpannedSymbol {
        symbol: name_symbol,
        span: name_span,
    };

    // Push a Module scope for lowering nested items
    ctx.resolver.push_scope(resolve::ScopeKind::Module);

    // Add all module items to the new scope for unqualified access within the module
    add_module_items_to_scope(ctx, module_def_id, declarations);

    // Lower all nested declarations
    lower_declarations(ctx, declarations);

    // Collect DefIds of the items we lowered
    let item_def_ids = collect_item_def_ids(ctx, module_def_id);

    // Pop the module scope
    ctx.resolver.pop_scope();

    // Create the ModuleDef
    let mod_def = hir_item::ModuleDef::new(item_def_ids);
    let item_kind = hir_item::ItemKind::Module(mod_def);

    // Create the Item (use Public visibility for external modules)
    let item = hir_item::Item::new(
        module_def_id,
        name,
        item_kind,
        common::Visibility::Public,
        name_span,
    );
    ctx.add_item(module_def_id, item);
}
