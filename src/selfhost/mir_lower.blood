// Blood Self-Hosted Compiler - MIR Lowering Driver
//
// This module provides the main entry point for lowering HIR to MIR.
// It orchestrates the lowering of function bodies from HIR representation
// to MIR control flow graphs.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod mir_lower_ctx;
mod mir_lower_util;
mod mir_lower_pattern;
mod mir_lower_expr;
mod unify;
mod type_intern;

// ============================================================
// MIR Lowering Result
// ============================================================

/// Result of MIR lowering for a single function body.
pub struct MirLowerResult {
    /// The lowered MIR body.
    pub body: mir_body::MirBody,
    /// Errors encountered during lowering.
    pub errors: Vec<mir_lower_ctx::MirLowerError>,
}

// ============================================================
// MIR Lowering Driver
// ============================================================

/// Lowers an HIR function body to MIR.
///
/// This is the main entry point for MIR lowering. It takes a function's
/// definition ID, the HIR body, and the substitution table from type
/// inference, and produces a complete MIR body with resolved types.
/// The method_resolutions parameter carries resolved method DefIds from
/// the type checker for method call expressions.
pub fn lower_body(
    def_id: hir_def::DefId,
    body: &hir_expr::Body,
    return_ty: type_intern::TyId,
    span: common::Span,
    subst_table: &unify::SubstTable,
    method_resolutions: &Vec<common::MethodResEntry>,
    field_resolutions: &Vec<common::FieldResEntry>,
) -> MirLowerResult {
    // Resolve the return type through the substitution table (TyId-native)
    let resolved_return_id = unify::apply_substs_id(subst_table, return_ty);

    // Borrow the substitution table by address (read-only during MIR lowering)
    let subst_table_addr = subst_table as u64;

    // Clone method resolutions for this lowering context
    let cloned_resolutions = clone_method_resolutions(method_resolutions);

    // Clone field resolutions for this lowering context
    let cloned_field_res = clone_field_resolutions(field_resolutions);

    // Create lowering context with the substitution table address, method and field resolutions
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_return_id, span, subst_table_addr, cloned_resolutions, cloned_field_res);

    // Lower parameters (first param_count locals are parameters)
    lower_params_from_body(&mut ctx, body, span);

    // Lower body expression, storing result in return place
    mir_lower_expr::lower_expr_to_return(&mut ctx, &body.expr);

    // Terminate with return if not already terminated
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    // Extract errors before finishing
    let errors = ctx.take_errors();

    // Finish and return the MIR body with any errors
    let mir_body = ctx.finish();
    MirLowerResult {
        body: mir_body,
        errors: errors,
    }
}

/// Lowers parameters from an HIR body.
///
/// In HIR, the first `param_count` locals in the body are the function parameters.
fn lower_params_from_body(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    body: &hir_expr::Body,
    span: common::Span,
) {
    let mut i: u32 = 0;
    while i < body.param_count {
        let local = &body.locals[i as usize];
        // Resolve the parameter type through the substitution table (TyId-native)
        let resolved_id = ctx.resolve_type_to_id(local.ty);
        // Create MIR local for the parameter using add_param which
        // correctly increments param_count (new_local does not).
        let mir_local = ctx.builder.add_param(
            resolved_id,
            String::new(),
            local.span,
        );
        // Register mapping from HIR local to MIR local
        ctx.register_local(local.id, mir_local);
        i = i + 1;
    }
}

// ============================================================
// Closure Lowering
// ============================================================

/// Lowers a closure body to MIR.
///
/// Closures are similar to functions but may capture variables from
/// their environment.
pub fn lower_closure(
    def_id: hir_def::DefId,
    params: &Vec<hir_expr::ClosureParam>,
    return_ty: type_intern::TyId,
    body_expr: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Resolve return type (TyId-native) and create lowering context
    let resolved_return_id = unify::apply_substs_id(subst_table, return_ty);
    let subst_table_addr = subst_table as u64;
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_return_id, span, subst_table_addr, Vec::new(), Vec::new());

    // Lower closure parameters
    lower_closure_params(&mut ctx, params, span);

    // Lower body expression
    mir_lower_expr::lower_expr_to_return(&mut ctx, body_expr);

    // Terminate with return if not already terminated
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    ctx.finish()
}

/// Lowers closure parameters.
fn lower_closure_params(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    params: &Vec<hir_expr::ClosureParam>,
    span: common::Span,
) {
    let mut i: usize = 0;
    while i < params.len() {
        let param = &params[i];
        // Use add_param to correctly increment param_count (TyId-native)
        let resolved_id = ctx.resolve_type_to_id(param.ty);
        let mir_local = ctx.builder.add_param(
            resolved_id,
            String::new(),
            span,
        );
        // Pattern binding for closure params
        let source = mir_types::Place::local(mir_local);
        mir_lower_pattern::lower_irrefutable_pattern(ctx, &param.pattern, source, span);
        i = i + 1;
    }
}

// ============================================================
// Static and Const Lowering
// ============================================================

/// Lowers a static initializer to MIR.
pub fn lower_static(
    def_id: hir_def::DefId,
    ty: type_intern::TyId,
    init: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Resolve type (TyId-native) and create context
    let resolved_id = unify::apply_substs_id(subst_table, ty);
    let subst_table_addr = subst_table as u64;
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_id, span, subst_table_addr, Vec::new(), Vec::new());

    // Lower initializer expression
    mir_lower_expr::lower_expr_to_return(&mut ctx, init);

    // Terminate with return
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    ctx.finish()
}

/// Lowers a const initializer to MIR.
pub fn lower_const(
    def_id: hir_def::DefId,
    ty: type_intern::TyId,
    init: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Constants are lowered the same way as statics
    lower_static(def_id, ty, init, span, subst_table)
}

// ============================================================
// Module-Level Lowering
// ============================================================

/// Result of lowering an entire module to MIR.
pub struct MirModule {
    /// MIR bodies for all functions.
    pub functions: Vec<mir_body::MirBody>,
    /// MIR bodies for all statics.
    pub statics: Vec<mir_body::MirBody>,
    /// MIR bodies for all constants.
    pub constants: Vec<mir_body::MirBody>,
}

impl MirModule {
    /// Creates a new empty MIR module.
    pub fn new() -> MirModule {
        MirModule {
            functions: Vec::new(),
            statics: Vec::new(),
            constants: Vec::new(),
        }
    }

    /// Adds a function body.
    pub fn add_function(self: &mut MirModule, body: mir_body::MirBody) {
        self.functions.push(body);
    }

    /// Adds a static body.
    pub fn add_static(self: &mut MirModule, body: mir_body::MirBody) {
        self.statics.push(body);
    }

    /// Adds a constant body.
    pub fn add_constant(self: &mut MirModule, body: mir_body::MirBody) {
        self.constants.push(body);
    }

    /// Returns the total number of bodies.
    pub fn body_count(self: &MirModule) -> usize {
        self.functions.len() + self.statics.len() + self.constants.len()
    }
}

// ============================================================
// Utility Functions
// ============================================================

/// Checks if a MIR body has any unreachable code.
pub fn has_unreachable_code(body: &mir_body::MirBody) -> bool {
    // Simple check: any block with unreachable terminator
    let mut i: usize = 0;
    while i < body.basic_blocks.len() {
        let block = &body.basic_blocks[i];
        match &block.terminator {
            &Option::Some(ref term) => {
                match &term.kind {
                    &mir_term::TerminatorKind::Unreachable => {
                        return true;
                    }
                    _ => {}
                }
            }
            &Option::None => {}
        }
        i = i + 1;
    }
    false
}

/// Counts the number of basic blocks in a MIR body.
pub fn block_count(body: &mir_body::MirBody) -> usize {
    body.basic_blocks.len()
}

/// Counts the number of locals in a MIR body.
pub fn local_count(body: &mir_body::MirBody) -> usize {
    body.locals.len()
}

/// Gets the return type of a MIR body.
/// The return type is stored in the first local (_0).
pub fn get_return_type(body: &mir_body::MirBody) -> hir_ty::Type {
    if body.locals.len() > 0 {
        type_intern::ty_id_to_type(body.locals[0].ty)
    } else {
        hir_ty::Type::unit()
    }
}

/// Clones a method resolution table for passing to a new MirLowerCtx.
fn clone_method_resolutions(src: &Vec<common::MethodResEntry>) -> Vec<common::MethodResEntry> {
    let mut result: Vec<common::MethodResEntry> = Vec::new();
    let mut i: usize = 0;
    while i < src.len() {
        result.push(common::MethodResEntry::new(src[i].body_def_id, src[i].span_start, src[i].def_id_index));
        i = i + 1;
    }
    result
}

/// Clones a field resolution table for passing to a new MirLowerCtx.
fn clone_field_resolutions(src: &Vec<common::FieldResEntry>) -> Vec<common::FieldResEntry> {
    let mut result: Vec<common::FieldResEntry> = Vec::new();
    let mut i: usize = 0;
    while i < src.len() {
        result.push(common::FieldResEntry::new(src[i].body_def_id, src[i].span_start, src[i].field_idx));
        i = i + 1;
    }
    result
}
