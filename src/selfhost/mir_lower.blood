// Blood Self-Hosted Compiler - MIR Lowering Driver
//
// This module provides the main entry point for lowering HIR to MIR.
// It orchestrates the lowering of function bodies from HIR representation
// to MIR control flow graphs.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod mir_lower_ctx;
mod mir_lower_util;
mod mir_lower_pattern;
mod mir_lower_expr;
mod unify;
mod type_intern;

// ============================================================
// MIR Lowering Result
// ============================================================

/// Result of MIR lowering for a single function body.
pub struct MirLowerResult {
    /// The lowered MIR body.
    pub body: mir_body::MirBody,
    /// Errors encountered during lowering.
    pub errors: Vec<mir_lower_ctx::MirLowerError>,
    /// Closure function names discovered during lowering.
    pub closure_names: Vec<String>,
    /// Closure MIR bodies (parallel to closure_names).
    pub closure_mir: Vec<mir_body::MirBody>,
    /// Monomorphization requests from const-generic call interception.
    pub mono_requests: Vec<mir_lower_ctx::MonoRequest>,
    /// Next mono DefId counter (after allocations in this lowering).
    pub next_mono_def_id: u32,
}

// ============================================================
// MIR Lowering Driver
// ============================================================

/// Lowers an HIR function body to MIR.
///
/// This is the main entry point for MIR lowering. It takes a function's
/// definition ID, the HIR body, and the substitution table from type
/// inference, and produces a complete MIR body with resolved types.
/// The method_resolutions parameter carries resolved method DefIds from
/// the type checker for method call expressions.
pub fn lower_body(
    def_id: hir_def::DefId,
    body: &hir_expr::Body,
    return_ty: type_intern::TyId,
    span: common::Span,
    subst_table: &unify::SubstTable,
    method_resolutions: &Vec<common::MethodResEntry>,
    field_resolutions: &Vec<common::FieldResEntry>,
    coercion_entries: &Vec<common::CoercionEntry>,
) -> MirLowerResult {
    // Resolve the return type through the substitution table (TyId-native)
    let resolved_return_id = unify::apply_substs_id(subst_table, return_ty);

    // Borrow the substitution table by address (read-only during MIR lowering)
    let subst_table_addr = subst_table as u64;

    // Clone method resolutions for this lowering context
    let cloned_resolutions = clone_method_resolutions(method_resolutions);

    // Clone field resolutions for this lowering context
    let cloned_field_res = clone_field_resolutions(field_resolutions);

    // Clone coercion entries for this lowering context
    let cloned_coercions = clone_coercion_entries(coercion_entries);

    // Create lowering context with the substitution table address, method and field resolutions
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_return_id, span, subst_table_addr, cloned_resolutions, cloned_field_res, cloned_coercions);

    // Lower parameters (first param_count locals are parameters)
    lower_params_from_body(&mut ctx, body, span);

    // Lower body expression, storing result in return place
    mir_lower_expr::lower_expr_to_return(&mut ctx, &body.expr);

    // Terminate with return if not already terminated
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    // Extract errors before finishing
    let errors = ctx.take_errors();

    // Directly copy the closure Vecs (bitwise copy of Vec struct).
    // Blood has no destructors â€” both copies point to the same buffer,
    // but the original is consumed by finish(). We do NOT use Vec::pop()
    // because blood-rust has a bug with pop() on Vecs allocated in regions.
    let closure_names = ctx.closure_names;
    let closure_mir = ctx.closure_mir;

    // Finish and return the MIR body
    let mono_requests = ctx.mono_requests;
    let next_mono_def_id = ctx.next_mono_def_id;
    let mir_body = ctx.finish();
    MirLowerResult {
        body: mir_body,
        errors: errors,
        closure_names: closure_names,
        closure_mir: closure_mir,
        mono_requests: mono_requests,
        next_mono_def_id: next_mono_def_id,
    }
}

/// Lowers an HIR function body to MIR with const-generic context.
///
/// This variant sets const-generic fields on the MIR lowering context before lowering.
/// Used for both:
/// - Normal bodies that may call const-generic functions (pass const_generic_fn_set)
/// - Specialized bodies where const params are bound to concrete values (pass const_bindings)
pub fn lower_body_with_const_info(
    def_id: hir_def::DefId,
    body: &hir_expr::Body,
    return_ty: type_intern::TyId,
    span: common::Span,
    subst_table: &unify::SubstTable,
    method_resolutions: &Vec<common::MethodResEntry>,
    field_resolutions: &Vec<common::FieldResEntry>,
    coercion_entries: &Vec<common::CoercionEntry>,
    const_bindings: Vec<mir_lower_ctx::ConstBinding>,
    const_generic_fn_set: Vec<u32>,
    turbofish_const_args: Vec<mir_lower_ctx::TurbofishConstArg>,
    const_generic_param_counts: Vec<u32>,
    next_mono_def_id: u32,
) -> MirLowerResult {
    let resolved_return_id = unify::apply_substs_id(subst_table, return_ty);
    let subst_table_addr = subst_table as u64;
    let cloned_resolutions = clone_method_resolutions(method_resolutions);
    let cloned_field_res = clone_field_resolutions(field_resolutions);
    let cloned_coercions = clone_coercion_entries(coercion_entries);

    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_return_id, span, subst_table_addr, cloned_resolutions, cloned_field_res, cloned_coercions);

    // Set const-generic fields
    ctx.const_bindings = const_bindings;
    ctx.const_generic_fn_set = const_generic_fn_set;
    ctx.turbofish_const_args = turbofish_const_args;
    ctx.const_generic_param_counts = const_generic_param_counts;
    ctx.next_mono_def_id = next_mono_def_id;

    lower_params_from_body(&mut ctx, body, span);
    mir_lower_expr::lower_expr_to_return(&mut ctx, &body.expr);

    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    let errors = ctx.take_errors();
    let closure_names = ctx.closure_names;
    let closure_mir = ctx.closure_mir;
    let mono_requests = ctx.mono_requests;
    let next_mono_def_id = ctx.next_mono_def_id;
    let mir_body = ctx.finish();
    MirLowerResult {
        body: mir_body,
        errors: errors,
        closure_names: closure_names,
        closure_mir: closure_mir,
        mono_requests: mono_requests,
        next_mono_def_id: next_mono_def_id,
    }
}

/// Lowers parameters from an HIR body.
///
/// In HIR, the first `param_count` locals in the body are the function parameters.
fn lower_params_from_body(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    body: &hir_expr::Body,
    span: common::Span,
) {
    for i in 0u32..body.param_count {
        let local = &body.locals[i as usize];
        // Resolve the parameter type through the substitution table (TyId-native)
        let resolved_id = ctx.resolve_type_to_id(local.ty);
        // Create MIR local for the parameter using add_param which
        // correctly increments param_count (new_local does not).
        let mir_local = ctx.builder.add_param(
            resolved_id,
            String::new(),
            local.span,
        );
        // Register mapping from HIR local to MIR local
        ctx.register_local(local.id, mir_local);
    }
}

// ============================================================
// Closure Lowering
// ============================================================

/// Lowers a closure body to MIR.
///
/// Closures are similar to functions but may capture variables from
/// their environment.
pub fn lower_closure(
    def_id: hir_def::DefId,
    params: &Vec<hir_expr::ClosureParam>,
    return_ty: type_intern::TyId,
    body_expr: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Resolve return type (TyId-native) and create lowering context
    let resolved_return_id = unify::apply_substs_id(subst_table, return_ty);
    let subst_table_addr = subst_table as u64;
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_return_id, span, subst_table_addr, Vec::new(), Vec::new(), Vec::new());

    // Lower closure parameters
    lower_closure_params(&mut ctx, params, span);

    // Lower body expression
    mir_lower_expr::lower_expr_to_return(&mut ctx, body_expr);

    // Terminate with return if not already terminated
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    ctx.finish()
}

/// Lowers closure parameters.
fn lower_closure_params(
    ctx: &mut mir_lower_ctx::MirLowerCtx,
    params: &Vec<hir_expr::ClosureParam>,
    span: common::Span,
) {
    for i in 0usize..params.len() {
        let param = &params[i];
        // Use add_param to correctly increment param_count (TyId-native)
        let resolved_id = ctx.resolve_type_to_id(param.ty);
        let mir_local = ctx.builder.add_param(
            resolved_id,
            String::new(),
            span,
        );
        // Pattern binding for closure params
        let source = mir_types::Place::local(mir_local);
        mir_lower_pattern::lower_irrefutable_pattern(ctx, &param.pattern, source, span);
    }
}

// ============================================================
// Static and Const Lowering
// ============================================================

/// Lowers a static initializer to MIR.
pub fn lower_static(
    def_id: hir_def::DefId,
    ty: type_intern::TyId,
    init: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Resolve type (TyId-native) and create context
    let resolved_id = unify::apply_substs_id(subst_table, ty);
    let subst_table_addr = subst_table as u64;
    let mut ctx = mir_lower_ctx::MirLowerCtx::new(def_id, resolved_id, span, subst_table_addr, Vec::new(), Vec::new(), Vec::new());

    // Lower initializer expression
    mir_lower_expr::lower_expr_to_return(&mut ctx, init);

    // Terminate with return
    if !ctx.is_terminated() {
        ctx.terminate_return(span);
    }

    ctx.finish()
}

/// Lowers a const initializer to MIR.
pub fn lower_const(
    def_id: hir_def::DefId,
    ty: type_intern::TyId,
    init: &hir_expr::Expr,
    span: common::Span,
    subst_table: &unify::SubstTable,
) -> mir_body::MirBody {
    // Constants are lowered the same way as statics
    lower_static(def_id, ty, init, span, subst_table)
}

// ============================================================
// Module-Level Lowering
// ============================================================

/// Result of lowering an entire module to MIR.
pub struct MirModule {
    /// MIR bodies for all functions.
    pub functions: Vec<mir_body::MirBody>,
    /// MIR bodies for all statics.
    pub statics: Vec<mir_body::MirBody>,
    /// MIR bodies for all constants.
    pub constants: Vec<mir_body::MirBody>,
}

impl MirModule {
    /// Creates a new empty MIR module.
    pub fn new() -> MirModule {
        MirModule {
            functions: Vec::new(),
            statics: Vec::new(),
            constants: Vec::new(),
        }
    }

    /// Adds a function body.
    pub fn add_function(self: &mut MirModule, body: mir_body::MirBody) {
        self.functions.push(body);
    }

    /// Adds a static body.
    pub fn add_static(self: &mut MirModule, body: mir_body::MirBody) {
        self.statics.push(body);
    }

    /// Adds a constant body.
    pub fn add_constant(self: &mut MirModule, body: mir_body::MirBody) {
        self.constants.push(body);
    }

    /// Returns the total number of bodies.
    pub fn body_count(self: &MirModule) -> usize {
        self.functions.len() + self.statics.len() + self.constants.len()
    }
}

// ============================================================
// Utility Functions
// ============================================================

/// Checks if a MIR body has any unreachable code.
pub fn has_unreachable_code(body: &mir_body::MirBody) -> bool {
    // Simple check: any block with unreachable terminator
    for i in 0usize..body.basic_blocks.len() {
        let block = &body.basic_blocks[i];
        match &block.terminator {
            &Option::Some(ref term) => {
                match &term.kind {
                    &mir_term::TerminatorKind::Unreachable => {
                        return true;
                    }
                    _ => {}
                }
            }
            &Option::None => {}
        }
    }
    false
}

/// Counts the number of basic blocks in a MIR body.
pub fn block_count(body: &mir_body::MirBody) -> usize {
    body.basic_blocks.len()
}

/// Counts the number of locals in a MIR body.
pub fn local_count(body: &mir_body::MirBody) -> usize {
    body.locals.len()
}

/// Gets the return type of a MIR body.
/// The return type is stored in the first local (_0).
pub fn get_return_type(body: &mir_body::MirBody) -> hir_ty::Type {
    if body.locals.len() > 0 {
        type_intern::ty_id_to_type(body.locals[0].ty)
    } else {
        hir_ty::Type::unit()
    }
}

/// Clones a method resolution table for passing to a new MirLowerCtx.
fn clone_method_resolutions(src: &Vec<common::MethodResEntry>) -> Vec<common::MethodResEntry> {
    let mut result: Vec<common::MethodResEntry> = Vec::new();
    for i in 0usize..src.len() {
        result.push(common::MethodResEntry::new(src[i].body_def_id, src[i].span_start, src[i].def_id_index));
    }
    result
}

/// Clones a field resolution table for passing to a new MirLowerCtx.
fn clone_field_resolutions(src: &Vec<common::FieldResEntry>) -> Vec<common::FieldResEntry> {
    let mut result: Vec<common::FieldResEntry> = Vec::new();
    for i in 0usize..src.len() {
        result.push(common::FieldResEntry::new(src[i].body_def_id, src[i].span_start, src[i].field_idx));
    }
    result
}

/// Clones a coercion entry table for passing to a new MirLowerCtx.
fn clone_coercion_entries(src: &Vec<common::CoercionEntry>) -> Vec<common::CoercionEntry> {
    let mut result: Vec<common::CoercionEntry> = Vec::new();
    for i in 0usize..src.len() {
        result.push(common::CoercionEntry::new(src[i].body_def_id, src[i].span_start, src[i].array_len));
    }
    result
}
