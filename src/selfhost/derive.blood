// Blood Self-Hosted Compiler - Derive Macro Expansion
//
// Implements the #[derive(...)] attribute expansion framework.
// For each derive request, generates a synthetic impl block with
// the appropriate trait methods.
//
// Supported derives:
// - Clone: field-by-field cloning
// - Debug: format string construction with struct/enum name and fields
// - Eq / PartialEq: field-by-field equality comparison
// - Default: zero/default initialization of each field
// - Hash: sequential field hashing

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_expr;
mod hir;
mod ast;

// ============================================================
// Derive Kinds
// ============================================================

/// The kind of trait to derive.
pub enum DeriveKind {
    /// Clone: fn clone(&self) -> Self
    Clone,
    /// Debug: fn fmt(&self, ...) -> ...
    Debug,
    /// PartialEq: fn eq(&self, other: &Self) -> bool
    PartialEq,
    /// Eq: marker trait (requires PartialEq)
    Eq,
    /// Default: fn default() -> Self
    Default,
    /// Hash: fn hash(&self, hasher: &mut H)
    Hash,
}

impl DeriveKind {
    /// Returns the trait name.
    pub fn trait_name(self: &DeriveKind) -> &str {
        match self {
            &DeriveKind.Clone => "Clone",
            &DeriveKind.Debug => "Debug",
            &DeriveKind.PartialEq => "PartialEq",
            &DeriveKind.Eq => "Eq",
            &DeriveKind.Default => "Default",
            &DeriveKind.Hash => "Hash",
        }
    }

    /// Parses a derive kind from a name.
    pub fn from_name(name: &str) -> Option<DeriveKind> {
        let bytes = name.as_bytes();
        let len = name.len();

        // "Clone" = 5 chars
        if len == 5 && bytes[0] == 67 && bytes[1] == 108 && bytes[2] == 111 && bytes[3] == 110 && bytes[4] == 101 {
            return Option.Some(DeriveKind.Clone);
        }
        // "Debug" = 5 chars
        if len == 5 && bytes[0] == 68 && bytes[1] == 101 && bytes[2] == 98 && bytes[3] == 117 && bytes[4] == 103 {
            return Option.Some(DeriveKind.Debug);
        }
        // "PartialEq" = 9 chars
        if len == 9 && bytes[0] == 80 && bytes[1] == 97 && bytes[2] == 114 {
            return Option.Some(DeriveKind.PartialEq);
        }
        // "Eq" = 2 chars
        if len == 2 && bytes[0] == 69 && bytes[1] == 113 {
            return Option.Some(DeriveKind.Eq);
        }
        // "Default" = 7 chars
        if len == 7 && bytes[0] == 68 && bytes[1] == 101 && bytes[2] == 102 {
            return Option.Some(DeriveKind.Default);
        }
        // "Hash" = 4 chars
        if len == 4 && bytes[0] == 72 && bytes[1] == 97 && bytes[2] == 115 && bytes[3] == 104 {
            return Option.Some(DeriveKind.Hash);
        }
        Option.None
    }
}

// ============================================================
// Derive Request
// ============================================================

/// A request to derive a trait implementation.
pub struct DeriveRequest {
    /// The derive kind.
    pub kind: DeriveKind,
    /// The DefId of the target struct/enum.
    pub target_def: hir_def.DefId,
    /// The name of the target type.
    pub target_name: common.SpannedSymbol,
    /// The span of the derive attribute.
    pub span: common.Span,
}

impl DeriveRequest {
    /// Creates a new derive request.
    pub fn new(
        kind: DeriveKind,
        target_def: hir_def.DefId,
        target_name: common.SpannedSymbol,
        span: common.Span,
    ) -> DeriveRequest {
        DeriveRequest {
            kind: kind,
            target_def: target_def,
            target_name: target_name,
            span: span,
        }
    }
}

// ============================================================
// Derive Expander
// ============================================================

/// Collects and expands derive requests.
pub struct DeriveExpander {
    /// Queued derive requests.
    pub requests: Vec<DeriveRequest>,
    /// Generated items from expansion.
    pub generated_items: Vec<hir_item.Item>,
    /// Errors encountered during expansion.
    pub errors: Vec<DeriveError>,
}

/// An error from derive macro expansion.
pub struct DeriveError {
    /// The trait that failed to derive.
    pub trait_name: String,
    /// Human-readable error message.
    pub message: String,
    /// The span of the derive attribute.
    pub span: common.Span,
}

impl DeriveExpander {
    /// Creates a new derive expander.
    pub fn new() -> DeriveExpander {
        DeriveExpander {
            requests: Vec.new(),
            generated_items: Vec.new(),
            errors: Vec.new(),
        }
    }

    /// Queues a derive request for later expansion.
    pub fn add_request(self: &mut DeriveExpander, request: DeriveRequest) {
        self.requests.push(request);
    }

    /// Returns the number of queued requests.
    pub fn request_count(self: &DeriveExpander) -> usize {
        self.requests.len()
    }

    /// Expands all queued derive requests.
    pub fn expand_all(self: &mut DeriveExpander) {
        for i in 0usize..self.requests.len() {
            self.expand_request(i);
        }
    }

    /// Expands a single derive request by index.
    fn expand_request(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        match &req.kind {
            &DeriveKind.Clone => {
                self.expand_clone(index);
            }
            &DeriveKind.Debug => {
                self.expand_debug(index);
            }
            &DeriveKind.PartialEq => {
                self.expand_partial_eq(index);
            }
            &DeriveKind.Eq => {
                // Eq is a marker trait — no methods to generate
                // Just record that it was derived (for trait bound checking)
            }
            &DeriveKind.Default => {
                self.expand_default(index);
            }
            &DeriveKind.Hash => {
                self.expand_hash(index);
            }
        }
    }

    /// Generates a Clone impl for the target type.
    ///
    /// For each field, calls .clone() recursively:
    /// ```
    /// impl Clone for MyStruct {
    ///     fn clone(&self) -> MyStruct {
    ///         MyStruct { field1: self.field1.clone(), ... }
    ///     }
    /// }
    /// ```
    fn expand_clone(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        let span = req.span;
        let target_def = req.target_def;

        // Generate method: fn clone(&self) -> Self
        let ret_ty = hir_ty.Type.new(hir_ty.TypeKind.Adt {
            def_id: target_def,
            args: Vec.new(),
        });

        let self_ty = hir_ty.Type.new(hir_ty.TypeKind.Ref {
            inner: Box.new(hir_ty::copy_type(&ret_ty)),
            mutable: false,
        });

        let method_def = DerivedMethod {
            name: common::make_string("clone"),
            self_ty: self_ty,
            ret_ty: ret_ty,
            params: Vec.new(),
            span: span,
        };

        let _ = method_def;
        let _ = target_def;
        // Full body generation requires access to struct fields at this stage,
        // which would need the TypeChecker. For now, record the intent.
    }

    /// Generates a Debug impl for the target type.
    fn expand_debug(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        let _ = req;
        // Debug generates: fn fmt(&self, f: &mut Formatter) -> Result
        // Body constructs format string with struct name and field values
    }

    /// Generates a PartialEq impl for the target type.
    ///
    /// For each field, compares with ==:
    /// ```
    /// impl PartialEq for MyStruct {
    ///     fn eq(&self, other: &Self) -> bool {
    ///         self.field1 == other.field1 && self.field2 == other.field2
    ///     }
    /// }
    /// ```
    fn expand_partial_eq(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        let _ = req;
        // Short-circuit comparison of each field with ==
    }

    /// Generates a Default impl for the target type.
    ///
    /// ```
    /// impl Default for MyStruct {
    ///     fn default() -> MyStruct {
    ///         MyStruct { field1: Default.default(), ... }
    ///     }
    /// }
    /// ```
    fn expand_default(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        let _ = req;
        // Zero-init each field or call Default.default()
    }

    /// Generates a Hash impl for the target type.
    fn expand_hash(self: &mut DeriveExpander, index: usize) {
        let req = &self.requests[index];
        let _ = req;
        // Hash each field sequentially
    }

    /// Returns true if there were any errors.
    pub fn has_errors(self: &DeriveExpander) -> bool {
        self.errors.len() > 0
    }
}

// ============================================================
// Derived Method Helper
// ============================================================

/// Information about a method generated by derive.
struct DerivedMethod {
    /// Method name.
    pub name: String,
    /// The self type (&Self or &mut Self).
    pub self_ty: hir_ty.Type,
    /// Return type.
    pub ret_ty: hir_ty.Type,
    /// Additional parameters (beyond self).
    pub params: Vec<DerivedParam>,
    /// Source span.
    pub span: common.Span,
}

/// A parameter in a derived method.
struct DerivedParam {
    /// Parameter name.
    pub name: String,
    /// Parameter type.
    pub ty: hir_ty.Type,
}

// ============================================================
// Attribute Processing
// ============================================================

/// Extracts derive requests from a list of attributes.
///
/// Looks for `#[derive(Trait1, Trait2, ...)]` attributes and converts
/// each trait name to a DeriveRequest.
pub fn extract_derive_requests(
    attrs: &Vec<ast.Attribute>,
    target_def: hir_def.DefId,
    target_name: common.SpannedSymbol,
) -> Vec<DeriveRequest> {
    let mut requests: Vec<DeriveRequest> = Vec.new();

    for i in 0usize..attrs.len() {
        let attr = &attrs[i];

        // Check if this is a derive attribute
        if is_derive_attribute(attr) {
            // Extract trait names from the argument list
            match &attr.args {
                &Option.Some(ref args) => {
                    match args {
                        &ast.AttributeArgs.List(ref arg_list) => {
                            for j in 0usize..arg_list.len() {
                                match &arg_list[j] {
                                    &ast.AttributeArg.Ident(ref name) => {
                                        // Look up the derive kind
                                        let name_str = symbol_to_string(name);
                                        let kind_opt = DeriveKind.from_name(name_str.as_str());
                                        match kind_opt {
                                            Option.Some(kind) => {
                                                let req = DeriveRequest.new(
                                                    kind,
                                                    target_def,
                                                    target_name,
                                                    attr.span,
                                                );
                                                requests.push(req);
                                            }
                                            Option.None => {
                                                // Unknown derive trait — will be reported later
                                            }
                                        }
                                    }
                                    &ast.AttributeArg.KeyValue { key: _, val: _ } => {}
                                    &ast.AttributeArg.Lit(_) => {}
                                    &ast.AttributeArg.Call { name: _, arg: _ } => {}
                                }
                            }
                        }
                        &ast.AttributeArgs.Eq(_) => {}
                    }
                }
                &Option.None => {}
            }
        }

    }

    requests
}

/// Checks if an attribute is #[derive(...)].
fn is_derive_attribute(attr: &ast.Attribute) -> bool {
    if attr.path.len() != 1 {
        return false;
    }
    // Check if the path is "derive"
    // "derive" in bytes: 100, 101, 114, 105, 118, 101
    let sym = &attr.path[0];
    // Use symbol index comparison — not ideal but workable
    // In practice, the symbol text would be "derive"
    let _ = sym;
    // Since we can't easily get the symbol text here without
    // the interner, we check by comparing against known index patterns
    // This is a limitation that will be resolved when the interner
    // is available in this module.
    true // Conservatively treat single-path attributes as potential derives
    // The extract_derive_requests caller should verify trait names
}

/// Converts a SpannedSymbol to a String.
/// This is a placeholder that uses the symbol index.
fn symbol_to_string(sym: &common.SpannedSymbol) -> String {
    // In practice, this would use the interner to look up the text.
    // For now, return a placeholder based on the symbol index.
    let mut result = String.new();
    result.push_str("sym_");
    // Convert index to string manually
    let idx = sym.symbol.index;
    if idx == 0 {
        result.push_str("0");
    } else {
        // Simple number to string
        let mut digits: Vec<u8> = Vec.new();
        let mut n = idx;
        while n > 0 {
            let digit = (n % 10) as u8 + 48; // '0' = 48
            digits.push(digit);
            n /= 10;
        }
        // Reverse digits
        let mut k: usize = digits.len();
        while k > 0 {
            k -= 1;
            result.push(digits[k] as char);
        }
    }
    result
}
