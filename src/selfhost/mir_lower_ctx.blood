// Blood Self-Hosted Compiler - MIR Lowering Context
//
// This module defines the context used during HIR to MIR lowering.
// It tracks the mapping from HIR locals to MIR locals, loop contexts
// for break/continue, and the current block being built.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod unify;
mod hashmap;
mod type_intern;

// ============================================================
// MIR Lowering Error Types
// ============================================================

/// Categories of errors that can occur during MIR lowering.
pub enum MirLowerErrorKind {
    /// HIR local not found in local_map.
    LocalNotFound,
    /// Method call target could not be resolved.
    MethodNotResolved,
    /// Field index could not be determined.
    FieldNotResolved,
    /// ADT DefId could not be extracted from type.
    AdtExtractionFailed,
    /// Array element type could not be determined.
    ArrayElementTypeUnknown,
    /// break outside of a loop.
    BreakOutsideLoop,
    /// continue outside of a loop.
    ContinueOutsideLoop,
    /// Variant index could not be determined.
    VariantIndexUnknown,
    /// Internal error (should not happen in correct code).
    InternalError,
}

/// A note attached to a MIR lowering error.
pub struct MirLowerNote {
    /// The note message.
    pub message: String,
}

impl MirLowerNote {
    pub fn new(message: String) -> MirLowerNote {
        MirLowerNote { message: message }
    }
}

/// An error produced during MIR lowering.
pub struct MirLowerError {
    /// The kind of error.
    pub kind: MirLowerErrorKind,
    /// Human-readable description.
    pub message: String,
    /// Source span where the error occurred.
    pub span: common::Span,
    /// Additional notes.
    pub notes: Vec<MirLowerNote>,
}

impl MirLowerError {
    /// Creates a new MIR lowering error.
    pub fn new(kind: MirLowerErrorKind, message: String, span: common::Span) -> MirLowerError {
        MirLowerError {
            kind: kind,
            message: message,
            span: span,
            notes: Vec::new(),
        }
    }

    /// Creates a new MIR lowering error with a note.
    pub fn with_note(kind: MirLowerErrorKind, message: String, span: common::Span, note: String) -> MirLowerError {
        let mut notes = Vec::new();
        notes.push(MirLowerNote::new(note));
        MirLowerError {
            kind: kind,
            message: message,
            span: span,
            notes: notes,
        }
    }
}

/// Clones a MirLowerErrorKind value.
pub fn clone_mir_error_kind(kind: &MirLowerErrorKind) -> MirLowerErrorKind {
    match kind {
        &MirLowerErrorKind::LocalNotFound => MirLowerErrorKind::LocalNotFound,
        &MirLowerErrorKind::MethodNotResolved => MirLowerErrorKind::MethodNotResolved,
        &MirLowerErrorKind::FieldNotResolved => MirLowerErrorKind::FieldNotResolved,
        &MirLowerErrorKind::AdtExtractionFailed => MirLowerErrorKind::AdtExtractionFailed,
        &MirLowerErrorKind::ArrayElementTypeUnknown => MirLowerErrorKind::ArrayElementTypeUnknown,
        &MirLowerErrorKind::BreakOutsideLoop => MirLowerErrorKind::BreakOutsideLoop,
        &MirLowerErrorKind::ContinueOutsideLoop => MirLowerErrorKind::ContinueOutsideLoop,
        &MirLowerErrorKind::VariantIndexUnknown => MirLowerErrorKind::VariantIndexUnknown,
        &MirLowerErrorKind::InternalError => MirLowerErrorKind::InternalError,
    }
}

/// Returns a human-readable label for a MirLowerErrorKind.
pub fn mir_error_kind_label(kind: &MirLowerErrorKind) -> &str {
    match kind {
        &MirLowerErrorKind::LocalNotFound => "local not found",
        &MirLowerErrorKind::MethodNotResolved => "method not resolved",
        &MirLowerErrorKind::FieldNotResolved => "field not resolved",
        &MirLowerErrorKind::AdtExtractionFailed => "ADT extraction failed",
        &MirLowerErrorKind::ArrayElementTypeUnknown => "array element type unknown",
        &MirLowerErrorKind::BreakOutsideLoop => "break outside loop",
        &MirLowerErrorKind::ContinueOutsideLoop => "continue outside loop",
        &MirLowerErrorKind::VariantIndexUnknown => "variant index unknown",
        &MirLowerErrorKind::InternalError => "internal MIR lowering error",
    }
}

/// Returns the error code string for a MirLowerErrorKind.
pub fn mir_error_code(kind: &MirLowerErrorKind) -> &str {
    match kind {
        &MirLowerErrorKind::LocalNotFound => "E0700",
        &MirLowerErrorKind::MethodNotResolved => "E0701",
        &MirLowerErrorKind::FieldNotResolved => "E0702",
        &MirLowerErrorKind::AdtExtractionFailed => "E0703",
        &MirLowerErrorKind::ArrayElementTypeUnknown => "E0704",
        &MirLowerErrorKind::BreakOutsideLoop => "E0705",
        &MirLowerErrorKind::ContinueOutsideLoop => "E0706",
        &MirLowerErrorKind::VariantIndexUnknown => "E0707",
        &MirLowerErrorKind::InternalError => "E0708",
    }
}

// ============================================================
// MIR Lowering Context
// ============================================================

/// Context for lowering a single function body from HIR to MIR.
pub struct MirLowerCtx {
    /// The MIR body being built.
    pub builder: mir_body::MirBodyBuilder,
    /// Mapping from HIR LocalId to MIR MirLocalId.
    /// Stored as pairs (hir_index, mir_index) for simplicity.
    local_map: Vec<LocalMapping>,
    /// Stack of loop contexts for break/continue.
    loop_stack: Vec<LoopContext>,
    /// Counter for generating unique temporary names.
    temp_counter: u32,
    /// Tracks moved places for use-after-move detection.
    pub move_tracker: MoveTracker,
    /// Address of the substitution table from type inference (borrowed, not owned).
    /// Used to resolve TypeKind::Infer variables to concrete types.
    ///
    /// SAFETY: This stores a raw pointer as u64 because Blood lacks lifetime-annotated
    /// struct fields. The SubstTable is owned by the TypeChecker which outlives
    /// MirLowerCtx â€” lower_body() runs synchronously within the typeck phase, and
    /// the SubstTable is never freed or reallocated during lowering. All accesses
    /// via get_subst_table() are read-only (apply_substs_id calls).
    subst_table_addr: u64,
    /// Method resolution side table from type checking.
    /// Maps (body_def_id, span_start) to resolved method DefIds.
    pub method_resolutions: Vec<common::MethodResEntry>,
    /// Field resolution side table from type checking.
    /// Maps field access expression span starts to resolved field indices.
    pub field_resolutions: Vec<common::FieldResEntry>,
    /// The DefId of the current function body being lowered.
    /// Used to scope method resolution lookups to this body.
    pub body_def_id: u32,
    /// Hash-based index for O(1) method resolution lookup.
    /// Key: combined (body_def_id, span_start), Value: def_id_index
    method_hash: hashmap::HashMapU64U32,
    /// Hash-based index for O(1) field resolution lookup.
    /// Key: span_start, Value: field_idx
    field_hash: hashmap::HashMapU64U32,
    /// Errors accumulated during MIR lowering.
    pub errors: Vec<MirLowerError>,
    /// Closure function names discovered during lowering.
    pub closure_names: Vec<String>,
    /// Closure MIR bodies discovered during lowering (parallel to closure_names).
    pub closure_mir: Vec<mir_body::MirBody>,
    /// Counter for generating unique closure DefIds.
    pub closure_counter: u32,
}

/// Mapping from an HIR local to a MIR local.
struct LocalMapping {
    hir_id: u32,
    mir_id: mir_def::MirLocalId,
}

impl MirLowerCtx {
    /// Creates a new lowering context for a function.
    pub fn new(
        def_id: hir_def::DefId,
        return_ty: type_intern::TyId,
        span: common::Span,
        subst_table_addr: u64,
        method_resolutions: Vec<common::MethodResEntry>,
        field_resolutions: Vec<common::FieldResEntry>,
    ) -> MirLowerCtx {
        // Build hash indexes for O(1) lookup
        let mut method_hash = hashmap::HashMapU64U32::with_capacity(method_resolutions.len());
        let mut i: usize = 0;
        while i < method_resolutions.len() {
            let key = hashmap::combine_u32_usize(
                method_resolutions[i].body_def_id,
                method_resolutions[i].span_start
            );
            method_hash.insert(key, method_resolutions[i].def_id_index);
            i = i + 1;
        }

        let mut field_hash = hashmap::HashMapU64U32::with_capacity(field_resolutions.len());
        i = 0;
        while i < field_resolutions.len() {
            let key = hashmap::combine_u32_usize(
                field_resolutions[i].body_def_id,
                field_resolutions[i].span_start
            );
            field_hash.insert(key, field_resolutions[i].field_idx);
            i = i + 1;
        }

        MirLowerCtx {
            builder: mir_body::MirBodyBuilder::new(def_id, return_ty, span),
            local_map: Vec::new(),
            loop_stack: Vec::new(),
            temp_counter: 0,
            move_tracker: MoveTracker::new(),
            subst_table_addr: subst_table_addr,
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
            body_def_id: def_id.index,
            method_hash: method_hash,
            field_hash: field_hash,
            errors: Vec::new(),
            closure_names: Vec::new(),
            closure_mir: Vec::new(),
            closure_counter: 0,
        }
    }

    // ======== Closure Registration ========

    /// Registers a closure body discovered during lowering.
    pub fn register_closure_body(self: &mut MirLowerCtx, name: String, body: mir_body::MirBody) {
        self.closure_names.push(name);
        self.closure_mir.push(body);
    }

    /// Returns the number of closure bodies registered.
    pub fn closure_count(self: &MirLowerCtx) -> usize {
        self.closure_names.len()
    }

    /// Generates a unique closure DefId.
    pub fn next_closure_def_id(self: &mut MirLowerCtx) -> hir_def::DefId {
        let base: u32 = 16777216; // 0x1000000 range for closures
        let id = base + self.closure_counter;
        self.closure_counter = self.closure_counter + 1;
        hir_def::DefId { index: id }
    }

    // ======== Error Reporting ========

    /// Records a MIR lowering error.
    pub fn mir_error(self: &mut MirLowerCtx, kind: MirLowerErrorKind, message: String, span: common::Span) {
        self.errors.push(MirLowerError::new(kind, message, span));
    }

    /// Records a MIR lowering error with a note.
    pub fn mir_error_with_note(self: &mut MirLowerCtx, kind: MirLowerErrorKind, message: String, span: common::Span, note: String) {
        self.errors.push(MirLowerError::with_note(kind, message, span, note));
    }

    /// Returns true if any errors have been recorded.
    pub fn has_mir_errors(self: &MirLowerCtx) -> bool {
        self.errors.len() > 0
    }

    /// Takes ownership of accumulated errors, leaving the error list empty.
    pub fn take_errors(self: &mut MirLowerCtx) -> Vec<MirLowerError> {
        let mut result = Vec::new();
        let mut i: usize = 0;
        while i < self.errors.len() {
            let err = &self.errors[i];
            let mut notes = Vec::new();
            let mut ni: usize = 0;
            while ni < err.notes.len() {
                notes.push(MirLowerNote::new(common::make_string(err.notes[ni].message.as_str())));
                ni = ni + 1;
            }
            result.push(MirLowerError {
                kind: clone_mir_error_kind(&err.kind),
                message: common::make_string(err.message.as_str()),
                span: err.span,
                notes: notes,
            });
            i = i + 1;
        }
        self.errors.clear();
        result
    }

    // ======== Local Management ========

    /// Registers a mapping from an HIR local to a MIR local.
    pub fn register_local(self: &mut MirLowerCtx, hir_id: hir_def::LocalId, mir_id: mir_def::MirLocalId) {
        self.local_map.push(LocalMapping {
            hir_id: hir_id.index,
            mir_id: mir_id,
        });
    }

    /// Looks up the MIR local for an HIR local.
    pub fn lookup_local(self: &MirLowerCtx, hir_id: hir_def::LocalId) -> Option<mir_def::MirLocalId> {
        let mut i: usize = 0;
        while i < self.local_map.len() {
            if self.local_map[i].hir_id == hir_id.index {
                return Option::Some(self.local_map[i].mir_id);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Returns the raw address of the substitution table.
    /// Used when creating child MirLowerCtx for closures.
    pub fn get_subst_table_addr(self: &Self) -> u64 {
        self.subst_table_addr
    }

    /// Returns a reference to the borrowed substitution table.
    /// SAFETY: See subst_table_addr field documentation for lifetime guarantees.
    fn get_subst_table(self: &Self) -> &unify::SubstTable {
        self.subst_table_addr as &unify::SubstTable
    }

    /// Resolves type inference variables to concrete types using the substitution table.
    /// This must be called on all types from HIR before they are used in MIR construction.
    pub fn resolve_type(self: &Self, ty: &hir_ty::Type) -> hir_ty::Type {
        let ty_id = type_intern::type_to_ty_id(ty);
        let resolved_id = unify::apply_substs_id(self.get_subst_table(), ty_id);
        type_intern::ty_id_to_type(resolved_id)
    }

    /// Resolves a TyId through the substitution table.
    /// Converts TyId to Type, applies substitutions, returns resolved Type.
    pub fn resolve_type_id(self: &Self, ty_id: type_intern::TyId) -> hir_ty::Type {
        let resolved_id = unify::apply_substs_id(self.get_subst_table(), ty_id);
        type_intern::ty_id_to_type(resolved_id)
    }

    /// Resolves a TyId through the substitution table, returning TyId directly.
    /// Avoids constructing intermediate Type trees.
    pub fn resolve_type_to_id(self: &Self, ty_id: type_intern::TyId) -> type_intern::TyId {
        unify::apply_substs_id(self.get_subst_table(), ty_id)
    }

    /// Looks up a resolved method DefId by the body's DefId and expression's span start.
    /// Returns the DefId if the type checker recorded a resolution for this body+span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    /// Filters by both body_def_id and span_start to handle span collisions across files
    /// (each file's spans start at byte 0, so span_start alone is not unique).
    pub fn lookup_method_def(self: &MirLowerCtx, span_start: usize) -> Option<hir_def::DefId> {
        // Fast path: hash-based lookup
        let key = hashmap::combine_u32_usize(self.body_def_id, span_start);
        match self.method_hash.get(key) {
            Option::Some(def_id_index) => {
                // Validate: dummy sentinel (0xFFFFFFFF) indicates corrupt resolution table
                if def_id_index == 0xFFFFFFFF {
                    panic("ICE: method resolution contains dummy DefId (corrupt resolution table)");
                }
                return Option::Some(hir_def::DefId::new(def_id_index));
            }
            Option::None => {}
        }

        // Hash lookup failed - fall back to linear scan for debugging
        let mut i: usize = 0;
        while i < self.method_resolutions.len() {
            if self.method_resolutions[i].body_def_id == self.body_def_id &&
               self.method_resolutions[i].span_start == span_start {
                let def_id_index = self.method_resolutions[i].def_id_index;
                if def_id_index == 0xFFFFFFFF {
                    panic("ICE: method resolution contains dummy DefId (corrupt resolution table)");
                }
                return Option::Some(hir_def::DefId::new(def_id_index));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Looks up a resolved field index by the expression's span start.
    /// Returns the field index if the type checker recorded a resolution for this span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    pub fn lookup_field_idx(self: &MirLowerCtx, span_start: usize) -> Option<u32> {
        // Fast path: hash-based lookup using composite key (body_def_id, span_start)
        let key = hashmap::combine_u32_usize(self.body_def_id, span_start);
        match self.field_hash.get(key) {
            Option::Some(field_idx) => {
                return Option::Some(field_idx);
            }
            Option::None => {}
        }

        // Fallback to linear scan (should not happen with correct hash population)
        let mut i: usize = 0;
        while i < self.field_resolutions.len() {
            if self.field_resolutions[i].body_def_id == self.body_def_id &&
               self.field_resolutions[i].span_start == span_start {
                return Option::Some(self.field_resolutions[i].field_idx);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Creates a new temporary and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_temp(self: &mut MirLowerCtx, ty_id: type_intern::TyId, span: common::Span) -> mir_def::MirLocalId {
        self.temp_counter = self.temp_counter + 1;
        let resolved = unify::apply_substs_id(self.get_subst_table(), ty_id);
        self.builder.new_temp(resolved, span)
    }

    /// Creates a new user variable and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_var(
        self: &mut MirLowerCtx,
        ty_id: type_intern::TyId,
        name: String,
        mutable: bool,
        span: common::Span,
    ) -> mir_def::MirLocalId {
        let resolved = unify::apply_substs_id(self.get_subst_table(), ty_id);
        self.builder.new_var(resolved, name, mutable, span)
    }

    // ======== Block Management ========

    /// Creates a new basic block.
    pub fn new_block(self: &mut MirLowerCtx) -> mir_def::BasicBlockId {
        self.builder.new_block()
    }

    /// Returns the current block.
    pub fn current_block(self: &MirLowerCtx) -> mir_def::BasicBlockId {
        self.builder.current_block()
    }

    /// Sets the current block.
    pub fn set_current_block(self: &mut MirLowerCtx, block: mir_def::BasicBlockId) {
        self.builder.set_current_block(block);
    }

    /// Returns true if the current block is already terminated.
    pub fn is_terminated(self: &MirLowerCtx) -> bool {
        self.builder.is_terminated()
    }

    // ======== Statement Emission ========

    /// Emits a statement to the current block.
    pub fn emit_stmt(self: &mut MirLowerCtx, stmt: mir_stmt::Statement) {
        self.builder.push_stmt(stmt);
    }

    /// Emits an assignment statement.
    pub fn emit_assign(
        self: &mut MirLowerCtx,
        place: mir_types::Place,
        rvalue: mir_types::Rvalue,
        span: common::Span,
    ) {
        self.builder.push_assign(place, rvalue, span);
    }

    /// Emits a storage live marker.
    pub fn emit_storage_live(self: &mut MirLowerCtx, local: mir_def::MirLocalId, span: common::Span) {
        self.emit_stmt(mir_stmt::Statement::storage_live(local, span));
    }

    /// Emits a storage dead marker.
    pub fn emit_storage_dead(self: &mut MirLowerCtx, local: mir_def::MirLocalId, span: common::Span) {
        self.emit_stmt(mir_stmt::Statement::storage_dead(local, span));
    }

    // ======== Terminator Emission ========

    /// Terminates with an unconditional goto.
    pub fn terminate_goto(self: &mut MirLowerCtx, target: mir_def::BasicBlockId, span: common::Span) {
        self.builder.terminate(mir_term::Terminator::goto(target, span));
    }

    /// Terminates with a return.
    pub fn terminate_return(self: &mut MirLowerCtx, span: common::Span) {
        self.builder.terminate_return(span);
    }

    /// Terminates with a conditional branch.
    pub fn terminate_if(
        self: &mut MirLowerCtx,
        cond: mir_types::Operand,
        true_block: mir_def::BasicBlockId,
        false_block: mir_def::BasicBlockId,
        span: common::Span,
    ) {
        self.builder.terminate_if(cond, true_block, false_block, span);
    }

    /// Terminates with a switch.
    pub fn terminate_switch(
        self: &mut MirLowerCtx,
        discr: mir_types::Operand,
        targets: mir_types::SwitchTargets,
        span: common::Span,
    ) {
        self.builder.terminate(mir_term::Terminator::new(
            mir_term::TerminatorKind::SwitchInt { discr, targets },
            span,
        ));
    }

    /// Terminates with a function call.
    pub fn terminate_call(
        self: &mut MirLowerCtx,
        func: mir_types::Operand,
        args: Vec<mir_types::Operand>,
        destination: mir_types::Place,
        target: mir_def::BasicBlockId,
        span: common::Span,
    ) {
        self.builder.terminate(mir_term::call(func, args, destination, target, span));
    }

    /// Terminates with unreachable.
    pub fn terminate_unreachable(self: &mut MirLowerCtx, span: common::Span) {
        self.builder.terminate(mir_term::Terminator::unreachable(span));
    }

    // ======== Loop Context ========

    /// Pushes a loop context.
    pub fn push_loop(
        self: &mut MirLowerCtx,
        label: Option<common::Symbol>,
        break_block: mir_def::BasicBlockId,
        continue_block: mir_def::BasicBlockId,
        result_dest: Destination,
    ) {
        self.loop_stack.push(LoopContext {
            label: label,
            break_block: break_block,
            continue_block: continue_block,
            result_dest: result_dest,
        });
    }

    /// Pops the current loop context.
    pub fn pop_loop(self: &mut MirLowerCtx) {
        if self.loop_stack.len() > 0 {
            self.loop_stack.pop();
        }
    }

    /// Finds the break block for the given label (or innermost loop if None).
    pub fn find_break_block(self: &MirLowerCtx, label: Option<common::Symbol>) -> Option<mir_def::BasicBlockId> {
        match label {
            Option::Some(lbl) => {
                // Search for matching label from innermost to outermost
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option::Some(self.loop_stack[i].break_block);
                            }
                        }
                        &Option::None => {}
                    }
                }
                Option::None
            }
            Option::None => {
                // Use innermost loop
                if self.loop_stack.len() > 0 {
                    Option::Some(self.loop_stack[self.loop_stack.len() - 1].break_block)
                } else {
                    Option::None
                }
            }
        }
    }

    /// Finds the continue block for the given label (or innermost loop if None).
    pub fn find_continue_block(self: &MirLowerCtx, label: Option<common::Symbol>) -> Option<mir_def::BasicBlockId> {
        match label {
            Option::Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option::Some(self.loop_stack[i].continue_block);
                            }
                        }
                        &Option::None => {}
                    }
                }
                Option::None
            }
            Option::None => {
                if self.loop_stack.len() > 0 {
                    Option::Some(self.loop_stack[self.loop_stack.len() - 1].continue_block)
                } else {
                    Option::None
                }
            }
        }
    }

    /// Finds the result destination for the given label (or innermost loop if None).
    pub fn find_break_dest(self: &MirLowerCtx, label: Option<common::Symbol>) -> Destination {
        match label {
            Option::Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i = i - 1;
                    match &self.loop_stack[i].label {
                        &Option::Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return self.loop_stack[i].result_dest.clone();
                            }
                        }
                        &Option::None => {}
                    }
                }
                Destination::Ignore
            }
            Option::None => {
                if self.loop_stack.len() > 0 {
                    self.loop_stack[self.loop_stack.len() - 1].result_dest.clone()
                } else {
                    Destination::Ignore
                }
            }
        }
    }

    // ======== Finalization ========

    /// Finishes building and returns the MIR body.
    pub fn finish(self: MirLowerCtx) -> mir_body::MirBody {
        self.builder.finish()
    }
}

// ============================================================
// Loop Context
// ============================================================

/// Context for a loop, tracking break and continue targets.
pub struct LoopContext {
    /// Optional label for this loop.
    pub label: Option<common::Symbol>,
    /// The block to jump to on break.
    pub break_block: mir_def::BasicBlockId,
    /// The block to jump to on continue.
    pub continue_block: mir_def::BasicBlockId,
    /// The destination where break values should be stored.
    pub result_dest: Destination,
}

// ============================================================
// Destination
// ============================================================
// This is the canonical definition of Destination. Other modules use
// standalone helper functions (destination_local, destination_ignore,
// destination_return_place) for cross-module access since blood-rust
// doesn't support cross-module associated function calls on enums.

/// The destination for an expression's value.
///
/// When lowering expressions, we need to know where to put the result.
/// This can be a specific place or we can ignore the result.
pub enum Destination {
    /// Write the result to this place.
    Place(mir_types::Place),
    /// Ignore the result (expression is used for side effects only).
    Ignore,
}

impl Destination {
    /// Creates a destination for a local.
    pub fn local(id: mir_def::MirLocalId) -> Destination {
        Destination::Place(mir_types::Place::local(id))
    }

    /// Creates a destination for the return place.
    pub fn return_place() -> Destination {
        Destination::Place(mir_types::Place::return_place())
    }

    /// Creates an ignore destination.
    pub fn ignore() -> Destination {
        Destination::Ignore
    }

    /// Returns the place if this is a Place destination.
    pub fn as_place(self: &Destination) -> Option<mir_types::Place> {
        match self {
            &Destination::Place(ref p) => Option::Some(p.clone()),
            &Destination::Ignore => Option::None,
        }
    }

    /// Clone the destination.
    pub fn clone(self: &Destination) -> Destination {
        match self {
            &Destination::Place(ref p) => Destination::Place(p.clone()),
            &Destination::Ignore => Destination::Ignore,
        }
    }
}

// ============================================================
// Destination Standalone Helper Functions
// ============================================================
// These standalone functions allow cross-module use because
// blood-rust doesn't support cross-module associated function calls
// (e.g., mir_lower_ctx::Destination::local(...) fails).
// Use these helpers instead: mir_lower_ctx::destination_local(...), etc.

/// Creates a destination for a local variable.
pub fn destination_local(id: mir_def::MirLocalId) -> Destination {
    Destination::Place(mir_types::Place::local(id))
}

/// Creates a destination for the return place.
pub fn destination_return_place() -> Destination {
    Destination::Place(mir_types::Place::return_place())
}

/// Creates an ignore destination.
pub fn destination_ignore() -> Destination {
    Destination::Ignore
}

// ============================================================
// Clone implementations
// ============================================================

// mir_types::Place needs clone for Destination
impl mir_types::Place {
    pub fn clone(self: &mir_types::Place) -> mir_types::Place {
        let mut proj = Vec::new();
        let mut i: usize = 0;
        while i < self.projection.len() {
            proj.push(self.projection[i].clone());
            i = i + 1;
        }
        mir_types::Place {
            local: self.local,
            projection: proj,
            static_def_id: self.static_def_id,
        }
    }
}

impl mir_types::PlaceElem {
    pub fn clone(self: &mir_types::PlaceElem) -> mir_types::PlaceElem {
        match self {
            &mir_types::PlaceElem::Deref => mir_types::PlaceElem::Deref,
            &mir_types::PlaceElem::Field(idx) => mir_types::PlaceElem::Field(idx),
            &mir_types::PlaceElem::Index(ref local) => mir_types::PlaceElem::Index(*local),
            &mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end } => {
                mir_types::PlaceElem::ConstantIndex { offset, min_length, from_end }
            }
            &mir_types::PlaceElem::Subslice { from, to, from_end } => {
                mir_types::PlaceElem::Subslice { from, to, from_end }
            }
            &mir_types::PlaceElem::Downcast(idx) => mir_types::PlaceElem::Downcast(idx),
        }
    }
}

// ============================================================
// Move Tracking Infrastructure
// ============================================================
//
// This section provides infrastructure for tracking moved values
// to detect use-after-move errors.
//
// # Architecture
//
// Move tracking operates in two phases:
// 1. During MIR lowering: Record when Move operands are created
// 2. During MIR analysis: Check that moved places aren't used again
//
// # Current Status
//
// MoveTracker is integrated into MirLowerCtx:
// - MirLowerCtx has a `move_tracker` field
// - `operand_from_place_tracked()` in mir_lower_util.blood checks for
//   use-after-move before creating operands and tracks moves
// - `clear_move_on_assign()` resets move status after reassignment
//
// # Usage
//
// Use `operand_from_place_tracked()` instead of `operand_from_place()`
// to enable move tracking. The function will return Option::None if
// the place has been moved from, allowing the caller to report an error.

/// Tracks which places have been moved from.
///
/// This is a simplified representation. A full implementation would
/// track partial moves (e.g., moving a struct field) and handle
/// re-assignment which allows reuse.
pub struct MoveTracker {
    /// Places that have been moved from.
    /// Stored as (local_index, moved) pairs.
    moved_locals: Vec<MovedLocal>,
}

/// A local that has been moved from.
struct MovedLocal {
    /// The local's index.
    local_index: u32,
    /// The span where the move occurred (for error messages).
    move_span: common::Span,
}

impl MoveTracker {
    /// Creates a new move tracker.
    pub fn new() -> MoveTracker {
        MoveTracker {
            moved_locals: Vec::new(),
        }
    }

    /// Records that a local has been moved.
    pub fn track_move(self: &mut Self, local: mir_def::MirLocalId, span: common::Span) {
        self.moved_locals.push(MovedLocal {
            local_index: local.index,
            move_span: span,
        });
    }

    /// Checks if a local has been moved.
    /// Returns Some(span) if moved, None otherwise.
    pub fn check_moved(self: &Self, local: mir_def::MirLocalId) -> Option<common::Span> {
        let mut i: usize = 0;
        while i < self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                return Option::Some(self.moved_locals[i].move_span);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Clears the moved status of a local (after re-assignment).
    pub fn clear_move(self: &mut Self, local: mir_def::MirLocalId) {
        let mut i: usize = 0;
        while i < self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                // Remove by swapping with last and popping
                let last = self.moved_locals.len() - 1;
                if i != last {
                    self.moved_locals[i] = MovedLocal {
                        local_index: self.moved_locals[last].local_index,
                        move_span: self.moved_locals[last].move_span,
                    };
                }
                self.moved_locals.pop();
                return;
            }
            i = i + 1;
        }
    }

    /// Resets all move tracking (for a new function body).
    pub fn reset(self: &mut Self) {
        while self.moved_locals.len() > 0 {
            self.moved_locals.pop();
        }
    }
}

// force recompile
