// Blood Self-Hosted Compiler - MIR Lowering Context
//
// This module defines the context used during HIR to MIR lowering.
// It tracks the mapping from HIR locals to MIR locals, loop contexts
// for break/continue, and the current block being built.

mod common;
mod hir_def;
mod hir_ty;
mod hir_expr;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod unify;
mod hashmap;
mod type_intern;

// ============================================================
// MIR Lowering Error Types
// ============================================================

/// Categories of errors that can occur during MIR lowering.
pub enum MirLowerErrorKind {
    /// HIR local not found in local_map.
    LocalNotFound,
    /// Method call target could not be resolved.
    MethodNotResolved,
    /// Field index could not be determined.
    FieldNotResolved,
    /// ADT DefId could not be extracted from type.
    AdtExtractionFailed,
    /// Array element type could not be determined.
    ArrayElementTypeUnknown,
    /// break outside of a loop.
    BreakOutsideLoop,
    /// continue outside of a loop.
    ContinueOutsideLoop,
    /// Variant index could not be determined.
    VariantIndexUnknown,
    /// Internal error (should not happen in correct code).
    InternalError,
}

/// A note attached to a MIR lowering error.
pub struct MirLowerNote {
    /// The note message.
    pub message: String,
}

impl MirLowerNote {
    pub fn new(message: String) -> MirLowerNote {
        MirLowerNote { message: message }
    }
}

/// An error produced during MIR lowering.
pub struct MirLowerError {
    /// The kind of error.
    pub kind: MirLowerErrorKind,
    /// Human-readable description.
    pub message: String,
    /// Source span where the error occurred.
    pub span: common.Span,
    /// Additional notes.
    pub notes: Vec<MirLowerNote>,
}

impl MirLowerError {
    /// Creates a new MIR lowering error.
    pub fn new(kind: MirLowerErrorKind, message: String, span: common.Span) -> MirLowerError {
        MirLowerError {
            kind: kind,
            message: message,
            span: span,
            notes: Vec.new(),
        }
    }

    /// Creates a new MIR lowering error with a note.
    pub fn with_note(kind: MirLowerErrorKind, message: String, span: common.Span, note: String) -> MirLowerError {
        let mut notes = Vec.new();
        notes.push(MirLowerNote.new(note));
        MirLowerError {
            kind: kind,
            message: message,
            span: span,
            notes: notes,
        }
    }
}

/// Clones a MirLowerErrorKind value.
pub fn clone_mir_error_kind(kind: &MirLowerErrorKind) -> MirLowerErrorKind {
    match kind {
        &MirLowerErrorKind.LocalNotFound => MirLowerErrorKind.LocalNotFound,
        &MirLowerErrorKind.MethodNotResolved => MirLowerErrorKind.MethodNotResolved,
        &MirLowerErrorKind.FieldNotResolved => MirLowerErrorKind.FieldNotResolved,
        &MirLowerErrorKind.AdtExtractionFailed => MirLowerErrorKind.AdtExtractionFailed,
        &MirLowerErrorKind.ArrayElementTypeUnknown => MirLowerErrorKind.ArrayElementTypeUnknown,
        &MirLowerErrorKind.BreakOutsideLoop => MirLowerErrorKind.BreakOutsideLoop,
        &MirLowerErrorKind.ContinueOutsideLoop => MirLowerErrorKind.ContinueOutsideLoop,
        &MirLowerErrorKind.VariantIndexUnknown => MirLowerErrorKind.VariantIndexUnknown,
        &MirLowerErrorKind.InternalError => MirLowerErrorKind.InternalError,
    }
}

/// Returns a human-readable label for a MirLowerErrorKind.
pub fn mir_error_kind_label(kind: &MirLowerErrorKind) -> &str {
    match kind {
        &MirLowerErrorKind.LocalNotFound => "local not found",
        &MirLowerErrorKind.MethodNotResolved => "method not resolved",
        &MirLowerErrorKind.FieldNotResolved => "field not resolved",
        &MirLowerErrorKind.AdtExtractionFailed => "ADT extraction failed",
        &MirLowerErrorKind.ArrayElementTypeUnknown => "array element type unknown",
        &MirLowerErrorKind.BreakOutsideLoop => "break outside loop",
        &MirLowerErrorKind.ContinueOutsideLoop => "continue outside loop",
        &MirLowerErrorKind.VariantIndexUnknown => "variant index unknown",
        &MirLowerErrorKind.InternalError => "internal MIR lowering error",
    }
}

/// Returns the error code string for a MirLowerErrorKind.
pub fn mir_error_code(kind: &MirLowerErrorKind) -> &str {
    match kind {
        &MirLowerErrorKind.LocalNotFound => "E0700",
        &MirLowerErrorKind.MethodNotResolved => "E0701",
        &MirLowerErrorKind.FieldNotResolved => "E0702",
        &MirLowerErrorKind.AdtExtractionFailed => "E0703",
        &MirLowerErrorKind.ArrayElementTypeUnknown => "E0704",
        &MirLowerErrorKind.BreakOutsideLoop => "E0705",
        &MirLowerErrorKind.ContinueOutsideLoop => "E0706",
        &MirLowerErrorKind.VariantIndexUnknown => "E0707",
        &MirLowerErrorKind.InternalError => "E0708",
    }
}

// ============================================================
// Sentinel Array Size Replacement
// ============================================================

/// Sentinel value for const-param-dependent array sizes.
fn const_param_sentinel() -> u64 {
    18446744073709551615
}

/// Replaces sentinel array sizes in a TyId with the first const binding value.
/// Used during specialized body lowering to turn `[i32; SENTINEL]` into `[i32; 5]`.
pub fn replace_sentinel_array_size(
    ty_id: type_intern.TyId,
    bindings: &Vec<ConstBinding>,
) -> type_intern.TyId {
    let kind = type_intern.type_interner().get(ty_id);
    match kind {
        &type_intern.InternedTypeKind.Array { element, size } => {
            if size == const_param_sentinel() && bindings.len() > 0 {
                // Replace sentinel with first const binding value
                type_intern.type_interner().mk_array(element, bindings[0].value)
            } else {
                ty_id
            }
        }
        &type_intern.InternedTypeKind.Ref { inner, mutable } => {
            let replaced = replace_sentinel_array_size(inner, bindings);
            if replaced.index != inner.index {
                type_intern.type_interner().mk_ref(replaced, mutable)
            } else {
                ty_id
            }
        }
        &type_intern.InternedTypeKind.Ptr { inner, mutable } => {
            let replaced = replace_sentinel_array_size(inner, bindings);
            if replaced.index != inner.index {
                type_intern.type_interner().mk_ptr(replaced, mutable)
            } else {
                ty_id
            }
        }
        _ => ty_id,
    }
}

// ============================================================
// MIR Lowering Context
// ============================================================

/// Context for lowering a single function body from HIR to MIR.
pub struct MirLowerCtx {
    /// The MIR body being built.
    pub builder: mir_body.MirBodyBuilder,
    /// Mapping from HIR LocalId to MIR MirLocalId.
    /// Stored as pairs (hir_index, mir_index) for simplicity.
    local_map: Vec<LocalMapping>,
    /// Stack of loop contexts for break/continue.
    loop_stack: Vec<LoopContext>,
    /// Counter for generating unique temporary names.
    temp_counter: u32,
    /// Tracks moved places for use-after-move detection.
    pub move_tracker: MoveTracker,
    /// Address of the substitution table from type inference (borrowed, not owned).
    /// Used to resolve TypeKind.Infer variables to concrete types.
    ///
    /// SAFETY: This stores a raw pointer as u64 because Blood lacks lifetime-annotated
    /// struct fields. The SubstTable is owned by the TypeChecker which outlives
    /// MirLowerCtx â€” lower_body() runs synchronously within the typeck phase, and
    /// the SubstTable is never freed or reallocated during lowering. All accesses
    /// via get_subst_table() are read-only (apply_substs_id calls).
    subst_table_addr: u64,
    /// Method resolution side table from type checking.
    /// Maps (body_def_id, span_start) to resolved method DefIds.
    pub method_resolutions: Vec<common.MethodResEntry>,
    /// Field resolution side table from type checking.
    /// Maps field access expression span starts to resolved field indices.
    pub field_resolutions: Vec<common.FieldResEntry>,
    /// The DefId of the current function body being lowered.
    /// Used to scope method resolution lookups to this body.
    pub body_def_id: u32,
    /// Hash-based index for O(1) method resolution lookup.
    /// Key: combined (body_def_id, span_start), Value: def_id_index
    method_hash: hashmap.HashMapU64U32,
    /// Hash-based index for O(1) field resolution lookup.
    /// Key: span_start, Value: field_idx
    field_hash: hashmap.HashMapU64U32,
    /// Errors accumulated during MIR lowering.
    pub errors: Vec<MirLowerError>,
    /// Closure function names discovered during lowering.
    pub closure_names: Vec<String>,
    /// Closure MIR bodies discovered during lowering (parallel to closure_names).
    pub closure_mir: Vec<mir_body.MirBody>,
    /// Counter for generating unique closure DefIds.
    pub closure_counter: u32,
    /// Coercion entries from type checking.
    /// Records array-to-slice coercions keyed by (body_def_id, span_start).
    coercion_entries: Vec<common.CoercionEntry>,
    /// Const parameter bindings for specialized body lowering.
    /// When lowering a monomorphized const-generic function body, these map
    /// const param DefId indices to their concrete values.
    pub const_bindings: Vec<ConstBinding>,
    /// DefId indices of all const-generic functions in the program.
    /// Used during caller body lowering to detect calls that need specialization.
    pub const_generic_fn_set: Vec<u32>,
    /// Turbofish const arg values keyed by path span start.
    /// Used to recover explicit const values from turbofish syntax.
    pub turbofish_const_args: Vec<TurbofishConstArg>,
    /// Recorded monomorphization requests from call interception.
    /// Each entry records a needed specialization of a const-generic function.
    pub mono_requests: Vec<MonoRequest>,
    /// Number of const params per const-generic function.
    /// Parallel to const_generic_fn_set: fn_set[i] has param_counts[i] const params.
    pub const_generic_param_counts: Vec<u32>,
    /// Counter for allocating specialized DefIds.
    pub next_mono_def_id: u32,
}

/// A const parameter binding: maps a const param DefId to a concrete value.
pub struct ConstBinding {
    pub def_id_index: u32,
    pub value: u64,
}

impl ConstBinding {
    pub fn new(def_id_index: u32, value: u64) -> ConstBinding {
        ConstBinding { def_id_index, value }
    }
}

/// Turbofish const arg values associated with a path expression span.
pub struct TurbofishConstArg {
    pub span_start: u32,
    pub values: Vec<u64>,
}

impl TurbofishConstArg {
    pub fn new(span_start: u32, values: Vec<u64>) -> TurbofishConstArg {
        TurbofishConstArg { span_start, values }
    }
}

/// A monomorphization request: records a needed specialization of a const-generic function.
pub struct MonoRequest {
    pub original_def_id: u32,
    pub const_values: Vec<u64>,
    pub specialized_def_id: u32,
    pub fn_name: String,
}

impl MonoRequest {
    pub fn new(original_def_id: u32, const_values: Vec<u64>, specialized_def_id: u32, fn_name: String) -> MonoRequest {
        MonoRequest { original_def_id, const_values, specialized_def_id, fn_name }
    }
}

/// Mapping from an HIR local to a MIR local.
struct LocalMapping {
    hir_id: u32,
    mir_id: mir_def.MirLocalId,
}

impl MirLowerCtx {
    /// Creates a new lowering context for a function.
    pub fn new(
        def_id: hir_def.DefId,
        return_ty: type_intern.TyId,
        span: common.Span,
        subst_table_addr: u64,
        method_resolutions: Vec<common.MethodResEntry>,
        field_resolutions: Vec<common.FieldResEntry>,
        coercion_entries: Vec<common.CoercionEntry>,
    ) -> MirLowerCtx {
        // Build hash indexes for O(1) lookup
        let mut method_hash = hashmap.HashMapU64U32.with_capacity(method_resolutions.len());
        let mut i: usize = 0;
        while i < method_resolutions.len() {
            let key = hashmap.combine_u32_usize(
                method_resolutions[i].body_def_id,
                method_resolutions[i].span_start
            );
            method_hash.insert(key, method_resolutions[i].def_id_index);
            i += 1;
        }

        let mut field_hash = hashmap.HashMapU64U32.with_capacity(field_resolutions.len());
        i = 0;
        while i < field_resolutions.len() {
            let key = hashmap.combine_u32_usize(
                field_resolutions[i].body_def_id,
                field_resolutions[i].span_start
            );
            field_hash.insert(key, field_resolutions[i].field_idx);
            i += 1;
        }

        MirLowerCtx {
            builder: mir_body.MirBodyBuilder.new(def_id, return_ty, span),
            local_map: Vec.new(),
            loop_stack: Vec.new(),
            temp_counter: 0,
            move_tracker: MoveTracker.new(),
            subst_table_addr: subst_table_addr,
            method_resolutions: method_resolutions,
            field_resolutions: field_resolutions,
            body_def_id: def_id.index,
            method_hash: method_hash,
            field_hash: field_hash,
            errors: Vec.new(),
            closure_names: Vec.new(),
            closure_mir: Vec.new(),
            closure_counter: 0,
            coercion_entries: coercion_entries,
            const_bindings: Vec.new(),
            const_generic_fn_set: Vec.new(),
            turbofish_const_args: Vec.new(),
            mono_requests: Vec.new(),
            const_generic_param_counts: Vec.new(),
            next_mono_def_id: 0,
        }
    }

    // ======== Closure Registration ========

    /// Registers a closure body discovered during lowering.
    pub fn register_closure_body(self: &mut MirLowerCtx, name: String, body: mir_body.MirBody) {
        self.closure_names.push(name);
        self.closure_mir.push(body);
    }

    /// Returns the number of closure bodies registered.
    pub fn closure_count(self: &MirLowerCtx) -> usize {
        self.closure_names.len()
    }

    /// Generates a unique closure DefId.
    pub fn next_closure_def_id(self: &mut MirLowerCtx) -> hir_def.DefId {
        let base: u32 = 16777216; // 0x1000000 range for closures
        let id = base + self.closure_counter;
        self.closure_counter = self.closure_counter + 1;
        hir_def.DefId { index: id }
    }

    // ======== Const Generic Helpers ========

    /// Looks up a const param binding by DefId index.
    /// Returns Some(value) if the DefId is a bound const param, None otherwise.
    pub fn lookup_const_binding(self: &MirLowerCtx, def_id_index: u32) -> Option<u64> {
        for i in 0usize..self.const_bindings.len() {
            if self.const_bindings[i].def_id_index == def_id_index {
                return Option.Some(self.const_bindings[i].value);
            }
        }
        Option.None
    }

    /// Returns true if the given DefId is a const-generic function.
    pub fn is_const_generic_fn(self: &MirLowerCtx, def_id_index: u32) -> bool {
        for i in 0usize..self.const_generic_fn_set.len() {
            if self.const_generic_fn_set[i] == def_id_index {
                return true;
            }
        }
        false
    }

    /// Gets the number of const params for a const-generic function.
    pub fn get_const_param_count(self: &MirLowerCtx, def_id_index: u32) -> u32 {
        for i in 0usize..self.const_generic_fn_set.len() {
            if self.const_generic_fn_set[i] == def_id_index {
                return self.const_generic_param_counts[i];
            }
        }
        0
    }

    /// Looks up turbofish const arg values by path span start.
    pub fn lookup_turbofish_const_args(self: &MirLowerCtx, span_start: u32) -> Option<u32> {
        for i in 0usize..self.turbofish_const_args.len() {
            if self.turbofish_const_args[i].span_start == span_start {
                return Option.Some(i as u32);
            }
        }
        Option.None
    }

    /// Allocates a new DefId for a monomorphized specialization.
    pub fn alloc_mono_def_id(self: &mut MirLowerCtx) -> u32 {
        let base: u32 = 33554432; // 0x2000000 range for mono specializations
        let id = base + self.next_mono_def_id;
        self.next_mono_def_id = self.next_mono_def_id + 1;
        id
    }

    // ======== Error Reporting ========

    /// Records a MIR lowering error.
    pub fn mir_error(self: &mut MirLowerCtx, kind: MirLowerErrorKind, message: String, span: common.Span) {
        self.errors.push(MirLowerError.new(kind, message, span));
    }

    /// Records a MIR lowering error with a note.
    pub fn mir_error_with_note(self: &mut MirLowerCtx, kind: MirLowerErrorKind, message: String, span: common.Span, note: String) {
        self.errors.push(MirLowerError.with_note(kind, message, span, note));
    }

    /// Returns true if any errors have been recorded.
    pub fn has_mir_errors(self: &MirLowerCtx) -> bool {
        self.errors.len() > 0
    }

    /// Takes ownership of accumulated errors, leaving the error list empty.
    pub fn take_errors(self: &mut MirLowerCtx) -> Vec<MirLowerError> {
        let mut result = Vec.new();
        for i in 0usize..self.errors.len() {
            let err = &self.errors[i];
            let mut notes = Vec.new();
            for ni in 0usize..err.notes.len() {
                notes.push(MirLowerNote.new(common.make_string(err.notes[ni].message.as_str())));
            }
            result.push(MirLowerError {
                kind: clone_mir_error_kind(&err.kind),
                message: common.make_string(err.message.as_str()),
                span: err.span,
                notes: notes,
            });
        }
        self.errors.clear();
        result
    }

    // ======== Local Management ========

    /// Registers a mapping from an HIR local to a MIR local.
    pub fn register_local(self: &mut MirLowerCtx, hir_id: hir_def.LocalId, mir_id: mir_def.MirLocalId) {
        self.local_map.push(LocalMapping {
            hir_id: hir_id.index,
            mir_id: mir_id,
        });
    }

    /// Looks up the MIR local for an HIR local.
    pub fn lookup_local(self: &MirLowerCtx, hir_id: hir_def.LocalId) -> Option<mir_def.MirLocalId> {
        for i in 0usize..self.local_map.len() {
            if self.local_map[i].hir_id == hir_id.index {
                return Option.Some(self.local_map[i].mir_id);
            }
        }
        Option.None
    }

    /// Returns the raw address of the substitution table.
    /// Used when creating child MirLowerCtx for closures.
    pub fn get_subst_table_addr(self: &Self) -> u64 {
        self.subst_table_addr
    }

    /// Returns a reference to the borrowed substitution table.
    /// SAFETY: See subst_table_addr field documentation for lifetime guarantees.
    fn get_subst_table(self: &Self) -> &unify.SubstTable {
        self.subst_table_addr as &unify.SubstTable
    }

    /// Resolves type inference variables to concrete types using the substitution table.
    /// This must be called on all types from HIR before they are used in MIR construction.
    pub fn resolve_type(self: &Self, ty: &hir_ty.Type) -> hir_ty.Type {
        let ty_id = type_intern.type_to_ty_id(ty);
        let mut resolved_id = unify.apply_substs_id(self.get_subst_table(), ty_id);
        if self.const_bindings.len() > 0 {
            resolved_id = replace_sentinel_array_size(resolved_id, &self.const_bindings);
        }
        type_intern.ty_id_to_type(resolved_id)
    }

    /// Resolves a TyId through the substitution table.
    /// Converts TyId to Type, applies substitutions, returns resolved Type.
    pub fn resolve_type_id(self: &Self, ty_id: type_intern.TyId) -> hir_ty.Type {
        let mut resolved_id = unify.apply_substs_id(self.get_subst_table(), ty_id);
        if self.const_bindings.len() > 0 {
            resolved_id = replace_sentinel_array_size(resolved_id, &self.const_bindings);
        }
        type_intern.ty_id_to_type(resolved_id)
    }

    /// Resolves a TyId through the substitution table, returning TyId directly.
    /// Avoids constructing intermediate Type trees.
    /// When const_bindings are present, replaces sentinel array sizes with
    /// the first const binding value (for monomorphization).
    pub fn resolve_type_to_id(self: &Self, ty_id: type_intern.TyId) -> type_intern.TyId {
        let resolved = unify.apply_substs_id(self.get_subst_table(), ty_id);
        if self.const_bindings.len() > 0 {
            replace_sentinel_array_size(resolved, &self.const_bindings)
        } else {
            resolved
        }
    }

    /// Looks up a resolved method DefId by the body's DefId and expression's span start.
    /// Returns the DefId if the type checker recorded a resolution for this body+span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    /// Filters by both body_def_id and span_start to handle span collisions across files
    /// (each file's spans start at byte 0, so span_start alone is not unique).
    pub fn lookup_method_def(self: &MirLowerCtx, span_start: usize) -> Option<hir_def.DefId> {
        // Fast path: hash-based lookup
        let key = hashmap.combine_u32_usize(self.body_def_id, span_start);
        match self.method_hash.get(key) {
            Option.Some(def_id_index) => {
                // Validate: dummy sentinel (0xFFFFFFFF) indicates corrupt resolution table
                if def_id_index == 0xFFFFFFFF {
                    panic("ICE: method resolution contains dummy DefId (corrupt resolution table)");
                }
                return Option.Some(hir_def.DefId.new(def_id_index));
            }
            Option.None => {}
        }

        // Hash lookup failed - fall back to linear scan for debugging
        for i in 0usize..self.method_resolutions.len() {
            if self.method_resolutions[i].body_def_id == self.body_def_id &&
               self.method_resolutions[i].span_start == span_start {
                let def_id_index = self.method_resolutions[i].def_id_index;
                if def_id_index == 0xFFFFFFFF {
                    panic("ICE: method resolution contains dummy DefId (corrupt resolution table)");
                }
                return Option.Some(hir_def.DefId.new(def_id_index));
            }
        }
        Option.None
    }

    /// Looks up a resolved field index by the expression's span start.
    /// Returns the field index if the type checker recorded a resolution for this span.
    ///
    /// Uses hash-based lookup for O(1) average case.
    pub fn lookup_field_idx(self: &MirLowerCtx, span_start: usize) -> Option<u32> {
        // Fast path: hash-based lookup using composite key (body_def_id, span_start)
        let key = hashmap.combine_u32_usize(self.body_def_id, span_start);
        match self.field_hash.get(key) {
            Option.Some(field_idx) => {
                return Option.Some(field_idx);
            }
            Option.None => {}
        }

        // Fallback to linear scan (should not happen with correct hash population)
        for i in 0usize..self.field_resolutions.len() {
            if self.field_resolutions[i].body_def_id == self.body_def_id &&
               self.field_resolutions[i].span_start == span_start {
                return Option.Some(self.field_resolutions[i].field_idx);
            }
        }
        Option.None
    }

    /// Looks up an array-to-slice coercion by the expression's span start.
    /// Returns the array length if a coercion was recorded for this expression.
    pub fn lookup_coercion(self: &MirLowerCtx, span_start: usize) -> Option<u64> {
        for i in 0usize..self.coercion_entries.len() {
            if self.coercion_entries[i].body_def_id == self.body_def_id &&
               self.coercion_entries[i].span_start == span_start {
                return Option.Some(self.coercion_entries[i].array_len);
            }
        }
        Option.None
    }

    /// Creates a new temporary and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_temp(self: &mut MirLowerCtx, ty_id: type_intern.TyId, span: common.Span) -> mir_def.MirLocalId {
        self.temp_counter = self.temp_counter + 1;
        let resolved = unify.apply_substs_id(self.get_subst_table(), ty_id);
        self.builder.new_temp(resolved, span)
    }

    /// Creates a new user variable and returns its ID.
    /// The type is automatically resolved through the substitution table.
    pub fn new_var(
        self: &mut MirLowerCtx,
        ty_id: type_intern.TyId,
        name: String,
        mutable: bool,
        span: common.Span,
    ) -> mir_def.MirLocalId {
        let resolved = unify.apply_substs_id(self.get_subst_table(), ty_id);
        self.builder.new_var(resolved, name, mutable, span)
    }

    // ======== Block Management ========

    /// Creates a new basic block.
    pub fn new_block(self: &mut MirLowerCtx) -> mir_def.BasicBlockId {
        self.builder.new_block()
    }

    /// Returns the current block.
    pub fn current_block(self: &MirLowerCtx) -> mir_def.BasicBlockId {
        self.builder.current_block()
    }

    /// Sets the current block.
    pub fn set_current_block(self: &mut MirLowerCtx, block: mir_def.BasicBlockId) {
        self.builder.set_current_block(block);
    }

    /// Returns true if the current block is already terminated.
    pub fn is_terminated(self: &MirLowerCtx) -> bool {
        self.builder.is_terminated()
    }

    // ======== Statement Emission ========

    /// Emits a statement to the current block.
    pub fn emit_stmt(self: &mut MirLowerCtx, stmt: mir_stmt.Statement) {
        self.builder.push_stmt(stmt);
    }

    /// Emits an assignment statement.
    pub fn emit_assign(
        self: &mut MirLowerCtx,
        place: mir_types.Place,
        rvalue: mir_types.Rvalue,
        span: common.Span,
    ) {
        self.builder.push_assign(place, rvalue, span);
    }

    /// Emits a storage live marker.
    pub fn emit_storage_live(self: &mut MirLowerCtx, local: mir_def.MirLocalId, span: common.Span) {
        self.emit_stmt(mir_stmt.Statement.storage_live(local, span));
    }

    /// Emits a storage dead marker.
    pub fn emit_storage_dead(self: &mut MirLowerCtx, local: mir_def.MirLocalId, span: common.Span) {
        self.emit_stmt(mir_stmt.Statement.storage_dead(local, span));
    }

    // ======== Terminator Emission ========

    /// Terminates with an unconditional goto.
    pub fn terminate_goto(self: &mut MirLowerCtx, target: mir_def.BasicBlockId, span: common.Span) {
        self.builder.terminate(mir_term.Terminator.goto(target, span));
    }

    /// Terminates with a return.
    pub fn terminate_return(self: &mut MirLowerCtx, span: common.Span) {
        self.builder.terminate_return(span);
    }

    /// Terminates with a conditional branch.
    pub fn terminate_if(
        self: &mut MirLowerCtx,
        cond: mir_types.Operand,
        true_block: mir_def.BasicBlockId,
        false_block: mir_def.BasicBlockId,
        span: common.Span,
    ) {
        self.builder.terminate_if(cond, true_block, false_block, span);
    }

    /// Terminates with a switch.
    pub fn terminate_switch(
        self: &mut MirLowerCtx,
        discr: mir_types.Operand,
        targets: mir_types.SwitchTargets,
        span: common.Span,
    ) {
        self.builder.terminate(mir_term.Terminator.new(
            mir_term.TerminatorKind.SwitchInt { discr, targets },
            span,
        ));
    }

    /// Terminates with a function call.
    pub fn terminate_call(
        self: &mut MirLowerCtx,
        func: mir_types.Operand,
        args: Vec<mir_types.Operand>,
        destination: mir_types.Place,
        target: mir_def.BasicBlockId,
        span: common.Span,
    ) {
        self.builder.terminate(mir_term.call(func, args, destination, target, span));
    }

    /// Terminates with unreachable.
    pub fn terminate_unreachable(self: &mut MirLowerCtx, span: common.Span) {
        self.builder.terminate(mir_term.Terminator.unreachable(span));
    }

    // ======== Loop Context ========

    /// Pushes a loop context.
    pub fn push_loop(
        self: &mut MirLowerCtx,
        label: Option<common.Symbol>,
        break_block: mir_def.BasicBlockId,
        continue_block: mir_def.BasicBlockId,
        result_dest: Destination,
    ) {
        self.loop_stack.push(LoopContext {
            label: label,
            break_block: break_block,
            continue_block: continue_block,
            result_dest: result_dest,
        });
    }

    /// Pops the current loop context.
    pub fn pop_loop(self: &mut MirLowerCtx) {
        if self.loop_stack.len() > 0 {
            self.loop_stack.pop();
        }
    }

    /// Finds the break block for the given label (or innermost loop if None).
    pub fn find_break_block(self: &MirLowerCtx, label: Option<common.Symbol>) -> Option<mir_def.BasicBlockId> {
        match label {
            Option.Some(lbl) => {
                // Search for matching label from innermost to outermost
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i -= 1;
                    match &self.loop_stack[i].label {
                        &Option.Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option.Some(self.loop_stack[i].break_block);
                            }
                        }
                        &Option.None => {}
                    }
                }
                Option.None
            }
            Option.None => {
                // Use innermost loop
                if self.loop_stack.len() > 0 {
                    Option.Some(self.loop_stack[self.loop_stack.len() - 1].break_block)
                } else {
                    Option.None
                }
            }
        }
    }

    /// Finds the continue block for the given label (or innermost loop if None).
    pub fn find_continue_block(self: &MirLowerCtx, label: Option<common.Symbol>) -> Option<mir_def.BasicBlockId> {
        match label {
            Option.Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i -= 1;
                    match &self.loop_stack[i].label {
                        &Option.Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return Option.Some(self.loop_stack[i].continue_block);
                            }
                        }
                        &Option.None => {}
                    }
                }
                Option.None
            }
            Option.None => {
                if self.loop_stack.len() > 0 {
                    Option.Some(self.loop_stack[self.loop_stack.len() - 1].continue_block)
                } else {
                    Option.None
                }
            }
        }
    }

    /// Finds the result destination for the given label (or innermost loop if None).
    pub fn find_break_dest(self: &MirLowerCtx, label: Option<common.Symbol>) -> Destination {
        match label {
            Option.Some(lbl) => {
                let mut i = self.loop_stack.len();
                while i > 0 {
                    i -= 1;
                    match &self.loop_stack[i].label {
                        &Option.Some(loop_lbl) => {
                            if loop_lbl.index == lbl.index {
                                return self.loop_stack[i].result_dest.clone();
                            }
                        }
                        &Option.None => {}
                    }
                }
                Destination.Ignore
            }
            Option.None => {
                if self.loop_stack.len() > 0 {
                    self.loop_stack[self.loop_stack.len() - 1].result_dest.clone()
                } else {
                    Destination.Ignore
                }
            }
        }
    }

    // ======== Finalization ========

    /// Finishes building and returns the MIR body.
    pub fn finish(self: MirLowerCtx) -> mir_body.MirBody {
        self.builder.finish()
    }
}

// ============================================================
// Loop Context
// ============================================================

/// Context for a loop, tracking break and continue targets.
pub struct LoopContext {
    /// Optional label for this loop.
    pub label: Option<common.Symbol>,
    /// The block to jump to on break.
    pub break_block: mir_def.BasicBlockId,
    /// The block to jump to on continue.
    pub continue_block: mir_def.BasicBlockId,
    /// The destination where break values should be stored.
    pub result_dest: Destination,
}

// ============================================================
// Destination
// ============================================================
// This is the canonical definition of Destination. Other modules use
// standalone helper functions (destination_local, destination_ignore,
// destination_return_place) for cross-module access since blood-rust
// doesn't support cross-module associated function calls on enums.

/// The destination for an expression's value.
///
/// When lowering expressions, we need to know where to put the result.
/// This can be a specific place or we can ignore the result.
pub enum Destination {
    /// Write the result to this place.
    Place(mir_types.Place),
    /// Ignore the result (expression is used for side effects only).
    Ignore,
}

impl Destination {
    /// Creates a destination for a local.
    pub fn local(id: mir_def.MirLocalId) -> Destination {
        Destination.Place(mir_types.Place.local(id))
    }

    /// Creates a destination for the return place.
    pub fn return_place() -> Destination {
        Destination.Place(mir_types.Place.return_place())
    }

    /// Creates an ignore destination.
    pub fn ignore() -> Destination {
        Destination.Ignore
    }

    /// Returns the place if this is a Place destination.
    pub fn as_place(self: &Destination) -> Option<mir_types.Place> {
        match self {
            &Destination.Place(ref p) => Option.Some(p.clone()),
            &Destination.Ignore => Option.None,
        }
    }

    /// Clone the destination.
    pub fn clone(self: &Destination) -> Destination {
        match self {
            &Destination.Place(ref p) => Destination.Place(p.clone()),
            &Destination.Ignore => Destination.Ignore,
        }
    }
}

// ============================================================
// Destination Standalone Helper Functions
// ============================================================
// These standalone functions allow cross-module use because
// blood-rust doesn't support cross-module associated function calls
// (e.g., mir_lower_ctx.Destination.local(...) fails).
// Use these helpers instead: mir_lower_ctx.destination_local(...), etc.

/// Creates a destination for a local variable.
pub fn destination_local(id: mir_def.MirLocalId) -> Destination {
    Destination.Place(mir_types.Place.local(id))
}

/// Creates a destination for the return place.
pub fn destination_return_place() -> Destination {
    Destination.Place(mir_types.Place.return_place())
}

/// Creates an ignore destination.
pub fn destination_ignore() -> Destination {
    Destination.Ignore
}

// ============================================================
// Clone implementations
// ============================================================

// mir_types.Place needs clone for Destination
impl mir_types.Place {
    pub fn clone(self: &mir_types.Place) -> mir_types.Place {
        let mut proj = Vec.new();
        for i in 0usize..self.projection.len() {
            proj.push(self.projection[i].clone());
        }
        mir_types.Place {
            local: self.local,
            projection: proj,
            static_def_id: self.static_def_id,
        }
    }
}

impl mir_types.PlaceElem {
    pub fn clone(self: &mir_types.PlaceElem) -> mir_types.PlaceElem {
        match self {
            &mir_types.PlaceElem.Deref => mir_types.PlaceElem.Deref,
            &mir_types.PlaceElem.Field(idx) => mir_types.PlaceElem.Field(idx),
            &mir_types.PlaceElem.Index(ref local) => mir_types.PlaceElem.Index(*local),
            &mir_types.PlaceElem.ConstantIndex { offset, min_length, from_end } => {
                mir_types.PlaceElem.ConstantIndex { offset, min_length, from_end }
            }
            &mir_types.PlaceElem.Subslice { from, to, from_end } => {
                mir_types.PlaceElem.Subslice { from, to, from_end }
            }
            &mir_types.PlaceElem.Downcast(idx) => mir_types.PlaceElem.Downcast(idx),
        }
    }
}

// ============================================================
// Move Tracking Infrastructure
// ============================================================
//
// This section provides infrastructure for tracking moved values
// to detect use-after-move errors.
//
// # Architecture
//
// Move tracking operates in two phases:
// 1. During MIR lowering: Record when Move operands are created
// 2. During MIR analysis: Check that moved places aren't used again
//
// # Current Status
//
// MoveTracker is integrated into MirLowerCtx:
// - MirLowerCtx has a `move_tracker` field
// - `operand_from_place_tracked()` in mir_lower_util.blood checks for
//   use-after-move before creating operands and tracks moves
// - `clear_move_on_assign()` resets move status after reassignment
//
// # Usage
//
// Use `operand_from_place_tracked()` instead of `operand_from_place()`
// to enable move tracking. The function will return Option.None if
// the place has been moved from, allowing the caller to report an error.

/// Tracks which places have been moved from.
///
/// This is a simplified representation. A full implementation would
/// track partial moves (e.g., moving a struct field) and handle
/// re-assignment which allows reuse.
pub struct MoveTracker {
    /// Places that have been moved from.
    /// Stored as (local_index, moved) pairs.
    moved_locals: Vec<MovedLocal>,
}

/// A local that has been moved from.
struct MovedLocal {
    /// The local's index.
    local_index: u32,
    /// The span where the move occurred (for error messages).
    move_span: common.Span,
}

impl MoveTracker {
    /// Creates a new move tracker.
    pub fn new() -> MoveTracker {
        MoveTracker {
            moved_locals: Vec.new(),
        }
    }

    /// Records that a local has been moved.
    pub fn track_move(self: &mut Self, local: mir_def.MirLocalId, span: common.Span) {
        self.moved_locals.push(MovedLocal {
            local_index: local.index,
            move_span: span,
        });
    }

    /// Checks if a local has been moved.
    /// Returns Some(span) if moved, None otherwise.
    pub fn check_moved(self: &Self, local: mir_def.MirLocalId) -> Option<common.Span> {
        for i in 0usize..self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                return Option.Some(self.moved_locals[i].move_span);
            }
        }
        Option.None
    }

    /// Clears the moved status of a local (after re-assignment).
    pub fn clear_move(self: &mut Self, local: mir_def.MirLocalId) {
        for i in 0usize..self.moved_locals.len() {
            if self.moved_locals[i].local_index == local.index {
                // Remove by swapping with last and popping
                let last = self.moved_locals.len() - 1;
                if i != last {
                    self.moved_locals[i] = MovedLocal {
                        local_index: self.moved_locals[last].local_index,
                        move_span: self.moved_locals[last].move_span,
                    };
                }
                self.moved_locals.pop();
                return;
            }
        }
    }

    /// Resets all move tracking (for a new function body).
    pub fn reset(self: &mut Self) {
        while self.moved_locals.len() > 0 {
            self.moved_locals.pop();
        }
    }
}

// force recompile
