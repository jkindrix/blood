// Blood Self-Hosted Compiler - Codegen Context
//
// This module defines the context used during MIR to LLVM IR codegen.
// It manages register allocation, local variable tracking, and IR emission.

mod common;
mod hir_def;
mod hir_ty;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod hashmap;
mod type_intern;

// ============================================================
// Codegen Error Types
// ============================================================

/// Categories of errors that can occur during code generation.
pub enum CodegenErrorKind {
    /// ADT (struct/enum) not found in registry.
    AdtLookupFailed,
    /// Function DefId not found in def_names table.
    FnLookupFailed,
    /// Static variable DefId not found or missing def_id.
    StaticLookupFailed,
    /// Type parameter substitution failed (index out of bounds).
    TypeSubstitutionFailed,
    /// Enum variant not found in layout registry.
    VariantLookupFailed,
    /// Effect operation index lookup failed.
    EffectOpLookupFailed,
    /// Unsupported operation (e.g., bitwise on float).
    UnsupportedOperation,
    /// LLVM type string could not be parsed.
    TypeParseFailed,
    /// Internal codegen error (unexpected state).
    InternalError,
}

/// A note attached to a codegen error providing additional context.
pub struct CodegenNote {
    /// The note message.
    pub message: String,
    /// Optional source span for the note.
    pub span: Option<common::Span>,
}

impl CodegenNote {
    /// Creates a note without a span.
    pub fn new(message: String) -> CodegenNote {
        CodegenNote {
            message: message,
            span: Option::None,
        }
    }

    /// Creates a note with a source span.
    pub fn with_span(message: String, span: common::Span) -> CodegenNote {
        CodegenNote {
            message: message,
            span: Option::Some(span),
        }
    }
}

/// An error produced during code generation.
pub struct CodegenError {
    /// The kind of error.
    pub kind: CodegenErrorKind,
    /// Human-readable description of the error.
    pub message: String,
    /// The function being generated when the error occurred (if known).
    pub fn_name: Option<String>,
    /// Source span where the error occurred (if known).
    pub span: Option<common::Span>,
    /// Additional contextual notes.
    pub notes: Vec<CodegenNote>,
}

impl CodegenError {
    /// Creates a new codegen error.
    pub fn new(kind: CodegenErrorKind, message: String) -> CodegenError {
        CodegenError {
            kind: kind,
            message: message,
            fn_name: Option::None,
            span: Option::None,
            notes: Vec::new(),
        }
    }

    /// Creates a new codegen error with function context.
    pub fn with_fn(kind: CodegenErrorKind, message: String, fn_name: String) -> CodegenError {
        CodegenError {
            kind: kind,
            message: message,
            fn_name: Option::Some(fn_name),
            span: Option::None,
            notes: Vec::new(),
        }
    }
}

// ============================================================
// Codegen Name (CgName) — Zero-Allocation Value Names
// ============================================================

/// A codegen value name that can be written to the output without heap allocation.
/// Instead of creating String objects for "%tmp42" or "label7", we store the
/// prefix type and integer, writing directly to the output buffer on demand.
pub enum CgName {
    /// %tmpN — SSA temporary value
    Temp(u32),
    /// %_N — local alloca name
    Local(u32),
    /// labelN — branch label
    Label(u32),
    /// bbN — MIR basic block label
    Block(u32),
    /// Arbitrary string value (pass-through SSA names, constants, etc.)
    Str(String),
}

// ============================================================
// ADT Layout Types
// ============================================================

/// Information about a single field's type (LLVM and optionally HIR).
pub struct AdtFieldInfo {
    /// The LLVM type string for this field (e.g., "i32", "ptr", "{ i32, i64 }").
    pub llvm_type: String,
    /// The HIR type for this field, if known (interned). Used for computing element sizes during indexing.
    pub hir_type: Option<type_intern::TyId>,
}

/// Layout of a struct type.
pub struct StructLayout {
    /// The DefId of the struct.
    pub def_id: u32,
    /// The fields in declaration order.
    pub fields: Vec<AdtFieldInfo>,
    /// The complete LLVM type string (e.g., "{ i32, i64, ptr }").
    pub llvm_type: String,
}

/// Layout of a single enum variant.
pub struct VariantLayout {
    /// The variant's discriminant index.
    pub variant_idx: u32,
    /// The fields/payload types for this variant.
    pub fields: Vec<AdtFieldInfo>,
    /// The LLVM type for this variant's payload (e.g., "{ i32, ptr }"), or "{}" for unit.
    pub payload_llvm_type: String,
}

/// Layout of an enum type.
pub struct EnumLayout {
    /// The DefId of the enum.
    pub def_id: u32,
    /// The LLVM type of the discriminant tag (e.g., "i8", "i32", "i64").
    pub discriminant_type: String,
    /// Layouts for each variant.
    pub variants: Vec<VariantLayout>,
    /// The complete LLVM type string (e.g., "{ i64, [16 x i8] }").
    pub llvm_type: String,
    /// The maximum payload size in bytes across all variants.
    pub max_payload_size: u64,
}

/// An ADT registry entry: either a struct or an enum.
pub enum AdtEntry {
    Struct(StructLayout),
    Enum(EnumLayout),
}

// ============================================================
// Codegen Context
// ============================================================

/// Context for generating LLVM IR from MIR.
pub struct CodegenCtx {
    /// The output buffer for LLVM IR.
    pub output: String,
    /// Current indentation level.
    indent_level: u32,
    /// Counter for generating unique SSA value names.
    value_counter: u32,
    /// Counter for generating unique labels.
    label_counter: u32,
    /// Mapping from MIR locals to LLVM value names.
    local_names: Vec<LocalName>,
    /// Mapping from MIR locals to their LLVM type strings.
    local_types: Vec<LocalType>,
    /// Mapping from MIR locals to their signedness (true = signed).
    local_signedness: Vec<LocalSignedness>,
    /// Mapping from MIR locals to their HIR types (for ADT lookups during projection).
    local_hir_types: Vec<LocalHirType>,
    /// Locals allocated via region allocator (freed on StorageDead).
    region_locals: Vec<RegionLocalEntry>,
    /// Locals allocated via persistent (ref-counted) allocator (decremented on StorageDead).
    persistent_locals: Vec<PersistentLocalEntry>,
    /// The current function being generated.
    current_fn: Option<String>,
    /// String constants table for global string literals.
    string_table: Vec<StringConstant>,
    /// Counter for generating unique string constant names.
    string_counter: u32,
    /// Mapping from DefIds to their global names (functions, consts, statics).
    def_names: Vec<DefNameEntry>,
    /// ADT type registry: maps DefIds to their layout information.
    pub adt_registry: Vec<AdtEntry>,
    // Hash indexes for O(1) lookups
    /// Hash index for def_names: def_id -> index in def_names vec
    def_names_hash: hashmap::HashMapU64U32,
    /// Hash index for local_names: local_id -> index in local_names vec
    local_names_hash: hashmap::HashMapU64U32,
    /// Hash index for local_types: local_id -> index in local_types vec
    local_types_hash: hashmap::HashMapU64U32,
    /// Hash index for local_signedness: local_id -> index in local_signedness vec
    local_signedness_hash: hashmap::HashMapU64U32,
    /// Hash index for local_hir_types: local_id -> index in local_hir_types vec
    local_hir_types_hash: hashmap::HashMapU64U32,
    /// Hash set for region_locals: local_id -> 1 if present
    region_locals_hash: hashmap::HashMapU64U32,
    /// Hash set for persistent_locals: local_id -> 1 if present
    persistent_locals_hash: hashmap::HashMapU64U32,
    /// Hash index for generation allocas: local_id -> index in local_generations vec
    local_generations_hash: hashmap::HashMapU64U32,
    /// Generation alloca SSA names for region-allocated locals.
    local_generations: Vec<LocalGeneration>,
    /// Hash index for string_table: string content hash -> index in string_table vec
    string_table_hash: hashmap::HashMapU64U32,
    /// Hash set for static def_ids: def_id -> 1 if static
    static_defs_hash: hashmap::HashMapU64U32,
    /// LLVM types for static variables: def_id -> index in static_types vec
    static_types_hash: hashmap::HashMapU64U32,
    /// LLVM type strings for static variables.
    static_types: Vec<String>,
    /// Hash set for const def_ids: def_id -> 1 if const
    const_defs_hash: hashmap::HashMapU64U32,
    /// Function signatures for generic call fixup: def_id -> index in fn_signatures vec
    fn_signatures: Vec<FnSigEntry>,
    fn_sigs_hash: hashmap::HashMapU64U32,
    /// Write buffer for batching file I/O during streaming codegen.
    write_buffer: String,
    /// Output file path for streaming codegen.
    output_path: String,
    /// Whether to emit MIR annotations as comments in LLVM IR.
    pub trace_codegen: bool,
    /// Per-function call remapping for trait default methods.
    /// When generating a default method body, calls to trait abstract method
    /// DefIds are redirected to concrete impl method DefIds.
    pub call_remaps: Vec<common::CallRemapEntry>,
    /// Mapping from handler DefId to effect DefId for evidence API calls.
    /// Vec entries allow iteration for cloning; hash for O(1) lookup.
    pub handler_effect_entries: Vec<HandlerEffectEntry>,
    handler_effect_hash: hashmap::HashMapU64U32,
    /// Mapping from handler DefId to state field count.
    /// Used during PushHandler codegen to determine if handler is truly stateless.
    handler_state_count_hash: hashmap::HashMapU64U32,
    /// Mapping from handler DefId to total state byte size.
    /// Used during PushHandler codegen to allocate correctly-sized state shadow allocas.
    /// Accounts for aggregate types like String (24 bytes) that need more than 8 bytes.
    handler_state_byte_size_hash: hashmap::HashMapU64U32,
    /// Whether the current function being generated is a handler op body.
    /// When true, Resume terminators emit `ret i64` instead of blood_resume calls.
    pub is_handler_op: bool,
    /// Deferred inline handler stub function definitions.
    /// Collected during PushInlineHandler codegen, emitted after all bodies.
    pub inline_stubs: Vec<String>,
    /// Counter for generating unique inline handler stub names.
    pub inline_stub_count: u32,
    /// MIR local index of the handler op state field (passed by pointer).
    /// Set to 1 when compiling handler op bodies, -1 otherwise.
    /// When >= 0, the local's alloca is `ptr` and accesses go through the pointer.
    pub handler_op_state_local: i32,
    /// Number of state fields in the current handler op body (0 if not a handler op).
    /// When > 1, locals 2..1+count are state fields accessed via GEP into the state pointer.
    pub handler_op_state_field_count: u32,
    /// Hash set of handler op body DefIds.  Value 1 = is a handler op body.
    handler_op_body_hash: hashmap::HashMapU64U32,
    /// Vec of handler op body DefIds (for cloning to worker contexts).
    pub handler_op_body_ids: Vec<u32>,
    /// Mapping from op DefId → positional op_index within its effect.
    /// MIR stores op_def.index as op_index; codegen resolves via this table.
    op_def_index_hash: hashmap::HashMapU64U32,
    /// Vec of (op_def_id, positional_index) for cloning to worker contexts.
    pub op_def_index_entries: Vec<OpDefIndexEntry>,
    /// Per-handler state shadow alloca names.
    /// Set during PushHandler codegen, read during CallReturnClause codegen.
    /// Keyed by handler_def_id to support nested handlers.
    pub handler_state_shadows: Vec<HandlerStateShadow>,
    /// Errors accumulated during code generation.
    pub codegen_errors: Vec<CodegenError>,
    /// Warnings accumulated during code generation.
    pub codegen_warnings: Vec<String>,
    /// The span of the MIR statement/terminator currently being compiled.
    /// Set before each statement/terminator codegen, used by codegen_error().
    pub current_span: Option<common::Span>,
    /// Cache of fn pointer wrapper: def_id → index into fn_ptr_wrapper_names/defs.
    fn_ptr_wrapper_hash: hashmap::HashMapU64U32,
    /// Wrapper function names (e.g., "fn_name$fnptr"), indexed by wrapper hash value.
    fn_ptr_wrapper_names: Vec<String>,
    /// Deferred fn pointer wrapper function LLVM IR definitions.
    /// Collected when FnDef values are used, emitted after all function bodies.
    pub fn_ptr_wrapper_defs: Vec<String>,
}

/// Entry mapping a handler DefId to its effect DefId.
pub struct HandlerEffectEntry {
    pub handler_def_id: u32,
    pub effect_def_id: u32,
}

/// Entry mapping an op DefId to its positional index within the effect.
pub struct OpDefIndexEntry {
    pub effect_def_id: u32,
    pub op_name_sym: u32,
    pub positional_index: u32,
}

/// Mapping from a handler DefId to its state shadow alloca name.
pub struct HandlerStateShadow {
    pub handler_def_id: u32,
    pub shadow_name: String,
}

/// Mapping from a MIR local to its LLVM type.
struct LocalType {
    local_id: u32,
    llvm_type: String,
}

/// Mapping from a MIR local to its HIR type (for ADT layout lookups).
struct LocalHirType {
    local_id: u32,
    hir_type: type_intern::TyId,
}

/// Mapping from a MIR local to its signedness.
struct LocalSignedness {
    local_id: u32,
    is_signed: bool,
}

/// Entry in the string constant table.
struct StringConstant {
    /// The global label for this string constant.
    label: String,
    /// The string content.
    content: String,
    /// The length of the string (including null terminator).
    length: usize,
}

/// Mapping from a MIR local to its LLVM name.
struct LocalName {
    local_id: u32,
    name: String,
}

/// Tracks a local that was allocated via a region allocator.
struct RegionLocalEntry {
    local_id: u32,
}

/// Tracks a local that was allocated via persistent (ref-counted) allocation.
struct PersistentLocalEntry {
    local_id: u32,
}

/// Mapping from a MIR local to its generation alloca SSA name.
struct LocalGeneration {
    local_id: u32,
    gen_name: String,
}

/// Mapping from a DefId to its global name (for functions, consts, statics).
pub struct DefNameEntry {
    pub def_id: u32,
    pub name: String,
}

impl DefNameEntry {
    /// Creates a new DefNameEntry.
    pub fn new(def_id: u32, name: String) -> DefNameEntry {
        DefNameEntry { def_id, name }
    }
}

/// Stored LLVM function signature for generic call fixup.
pub struct FnSigEntry {
    pub def_id: u32,
    pub param_types: Vec<String>,
    pub return_type: String,
}

impl CodegenCtx {
    /// Creates a new codegen context.
    pub fn new() -> CodegenCtx {
        CodegenCtx {
            // Pre-allocate output buffer (1 MB) and write buffer (64 KB)
            // to reduce realloc frequency during codegen
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            // Per-function Vecs: pre-allocate for typical function size (~64 locals)
            local_names: Vec::with_capacity(64),
            local_types: Vec::with_capacity(64),
            local_signedness: Vec::with_capacity(64),
            local_hir_types: Vec::with_capacity(64),
            region_locals: Vec::with_capacity(16),
            persistent_locals: Vec::with_capacity(16),
            current_fn: Option::None,
            // Persistent cross-function Vecs: pre-allocate for typical compiler size
            string_table: Vec::with_capacity(512),
            string_counter: 0,
            def_names: Vec::with_capacity(2048),
            adt_registry: Vec::with_capacity(256),
            def_names_hash: hashmap::HashMapU64U32::with_capacity(2048),
            local_names_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_signedness_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_hir_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            region_locals_hash: hashmap::HashMapU64U32::with_capacity(16),
            persistent_locals_hash: hashmap::HashMapU64U32::with_capacity(16),
            local_generations_hash: hashmap::HashMapU64U32::with_capacity(32),
            local_generations: Vec::with_capacity(32),
            string_table_hash: hashmap::HashMapU64U32::with_capacity(512),
            static_defs_hash: hashmap::HashMapU64U32::with_capacity(64),
            static_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            static_types: Vec::with_capacity(64),
            const_defs_hash: hashmap::HashMapU64U32::with_capacity(64),
            fn_signatures: Vec::with_capacity(512),
            fn_sigs_hash: hashmap::HashMapU64U32::with_capacity(512),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: false,
            call_remaps: Vec::new(),
            handler_effect_entries: Vec::with_capacity(32),
            handler_effect_hash: hashmap::HashMapU64U32::with_capacity(32),
            handler_state_count_hash: hashmap::HashMapU64U32::with_capacity(16),
            handler_state_byte_size_hash: hashmap::HashMapU64U32::with_capacity(16),
            is_handler_op: false,
            inline_stubs: Vec::with_capacity(128),
            inline_stub_count: 0,
            handler_op_state_local: -1,
            handler_op_state_field_count: 0,
            handler_op_body_hash: hashmap::HashMapU64U32::with_capacity(16),
            handler_op_body_ids: Vec::with_capacity(16),
            op_def_index_hash: hashmap::HashMapU64U32::with_capacity(16),
            op_def_index_entries: Vec::with_capacity(16),
            handler_state_shadows: Vec::with_capacity(8),
            codegen_errors: Vec::new(),
            codegen_warnings: Vec::new(),
            current_span: Option::None,
            fn_ptr_wrapper_hash: hashmap::HashMapU64U32::with_capacity(32),
            fn_ptr_wrapper_names: Vec::with_capacity(32),
            fn_ptr_wrapper_defs: Vec::with_capacity(32),
        }
    }

    /// Creates a new codegen context with pre-populated def names.
    pub fn with_def_names(def_names: Vec<DefNameEntry>) -> CodegenCtx {
        // Build hash index for def_names
        let mut def_names_hash = hashmap::HashMapU64U32::with_capacity(def_names.len());
        let mut i: usize = 0;
        while i < def_names.len() {
            def_names_hash.insert(def_names[i].def_id as u64, i as u32);
            i = i + 1;
        }

        CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::with_capacity(64),
            local_types: Vec::with_capacity(64),
            local_signedness: Vec::with_capacity(64),
            local_hir_types: Vec::with_capacity(64),
            region_locals: Vec::with_capacity(16),
            persistent_locals: Vec::with_capacity(16),
            current_fn: Option::None,
            string_table: Vec::with_capacity(512),
            string_counter: 0,
            def_names: def_names,
            adt_registry: Vec::with_capacity(256),
            def_names_hash: def_names_hash,
            local_names_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_signedness_hash: hashmap::HashMapU64U32::with_capacity(64),
            local_hir_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            region_locals_hash: hashmap::HashMapU64U32::with_capacity(16),
            persistent_locals_hash: hashmap::HashMapU64U32::with_capacity(16),
            local_generations_hash: hashmap::HashMapU64U32::with_capacity(32),
            local_generations: Vec::with_capacity(32),
            string_table_hash: hashmap::HashMapU64U32::with_capacity(512),
            static_defs_hash: hashmap::HashMapU64U32::with_capacity(64),
            static_types_hash: hashmap::HashMapU64U32::with_capacity(64),
            static_types: Vec::with_capacity(64),
            const_defs_hash: hashmap::HashMapU64U32::with_capacity(64),
            fn_signatures: Vec::with_capacity(512),
            fn_sigs_hash: hashmap::HashMapU64U32::with_capacity(512),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: false,
            call_remaps: Vec::new(),
            handler_effect_entries: Vec::with_capacity(32),
            handler_effect_hash: hashmap::HashMapU64U32::with_capacity(32),
            handler_state_count_hash: hashmap::HashMapU64U32::with_capacity(16),
            handler_state_byte_size_hash: hashmap::HashMapU64U32::with_capacity(16),
            is_handler_op: false,
            inline_stubs: Vec::with_capacity(128),
            inline_stub_count: 0,
            handler_op_state_local: -1,
            handler_op_state_field_count: 0,
            handler_op_body_hash: hashmap::HashMapU64U32::with_capacity(16),
            handler_op_body_ids: Vec::with_capacity(16),
            op_def_index_hash: hashmap::HashMapU64U32::with_capacity(16),
            op_def_index_entries: Vec::with_capacity(16),
            handler_state_shadows: Vec::with_capacity(8),
            codegen_errors: Vec::new(),
            codegen_warnings: Vec::new(),
            current_span: Option::None,
            fn_ptr_wrapper_hash: hashmap::HashMapU64U32::with_capacity(32),
            fn_ptr_wrapper_names: Vec::with_capacity(32),
            fn_ptr_wrapper_defs: Vec::with_capacity(32),
        }
    }

    /// Registers a DefId with its global name.
    pub fn register_def_name(self: &mut CodegenCtx, def_id: u32, name: String) {
        let idx = self.def_names.len() as u32;
        self.def_names.push(DefNameEntry { def_id, name });
        self.def_names_hash.insert(def_id as u64, idx);
    }

    /// Looks up the global name for a DefId.
    pub fn lookup_def_name(self: &CodegenCtx, def_id: u32) -> Option<String> {
        // Fast path: hash lookup
        match self.def_names_hash.get(def_id as u64) {
            Option::Some(idx) => {
                return Option::Some(clone_string(&self.def_names[idx as usize].name));
            }
            Option::None => {}
        }
        // Fallback: linear scan (should not happen)
        let mut i: usize = 0;
        while i < self.def_names.len() {
            if self.def_names[i].def_id == def_id {
                return Option::Some(clone_string(&self.def_names[i].name));
            }
            i = i + 1;
        }
        Option::None
    }

    /// Gets a reference to a def name. Zero allocation.
    /// Returns None if not found.
    pub fn lookup_def_name_ref(self: &CodegenCtx, def_id: u32) -> Option<&String> {
        match self.def_names_hash.get(def_id as u64) {
            Option::Some(idx) => {
                return Option::Some(&self.def_names[idx as usize].name);
            }
            Option::None => {}
        }
        // Fallback: linear scan
        let mut i: usize = 0;
        while i < self.def_names.len() {
            if self.def_names[i].def_id == def_id {
                return Option::Some(&self.def_names[i].name);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Registers LLVM function signature for a compiled function (keyed by def_id).
    pub fn register_fn_signature(self: &mut CodegenCtx, def_id: u32, param_types: Vec<String>, return_type: String) {
        let idx = self.fn_signatures.len() as u32;
        self.fn_signatures.push(FnSigEntry { def_id, param_types, return_type });
        self.fn_sigs_hash.insert(def_id as u64, idx);
    }

    /// Looks up the LLVM function signature for a given def_id.
    /// Returns the parameter types and return type if found.
    pub fn lookup_fn_param_type(self: &CodegenCtx, def_id: u32, param_idx: usize) -> Option<String> {
        match self.fn_sigs_hash.get(def_id as u64) {
            Option::Some(idx) => {
                let entry = &self.fn_signatures[idx as usize];
                if param_idx < entry.param_types.len() {
                    return Option::Some(clone_string(&entry.param_types[param_idx]));
                }
                Option::None
            }
            Option::None => Option::None,
        }
    }

    /// Looks up the LLVM return type for a given def_id.
    pub fn lookup_fn_ret_type(self: &CodegenCtx, def_id: u32) -> Option<String> {
        match self.fn_sigs_hash.get(def_id as u64) {
            Option::Some(idx) => {
                let entry = &self.fn_signatures[idx as usize];
                Option::Some(clone_string(&entry.return_type))
            }
            Option::None => Option::None,
        }
    }

    /// Returns the number of registered def_names.
    pub fn def_names_count(self: &CodegenCtx) -> usize {
        self.def_names.len()
    }

    /// Returns the def_id and name for a def_name entry at the given index.
    pub fn def_name_at(self: &CodegenCtx, index: usize) -> (u32, String) {
        let entry = &self.def_names[index];
        (entry.def_id, clone_string(&entry.name))
    }

    /// Gets or creates a fn pointer wrapper for the given def_id.
    /// Returns the wrapper function name (e.g., "fn_name$fnptr").
    /// The wrapper has signature (ptr %env, params...) -> ret and
    /// forwards to the original function ignoring the env parameter.
    pub fn get_or_create_fn_wrapper(self: &mut CodegenCtx, def_id: u32) -> Option<String> {
        // Check cache first
        match self.fn_ptr_wrapper_hash.get(def_id as u64) {
            Option::Some(idx) => {
                return Option::Some(clone_string(&self.fn_ptr_wrapper_names[idx as usize]));
            }
            Option::None => {}
        }

        // Get the original function name
        let fn_name = match self.lookup_def_name(def_id) {
            Option::Some(name) => name,
            Option::None => { return Option::None; }
        };

        // Build wrapper name
        let mut wrapper_name = clone_string(&fn_name);
        wrapper_name.push_str("$fnptr");

        // Get parameter types and return type from fn_signatures
        let has_sig = match self.fn_sigs_hash.get(def_id as u64) {
            Option::Some(_) => true,
            Option::None => false,
        };

        // Build wrapper function definition
        let mut def = String::new();
        def.push_str("define linkonce_odr ");

        if has_sig {
            let sig_idx = match self.fn_sigs_hash.get(def_id as u64) {
                Option::Some(idx) => idx as usize,
                Option::None => 0,
            };
            let ret_ty_str = clone_string(&self.fn_signatures[sig_idx].return_type);
            let param_count = self.fn_signatures[sig_idx].param_types.len();

            // Return type
            def.push_str(ret_ty_str.as_str());
            def.push_str(" @\"");
            def.push_str(wrapper_name.as_str());
            def.push_str("\"(ptr %env");

            // Add original parameters
            let mut pi: usize = 0;
            while pi < param_count {
                def.push_str(", ");
                let pty = clone_string(&self.fn_signatures[sig_idx].param_types[pi]);
                def.push_str(pty.as_str());
                def.push_str(" %p");
                def.push_str(codegen_types::format_u64(pi as u64).as_str());
                pi = pi + 1;
            }
            def.push_str(") {\nentry:\n");

            // Build the forwarding call
            let ret_bytes = ret_ty_str.as_bytes();
            let is_void = (ret_bytes.len() == 4 && ret_bytes[0] == 118 && ret_bytes[1] == 111 && ret_bytes[2] == 105 && ret_bytes[3] == 100) || (ret_bytes.len() == 2 && ret_bytes[0] == 123 && ret_bytes[1] == 125);
            if is_void {
                def.push_str("  call void @");
            } else {
                def.push_str("  %result = call ");
                def.push_str(ret_ty_str.as_str());
                def.push_str(" @");
            }
            def.push_str(fn_name.as_str());
            def.push_str("(");
            let mut ai: usize = 0;
            while ai < param_count {
                if ai > 0 {
                    def.push_str(", ");
                }
                let pty = clone_string(&self.fn_signatures[sig_idx].param_types[ai]);
                def.push_str(pty.as_str());
                def.push_str(" %p");
                def.push_str(codegen_types::format_u64(ai as u64).as_str());
                ai = ai + 1;
            }
            def.push_str(")\n");

            // Return
            if is_void {
                def.push_str("  ret void\n");
            } else {
                def.push_str("  ret ");
                def.push_str(ret_ty_str.as_str());
                def.push_str(" %result\n");
            }
            def.push_str("}\n");
        } else {
            // No signature info — generate a generic ptr-returning wrapper
            def.push_str("i64 @\"");
            def.push_str(wrapper_name.as_str());
            def.push_str("\"(ptr %env) {\nentry:\n");
            def.push_str("  %result = call i64 @");
            def.push_str(fn_name.as_str());
            def.push_str("()\n");
            def.push_str("  ret i64 %result\n");
            def.push_str("}\n");
        }

        // Cache the wrapper name and store the definition for later emission
        let idx = self.fn_ptr_wrapper_names.len() as u32;
        self.fn_ptr_wrapper_names.push(clone_string(&wrapper_name));
        self.fn_ptr_wrapper_defs.push(def);
        self.fn_ptr_wrapper_hash.insert(def_id as u64, idx);

        Option::Some(wrapper_name)
    }

    /// Registers a DefId as a static variable.
    pub fn register_static(self: &mut CodegenCtx, def_id: u32) {
        self.static_defs_hash.insert(def_id as u64, 1);
    }

    /// Registers the LLVM type for a static variable.
    pub fn register_static_type(self: &mut CodegenCtx, def_id: u32, llvm_type: String) {
        let idx = self.static_types.len() as u32;
        self.static_types.push(llvm_type);
        self.static_types_hash.insert(def_id as u64, idx);
    }

    /// Returns the LLVM type for a static variable, if registered.
    pub fn get_static_type(self: &CodegenCtx, def_id: u32) -> Option<String> {
        match self.static_types_hash.get(def_id as u64) {
            Option::Some(idx) => {
                Option::Some(clone_string(&self.static_types[idx as usize]))
            }
            Option::None => Option::None,
        }
    }

    /// Returns true if the given DefId is a static variable.
    pub fn is_static(self: &CodegenCtx, def_id: u32) -> bool {
        match self.static_defs_hash.get(def_id as u64) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Registers a DefId as a const item.
    pub fn register_const(self: &mut CodegenCtx, def_id: u32) {
        self.const_defs_hash.insert(def_id as u64, 1);
    }

    /// Returns true if the given DefId is a const item.
    pub fn is_const(self: &CodegenCtx, def_id: u32) -> bool {
        match self.const_defs_hash.get(def_id as u64) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Remaps a DefId through the call_remaps table.
    /// If the DefId matches a from_def_id in call_remaps, returns the to_def_id.
    /// Otherwise returns the original def_id unchanged.
    pub fn remap_def_id(self: &CodegenCtx, def_id: u32) -> u32 {
        let mut i: usize = 0;
        while i < self.call_remaps.len() {
            if self.call_remaps[i].from_def_id == def_id {
                return self.call_remaps[i].to_def_id;
            }
            i = i + 1;
        }
        def_id
    }

    /// Registers a handler DefId → effect DefId mapping.
    pub fn register_handler_effect(self: &mut CodegenCtx, handler_def_id: u32, effect_def_id: u32) {
        self.handler_effect_entries.push(HandlerEffectEntry { handler_def_id, effect_def_id });
        self.handler_effect_hash.insert(handler_def_id as u64, effect_def_id);
    }

    /// Looks up the effect DefId for a handler DefId.
    pub fn lookup_handler_effect(self: &CodegenCtx, handler_def_id: u32) -> Option<u32> {
        match self.handler_effect_hash.get(handler_def_id as u64) {
            Option::Some(v) => Option::Some(v),
            Option::None => Option::None,
        }
    }

    /// Registers handler DefId → state field count mapping.
    pub fn register_handler_state_count(self: &mut CodegenCtx, handler_def_id: u32, state_count: u32) {
        self.handler_state_count_hash.insert(handler_def_id as u64, state_count);
    }

    /// Looks up the state field count for a handler DefId.
    /// Returns 0 if not registered.
    pub fn lookup_handler_state_count(self: &CodegenCtx, handler_def_id: u32) -> u32 {
        match self.handler_state_count_hash.get(handler_def_id as u64) {
            Option::Some(v) => v,
            Option::None => 0,
        }
    }

    /// Registers handler DefId → total state byte size mapping.
    pub fn register_handler_state_byte_size(self: &mut CodegenCtx, handler_def_id: u32, byte_size: u32) {
        self.handler_state_byte_size_hash.insert(handler_def_id as u64, byte_size);
    }

    /// Looks up the total state byte size for a handler DefId.
    /// Returns 0 if not registered.
    pub fn lookup_handler_state_byte_size(self: &CodegenCtx, handler_def_id: u32) -> u32 {
        match self.handler_state_byte_size_hash.get(handler_def_id as u64) {
            Option::Some(v) => v,
            Option::None => 0,
        }
    }

    /// Registers a state shadow alloca name for a handler.
    pub fn set_handler_state_shadow(self: &mut CodegenCtx, handler_def_id: u32, shadow_name: String) {
        self.handler_state_shadows.push(HandlerStateShadow {
            handler_def_id,
            shadow_name,
        });
    }

    /// Looks up the state shadow alloca name for a handler.
    pub fn get_handler_state_shadow(self: &CodegenCtx, handler_def_id: u32) -> Option<&String> {
        let mut i: usize = 0;
        while i < self.handler_state_shadows.len() {
            if self.handler_state_shadows[i].handler_def_id == handler_def_id {
                return Option::Some(&self.handler_state_shadows[i].shadow_name);
            }
            i = i + 1;
        }
        Option::None
    }

    /// Resets per-function state while keeping global state (def_names).
    pub fn reset_function_state(self: &mut CodegenCtx) {
        self.output = String::new();
        self.indent_level = 0;
        self.value_counter = 0;
        self.label_counter = 0;
        self.local_names = Vec::new();
        self.local_types = Vec::new();
        self.local_signedness = Vec::new();
        self.current_fn = Option::None;
        self.current_span = Option::None;
        // Note: string_table and def_names are preserved
    }

    // ======== Output Management ========

    /// Writes a string to the output.
    pub fn write(self: &mut CodegenCtx, s: &str) {
        self.output.push_str(s);
    }

    /// Writes a String to the output.
    pub fn write_string(self: &mut CodegenCtx, s: &String) {
        self.output.push_str(s.as_str());
    }

    /// Writes a newline with current indentation.
    pub fn writeln(self: &mut CodegenCtx, s: &str) {
        self.write_indent();
        self.write(s);
        self.write("\n");
    }

    /// Writes a newline.
    pub fn newline(self: &mut CodegenCtx) {
        self.write("\n");
    }

    /// Writes current indentation.
    fn write_indent(self: &mut CodegenCtx) {
        let mut i: u32 = 0;
        while i < self.indent_level {
            self.write("    ");
            i = i + 1;
        }
    }

    /// Increases indentation level.
    pub fn indent(self: &mut CodegenCtx) {
        self.indent_level = self.indent_level + 1;
    }

    /// Decreases indentation level.
    pub fn dedent(self: &mut CodegenCtx) {
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;
        }
    }

    /// Writes a u64 as decimal digits directly to the output. No String allocation.
    pub fn write_u64(self: &mut CodegenCtx, n: u64) {
        if n == 0 {
            self.output.push('0');
            return;
        }
        // Find the highest power of 10 <= n
        let mut divisor: u64 = 1;
        let mut temp: u64 = n;
        while temp >= 10 {
            divisor = divisor * 10;
            temp = temp / 10;
        }
        // Write digits from most significant to least
        let mut d: u64 = divisor;
        while d > 0 {
            let digit: u64 = (n / d) % 10;
            let d32: u32 = digit as u32;
            let ch: char = (48u32 + d32) as char;
            self.output.push(ch);
            d = d / 10;
        }
    }

    /// Writes a CgName to the output without allocating any String.
    pub fn write_cgname(self: &mut CodegenCtx, name: &CgName) {
        match name {
            &CgName::Temp(n) => {
                self.write("%tmp");
                self.write_u64(n as u64);
            }
            &CgName::Local(n) => {
                self.write("%_");
                self.write_u64(n as u64);
            }
            &CgName::Label(n) => {
                self.write("label");
                self.write_u64(n as u64);
            }
            &CgName::Block(n) => {
                self.write("bb");
                self.write_u64(n as u64);
            }
            &CgName::Str(ref s) => {
                self.write(s.as_str());
            }
        }
    }

    /// Converts a CgName to a String representation for use at boundaries
    /// where String is required (e.g., llvm_args vectors).
    pub fn cgname_to_string(name: &CgName) -> String {
        match name {
            &CgName::Temp(n) => {
                let mut s = common::make_string("%tmp");
                let ns = codegen_types::format_u64(n as u64);
                s.push_str(ns.as_str());
                s
            }
            &CgName::Local(n) => {
                let mut s = common::make_string("%_");
                let ns = codegen_types::format_u64(n as u64);
                s.push_str(ns.as_str());
                s
            }
            &CgName::Label(n) => {
                let mut s = common::make_string("label");
                let ns = codegen_types::format_u64(n as u64);
                s.push_str(ns.as_str());
                s
            }
            &CgName::Block(n) => {
                let mut s = common::make_string("bb");
                let ns = codegen_types::format_u64(n as u64);
                s.push_str(ns.as_str());
                s
            }
            &CgName::Str(ref s) => {
                clone_string(s)
            }
        }
    }

    // ======== Buffered File I/O ========

    /// Sets the output file path for buffered streaming writes.
    pub fn set_output_path(self: &mut CodegenCtx, path: &str) {
        self.output_path = String::new();
        self.output_path.push_str(path);
    }

    /// Appends text to the write buffer. Flushes to disk when buffer exceeds 65536 bytes.
    pub fn buffer_write(self: &mut CodegenCtx, s: &str) {
        self.write_buffer.push_str(s);
        if self.write_buffer.len() > 65536 {
            self.flush_write_buffer();
        }
    }

    /// Flushes the write buffer to the output file.
    pub fn flush_write_buffer(self: &mut CodegenCtx) {
        if self.write_buffer.len() > 0 {
            file_append_string(self.output_path.as_str(), self.write_buffer.as_str());
            self.write_buffer = String::new();
        }
    }

    /// Writes an HIR type as LLVM IR directly to the output buffer.
    /// Uses the fast path (no String allocation) for common types,
    /// falls back to type_to_llvm for compound types.
    pub fn write_type(self: &mut CodegenCtx, ty: &hir_ty::Type) {
        match codegen_types::type_to_llvm_fast(ty) {
            Option::Some(s) => self.write(s),
            Option::None => {
                let s = codegen_types::type_to_llvm(ty);
                self.write(s.as_str());
            }
        }
    }

    /// Writes an HIR type as LLVM IR directly to the output buffer,
    /// using ADT registry lookups. No String allocation for common types.
    pub fn write_type_with_ctx(self: &mut CodegenCtx, ty: &hir_ty::Type) {
        match &ty.kind {
            &hir_ty::TypeKind::Adt { def_id, args: _ } => {
                let s = self.adt_llvm_type(def_id.index);
                self.write(s.as_str());
            }
            _ => self.write_type(ty),
        }
    }

    // ======== Value Names ========

    /// Generates a new unique temporary CgName. Zero allocation.
    pub fn fresh_temp_cg(self: &mut CodegenCtx) -> CgName {
        let n = self.value_counter;
        self.value_counter = self.value_counter + 1;
        CgName::Temp(n)
    }

    /// Generates a new unique label CgName. Zero allocation.
    pub fn fresh_label_cg(self: &mut CodegenCtx) -> CgName {
        let n = self.label_counter;
        self.label_counter = self.label_counter + 1;
        CgName::Label(n)
    }

    /// Returns a CgName for a basic block label. Zero allocation.
    pub fn block_label_cg(self: &CodegenCtx, block: mir_def::BasicBlockId) -> CgName {
        CgName::Block(block.index)
    }

    /// Returns a CgName for a MIR local alloca. Zero allocation.
    pub fn local_cg(self: &CodegenCtx, local: mir_def::MirLocalId) -> CgName {
        CgName::Local(local.index)
    }

    /// Gets the LLVM name for a MIR local.
    /// Gets a reference to the local's LLVM name. Zero allocation.
    /// Returns None if the local has no registered name (use local_cg() for %_N fallback).
    pub fn local_name_ref(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<&String> {
        match self.local_names_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return Option::Some(&self.local_names[idx as usize].name);
            }
            Option::None => {}
        }
        Option::None
    }

    /// Registers a local with its LLVM name.
    pub fn register_local(self: &mut CodegenCtx, local: mir_def::MirLocalId, name: String) {
        let idx = self.local_names.len() as u32;
        self.local_names.push(LocalName {
            local_id: local.index,
            name: name,
        });
        self.local_names_hash.insert(local.index as u64, idx);
    }

    /// Registers a local with its LLVM type.
    pub fn register_local_type(self: &mut CodegenCtx, local: mir_def::MirLocalId, llvm_type: String) {
        let idx = self.local_types.len() as u32;
        self.local_types.push(LocalType {
            local_id: local.index,
            llvm_type: llvm_type,
        });
        self.local_types_hash.insert(local.index as u64, idx);
    }

    /// Gets the LLVM type for a MIR local.
    pub fn get_local_type(self: &CodegenCtx, local: mir_def::MirLocalId) -> String {
        // Fast path: hash lookup
        match self.local_types_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return clone_string(&self.local_types[idx as usize].llvm_type);
            }
            Option::None => {}
        }
        // Fallback: return i64 if type not found
        common::make_string("i64")
    }

    /// Gets a reference to the local's LLVM type string. Zero allocation.
    /// Returns None if the local has no registered type.
    pub fn get_local_type_ref(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<&String> {
        match self.local_types_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return Option::Some(&self.local_types[idx as usize].llvm_type);
            }
            Option::None => {}
        }
        Option::None
    }

    /// Registers a local with its signedness (true = signed, false = unsigned).
    pub fn register_local_signedness(self: &mut CodegenCtx, local: mir_def::MirLocalId, is_signed: bool) {
        let idx = self.local_signedness.len() as u32;
        self.local_signedness.push(LocalSignedness {
            local_id: local.index,
            is_signed: is_signed,
        });
        self.local_signedness_hash.insert(local.index as u64, idx);
    }

    /// Returns whether a local is signed. Defaults to true if not found.
    pub fn is_local_signed(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        // Fast path: hash lookup
        match self.local_signedness_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return self.local_signedness[idx as usize].is_signed;
            }
            Option::None => {}
        }
        // Default to signed if not found
        true
    }

    /// Registers a local with its HIR type.
    pub fn register_local_hir_type(self: &mut CodegenCtx, local: mir_def::MirLocalId, hir_type: type_intern::TyId) {
        let idx = self.local_hir_types.len() as u32;
        self.local_hir_types.push(LocalHirType {
            local_id: local.index,
            hir_type: hir_type,
        });
        self.local_hir_types_hash.insert(local.index as u64, idx);
    }

    /// Gets the HIR type for a MIR local.
    pub fn get_local_hir_type(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<type_intern::TyId> {
        // Fast path: hash lookup
        match self.local_hir_types_hash.get(local.index as u64) {
            Option::Some(idx) => {
                return Option::Some(self.local_hir_types[idx as usize].hir_type);
            }
            Option::None => {}
        }
        Option::None
    }

    /// Marks a local as region-allocated (will be unregistered on StorageDead).
    pub fn mark_region_allocated(self: &mut CodegenCtx, local: mir_def::MirLocalId) {
        self.region_locals.push(RegionLocalEntry { local_id: local.index });
        self.region_locals_hash.insert(local.index as u64, 1);
    }

    /// Marks a local as persistent-allocated (will be decremented on StorageDead).
    pub fn mark_persistent_allocated(self: &mut CodegenCtx, local: mir_def::MirLocalId) {
        self.persistent_locals.push(PersistentLocalEntry { local_id: local.index });
        self.persistent_locals_hash.insert(local.index as u64, 1);
    }

    /// Returns true if a local is region-allocated.
    pub fn is_region_allocated(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        self.region_locals_hash.contains_key(local.index as u64)
    }

    /// Returns true if a local is persistent-allocated.
    pub fn is_persistent_allocated(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        self.persistent_locals_hash.contains_key(local.index as u64)
    }

    /// Returns true if a local is the handler op state pointer.
    /// When true, the local's alloca holds a `ptr` (not the value directly),
    /// and all loads/stores must go through the pointer indirection.
    pub fn is_handler_state_ptr(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        self.handler_op_state_local >= 0 && local.index == (self.handler_op_state_local as u32)
    }

    /// Returns true if a local is a handler state field (not the state pointer itself,
    /// but a secondary field accessed via GEP into the state struct).
    /// For state_field_count=2, locals 2 through 2 are state fields (local 2 is field index 1).
    pub fn is_handler_state_field(self: &CodegenCtx, local: mir_def::MirLocalId) -> bool {
        if self.handler_op_state_field_count <= 1 {
            return false;
        }
        // State fields are locals 2 through (1 + state_field_count - 1)
        // i.e., local index 2 to handler_op_state_field_count (inclusive)
        local.index >= 2 && local.index <= self.handler_op_state_field_count
    }

    /// Returns the GEP field index for a handler state field local.
    /// Local 2 = field index 1, local 3 = field index 2, etc.
    pub fn handler_state_field_gep_index(self: &CodegenCtx, local: mir_def::MirLocalId) -> u32 {
        local.index - 1
    }

    /// Registers a DefId as a handler op body function.
    /// state_count is the number of state fields in the enclosing handler.
    pub fn register_handler_op_body(self: &mut CodegenCtx, def_id: u32, state_count: u32) {
        self.handler_op_body_hash.insert(def_id as u64, state_count);
        self.handler_op_body_ids.push(def_id);
    }

    /// Returns true if the given DefId is a handler op body function.
    pub fn is_handler_op_body(self: &CodegenCtx, def_id: u32) -> bool {
        self.handler_op_body_hash.contains_key(def_id as u64)
    }

    /// Returns the number of state fields for a handler op body.
    /// Returns 0 if the handler has no state or the DefId is not a handler op.
    pub fn handler_op_state_count(self: &CodegenCtx, def_id: u32) -> u32 {
        match self.handler_op_body_hash.get(def_id as u64) {
            Option::Some(v) => v,
            Option::None => 0,
        }
    }

    /// Registers an (effect_def_id, op_name_symbol) → positional index mapping.
    pub fn register_op_def_index(self: &mut CodegenCtx, effect_def_id: u32, op_name_sym: u32, positional_index: u32) {
        self.op_def_index_entries.push(OpDefIndexEntry { effect_def_id, op_name_sym, positional_index });
        let key = ((effect_def_id as u64) << 32) | (op_name_sym as u64);
        self.op_def_index_hash.insert(key, positional_index);
    }

    /// Looks up the positional op_index for an (effect_def_id, op_name_symbol) pair.
    /// Returns 0 as fallback if not found.
    pub fn resolve_op_index(self: &CodegenCtx, effect_def_id: u32, op_name_sym: u32) -> u32 {
        let key = ((effect_def_id as u64) << 32) | (op_name_sym as u64);
        match self.op_def_index_hash.get(key) {
            Option::Some(idx) => idx,
            Option::None => 0,
        }
    }

    /// Records the generation alloca SSA name for a region-allocated local.
    pub fn set_local_generation(self: &mut CodegenCtx, local: mir_def::MirLocalId, gen_name: String) {
        let idx = self.local_generations.len() as u32;
        self.local_generations.push(LocalGeneration {
            local_id: local.index,
            gen_name: gen_name,
        });
        self.local_generations_hash.insert(local.index as u64, idx);
    }

    /// Gets the generation alloca SSA name for a local, if it has one.
    pub fn get_local_generation(self: &CodegenCtx, local: mir_def::MirLocalId) -> Option<String> {
        match self.local_generations_hash.get(local.index as u64) {
            Option::Some(idx) => {
                Option::Some(clone_string(&self.local_generations[idx as usize].gen_name))
            }
            Option::None => Option::None,
        }
    }

    /// Clears all local names, types, and signedness (for reuse between functions).
    pub fn clear_locals(self: &mut CodegenCtx) {
        self.local_names.clear();
        self.local_types.clear();
        self.local_signedness.clear();
        self.local_hir_types.clear();
        self.region_locals.clear();
        self.persistent_locals.clear();
        // Clear hash indexes too
        self.local_names_hash = hashmap::HashMapU64U32::new();
        self.local_types_hash = hashmap::HashMapU64U32::new();
        self.local_signedness_hash = hashmap::HashMapU64U32::new();
        self.local_hir_types_hash = hashmap::HashMapU64U32::new();
        self.region_locals_hash = hashmap::HashMapU64U32::new();
        self.persistent_locals_hash = hashmap::HashMapU64U32::new();
        self.local_generations.clear();
        self.local_generations_hash = hashmap::HashMapU64U32::new();
    }

    // ======== Error Reporting ========

    /// Records a codegen error with the current function and span context.
    pub fn codegen_error(self: &mut CodegenCtx, kind: CodegenErrorKind, message: String) {
        let fn_name = match &self.current_fn {
            &Option::Some(ref name) => Option::Some(clone_string(name)),
            &Option::None => Option::None,
        };
        let span = match &self.current_span {
            &Option::Some(ref s) => Option::Some(*s),
            &Option::None => Option::None,
        };
        self.codegen_errors.push(CodegenError {
            kind: kind,
            message: message,
            fn_name: fn_name,
            span: span,
            notes: Vec::new(),
        });
    }

    /// Records a codegen error with the current context and an attached note.
    pub fn codegen_error_with_note(self: &mut CodegenCtx, kind: CodegenErrorKind, message: String, note: String) {
        let fn_name = match &self.current_fn {
            &Option::Some(ref name) => Option::Some(clone_string(name)),
            &Option::None => Option::None,
        };
        let span = match &self.current_span {
            &Option::Some(ref s) => Option::Some(*s),
            &Option::None => Option::None,
        };
        let mut notes = Vec::new();
        notes.push(CodegenNote::new(note));
        self.codegen_errors.push(CodegenError {
            kind: kind,
            message: message,
            fn_name: fn_name,
            span: span,
            notes: notes,
        });
    }

    /// Returns true if any codegen errors have been recorded.
    pub fn has_codegen_errors(self: &CodegenCtx) -> bool {
        self.codegen_errors.len() > 0
    }

    /// Takes ownership of accumulated errors, leaving the error list empty.
    pub fn take_errors(self: &mut CodegenCtx) -> Vec<CodegenError> {
        let mut errors: Vec<CodegenError> = Vec::new();
        let mut i: usize = 0;
        while i < self.codegen_errors.len() {
            let err = &self.codegen_errors[i];
            let fn_name = match &err.fn_name {
                &Option::Some(ref name) => Option::Some(clone_string(name)),
                &Option::None => Option::None,
            };
            let span = match &err.span {
                &Option::Some(ref s) => Option::Some(*s),
                &Option::None => Option::None,
            };
            let mut notes = Vec::new();
            let mut ni: usize = 0;
            while ni < err.notes.len() {
                let note_span = match &err.notes[ni].span {
                    &Option::Some(ref s) => Option::Some(*s),
                    &Option::None => Option::None,
                };
                notes.push(CodegenNote {
                    message: clone_string(&err.notes[ni].message),
                    span: note_span,
                });
                ni = ni + 1;
            }
            errors.push(CodegenError {
                kind: clone_error_kind(&err.kind),
                message: clone_string(&err.message),
                fn_name: fn_name,
                span: span,
                notes: notes,
            });
            i = i + 1;
        }
        self.codegen_errors.clear();
        errors
    }

    /// Takes ownership of accumulated warnings, leaving the warning list empty.
    pub fn take_warnings(self: &mut CodegenCtx) -> Vec<String> {
        let mut warnings: Vec<String> = Vec::new();
        let mut i: usize = 0;
        while i < self.codegen_warnings.len() {
            warnings.push(clone_string(&self.codegen_warnings[i]));
            i = i + 1;
        }
        self.codegen_warnings.clear();
        warnings
    }

    // ======== ADT Registry ========

    /// Registers a struct layout in the ADT registry.
    pub fn register_struct(self: &mut CodegenCtx, layout: StructLayout) {
        self.adt_registry.push(AdtEntry::Struct(layout));
    }

    /// Registers an enum layout in the ADT registry.
    pub fn register_enum(self: &mut CodegenCtx, layout: EnumLayout) {
        self.adt_registry.push(AdtEntry::Enum(layout));
    }

    /// Looks up a struct layout by DefId.
    /// Scans from the end so that later registrations (e.g., pass 2 with resolved
    /// nested ADT types) take precedence over earlier ones.
    pub fn lookup_struct(self: &CodegenCtx, def_id: u32) -> Option<&StructLayout> {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(ref layout) => {
                    if layout.def_id == def_id {
                        return Option::Some(layout);
                    }
                }
                &AdtEntry::Enum(_) => {}
            }
        }
        Option::None
    }

    /// Looks up an enum layout by DefId.
    /// Scans from the end so that later registrations take precedence.
    pub fn lookup_enum(self: &CodegenCtx, def_id: u32) -> Option<&EnumLayout> {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(_) => {}
                &AdtEntry::Enum(ref layout) => {
                    if layout.def_id == def_id {
                        return Option::Some(layout);
                    }
                }
            }
        }
        Option::None
    }

    /// Looks up a struct field's HIR type by struct DefId and field index.
    pub fn lookup_field_hir_type(self: &CodegenCtx, def_id: u32, field_idx: u32) -> Option<type_intern::TyId> {
        match self.lookup_struct(def_id) {
            Option::Some(layout) => {
                if (field_idx as usize) < layout.fields.len() {
                    match &layout.fields[field_idx as usize].hir_type {
                        &Option::Some(ty_id) => Option::Some(ty_id),
                        &Option::None => Option::None,
                    }
                } else {
                    Option::None
                }
            }
            Option::None => Option::None,
        }
    }

    /// Gets the LLVM type for an ADT (struct or enum) by DefId.
    /// Returns "ptr" as fallback if not found in the registry.
    /// Scans from the end so that pass 2 entries (with resolved nested types)
    /// take precedence over pass 1 entries.
    pub fn adt_llvm_type(self: &CodegenCtx, def_id: u32) -> String {
        let mut i: usize = self.adt_registry.len();
        while i > 0 {
            i = i - 1;
            match &self.adt_registry[i] {
                &AdtEntry::Struct(ref layout) => {
                    if layout.def_id == def_id {
                        return clone_string(&layout.llvm_type);
                    }
                }
                &AdtEntry::Enum(ref layout) => {
                    if layout.def_id == def_id {
                        return clone_string(&layout.llvm_type);
                    }
                }
            }
        }
        // Fallback: check if this is a known builtin ADT
        match self.lookup_def_name(def_id) {
            Option::Some(name) => {
                let name_bytes = name.as_bytes();
                // Vec -> { ptr, i64, i64 }
                if name_bytes.len() == 3 && name_bytes[0] == 86 && name_bytes[1] == 101 && name_bytes[2] == 99 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // String -> { ptr, i64, i64 }
                if name_bytes.len() == 6 && name_bytes[0] == 83 && name_bytes[1] == 116 && name_bytes[2] == 114 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // HashMap -> { ptr, i64, i64 }
                if name_bytes.len() == 7 && name_bytes[0] == 72 && name_bytes[1] == 97 && name_bytes[2] == 115 && name_bytes[3] == 104 {
                    return common::make_string("{ ptr, i64, i64 }");
                }
                // Box -> ptr
                if name_bytes.len() == 3 && name_bytes[0] == 66 && name_bytes[1] == 111 && name_bytes[2] == 120 {
                    return common::make_string("ptr");
                }
                common::make_string("ptr")
            }
            Option::None => common::make_string("ptr"),
        }
    }

    /// Converts a type to LLVM IR, using the ADT registry for struct/enum types.
    /// This is the context-aware version that properly resolves ADT types.
    /// Falls back to `codegen_types::type_to_llvm` for non-ADT types.
    pub fn type_to_llvm_with_ctx(self: &CodegenCtx, ty: &hir_ty::Type) -> String {
        match &ty.kind {
            &hir_ty::TypeKind::Adt { def_id, args: _ } => {
                self.adt_llvm_type(def_id.index)
            }
            &hir_ty::TypeKind::Tuple(ref elems) => {
                if elems.len() == 0 {
                    common::make_string("{}")
                } else {
                    let mut result = common::make_string("{ ");
                    let mut i: usize = 0;
                    while i < elems.len() {
                        if i > 0 {
                            result.push_str(", ");
                        }
                        let elem_str = self.type_to_llvm_with_ctx(&elems[i]);
                        result.push_str(elem_str.as_str());
                        i = i + 1;
                    }
                    result.push_str(" }");
                    result
                }
            }
            _ => codegen_types::type_to_llvm(ty),
        }
    }

    /// Generates the name for a MIR local alloca.
    pub fn local_alloca_name(self: &mut CodegenCtx, local: mir_def::MirLocalId) -> String {
        let mut name = common::make_string("%_");
        let num_str = codegen_types::format_u64(local.index as u64);
        name.push_str(num_str.as_str());
        name
    }

    // ======== Block Labels ========

    // ======== Function Management ========

    /// Begins generating a new function.
    pub fn begin_function(self: &mut CodegenCtx, name: String) {
        self.current_fn = Option::Some(clone_string(&name));
        self.current_span = Option::None;
        self.value_counter = 0;
        self.local_names.clear();
    }

    /// Ends the current function.
    pub fn end_function(self: &mut CodegenCtx) {
        self.current_fn = Option::None;
        self.current_span = Option::None;
    }

    /// Returns the current function name, or empty string if none.
    pub fn current_function(self: &CodegenCtx) -> String {
        match &self.current_fn {
            &Option::Some(ref name) => clone_string(name),
            &Option::None => common::make_string(""),
        }
    }

    // ======== String Constants ========

    /// Adds a string constant to the table and returns its global label.
    pub fn add_string_constant(self: &mut CodegenCtx, content: &String) -> String {
        // Fast path: check hash index
        let hash = hashmap::hash_string(content);
        match self.string_table_hash.get(hash) {
            Option::Some(idx) => {
                // Verify it's the same string (handle hash collisions)
                if string_equal(&self.string_table[idx as usize].content, content) {
                    return clone_string(&self.string_table[idx as usize].label);
                }
                // Hash collision - fall through to linear scan
            }
            Option::None => {
                // Definitely new, add it
                let n = self.string_counter;
                self.string_counter = self.string_counter + 1;
                let mut label = common::make_string("@.str.");
                let num_str = codegen_types::format_u64(n as u64);
                label.push_str(num_str.as_str());

                let length = content.len() + 1; // +1 for null terminator
                let idx = self.string_table.len() as u32;

                self.string_table.push(StringConstant {
                    label: clone_string(&label),
                    content: clone_string(content),
                    length: length,
                });
                self.string_table_hash.insert(hash, idx);

                return label;
            }
        }

        // Hash collision case: linear scan
        let mut i: usize = 0;
        while i < self.string_table.len() {
            if string_equal(&self.string_table[i].content, content) {
                return clone_string(&self.string_table[i].label);
            }
            i = i + 1;
        }

        // Not found, add new (collision case)
        let n = self.string_counter;
        self.string_counter = self.string_counter + 1;
        let mut label = common::make_string("@.str.");
        let num_str = codegen_types::format_u64(n as u64);
        label.push_str(num_str.as_str());

        let length = content.len() + 1;

        self.string_table.push(StringConstant {
            label: clone_string(&label),
            content: clone_string(content),
            length: length,
        });

        label
    }

    /// Emits all string constants as global declarations.
    /// Should be called at the beginning of the module.
    pub fn emit_string_constants(self: &mut CodegenCtx) {
        let mut i: usize = 0;
        while i < self.string_table.len() {
            let entry = &self.string_table[i];
            // Emit: @.str.N = private unnamed_addr constant [M x i8] c"...\00"
            self.write_string(&entry.label);
            self.write(" = private unnamed_addr constant [");
            let len_str = codegen_types::format_u64(entry.length as u64);
            self.write_string(&len_str);
            self.write(" x i8] c\"");
            self.emit_string_literal_bytes(&entry.content);
            self.write("\\00\"\n");
            i = i + 1;
        }
        if self.string_table.len() > 0 {
            self.newline();
        }
    }

    /// Emits a string literal as LLVM string bytes (escaping special chars).
    fn emit_string_literal_bytes(self: &mut CodegenCtx, s: &String) {
        let bytes = s.as_bytes();
        let mut i: usize = 0;
        while i < bytes.len() {
            let b = bytes[i];
            if b == 34 {
                // Quote "
                self.write("\\22");
            } else if b == 92 {
                // Backslash
                self.write("\\5C");
            } else if b == 10 {
                // Newline
                self.write("\\0A");
            } else if b == 13 {
                // Carriage return
                self.write("\\0D");
            } else if b == 9 {
                // Tab
                self.write("\\09");
            } else if b < 32 || b > 126 {
                // Non-printable - emit as hex
                self.write("\\");
                let hex = byte_to_hex(b);
                self.write_string(&hex);
            } else {
                // Printable character
                self.output.push(b as char);
            }
            i = i + 1;
        }
    }

    // ======== LLVM IR Emission Helpers ========

    /// Emits a function definition header.
    pub fn emit_fn_header(
        self: &mut CodegenCtx,
        name: &str,
        params: &Vec<(String, String)>,
        return_ty: &str,
    ) {
        self.write("define ");
        self.write(return_ty);
        self.write(" @");
        self.write(name);
        self.write("(");

        let mut i: usize = 0;
        while i < params.len() {
            if i > 0 {
                self.write(", ");
            }
            let param = &params[i];
            self.write_string(&param.0);
            self.write(" ");
            self.write_string(&param.1);
            i = i + 1;
        }

        self.write(") {\n");
    }

    /// Emits a function definition footer.
    pub fn emit_fn_footer(self: &mut CodegenCtx) {
        self.write("}\n\n");
    }

    /// Emits a store instruction.
    pub fn emit_store(self: &mut CodegenCtx, ty: &str, val: &str, ptr: &str) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a getelementptr instruction.


    /// Emits a GEP instruction with CgName result and CgName ptr.
    pub fn emit_gep_cg(
        self: &mut CodegenCtx,
        result: &CgName,
        base_ty: &str,
        ptr: &CgName,
        indices: &Vec<String>,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = getelementptr ");
        self.write(base_ty);
        self.write(", ptr ");
        self.write_cgname(ptr);

        let mut i: usize = 0;
        while i < indices.len() {
            if i == 0 {
                self.write(", i64 ");
            } else {
                let ref idx = indices[i];
                let bytes = idx.as_bytes();
                if bytes.len() > 0 && bytes[0] == 37 {
                    self.write(", i64 ");
                } else {
                    self.write(", i32 ");
                }
            }
            self.write_string(&indices[i]);
            i = i + 1;
        }

        self.write("\n");
    }

    /// Emits a ret instruction.
    pub fn emit_ret(self: &mut CodegenCtx, ty: &str, val: Option<&str>) {
        self.write_indent();
        self.write("ret ");
        self.write(ty);
        match val {
            Option::Some(v) => {
                self.write(" ");
                self.write(v);
            }
            Option::None => {}
        }
        self.write("\n");
    }

    /// Emits a label.
    pub fn emit_label(self: &mut CodegenCtx, label: &str) {
        self.write(label);
        self.write(":\n");
    }

    /// Emits an unreachable instruction.
    pub fn emit_unreachable(self: &mut CodegenCtx) {
        self.write_indent();
        self.write("unreachable\n");
    }

    // ======== CgName-Based Emit Methods (Zero Allocation) ========

    /// Emits an alloca instruction using CgName for result.
    pub fn emit_alloca_cg(self: &mut CodegenCtx, result: &CgName, ty: &str) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = alloca ");
        self.write(ty);
        self.write("\n");
    }

    /// Emits a load instruction using CgName for result and &str for ptr.
    pub fn emit_load_cg(self: &mut CodegenCtx, result: &CgName, ty: &str, ptr: &str) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = load ");
        self.write(ty);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a load instruction using CgName for both result and ptr.
    pub fn emit_load_cg2(self: &mut CodegenCtx, result: &CgName, ty: &str, ptr: &CgName) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = load ");
        self.write(ty);
        self.write(", ptr ");
        self.write_cgname(ptr);
        self.write("\n");
    }

    /// Emits a store instruction using CgName for val.
    pub fn emit_store_cg(self: &mut CodegenCtx, ty: &str, val: &CgName, ptr: &str) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(val);
        self.write(", ptr ");
        self.write(ptr);
        self.write("\n");
    }

    /// Emits a store instruction using CgName for both val and ptr.
    pub fn emit_store_cg2(self: &mut CodegenCtx, ty: &str, val: &CgName, ptr: &CgName) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(val);
        self.write(", ptr ");
        self.write_cgname(ptr);
        self.write("\n");
    }

    /// Emits a store with &str val and CgName ptr.
    pub fn emit_store_str_cg(self: &mut CodegenCtx, ty: &str, val: &str, ptr: &CgName) {
        self.write_indent();
        self.write("store ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", ptr ");
        self.write_cgname(ptr);
        self.write("\n");
    }

    /// Emits a binary operation using CgName for result.
    pub fn emit_binop_cg(
        self: &mut CodegenCtx,
        result: &CgName,
        opcode: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits a binary operation using CgName for result and both operands.
    pub fn emit_binop_cg3(
        self: &mut CodegenCtx,
        result: &CgName,
        opcode: &str,
        ty: &str,
        left: &CgName,
        right: &CgName,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(left);
        self.write(", ");
        self.write_cgname(right);
        self.write("\n");
    }

    /// Emits an icmp instruction using CgName for result.
    pub fn emit_icmp_cg(
        self: &mut CodegenCtx,
        result: &CgName,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = icmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an icmp instruction using CgName for result and left operand.
    pub fn emit_icmp_cg2(
        self: &mut CodegenCtx,
        result: &CgName,
        cond: &str,
        ty: &str,
        left: &CgName,
        right: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = icmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits an fcmp instruction using CgName for result.
    pub fn emit_fcmp_cg(
        self: &mut CodegenCtx,
        result: &CgName,
        cond: &str,
        ty: &str,
        left: &str,
        right: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = fcmp ");
        self.write(cond);
        self.write(" ");
        self.write(ty);
        self.write(" ");
        self.write(left);
        self.write(", ");
        self.write(right);
        self.write("\n");
    }

    /// Emits a cast instruction using CgName for result.
    pub fn emit_cast_cg(
        self: &mut CodegenCtx,
        result: &CgName,
        opcode: &str,
        src_ty: &str,
        val: &str,
        tgt_ty: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(src_ty);
        self.write(" ");
        self.write(val);
        self.write(" to ");
        self.write(tgt_ty);
        self.write("\n");
    }

    /// Emits a cast with CgName result and CgName val.
    pub fn emit_cast_cg2(
        self: &mut CodegenCtx,
        result: &CgName,
        opcode: &str,
        src_ty: &str,
        val: &CgName,
        tgt_ty: &str,
    ) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = ");
        self.write(opcode);
        self.write(" ");
        self.write(src_ty);
        self.write(" ");
        self.write_cgname(val);
        self.write(" to ");
        self.write(tgt_ty);
        self.write("\n");
    }

    /// Emits a br instruction using CgName for label.
    pub fn emit_br_cg(self: &mut CodegenCtx, label: &CgName) {
        self.write_indent();
        self.write("br label %");
        self.write_cgname(label);
        self.write("\n");
    }

    /// Emits a conditional br using CgName for condition and labels.
    pub fn emit_cond_br_cg(
        self: &mut CodegenCtx,
        cond: &CgName,
        true_label: &CgName,
        false_label: &CgName,
    ) {
        self.write_indent();
        self.write("br i1 ");
        self.write_cgname(cond);
        self.write(", label %");
        self.write_cgname(true_label);
        self.write(", label %");
        self.write_cgname(false_label);
        self.write("\n");
    }

    /// Emits a conditional br with &str cond and CgName labels.
    pub fn emit_cond_br_str_cg(
        self: &mut CodegenCtx,
        cond: &str,
        true_label: &CgName,
        false_label: &CgName,
    ) {
        self.write_indent();
        self.write("br i1 ");
        self.write(cond);
        self.write(", label %");
        self.write_cgname(true_label);
        self.write(", label %");
        self.write_cgname(false_label);
        self.write("\n");
    }

    /// Emits a ret instruction using CgName for val.
    pub fn emit_ret_cg(self: &mut CodegenCtx, ty: &str, val: &CgName) {
        self.write_indent();
        self.write("ret ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(val);
        self.write("\n");
    }

    /// Emits a label using CgName.
    pub fn emit_label_cg(self: &mut CodegenCtx, label: &CgName) {
        self.write_cgname(label);
        self.write(":\n");
    }

    // ======== Call/GEP/Switch Builder APIs (Zero Allocation) ========

    /// Begins a call instruction. Follow with call_arg_* calls and end_call().
    pub fn begin_call(self: &mut CodegenCtx, result: Option<&CgName>, ret_ty: &str, func: &str) {
        self.write_indent();
        match result {
            Option::Some(r) => {
                self.write_cgname(r);
                self.write(" = ");
            }
            Option::None => {}
        }
        self.write("call ");
        self.write(ret_ty);
        self.write(" ");
        self.write(func);
        self.write("(");
    }

    /// Begins a call with &str result (for rare cases where result is already a string).
    pub fn begin_call_str(self: &mut CodegenCtx, result: Option<&str>, ret_ty: &str, func: &str) {
        self.write_indent();
        match result {
            Option::Some(r) => {
                self.write(r);
                self.write(" = ");
            }
            Option::None => {}
        }
        self.write("call ");
        self.write(ret_ty);
        self.write(" ");
        self.write(func);
        self.write("(");
    }

    /// Writes a call argument with CgName value.
    pub fn call_arg_cg(self: &mut CodegenCtx, first: bool, ty: &str, val: &CgName) {
        if !first { self.write(", "); }
        self.write(ty);
        self.write(" ");
        self.write_cgname(val);
    }

    /// Writes a call argument with &str value.
    pub fn call_arg_str(self: &mut CodegenCtx, first: bool, ty: &str, val: &str) {
        if !first { self.write(", "); }
        self.write(ty);
        self.write(" ");
        self.write(val);
    }

    /// Ends a call instruction.
    pub fn end_call(self: &mut CodegenCtx) {
        self.write(")\n");
    }

    /// Begins a GEP instruction with CgName result and ptr.
    pub fn begin_gep(self: &mut CodegenCtx, result: &CgName, base_ty: &str, ptr: &CgName) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = getelementptr ");
        self.write(base_ty);
        self.write(", ptr ");
        self.write_cgname(ptr);
    }

    /// Begins a GEP instruction with CgName result and &str ptr.
    pub fn begin_gep_str(self: &mut CodegenCtx, result: &CgName, base_ty: &str, ptr: &str) {
        self.write_indent();
        self.write_cgname(result);
        self.write(" = getelementptr ");
        self.write(base_ty);
        self.write(", ptr ");
        self.write(ptr);
    }

    /// Writes a GEP pointer offset index (first index, i64 constant).
    pub fn gep_ptr_offset(self: &mut CodegenCtx, offset: u64) {
        self.write(", i64 ");
        self.write_u64(offset);
    }

    /// Writes a GEP struct field index (i32 constant).
    pub fn gep_field(self: &mut CodegenCtx, field_idx: u32) {
        self.write(", i32 ");
        self.write_u64(field_idx as u64);
    }

    /// Writes a GEP array index from a CgName (i64 SSA value).
    pub fn gep_index_cg(self: &mut CodegenCtx, val: &CgName) {
        self.write(", i64 ");
        self.write_cgname(val);
    }

    /// Writes a GEP index from a &str value.
    pub fn gep_index_str(self: &mut CodegenCtx, ty: &str, val: &str) {
        self.write(", ");
        self.write(ty);
        self.write(" ");
        self.write(val);
    }

    /// Ends a GEP instruction.
    pub fn end_gep(self: &mut CodegenCtx) {
        self.write("\n");
    }

    /// Begins a switch instruction with CgName val and default label.
    pub fn begin_switch(self: &mut CodegenCtx, ty: &str, val: &CgName, default_label: &CgName) {
        self.write_indent();
        self.write("switch ");
        self.write(ty);
        self.write(" ");
        self.write_cgname(val);
        self.write(", label %");
        self.write_cgname(default_label);
        self.write(" [\n");
        self.indent();
    }

    /// Begins a switch with &str val and CgName default label.
    pub fn begin_switch_str(self: &mut CodegenCtx, ty: &str, val: &str, default_label: &CgName) {
        self.write_indent();
        self.write("switch ");
        self.write(ty);
        self.write(" ");
        self.write(val);
        self.write(", label %");
        self.write_cgname(default_label);
        self.write(" [\n");
        self.indent();
    }

    /// Writes a switch case with &str value and CgName label.
    pub fn switch_case(self: &mut CodegenCtx, ty: &str, case_val: &str, label: &CgName) {
        self.write_indent();
        self.write(ty);
        self.write(" ");
        self.write(case_val);
        self.write(", label %");
        self.write_cgname(label);
        self.write("\n");
    }

    /// Writes a switch case with u64 value and CgName label.
    pub fn switch_case_u64(self: &mut CodegenCtx, ty: &str, case_val: u64, label: &CgName) {
        self.write_indent();
        self.write(ty);
        self.write(" ");
        self.write_u64(case_val);
        self.write(", label %");
        self.write_cgname(label);
        self.write("\n");
    }

    /// Ends a switch instruction.
    pub fn end_switch(self: &mut CodegenCtx) {
        self.dedent();
        self.write_indent();
        self.write("]\n");
    }

    // ======== Worker Context for Parallel Codegen ========

    /// Creates an isolated worker context that clones read-only state from the parent.
    /// Worker contexts have their own string table, counters, and per-function state.
    /// Used for parallel codegen: each thread gets a worker ctx, produces IR independently,
    /// then string tables are merged back into the parent.
    pub fn create_worker_ctx(self: &CodegenCtx) -> CodegenCtx {
        // Clone def_names (read-only during codegen)
        let mut worker_def_names: Vec<DefNameEntry> = Vec::new();
        let mut worker_def_hash = hashmap::HashMapU64U32::with_capacity(self.def_names.len());
        let mut i: usize = 0;
        while i < self.def_names.len() {
            let entry = &self.def_names[i];
            worker_def_names.push(DefNameEntry::new(entry.def_id, clone_string(&entry.name)));
            worker_def_hash.insert(entry.def_id as u64, i as u32);
            i = i + 1;
        }

        // Deep-clone adt_registry (read-only during codegen, but each thread needs its own copy)
        let mut worker_adt_registry: Vec<AdtEntry> = Vec::new();
        let mut ai: usize = 0;
        while ai < self.adt_registry.len() {
            match &self.adt_registry[ai] {
                &AdtEntry::Struct(ref sl) => {
                    let mut cloned_fields: Vec<AdtFieldInfo> = Vec::new();
                    let mut fi: usize = 0;
                    while fi < sl.fields.len() {
                        let field = &sl.fields[fi];
                        cloned_fields.push(AdtFieldInfo {
                            llvm_type: clone_string(&field.llvm_type),
                            hir_type: field.hir_type,
                        });
                        fi = fi + 1;
                    }
                    worker_adt_registry.push(AdtEntry::Struct(StructLayout {
                        def_id: sl.def_id,
                        fields: cloned_fields,
                        llvm_type: clone_string(&sl.llvm_type),
                    }));
                }
                &AdtEntry::Enum(ref el) => {
                    let mut cloned_variants: Vec<VariantLayout> = Vec::new();
                    let mut vi: usize = 0;
                    while vi < el.variants.len() {
                        let variant = &el.variants[vi];
                        let mut cloned_vfields: Vec<AdtFieldInfo> = Vec::new();
                        let mut vfi: usize = 0;
                        while vfi < variant.fields.len() {
                            let vf = &variant.fields[vfi];
                            cloned_vfields.push(AdtFieldInfo {
                                llvm_type: clone_string(&vf.llvm_type),
                                hir_type: vf.hir_type,
                            });
                            vfi = vfi + 1;
                        }
                        cloned_variants.push(VariantLayout {
                            variant_idx: variant.variant_idx,
                            fields: cloned_vfields,
                            payload_llvm_type: clone_string(&variant.payload_llvm_type),
                        });
                        vi = vi + 1;
                    }
                    worker_adt_registry.push(AdtEntry::Enum(EnumLayout {
                        def_id: el.def_id,
                        discriminant_type: clone_string(&el.discriminant_type),
                        variants: cloned_variants,
                        llvm_type: clone_string(&el.llvm_type),
                        max_payload_size: el.max_payload_size,
                    }));
                }
            }
            ai = ai + 1;
        }

        let mut worker = CodegenCtx {
            output: String::new(),
            indent_level: 0,
            value_counter: 0,
            label_counter: 0,
            local_names: Vec::new(),
            local_types: Vec::new(),
            local_signedness: Vec::new(),
            local_hir_types: Vec::new(),
            region_locals: Vec::new(),
            persistent_locals: Vec::new(),
            current_fn: Option::None,
            string_table: Vec::new(),
            string_counter: 0,
            def_names: worker_def_names,
            adt_registry: worker_adt_registry,
            def_names_hash: worker_def_hash,
            local_names_hash: hashmap::HashMapU64U32::new(),
            local_types_hash: hashmap::HashMapU64U32::new(),
            local_signedness_hash: hashmap::HashMapU64U32::new(),
            local_hir_types_hash: hashmap::HashMapU64U32::new(),
            region_locals_hash: hashmap::HashMapU64U32::new(),
            persistent_locals_hash: hashmap::HashMapU64U32::new(),
            local_generations_hash: hashmap::HashMapU64U32::new(),
            local_generations: Vec::new(),
            string_table_hash: hashmap::HashMapU64U32::new(),
            static_defs_hash: hashmap::HashMapU64U32::new(),
            static_types_hash: hashmap::HashMapU64U32::new(),
            static_types: Vec::new(),
            const_defs_hash: hashmap::HashMapU64U32::new(),
            fn_signatures: Vec::new(),
            fn_sigs_hash: hashmap::HashMapU64U32::new(),
            write_buffer: String::new(),
            output_path: String::new(),
            trace_codegen: self.trace_codegen,
            call_remaps: Vec::new(),
            handler_effect_entries: Vec::new(),
            handler_effect_hash: hashmap::HashMapU64U32::new(),
            handler_state_count_hash: hashmap::HashMapU64U32::new(),
            handler_state_byte_size_hash: hashmap::HashMapU64U32::new(),
            is_handler_op: false,
            inline_stubs: Vec::new(),
            inline_stub_count: 0,
            handler_op_state_local: -1,
            handler_op_state_field_count: 0,
            handler_op_body_hash: hashmap::HashMapU64U32::new(),
            handler_op_body_ids: Vec::new(),
            op_def_index_hash: hashmap::HashMapU64U32::new(),
            op_def_index_entries: Vec::new(),
            handler_state_shadows: Vec::new(),
            codegen_errors: Vec::new(),
            codegen_warnings: Vec::new(),
            current_span: Option::None,
            fn_ptr_wrapper_hash: hashmap::HashMapU64U32::with_capacity(32),
            fn_ptr_wrapper_names: Vec::with_capacity(32),
            fn_ptr_wrapper_defs: Vec::with_capacity(32),
        };

        // Copy handler_op_body_ids with state counts (read-only, needed to flag handler op bodies)
        let mut hbi: usize = 0;
        while hbi < self.handler_op_body_ids.len() {
            let hbi_def_id = self.handler_op_body_ids[hbi];
            let hbi_state_count = self.handler_op_state_count(hbi_def_id);
            worker.register_handler_op_body(hbi_def_id, hbi_state_count);
            hbi = hbi + 1;
        }

        // Copy handler_effect_entries (read-only, needed during codegen)
        let mut hei: usize = 0;
        while hei < self.handler_effect_entries.len() {
            let he = &self.handler_effect_entries[hei];
            worker.register_handler_effect(he.handler_def_id, he.effect_def_id);
            worker.register_handler_state_count(he.handler_def_id, self.lookup_handler_state_count(he.handler_def_id));
            worker.register_handler_state_byte_size(he.handler_def_id, self.lookup_handler_state_byte_size(he.handler_def_id));
            hei = hei + 1;
        }

        // Copy op_def_index_entries (read-only, needed for Perform op_index resolution)
        let mut odi: usize = 0;
        while odi < self.op_def_index_entries.len() {
            let ode = &self.op_def_index_entries[odi];
            worker.register_op_def_index(ode.effect_def_id, ode.op_name_sym, ode.positional_index);
            odi = odi + 1;
        }

        // Copy function signatures (read-only, needed at call sites)
        let mut fi: usize = 0;
        while fi < self.fn_signatures.len() {
            let sig = &self.fn_signatures[fi];
            let mut cloned_params: Vec<String> = Vec::new();
            let mut pi: usize = 0;
            while pi < sig.param_types.len() {
                let mut p = String::new();
                p.push_str(sig.param_types[pi].as_str());
                cloned_params.push(p);
                pi = pi + 1;
            }
            let mut cloned_ret = String::new();
            cloned_ret.push_str(sig.return_type.as_str());
            worker.register_fn_signature(sig.def_id, cloned_params, cloned_ret);
            fi = fi + 1;
        }

        // Copy static and const defs hashes (read-only)
        let mut si: usize = 0;
        while si < self.def_names.len() {
            let entry = &self.def_names[si];
            if self.is_static(entry.def_id) {
                worker.register_static(entry.def_id);
                match self.get_static_type(entry.def_id) {
                    Option::Some(ty) => {
                        worker.register_static_type(entry.def_id, ty);
                    }
                    Option::None => {}
                }
            }
            if self.is_const(entry.def_id) {
                worker.register_const(entry.def_id);
            }
            si = si + 1;
        }

        worker
    }

    /// Returns the number of string constants in the string table.
    pub fn string_table_len(self: &CodegenCtx) -> usize {
        self.string_table.len()
    }

    /// Returns the content of the string constant at the given index.
    pub fn string_content_at(self: &CodegenCtx, index: usize) -> &String {
        &self.string_table[index].content
    }

    /// Returns the label of the string constant at the given index.
    pub fn string_label_at(self: &CodegenCtx, index: usize) -> &String {
        &self.string_table[index].label
    }
}

/// A string label remapping entry (from worker-local to final label).
pub struct StringRemap {
    /// The worker-local label (e.g., "@.str.0").
    pub from: String,
    /// The final label in the merged table (e.g., "@.str.42").
    pub to: String,
}

/// Merges a worker's string table into the main context's string table.
/// Returns a list of remappings (worker label -> final label) for any labels that changed.
/// String constants that already exist in the main table are deduplicated.
pub fn merge_string_tables(
    main_ctx: &mut CodegenCtx,
    worker_ctx: &CodegenCtx,
) -> Vec<StringRemap> {
    let mut remaps: Vec<StringRemap> = Vec::new();

    let mut i: usize = 0;
    while i < worker_ctx.string_table_len() {
        let content = worker_ctx.string_content_at(i);
        let worker_label = worker_ctx.string_label_at(i);

        // Add to main (deduplicates internally)
        let final_label = main_ctx.add_string_constant(content);

        // If the label changed, record the remapping
        if !string_equal(worker_label, &final_label) {
            remaps.push(StringRemap {
                from: clone_string(worker_label),
                to: final_label,
            });
        }

        i = i + 1;
    }

    remaps
}

/// Applies string label remappings to an IR string.
/// Replaces each occurrence of remap.from with remap.to.
/// Only needed when parallel codegen produces worker-local string labels.
pub fn remap_string_labels(ir: &String, remaps: &Vec<StringRemap>) -> String {
    if remaps.len() == 0 {
        return clone_string(ir);
    }

    let mut result = clone_string(ir);

    // Apply remappings. Since labels are unique (@.str.N), simple replacement is safe.
    // Process in reverse order of label number to avoid @.str.1 replacing part of @.str.10.
    let mut i: usize = remaps.len();
    while i > 0 {
        i = i - 1;
        let remap = &remaps[i];
        result = string_replace(&result, &remap.from, &remap.to);
    }

    result
}

/// Replaces all occurrences of `from` with `to` in `s`.
fn string_replace(s: &String, from: &String, to: &String) -> String {
    let s_bytes = s.as_bytes();
    let from_bytes = from.as_bytes();
    let to_bytes = to.as_bytes();
    let s_len = s_bytes.len();
    let from_len = from_bytes.len();

    if from_len == 0 || from_len > s_len {
        return clone_string(s);
    }

    let mut result = String::new();
    let mut i: usize = 0;

    while i < s_len {
        // Check if `from` starts at position i
        if i + from_len <= s_len {
            let mut matches = true;
            let mut j: usize = 0;
            while j < from_len {
                if s_bytes[i + j] != from_bytes[j] {
                    matches = false;
                    j = from_len; // break
                }
                j = j + 1;
            }
            if matches {
                // Append replacement
                let mut k: usize = 0;
                while k < to_bytes.len() {
                    result.push(to_bytes[k] as char);
                    k = k + 1;
                }
                i = i + from_len;
                continue;
            }
        }
        result.push(s_bytes[i] as char);
        i = i + 1;
    }

    result
}

// ============================================================
// String Helpers
// ============================================================

/// Clones a CodegenErrorKind.
pub fn clone_error_kind(kind: &CodegenErrorKind) -> CodegenErrorKind {
    match kind {
        &CodegenErrorKind::AdtLookupFailed => CodegenErrorKind::AdtLookupFailed,
        &CodegenErrorKind::FnLookupFailed => CodegenErrorKind::FnLookupFailed,
        &CodegenErrorKind::StaticLookupFailed => CodegenErrorKind::StaticLookupFailed,
        &CodegenErrorKind::TypeSubstitutionFailed => CodegenErrorKind::TypeSubstitutionFailed,
        &CodegenErrorKind::VariantLookupFailed => CodegenErrorKind::VariantLookupFailed,
        &CodegenErrorKind::EffectOpLookupFailed => CodegenErrorKind::EffectOpLookupFailed,
        &CodegenErrorKind::UnsupportedOperation => CodegenErrorKind::UnsupportedOperation,
        &CodegenErrorKind::TypeParseFailed => CodegenErrorKind::TypeParseFailed,
        &CodegenErrorKind::InternalError => CodegenErrorKind::InternalError,
    }
}

/// Converts a CodegenErrorKind to a human-readable category string.
pub fn error_kind_label(kind: &CodegenErrorKind) -> &str {
    match kind {
        &CodegenErrorKind::AdtLookupFailed => "ADT lookup failed",
        &CodegenErrorKind::FnLookupFailed => "function lookup failed",
        &CodegenErrorKind::StaticLookupFailed => "static lookup failed",
        &CodegenErrorKind::TypeSubstitutionFailed => "type substitution failed",
        &CodegenErrorKind::VariantLookupFailed => "variant lookup failed",
        &CodegenErrorKind::EffectOpLookupFailed => "effect operation lookup failed",
        &CodegenErrorKind::UnsupportedOperation => "unsupported operation",
        &CodegenErrorKind::TypeParseFailed => "type parse failed",
        &CodegenErrorKind::InternalError => "internal codegen error",
    }
}

/// Returns the error code string for a CodegenErrorKind.
pub fn error_kind_code(kind: &CodegenErrorKind) -> &str {
    match kind {
        &CodegenErrorKind::AdtLookupFailed => "E0800",
        &CodegenErrorKind::FnLookupFailed => "E0801",
        &CodegenErrorKind::StaticLookupFailed => "E0802",
        &CodegenErrorKind::TypeSubstitutionFailed => "E0803",
        &CodegenErrorKind::VariantLookupFailed => "E0804",
        &CodegenErrorKind::EffectOpLookupFailed => "E0805",
        &CodegenErrorKind::UnsupportedOperation => "E0806",
        &CodegenErrorKind::TypeParseFailed => "E0807",
        &CodegenErrorKind::InternalError => "E0808",
    }
}

/// Clones a String.
fn clone_string(s: &String) -> String {
    let mut result = String::new();
    result.push_str(s.as_str());
    result
}

/// Compares two strings for equality.
fn string_equal(a: &String, b: &String) -> bool {
    let a_bytes = a.as_bytes();
    let b_bytes = b.as_bytes();
    if a_bytes.len() != b_bytes.len() {
        return false;
    }
    let mut i: usize = 0;
    while i < a_bytes.len() {
        if a_bytes[i] != b_bytes[i] {
            return false;
        }
        i = i + 1;
    }
    true
}

/// Converts a byte to a two-character hex string.
fn byte_to_hex(b: u8) -> String {
    let mut result = String::new();
    let high = (b >> 4) & 0xF;
    let low = b & 0xF;
    result.push(nibble_to_hex(high));
    result.push(nibble_to_hex(low));
    result
}

/// Converts a nibble (0-15) to a hex character.
fn nibble_to_hex(n: u8) -> char {
    if n < 10 {
        (48u8 + n) as char
    } else {
        (55u8 + n) as char
    }
}
