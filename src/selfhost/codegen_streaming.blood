// Blood Self-Hosted Compiler - Streaming Code Generator
//
// This module provides streaming codegen functions that write LLVM IR
// to disk one function at a time, avoiding OOM on large programs.
// Blood has no destructors, so without streaming the memory grows unbounded.

mod common;
mod hir_def;
mod hir_ty;
mod hir_item;
mod hir_lower_ctx;
mod mir_def;
mod mir_types;
mod mir_stmt;
mod mir_term;
mod mir_body;
mod codegen_types;
mod codegen_ctx;
mod codegen_expr;
mod codegen_stmt;
mod codegen_term;
mod codegen;
mod interner;
mod type_intern;

// ============================================================
// Streaming Code Generation
// ============================================================

/// Begins streaming module generation by writing the module header to a file.
/// Returns a CodegenCtx that the caller uses for per-function generation.
/// The caller must register def_names and call generate_function_to_file for each body,
/// then call finish_streaming_module to write trailing declarations.
pub fn begin_streaming_module(
    module_name: &str,
    output_path: &str,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) -> codegen_ctx::CodegenCtx {
    let mut ctx = codegen_ctx::CodegenCtx::new();

    // NOTE: ADT registry population is done by the caller after registering
    // builtin ADTs (Vec, String, HashMap, Box). This ensures builtins are
    // available during populate_adt_registry so Box<T> resolves to "ptr"
    // instead of being expanded as { i8, [sizeof(T) x i8] }.

    // Build module header
    let mut header = String::new();
    header.push_str("; ModuleID = '");
    header.push_str(module_name);
    header.push_str("'\n");
    header.push_str("source_filename = \"");
    header.push_str(module_name);
    header.push_str(".blood\"\n");
    header.push_str("target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128\"\n");
    header.push_str("target triple = \"x86_64-unknown-linux-gnu\"\n");
    header.push_str("\n");

    // Write header to file (overwrite/create) and store path for buffered writes
    file_write_string(output_path, header.as_str());
    ctx.set_output_path(output_path);

    ctx
}

/// Generates LLVM IR for a single function and buffers it for batched file I/O.
/// Returns true on success.
pub fn generate_function_to_file(
    ctx: &mut codegen_ctx::CodegenCtx,
    body: &mir_body::MirBody,
    fn_name: &str,
) -> bool {
    // Generate the function IR using the shared codegen logic
    let fn_ir = codegen::generate_function_with_ctx(ctx, body, fn_name);

    // Buffer the function IR (auto-flushes at 64KB)
    ctx.buffer_write(fn_ir.as_str());

    true
}

/// Finishes streaming module generation by buffering string constants and declarations,
/// then flushing the write buffer to disk.
/// Returns true on success.
pub fn finish_streaming_module(
    ctx: &mut codegen_ctx::CodegenCtx,
) -> bool {
    // Emit string constants into ctx.output, then copy to avoid aliased borrow
    ctx.output = String::new();
    ctx.emit_string_constants();
    let constants_ir = codegen_stmt::clone_string(&ctx.output);
    ctx.buffer_write(constants_ir.as_str());

    // Emit intrinsic declarations
    let decls = codegen::intrinsic_declarations();
    ctx.buffer_write(decls.as_str());

    true
}

/// Emits LLVM global variable declarations for static items with proper names.
/// Should be called after begin_streaming_module but before generating functions.
/// Uses the interner to get the actual static variable names.
pub fn emit_static_globals_with_names(
    ctx: &mut codegen_ctx::CodegenCtx,
    interner: &interner::StringInterner,
    items: &Vec<hir_lower_ctx::ItemEntry>,
) {
    let mut output = String::new();
    output.push_str("\n; Static global variables\n");

    for i in 0usize..items.len() {
        let item = &items[i].item;
        match &item.kind {
            &hir_item::ItemKind::Static(ref static_def) => {
                // Get mangled name for the static using the actual symbol name
                // Convention: names are stored WITHOUT @ prefix, @ is added when emitting
                let mut name = String::new();
                name.push_str("def");
                push_u32(&mut name, item.def_id.index);
                name.push('_');
                // Get the actual name from the interner
                match interner.resolve(item.name.symbol) {
                    Option::Some(symbol_name) => {
                        name.push_str(symbol_name.as_str());
                    }
                    Option::None => {
                        name.push_str("STATIC");
                    }
                }

                // Get LLVM type for the static's type (use codegen_stmt for generic arg handling)
                let static_hir_ty = type_intern::ty_id_to_type(static_def.ty);
                let llvm_type = codegen_stmt::type_to_llvm_with_ctx(ctx, &static_hir_ty);

                // Emit global variable declaration
                // Format: @name = global <type> zeroinitializer
                output.push('@');
                output.push_str(name.as_str());
                output.push_str(" = global ");
                output.push_str(llvm_type.as_str());
                output.push_str(" zeroinitializer\n");

                // Register the static's name (without @), mark it as static, and store its LLVM type
                ctx.register_def_name(item.def_id.index, name);
                ctx.register_static(item.def_id.index);
                ctx.register_static_type(item.def_id.index, llvm_type);
            }
            &hir_item::ItemKind::Const(ref _const_def) => {
                // Mark this DefId as a const item so codegen can call its body function
                // (instead of treating it as a function pointer reference)
                ctx.register_const(item.def_id.index);
            }
            _ => {}
        }
    }

    output.push('\n');
    ctx.buffer_write(output.as_str());
}

/// Helper to push u32 as decimal string.
fn push_u32(s: &mut String, val: u32) {
    if val == 0 {
        s.push('0');
        return;
    }
    let mut digits: Vec<u8> = Vec::new();
    let mut n = val;
    while n > 0 {
        digits.push((n % 10) as u8);
        n /= 10;
    }
    let mut j: usize = digits.len();
    while j > 0 {
        j -= 1;
        s.push((48 + (digits[j] as i32)) as char);
    }
}
