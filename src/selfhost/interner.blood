// Blood Self-Hosted Compiler - String Interner
//
// This module provides string interning for identifiers and symbols.
// Interning ensures that identical strings share the same storage and
// can be compared efficiently via their indices.
//
// PERFORMANCE: Uses HashMap for O(1) average-case lookup instead of O(n) linear scan.

mod common;
mod hashmap;

// ============================================================
// String Interner
// ============================================================

/// A string interner that maps strings to unique indices.
///
/// The interner stores strings and returns `Symbol` indices that can be
/// used for efficient comparison and storage. Each unique string is only
/// stored once.
///
/// Uses a hash map for O(1) average-case lookup instead of O(n) linear scan.
pub struct StringInterner {
    /// Storage for interned strings (symbol index → string).
    strings: Vec<String>,
    /// Hash-based reverse lookup (string hash → symbol index).
    /// Multiple strings may hash to the same value; we verify with str_equals.
    hash_index: hashmap.HashMapU64U32,
}

impl StringInterner {
    /// Creates a new empty string interner.
    pub fn new() -> StringInterner {
        let mut interner = StringInterner {
            strings: Vec.new(),
            hash_index: hashmap.HashMapU64U32.with_capacity(256),
        };
        // Pre-intern common strings at known indices
        interner.intern_keywords();
        interner
    }

    /// Interns common keywords at fixed indices for fast lookup.
    fn intern_keywords(self: &mut StringInterner) {
        // Keywords - indices 0-39
        self.strings.push(common.make_string(""));          // 0: empty string
        self.strings.push(common.make_string("fn"));        // 1
        self.strings.push(common.make_string("let"));       // 2
        self.strings.push(common.make_string("mut"));       // 3
        self.strings.push(common.make_string("if"));        // 4
        self.strings.push(common.make_string("else"));      // 5
        self.strings.push(common.make_string("while"));     // 6
        self.strings.push(common.make_string("for"));       // 7
        self.strings.push(common.make_string("in"));        // 8
        self.strings.push(common.make_string("return"));    // 9
        self.strings.push(common.make_string("break"));     // 10
        self.strings.push(common.make_string("continue"));  // 11
        self.strings.push(common.make_string("match"));     // 12
        self.strings.push(common.make_string("struct"));    // 13
        self.strings.push(common.make_string("enum"));      // 14
        self.strings.push(common.make_string("impl"));      // 15
        self.strings.push(common.make_string("trait"));     // 16
        self.strings.push(common.make_string("type"));      // 17
        self.strings.push(common.make_string("pub"));       // 18
        self.strings.push(common.make_string("self"));      // 19
        self.strings.push(common.make_string("Self"));      // 20
        self.strings.push(common.make_string("true"));      // 21
        self.strings.push(common.make_string("false"));     // 22
        self.strings.push(common.make_string("mod"));       // 23
        self.strings.push(common.make_string("use"));       // 24
        self.strings.push(common.make_string("as"));        // 25
        self.strings.push(common.make_string("const"));     // 26
        self.strings.push(common.make_string("static"));    // 27
        self.strings.push(common.make_string("unsafe"));    // 28
        self.strings.push(common.make_string("extern"));    // 29
        self.strings.push(common.make_string("where"));     // 30
        self.strings.push(common.make_string("loop"));      // 31
        self.strings.push(common.make_string("fiber"));     // 32
        self.strings.push(common.make_string("suspend"));   // 33
        self.strings.push(common.make_string("effect"));    // 34
        self.strings.push(common.make_string("handler"));   // 35
        self.strings.push(common.make_string("perform"));   // 36
        self.strings.push(common.make_string("resume"));    // 37
        self.strings.push(common.make_string("with"));      // 38
        self.strings.push(common.make_string("module"));    // 39

        // Special identifiers - index 40
        self.strings.push(common.make_string("main"));       // 40

        // Primitive types - indices 41-57
        self.strings.push(common.make_string("bool"));       // 41
        self.strings.push(common.make_string("i8"));         // 42
        self.strings.push(common.make_string("i16"));        // 43
        self.strings.push(common.make_string("i32"));        // 44
        self.strings.push(common.make_string("i64"));        // 45
        self.strings.push(common.make_string("i128"));       // 46
        self.strings.push(common.make_string("isize"));      // 47
        self.strings.push(common.make_string("u8"));         // 48
        self.strings.push(common.make_string("u16"));        // 49
        self.strings.push(common.make_string("u32"));        // 50
        self.strings.push(common.make_string("u64"));        // 51
        self.strings.push(common.make_string("u128"));       // 52
        self.strings.push(common.make_string("usize"));      // 53
        self.strings.push(common.make_string("f32"));        // 54
        self.strings.push(common.make_string("f64"));        // 55
        self.strings.push(common.make_string("char"));       // 56
        self.strings.push(common.make_string("str"));        // 57

        // Builtin method names - indices 58-82
        // These must be pre-interned so all module-local interner instances
        // share the same Symbol indices for method names used by the type checker.
        self.strings.push(common.make_string("len"));          // 58
        self.strings.push(common.make_string("is_empty"));     // 59
        self.strings.push(common.make_string("push_str"));     // 60
        self.strings.push(common.make_string("push"));         // 61
        self.strings.push(common.make_string("as_str"));       // 62
        self.strings.push(common.make_string("clone"));        // 63
        self.strings.push(common.make_string("contains"));     // 64
        self.strings.push(common.make_string("starts_with"));  // 65
        self.strings.push(common.make_string("ends_with"));    // 66
        self.strings.push(common.make_string("as_bytes"));     // 67
        self.strings.push(common.make_string("pop"));          // 68
        self.strings.push(common.make_string("get"));          // 69
        self.strings.push(common.make_string("last"));         // 70
        self.strings.push(common.make_string("clear"));        // 71
        self.strings.push(common.make_string("remove"));       // 72
        self.strings.push(common.make_string("insert"));       // 73
        self.strings.push(common.make_string("is_some"));      // 74
        self.strings.push(common.make_string("is_none"));      // 75
        self.strings.push(common.make_string("unwrap"));       // 76
        self.strings.push(common.make_string("unwrap_or"));    // 77
        self.strings.push(common.make_string("expect"));       // 78
        self.strings.push(common.make_string("as_ref"));       // 79
        self.strings.push(common.make_string("contains_key")); // 80
        self.strings.push(common.make_string("is_ok"));        // 81
        self.strings.push(common.make_string("is_err"));       // 82

        // Builtin type/variant names - indices 83-88
        // Used by register_builtin_enums for Option and Result registration.
        self.strings.push(common.make_string("Option"));       // 83
        self.strings.push(common.make_string("Some"));         // 84
        self.strings.push(common.make_string("None"));         // 85
        self.strings.push(common.make_string("Result"));       // 86
        self.strings.push(common.make_string("Ok"));           // 87
        self.strings.push(common.make_string("Err"));          // 88

        // Populate hash index for all pre-interned strings
        for i in 0usize..self.strings.len() {
            let hash = hashmap.hash_string(&self.strings[i]);
            self.hash_index.insert(hash, i as u32);
        }
    }

    /// Interns a string, returning its symbol index.
    ///
    /// If the string is already interned, returns the existing index.
    /// Otherwise, adds the string and returns a new index.
    ///
    /// Uses hash-based lookup for O(1) average case instead of O(n) linear scan.
    pub fn intern(self: &mut StringInterner, s: &str) -> common.Symbol {
        let hash = hashmap.hash_str(s);

        // Fast path: check hash index for existing entry
        match self.hash_index.get(hash) {
            Option.Some(idx) => {
                // Found a candidate - verify it's the same string (handle collisions)
                if str_equals(&self.strings[idx as usize], s) {
                    return common.Symbol.new(idx);
                }
                // Hash collision - fall through to linear scan for this rare case
            }
            Option.None => {
                // Not in hash index - definitely new, add it
                let index = self.strings.len() as u32;
                self.strings.push(common.make_string(s));
                self.hash_index.insert(hash, index);
                return common.Symbol.new(index);
            }
        }

        // Hash collision case: linear scan to find or add
        // This is rare with good hash function
        for i in 0usize..self.strings.len() {
            if str_equals(&self.strings[i], s) {
                return common.Symbol.new(i as u32);
            }
        }

        // Not found, add new string (collision case - hash already in use)
        let index = self.strings.len() as u32;
        self.strings.push(common.make_string(s));
        // Note: We don't overwrite the hash_index entry since another string has this hash
        common.Symbol.new(index)
    }

    /// Interns a String, returning its symbol index.
    pub fn intern_string(self: &mut StringInterner, s: &String) -> common.Symbol {
        self.intern(s.as_str())
    }

    /// Resolves a symbol back to its string.
    ///
    /// Returns None if the symbol index is out of bounds.
    pub fn resolve(self: &StringInterner, symbol: common.Symbol) -> Option<&String> {
        let index = symbol.index as usize;
        if index < self.strings.len() {
            Option.Some(&self.strings[index])
        } else {
            Option.None
        }
    }

    /// Resolves a symbol, returning an empty string if not found.
    pub fn resolve_or_empty(self: &StringInterner, symbol: common.Symbol) -> &String {
        match self.resolve(symbol) {
            Option.Some(s) => s,
            Option.None => &self.strings[0], // Empty string at index 0
        }
    }

    /// Returns the number of interned strings.
    pub fn len(self: &StringInterner) -> usize {
        self.strings.len()
    }

    /// Checks if the interner is empty.
    pub fn is_empty(self: &StringInterner) -> bool {
        self.strings.len() == 0
    }

    /// Finds a string that was previously interned.
    /// Returns the Symbol if found, None if not found.
    /// Unlike intern(), this does not modify the interner.
    ///
    /// Uses hash-based lookup for O(1) average case.
    pub fn find(self: &StringInterner, s: &str) -> Option<common.Symbol> {
        let hash = hashmap.hash_str(s);

        // Fast path: check hash index
        match self.hash_index.get(hash) {
            Option.Some(idx) => {
                // Verify it's the same string (handle collisions)
                if str_equals(&self.strings[idx as usize], s) {
                    return Option.Some(common.Symbol.new(idx));
                }
                // Hash collision - fall through to linear scan
            }
            Option.None => {
                return Option.None;
            }
        }

        // Hash collision case: linear scan
        for i in 0usize..self.strings.len() {
            if str_equals(&self.strings[i], s) {
                return Option.Some(common.Symbol.new(i as u32));
            }
        }
        Option.None
    }

    /// Gets the string at a specific index (for debugging).
    pub fn get(self: &StringInterner, index: u32) -> Option<&String> {
        let idx = index as usize;
        if idx < self.strings.len() {
            Option.Some(&self.strings[idx])
        } else {
            Option.None
        }
    }
}

// ============================================================
// Keyword Symbol Constants
// ============================================================

/// Well-known symbol indices for keywords.
/// These match the order in intern_keywords().
pub struct Keywords {}

impl Keywords {
    pub fn empty() -> common.Symbol { common.Symbol.new(0) }
    pub fn fn_kw() -> common.Symbol { common.Symbol.new(1) }
    pub fn let_kw() -> common.Symbol { common.Symbol.new(2) }
    pub fn mut_kw() -> common.Symbol { common.Symbol.new(3) }
    pub fn if_kw() -> common.Symbol { common.Symbol.new(4) }
    pub fn else_kw() -> common.Symbol { common.Symbol.new(5) }
    pub fn while_kw() -> common.Symbol { common.Symbol.new(6) }
    pub fn for_kw() -> common.Symbol { common.Symbol.new(7) }
    pub fn in_kw() -> common.Symbol { common.Symbol.new(8) }
    pub fn return_kw() -> common.Symbol { common.Symbol.new(9) }
    pub fn break_kw() -> common.Symbol { common.Symbol.new(10) }
    pub fn continue_kw() -> common.Symbol { common.Symbol.new(11) }
    pub fn match_kw() -> common.Symbol { common.Symbol.new(12) }
    pub fn struct_kw() -> common.Symbol { common.Symbol.new(13) }
    pub fn enum_kw() -> common.Symbol { common.Symbol.new(14) }
    pub fn impl_kw() -> common.Symbol { common.Symbol.new(15) }
    pub fn trait_kw() -> common.Symbol { common.Symbol.new(16) }
    pub fn type_kw() -> common.Symbol { common.Symbol.new(17) }
    pub fn pub_kw() -> common.Symbol { common.Symbol.new(18) }
    pub fn self_kw() -> common.Symbol { common.Symbol.new(19) }
    pub fn self_ty() -> common.Symbol { common.Symbol.new(20) }
    pub fn true_kw() -> common.Symbol { common.Symbol.new(21) }
    pub fn false_kw() -> common.Symbol { common.Symbol.new(22) }
    pub fn mod_kw() -> common.Symbol { common.Symbol.new(23) }
    pub fn use_kw() -> common.Symbol { common.Symbol.new(24) }
    pub fn as_kw() -> common.Symbol { common.Symbol.new(25) }
    pub fn const_kw() -> common.Symbol { common.Symbol.new(26) }
    pub fn static_kw() -> common.Symbol { common.Symbol.new(27) }
    pub fn unsafe_kw() -> common.Symbol { common.Symbol.new(28) }
    pub fn extern_kw() -> common.Symbol { common.Symbol.new(29) }
    pub fn where_kw() -> common.Symbol { common.Symbol.new(30) }
    pub fn loop_kw() -> common.Symbol { common.Symbol.new(31) }
    pub fn fiber_kw() -> common.Symbol { common.Symbol.new(32) }
    pub fn suspend_kw() -> common.Symbol { common.Symbol.new(33) }
    pub fn effect_kw() -> common.Symbol { common.Symbol.new(34) }
    pub fn handler_kw() -> common.Symbol { common.Symbol.new(35) }
    pub fn perform_kw() -> common.Symbol { common.Symbol.new(36) }
    pub fn resume_kw() -> common.Symbol { common.Symbol.new(37) }
    pub fn with_kw() -> common.Symbol { common.Symbol.new(38) }
    pub fn module_kw() -> common.Symbol { common.Symbol.new(39) }
}

// ============================================================
// Special Identifier Symbol Constants
// ============================================================

/// Well-known symbol indices for special identifiers.
pub struct SpecialIdents {}

impl SpecialIdents {
    /// Symbol for "main" - the entry point function.
    pub fn main_sym() -> common.Symbol { common.Symbol.new(40) }
}

// ============================================================
// Primitive Type Symbol Constants
// ============================================================

/// Well-known symbol indices for primitive type names.
/// These match the order in intern_keywords() after special identifiers.
pub struct Primitives {}

impl Primitives {
    pub fn bool_sym() -> common.Symbol { common.Symbol.new(41) }
    pub fn i8_sym() -> common.Symbol { common.Symbol.new(42) }
    pub fn i16_sym() -> common.Symbol { common.Symbol.new(43) }
    pub fn i32_sym() -> common.Symbol { common.Symbol.new(44) }
    pub fn i64_sym() -> common.Symbol { common.Symbol.new(45) }
    pub fn i128_sym() -> common.Symbol { common.Symbol.new(46) }
    pub fn isize_sym() -> common.Symbol { common.Symbol.new(47) }
    pub fn u8_sym() -> common.Symbol { common.Symbol.new(48) }
    pub fn u16_sym() -> common.Symbol { common.Symbol.new(49) }
    pub fn u32_sym() -> common.Symbol { common.Symbol.new(50) }
    pub fn u64_sym() -> common.Symbol { common.Symbol.new(51) }
    pub fn u128_sym() -> common.Symbol { common.Symbol.new(52) }
    pub fn usize_sym() -> common.Symbol { common.Symbol.new(53) }
    pub fn f32_sym() -> common.Symbol { common.Symbol.new(54) }
    pub fn f64_sym() -> common.Symbol { common.Symbol.new(55) }
    pub fn char_sym() -> common.Symbol { common.Symbol.new(56) }
    pub fn str_sym() -> common.Symbol { common.Symbol.new(57) }

    /// Checks if a symbol is a primitive type name.
    /// Returns true if the symbol index is in the primitive range (41-57).
    pub fn is_primitive(sym: common.Symbol) -> bool {
        sym.index >= 41 && sym.index <= 57
    }
}

// ============================================================
// Builtin Method Symbol Constants
// ============================================================

/// Well-known symbol indices for builtin method names.
/// These match the order in intern_keywords() after primitive types.
pub struct BuiltinMethods {}

impl BuiltinMethods {
    pub fn len_sym() -> common.Symbol { common.Symbol.new(58) }
    pub fn is_empty_sym() -> common.Symbol { common.Symbol.new(59) }
    pub fn push_str_sym() -> common.Symbol { common.Symbol.new(60) }
    pub fn push_sym() -> common.Symbol { common.Symbol.new(61) }
    pub fn as_str_sym() -> common.Symbol { common.Symbol.new(62) }
    pub fn clone_sym() -> common.Symbol { common.Symbol.new(63) }
    pub fn contains_sym() -> common.Symbol { common.Symbol.new(64) }
    pub fn starts_with_sym() -> common.Symbol { common.Symbol.new(65) }
    pub fn ends_with_sym() -> common.Symbol { common.Symbol.new(66) }
    pub fn as_bytes_sym() -> common.Symbol { common.Symbol.new(67) }
    pub fn pop_sym() -> common.Symbol { common.Symbol.new(68) }
    pub fn get_sym() -> common.Symbol { common.Symbol.new(69) }
    pub fn last_sym() -> common.Symbol { common.Symbol.new(70) }
    pub fn clear_sym() -> common.Symbol { common.Symbol.new(71) }
    pub fn remove_sym() -> common.Symbol { common.Symbol.new(72) }
    pub fn insert_sym() -> common.Symbol { common.Symbol.new(73) }
    pub fn is_some_sym() -> common.Symbol { common.Symbol.new(74) }
    pub fn is_none_sym() -> common.Symbol { common.Symbol.new(75) }
    pub fn unwrap_sym() -> common.Symbol { common.Symbol.new(76) }
    pub fn unwrap_or_sym() -> common.Symbol { common.Symbol.new(77) }
    pub fn expect_sym() -> common.Symbol { common.Symbol.new(78) }
    pub fn as_ref_sym() -> common.Symbol { common.Symbol.new(79) }
    pub fn contains_key_sym() -> common.Symbol { common.Symbol.new(80) }
    pub fn is_ok_sym() -> common.Symbol { common.Symbol.new(81) }
    pub fn is_err_sym() -> common.Symbol { common.Symbol.new(82) }
}

// ============================================================
// Global Interner (Thread-Local Singleton Pattern)
// ============================================================

/// Global interner instance.
/// In a multi-threaded context, this would need synchronization.
static mut GLOBAL_INTERNER: Option<StringInterner> = Option.None;

/// Initializes the global interner.
/// Must be called before any interning operations.
pub fn init_global_interner() {
    @unsafe {
        GLOBAL_INTERNER = Option.Some(StringInterner.new());
    }
}

/// Gets a mutable reference to the global interner.
/// Panics if the interner hasn't been initialized.
pub fn global_interner() -> &mut StringInterner {
    @unsafe {
        match &mut GLOBAL_INTERNER {
            &mut Option.Some(ref mut interner) => interner,
            &mut Option.None => {
                // Auto-initialize if not done
                GLOBAL_INTERNER = Option.Some(StringInterner.new());
                match &mut GLOBAL_INTERNER {
                    &mut Option.Some(ref mut interner) => interner,
                    &mut Option.None => {
                        // This should never happen
                        panic("Global interner initialization failed");
                    }
                }
            }
        }
    }
}

/// Interns a string using the global interner.
pub fn intern(s: &str) -> common.Symbol {
    global_interner().intern(s)
}

/// Resolves a symbol using the global interner.
pub fn resolve(symbol: common.Symbol) -> Option<&String> {
    // Note: This is unsafe due to static mut, but necessary for global access
    @unsafe {
        match &GLOBAL_INTERNER {
            &Option.Some(ref interner) => interner.resolve(symbol),
            &Option.None => Option.None,
        }
    }
}

// ============================================================
// Helper Functions
// ============================================================

/// Compares a String with a &str for equality.
fn str_equals(s: &String, other: &str) -> bool {
    let bytes = s.as_bytes();
    let other_bytes = other.as_bytes();

    if bytes.len() != other_bytes.len() {
        return false;
    }

    for i in 0usize..bytes.len() {
        if bytes[i] != other_bytes[i] {
            return false;
        }
    }

    true
}

