// N-Body Benchmark - CLBG Compliant (Array-Based)
// =================================================
//
// Computer Language Benchmarks Game n-body benchmark.
// https://benchmarksgame-team.pages.debian.net/benchmarksgame/
//
// This implementation uses the SAME ALGORITHM as the C reference:
// - Array of 5 body structs
// - Nested loops for pairwise interactions
// - Array indexing via ptr_read_f64/ptr_write_f64
//
// This ensures a fair performance comparison.
//
// CLBG Standard: 50,000,000 iterations
//
// Expected output (must match C reference):
//   -0.169075164
//   -0.169059907

const PI: f64 = 3.141592653589793;
const SOLAR_MASS: f64 = 39.478417604357434;  // 4 * PI * PI
const DAYS_PER_YEAR: f64 = 365.24;
const NBODIES: i32 = 5;

// Body struct layout (56 bytes):
//   offset 0:  x (f64)
//   offset 8:  y (f64)
//   offset 16: z (f64)
//   offset 24: vx (f64)
//   offset 32: vy (f64)
//   offset 40: vz (f64)
//   offset 48: mass (f64)
const BODY_SIZE: u64 = 56;

// Field offsets
const OFF_X: u64 = 0;
const OFF_Y: u64 = 8;
const OFF_Z: u64 = 16;
const OFF_VX: u64 = 24;
const OFF_VY: u64 = 32;
const OFF_VZ: u64 = 40;
const OFF_MASS: u64 = 48;

// Get pointer to body i in array
fn body_ptr(bodies: u64, i: i32) -> u64 {
    bodies + (i as u64) * BODY_SIZE
}

// Field accessors
fn get_x(b: u64) -> f64 { ptr_read_f64(b + OFF_X) }
fn get_y(b: u64) -> f64 { ptr_read_f64(b + OFF_Y) }
fn get_z(b: u64) -> f64 { ptr_read_f64(b + OFF_Z) }
fn get_vx(b: u64) -> f64 { ptr_read_f64(b + OFF_VX) }
fn get_vy(b: u64) -> f64 { ptr_read_f64(b + OFF_VY) }
fn get_vz(b: u64) -> f64 { ptr_read_f64(b + OFF_VZ) }
fn get_mass(b: u64) -> f64 { ptr_read_f64(b + OFF_MASS) }

fn set_x(b: u64, v: f64) { ptr_write_f64(b + OFF_X, v); }
fn set_y(b: u64, v: f64) { ptr_write_f64(b + OFF_Y, v); }
fn set_z(b: u64, v: f64) { ptr_write_f64(b + OFF_Z, v); }
fn set_vx(b: u64, v: f64) { ptr_write_f64(b + OFF_VX, v); }
fn set_vy(b: u64, v: f64) { ptr_write_f64(b + OFF_VY, v); }
fn set_vz(b: u64, v: f64) { ptr_write_f64(b + OFF_VZ, v); }
fn set_mass(b: u64, v: f64) { ptr_write_f64(b + OFF_MASS, v); }

// Initialize a body with given values
fn init_body(b: u64, x: f64, y: f64, z: f64, vx: f64, vy: f64, vz: f64, mass: f64) {
    set_x(b, x);
    set_y(b, y);
    set_z(b, z);
    set_vx(b, vx);
    set_vy(b, vy);
    set_vz(b, vz);
    set_mass(b, mass);
}

// Initialize all bodies (matches C init_bodies)
fn init_bodies(bodies: u64) {
    // Sun (body 0)
    init_body(body_ptr(bodies, 0),
        0.0, 0.0, 0.0,
        0.0, 0.0, 0.0,
        SOLAR_MASS);

    // Jupiter (body 1)
    init_body(body_ptr(bodies, 1),
        4.84143144246472090e+00,
        -1.16032004402742839e+00,
        -1.03622044471123109e-01,
        1.66007664274403694e-03 * DAYS_PER_YEAR,
        7.69901118419740425e-03 * DAYS_PER_YEAR,
        -6.90460016972063023e-05 * DAYS_PER_YEAR,
        9.54791938424326609e-04 * SOLAR_MASS);

    // Saturn (body 2)
    init_body(body_ptr(bodies, 2),
        8.34336671824457987e+00,
        4.12479856412430479e+00,
        -4.03523417114321381e-01,
        -2.76742510726862411e-03 * DAYS_PER_YEAR,
        4.99852801234917238e-03 * DAYS_PER_YEAR,
        2.30417297573763929e-05 * DAYS_PER_YEAR,
        2.85885980666130812e-04 * SOLAR_MASS);

    // Uranus (body 3)
    init_body(body_ptr(bodies, 3),
        1.28943695621391310e+01,
        -1.51111514016986312e+01,
        -2.23307578892655734e-01,
        2.96460137564761618e-03 * DAYS_PER_YEAR,
        2.37847173959480950e-03 * DAYS_PER_YEAR,
        -2.96589568540237556e-05 * DAYS_PER_YEAR,
        4.36624404335156298e-05 * SOLAR_MASS);

    // Neptune (body 4)
    init_body(body_ptr(bodies, 4),
        1.53796971148509165e+01,
        -2.59193146099879641e+01,
        1.79258772950371181e-01,
        2.68067772490389322e-03 * DAYS_PER_YEAR,
        1.62824170038242295e-03 * DAYS_PER_YEAR,
        -9.51592254519715870e-05 * DAYS_PER_YEAR,
        5.15138902046611451e-05 * SOLAR_MASS);
}

// Offset momentum (matches C offset_momentum)
fn offset_momentum(bodies: u64) {
    let mut px: f64 = 0.0;
    let mut py: f64 = 0.0;
    let mut pz: f64 = 0.0;

    let mut i = 0;
    while i < NBODIES {
        let b = body_ptr(bodies, i);
        px = px + get_vx(b) * get_mass(b);
        py = py + get_vy(b) * get_mass(b);
        pz = pz + get_vz(b) * get_mass(b);
        i = i + 1;
    }

    let sun = body_ptr(bodies, 0);
    set_vx(sun, -px / SOLAR_MASS);
    set_vy(sun, -py / SOLAR_MASS);
    set_vz(sun, -pz / SOLAR_MASS);
}

// Advance simulation (matches C advance with nested loops)
fn advance(bodies: u64, dt: f64) {
    // Nested loop for pairwise interactions (same as C)
    let mut i = 0;
    while i < NBODIES {
        let bi = body_ptr(bodies, i);
        let mut j = i + 1;
        while j < NBODIES {
            let bj = body_ptr(bodies, j);

            let dx = get_x(bi) - get_x(bj);
            let dy = get_y(bi) - get_y(bj);
            let dz = get_z(bi) - get_z(bj);

            let dist = sqrt(dx * dx + dy * dy + dz * dz);
            let mag = dt / (dist * dist * dist);

            set_vx(bi, get_vx(bi) - dx * get_mass(bj) * mag);
            set_vy(bi, get_vy(bi) - dy * get_mass(bj) * mag);
            set_vz(bi, get_vz(bi) - dz * get_mass(bj) * mag);

            set_vx(bj, get_vx(bj) + dx * get_mass(bi) * mag);
            set_vy(bj, get_vy(bj) + dy * get_mass(bi) * mag);
            set_vz(bj, get_vz(bj) + dz * get_mass(bi) * mag);

            j = j + 1;
        }
        i = i + 1;
    }

    // Update positions (same as C)
    i = 0;
    while i < NBODIES {
        let b = body_ptr(bodies, i);
        set_x(b, get_x(b) + dt * get_vx(b));
        set_y(b, get_y(b) + dt * get_vy(b));
        set_z(b, get_z(b) + dt * get_vz(b));
        i = i + 1;
    }
}

// Calculate total energy (matches C energy with nested loops)
fn energy(bodies: u64) -> f64 {
    let mut e: f64 = 0.0;

    let mut i = 0;
    while i < NBODIES {
        let bi = body_ptr(bodies, i);

        // Kinetic energy
        e = e + 0.5 * get_mass(bi) *
            (get_vx(bi) * get_vx(bi) +
             get_vy(bi) * get_vy(bi) +
             get_vz(bi) * get_vz(bi));

        // Potential energy (nested loop, same as C)
        let mut j = i + 1;
        while j < NBODIES {
            let bj = body_ptr(bodies, j);

            let dx = get_x(bi) - get_x(bj);
            let dy = get_y(bi) - get_y(bj);
            let dz = get_z(bi) - get_z(bj);

            let dist = sqrt(dx * dx + dy * dy + dz * dz);
            e = e - (get_mass(bi) * get_mass(bj)) / dist;

            j = j + 1;
        }
        i = i + 1;
    }

    e
}

fn main() {
    // Allocate array of 5 bodies (same as C global array)
    let bodies = alloc(BODY_SIZE * 5 as u64);

    init_bodies(bodies);
    offset_momentum(bodies);

    // Output initial energy
    println_f64(energy(bodies));

    // CLBG standard: 50,000,000 iterations
    let n = 50000000;
    let dt = 0.01;
    let mut i = 0;
    while i < n {
        advance(bodies, dt);
        i = i + 1;
    }

    // Output final energy
    println_f64(energy(bodies));

    // Clean up
    free(bodies);
}
