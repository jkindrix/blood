// CLBG Spectral Norm Benchmark for Blood
// =======================================
//
// This is a faithful port of the Computer Language Benchmarks Game spectral-norm
// benchmark, designed for direct comparison with the C reference implementation.
//
// CLBG Standard: N = 5500 (hardcoded since Blood doesn't have command-line args)
//
// Algorithm:
// 1. Matrix A(i,j) = 1/((i+j)(i+j+1)/2 + i + 1)
// 2. Perform 10 iterations of A^T*A multiplication
// 3. Compute spectral norm: sqrt(vBv / vv)
//
// Output format (must match C exactly):
//   <result with 9 decimal places>
//
// Note: Blood uses %g format (6 significant digits) in println_f64,
// but we can use print_f64_9 if available, or accept the format difference.

// CLBG standard N = 5500
fn get_n() -> i32 {
    5500
}

// Matrix element A(i,j)
fn matrix_a(i: i32, j: i32) -> f64 {
    let sum = i + j;
    1.0 / ((sum * (sum + 1)) / 2 + i + 1) as f64
}

// Multiply vector v by matrix A: out = A * v
fn av(n: i32, v: u64, out: u64) {
    let mut i = 0;
    while i < n {
        let mut sum = 0.0;
        let mut j = 0;
        while j < n {
            // v[j] is at offset j*8 (f64 is 8 bytes)
            let vj = ptr_read_f64(v + (j * 8) as u64);
            sum = sum + matrix_a(i, j) * vj;
            j = j + 1;
        }
        // out[i] = sum
        ptr_write_f64(out + (i * 8) as u64, sum);
        i = i + 1;
    }
}

// Multiply vector v by A^T: out = A^T * v
fn atv(n: i32, v: u64, out: u64) {
    let mut i = 0;
    while i < n {
        let mut sum = 0.0;
        let mut j = 0;
        while j < n {
            let vj = ptr_read_f64(v + (j * 8) as u64);
            sum = sum + matrix_a(j, i) * vj;  // Note: A^T means A(j,i) instead of A(i,j)
            j = j + 1;
        }
        ptr_write_f64(out + (i * 8) as u64, sum);
        i = i + 1;
    }
}

// Multiply by A^T*A: out = A^T * A * v
fn atav(n: i32, v: u64, out: u64, tmp: u64) {
    av(n, v, tmp);
    atv(n, tmp, out);
}

// Square root approximation using Newton's method
fn sqrt(x: f64) -> f64 {
    if x <= 0.0 {
        0.0
    } else {
        let mut guess = x;
        let mut i = 0;
        // 20 iterations is plenty for f64 precision
        while i < 20 {
            guess = (guess + x / guess) / 2.0;
            i = i + 1;
        }
        guess
    }
}

fn main() {
    let n = get_n();

    // Allocate arrays: u, v, tmp (each n * 8 bytes for f64)
    let array_size = (n * 8) as u64;
    let u = alloc(array_size);
    let v = alloc(array_size);
    let tmp = alloc(array_size);

    // Initialize u[i] = 1.0
    let mut i = 0;
    while i < n {
        ptr_write_f64(u + (i * 8) as u64, 1.0);
        i = i + 1;
    }

    // 10 iterations of A^T*A multiplication
    i = 0;
    while i < 10 {
        atav(n, u, v, tmp);
        atav(n, v, u, tmp);
        i = i + 1;
    }

    // Compute vBv = sum(u[i] * v[i]) and vv = sum(v[i] * v[i])
    let mut vbv = 0.0;
    let mut vv = 0.0;
    i = 0;
    while i < n {
        let ui = ptr_read_f64(u + (i * 8) as u64);
        let vi = ptr_read_f64(v + (i * 8) as u64);
        vbv = vbv + ui * vi;
        vv = vv + vi * vi;
        i = i + 1;
    }

    // Result: sqrt(vBv / vv)
    let result = sqrt(vbv / vv);

    // Print result
    // Note: println_f64 uses %g format (6 significant digits)
    // C uses %.9f (9 decimal places)
    // The values should match within tolerance
    println_f64(result);

    // Free memory
    free(u);
    free(v);
    free(tmp);
}
