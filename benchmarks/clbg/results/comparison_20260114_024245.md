# Blood vs C vs Rust Benchmark Comparison

**Generated**: Wed Jan 14 02:42:45 AM UTC 2026
**System**: Linux 6.1.0-39-amd64 x86_64
**Iterations**: 5 per benchmark

## Methodology

- Each benchmark run 5 times, median reported
- Wall-clock time measured in milliseconds
- All compilers use maximum optimization
- Blood benchmarks have hardcoded sizes (smaller than CLBG standard)

## Results


### N-Body (10000 steps)

| Language | Median (ms) | Min | Max | Ratio vs C |
|----------|-------------|-----|-----|------------|
| C | 1 | 1 | 1 | 1.00x |
| Rust | 1 | 1 | 1 | 1.00x |
| Blood | 1724 | 1718 | 1728 | 1724.00x |

### Spectral-Norm (N=10)

| Language | Median (ms) | Min | Max | Ratio vs C |
|----------|-------------|-----|-----|------------|
| C | 0 | 0 | 0 | 1.00x |
| Rust | 0 | 0 | 0 | N/Ax |
| Blood | 6 | 5 | 6 | N/Ax |

### Binary-Trees (depth=10)

| Language | Median (ms) | Min | Max | Ratio vs C |
|----------|-------------|-----|-----|------------|
| C | 1 | 1 | 1 | 1.00x |
| Rust | 3 | 3 | 3 | 3.00x |
| Blood | 14 | 14 | 15 | 14.00x |

### Fannkuch-Redux (N=5)

| Language | Median (ms) | Min | Max | Ratio vs C |
|----------|-------------|-----|-----|------------|
| C | 0 | 0 | 0 | 1.00x |
| Rust | 0 | 0 | 0 | N/Ax |
| Blood | 0 | 0 | 0 | N/Ax |

### Fasta (N=1000)

| Language | Median (ms) | Min | Max | Ratio vs C |
|----------|-------------|-----|-----|------------|
| C | 0 | 0 | 0 | 1.00x |
| Rust | 0 | 0 | 0 | N/Ax |
| Blood | 2 | 2 | 2 | N/Ax |

## Analysis

### Key Observations

1. **Startup overhead dominates at small sizes**: Blood programs include runtime initialization that's amortized over longer runs.

2. **128-bit pointer overhead**: Binary-trees shows the impact of Blood's fat pointers on allocation-heavy workloads.

3. **Compute-bound performance**: N-body and spectral-norm are compute-heavy and should show minimal overhead.

### Limitations

1. **Non-standard sizes**: Blood benchmarks use hardcoded sizes smaller than CLBG standard
2. **No CLI argument support**: Blood benchmarks can't be configured at runtime
3. **Startup overhead**: Significant at small problem sizes
4. **Missing: Large-scale benchmarks**: True performance characteristics require CLBG-standard sizes

### Recommendations

1. Add CLI argument parsing to Blood benchmarks
2. Run at CLBG-standard sizes for accurate comparison
3. Profile to understand overhead sources
