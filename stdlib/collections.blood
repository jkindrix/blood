// Blood Standard Library - Collections
// 
// To use: Create a `stdlib` directory in your project and copy this file there.
// Then use: mod stdlib; and access via stdlib::collections
//
// Or copy this file as `collections.blood` next to your main.blood and use:
// mod collections;

// Helper functions for u64 constants (workaround for lack of integer suffixes)
fn u64_zero() -> u64 { 0 as u64 }
fn u64_one() -> u64 { 1 as u64 }
fn u64_two() -> u64 { 2 as u64 }
fn u64_four() -> u64 { 4 as u64 }
fn u64_eight() -> u64 { 8 as u64 }

// =============================================================================
// VecI32 - A growable array of i32 values
// =============================================================================

pub struct VecI32 {
    ptr: u64,    // pointer to data
    len: u64,    // number of elements
    cap: u64,    // capacity
}

impl VecI32 {
    /// Creates a new empty Vec
    pub fn new() -> VecI32 {
        VecI32 { ptr: u64_zero(), len: u64_zero(), cap: u64_zero() }
    }
    
    /// Creates a Vec with pre-allocated capacity
    pub fn with_capacity(cap: u64) -> VecI32 {
        if cap == u64_zero() {
            return VecI32::new();
        }
        let size = cap * u64_four();
        let ptr = alloc(size);
        VecI32 { ptr: ptr, len: u64_zero(), cap: cap }
    }
    
    /// Returns the number of elements
    pub fn len(self: &VecI32) -> u64 {
        self.len
    }
    
    /// Returns the capacity
    pub fn capacity(self: &VecI32) -> u64 {
        self.cap
    }
    
    /// Returns true if the Vec is empty
    pub fn is_empty(self: &VecI32) -> bool {
        self.len == u64_zero()
    }
    
    /// Appends an element to the end
    pub fn push(self: &mut VecI32, value: i32) {
        if self.len == self.cap {
            let new_cap = if self.cap == u64_zero() { u64_four() } else { self.cap * u64_two() };
            let new_size = new_cap * u64_four();
            if self.ptr == u64_zero() {
                self.ptr = alloc(new_size);
            } else {
                self.ptr = realloc(self.ptr, new_size);
            }
            self.cap = new_cap;
        }
        let offset = self.len * u64_four();
        let addr = self.ptr + offset;
        ptr_write_i32(addr, value);
        self.len = self.len + u64_one();
    }
    
    /// Gets the element at the given index (no bounds checking)
    pub fn get(self: &VecI32, index: u64) -> i32 {
        let offset = index * u64_four();
        let addr = self.ptr + offset;
        ptr_read_i32(addr)
    }
    
    /// Sets the element at the given index (no bounds checking)
    pub fn set(self: &mut VecI32, index: u64, value: i32) {
        let offset = index * u64_four();
        let addr = self.ptr + offset;
        ptr_write_i32(addr, value);
    }
    
    /// Removes and returns the last element
    pub fn pop(self: &mut VecI32) -> i32 {
        self.len = self.len - u64_one();
        let offset = self.len * u64_four();
        let addr = self.ptr + offset;
        ptr_read_i32(addr)
    }
    
    /// Clears all elements (but retains capacity)
    pub fn clear(self: &mut VecI32) {
        self.len = u64_zero();
    }
    
    /// Frees the memory used by the Vec
    pub fn drop(self: &mut VecI32) {
        if self.ptr != u64_zero() {
            free(self.ptr);
            self.ptr = u64_zero();
            self.len = u64_zero();
            self.cap = u64_zero();
        }
    }
}

// =============================================================================
// VecI64 - A growable array of i64 values
// =============================================================================

pub struct VecI64 {
    ptr: u64,
    len: u64,
    cap: u64,
}

impl VecI64 {
    pub fn new() -> VecI64 {
        VecI64 { ptr: u64_zero(), len: u64_zero(), cap: u64_zero() }
    }
    
    pub fn with_capacity(cap: u64) -> VecI64 {
        if cap == u64_zero() {
            return VecI64::new();
        }
        let size = cap * u64_eight();
        let ptr = alloc(size);
        VecI64 { ptr: ptr, len: u64_zero(), cap: cap }
    }
    
    pub fn len(self: &VecI64) -> u64 { self.len }
    pub fn capacity(self: &VecI64) -> u64 { self.cap }
    pub fn is_empty(self: &VecI64) -> bool { self.len == u64_zero() }
    
    pub fn push(self: &mut VecI64, value: i64) {
        if self.len == self.cap {
            let new_cap = if self.cap == u64_zero() { u64_four() } else { self.cap * u64_two() };
            let new_size = new_cap * u64_eight();
            if self.ptr == u64_zero() {
                self.ptr = alloc(new_size);
            } else {
                self.ptr = realloc(self.ptr, new_size);
            }
            self.cap = new_cap;
        }
        let offset = self.len * u64_eight();
        let addr = self.ptr + offset;
        ptr_write_i64(addr, value);
        self.len = self.len + u64_one();
    }
    
    pub fn get(self: &VecI64, index: u64) -> i64 {
        let offset = index * u64_eight();
        let addr = self.ptr + offset;
        ptr_read_i64(addr)
    }
    
    pub fn set(self: &mut VecI64, index: u64, value: i64) {
        let offset = index * u64_eight();
        let addr = self.ptr + offset;
        ptr_write_i64(addr, value);
    }
    
    pub fn pop(self: &mut VecI64) -> i64 {
        self.len = self.len - u64_one();
        let offset = self.len * u64_eight();
        let addr = self.ptr + offset;
        ptr_read_i64(addr)
    }
    
    pub fn clear(self: &mut VecI64) {
        self.len = u64_zero();
    }
    
    pub fn drop(self: &mut VecI64) {
        if self.ptr != u64_zero() {
            free(self.ptr);
            self.ptr = u64_zero();
            self.len = u64_zero();
            self.cap = u64_zero();
        }
    }
}

// =============================================================================
// VecU64 - A growable array of u64 values
// =============================================================================

pub struct VecU64 {
    ptr: u64,
    len: u64,
    cap: u64,
}

impl VecU64 {
    pub fn new() -> VecU64 {
        VecU64 { ptr: u64_zero(), len: u64_zero(), cap: u64_zero() }
    }
    
    pub fn with_capacity(cap: u64) -> VecU64 {
        if cap == u64_zero() {
            return VecU64::new();
        }
        let size = cap * u64_eight();
        let ptr = alloc(size);
        VecU64 { ptr: ptr, len: u64_zero(), cap: cap }
    }
    
    pub fn len(self: &VecU64) -> u64 { self.len }
    pub fn capacity(self: &VecU64) -> u64 { self.cap }
    pub fn is_empty(self: &VecU64) -> bool { self.len == u64_zero() }
    
    pub fn push(self: &mut VecU64, value: u64) {
        if self.len == self.cap {
            let new_cap = if self.cap == u64_zero() { u64_four() } else { self.cap * u64_two() };
            let new_size = new_cap * u64_eight();
            if self.ptr == u64_zero() {
                self.ptr = alloc(new_size);
            } else {
                self.ptr = realloc(self.ptr, new_size);
            }
            self.cap = new_cap;
        }
        let offset = self.len * u64_eight();
        let addr = self.ptr + offset;
        ptr_write_u64(addr, value);
        self.len = self.len + u64_one();
    }
    
    pub fn get(self: &VecU64, index: u64) -> u64 {
        let offset = index * u64_eight();
        let addr = self.ptr + offset;
        ptr_read_u64(addr)
    }
    
    pub fn set(self: &mut VecU64, index: u64, value: u64) {
        let offset = index * u64_eight();
        let addr = self.ptr + offset;
        ptr_write_u64(addr, value);
    }
    
    pub fn pop(self: &mut VecU64) -> u64 {
        self.len = self.len - u64_one();
        let offset = self.len * u64_eight();
        let addr = self.ptr + offset;
        ptr_read_u64(addr)
    }
    
    pub fn clear(self: &mut VecU64) {
        self.len = u64_zero();
    }
    
    pub fn drop(self: &mut VecU64) {
        if self.ptr != u64_zero() {
            free(self.ptr);
            self.ptr = u64_zero();
            self.len = u64_zero();
            self.cap = u64_zero();
        }
    }
}

// =============================================================================
// HashMapI32 - A hash map with i32 keys and i32 values
// Uses open addressing with linear probing
// =============================================================================

// Slot states
fn state_empty() -> u8 { 0 as u8 }
fn state_occupied() -> u8 { 1 as u8 }
fn state_deleted() -> u8 { 2 as u8 }

// Additional helper constants
fn u64_sixteen() -> u64 { 16 as u64 }
fn load_factor_threshold() -> u64 { 70 as u64 }  // 70% load factor

pub struct HashMapI32 {
    keys_ptr: u64,      // pointer to i32 keys array
    values_ptr: u64,    // pointer to i32 values array
    states_ptr: u64,    // pointer to u8 states array (empty/occupied/deleted)
    len: u64,           // number of entries
    cap: u64,           // capacity (number of slots)
}

impl HashMapI32 {
    /// Creates a new empty HashMap
    pub fn new() -> HashMapI32 {
        HashMapI32 {
            keys_ptr: u64_zero(),
            values_ptr: u64_zero(),
            states_ptr: u64_zero(),
            len: u64_zero(),
            cap: u64_zero()
        }
    }

    /// Creates a HashMap with pre-allocated capacity
    pub fn with_capacity(cap: u64) -> HashMapI32 {
        if cap == u64_zero() {
            return HashMapI32::new();
        }
        let keys_size = cap * u64_four();      // i32 = 4 bytes
        let values_size = cap * u64_four();    // i32 = 4 bytes
        let states_size = cap;                  // u8 = 1 byte

        let keys_ptr = alloc(keys_size);
        let values_ptr = alloc(values_size);
        let states_ptr = alloc(states_size);

        // Initialize all states to empty
        let mut i = u64_zero();
        while i < cap {
            ptr_write_u8(states_ptr + i, state_empty());
            i = i + u64_one();
        }

        HashMapI32 {
            keys_ptr: keys_ptr,
            values_ptr: values_ptr,
            states_ptr: states_ptr,
            len: u64_zero(),
            cap: cap
        }
    }

    /// Returns the number of entries
    pub fn len(self: &HashMapI32) -> u64 { self.len }

    /// Returns the capacity
    pub fn capacity(self: &HashMapI32) -> u64 { self.cap }

    /// Returns true if the HashMap is empty
    pub fn is_empty(self: &HashMapI32) -> bool { self.len == u64_zero() }

    /// Simple hash function for i32 keys
    fn hash(self: &HashMapI32, key: i32) -> u64 {
        // Handle negative numbers by making them positive
        let k = if key < 0 { (0 - key) as u64 } else { key as u64 };
        k % self.cap
    }

    /// Finds the slot index for a key (for insertion or lookup)
    /// Returns the index where the key is or should be placed
    fn find_slot(self: &HashMapI32, key: i32) -> u64 {
        let start = self.hash(key);
        let mut idx = start;
        let mut first_deleted = self.cap;  // Invalid index as sentinel

        // Linear probing
        loop {
            let state_addr = self.states_ptr + idx;
            let state = ptr_read_u8(state_addr);

            if state == state_empty() {
                // Empty slot - key not found
                // Return first deleted slot if we found one, otherwise this slot
                if first_deleted < self.cap {
                    return first_deleted;
                }
                return idx;
            }

            if state == state_deleted() {
                // Remember first deleted slot for potential insertion
                if first_deleted == self.cap {
                    first_deleted = idx;
                }
            } else {
                // state == occupied - check if key matches
                let key_addr = self.keys_ptr + idx * u64_four();
                let stored_key = ptr_read_i32(key_addr);
                if stored_key == key {
                    return idx;
                }
            }

            // Move to next slot (wrap around)
            idx = (idx + u64_one()) % self.cap;

            // If we've wrapped all the way around, table is full
            if idx == start {
                // Return first deleted if found, otherwise start
                if first_deleted < self.cap {
                    return first_deleted;
                }
                return start;
            }
        }
    }

    /// Checks if should resize based on load factor
    fn should_resize(self: &HashMapI32) -> bool {
        if self.cap == u64_zero() {
            return true;
        }
        // Check if (len * 100) / cap > 70
        let load = (self.len * (100 as u64)) / self.cap;
        load > load_factor_threshold()
    }

    /// Resizes the HashMap to a new capacity
    fn resize(self: &mut HashMapI32, new_cap: u64) {
        let old_keys_ptr = self.keys_ptr;
        let old_values_ptr = self.values_ptr;
        let old_states_ptr = self.states_ptr;
        let old_cap = self.cap;

        // Allocate new arrays
        let keys_size = new_cap * u64_four();
        let values_size = new_cap * u64_four();
        let states_size = new_cap;

        self.keys_ptr = alloc(keys_size);
        self.values_ptr = alloc(values_size);
        self.states_ptr = alloc(states_size);
        self.cap = new_cap;
        self.len = u64_zero();

        // Initialize all states to empty
        let mut i = u64_zero();
        while i < new_cap {
            ptr_write_u8(self.states_ptr + i, state_empty());
            i = i + u64_one();
        }

        // Re-insert all entries from old table
        if old_cap > u64_zero() {
            i = u64_zero();
            while i < old_cap {
                let old_state = ptr_read_u8(old_states_ptr + i);
                if old_state == state_occupied() {
                    let key = ptr_read_i32(old_keys_ptr + i * u64_four());
                    let value = ptr_read_i32(old_values_ptr + i * u64_four());
                    self.insert(key, value);
                }
                i = i + u64_one();
            }

            // Free old arrays
            free(old_keys_ptr);
            free(old_values_ptr);
            free(old_states_ptr);
        }
    }

    /// Inserts a key-value pair into the HashMap
    /// If the key already exists, updates the value
    pub fn insert(self: &mut HashMapI32, key: i32, value: i32) {
        // Check if we need to resize
        if self.should_resize() {
            let new_cap = if self.cap == u64_zero() { u64_sixteen() } else { self.cap * u64_two() };
            self.resize(new_cap);
        }

        let idx = self.find_slot(key);
        let state_addr = self.states_ptr + idx;
        let state = ptr_read_u8(state_addr);

        let key_addr = self.keys_ptr + idx * u64_four();
        let value_addr = self.values_ptr + idx * u64_four();

        // Check if this is a new entry or update
        if state == state_occupied() {
            let stored_key = ptr_read_i32(key_addr);
            if stored_key == key {
                // Update existing entry
                ptr_write_i32(value_addr, value);
                return;
            }
        }

        // New entry
        ptr_write_i32(key_addr, key);
        ptr_write_i32(value_addr, value);
        ptr_write_u8(state_addr, state_occupied());
        self.len = self.len + u64_one();
    }

    /// Gets the value for a key, returns 0 if not found
    /// Use contains() to check if a key exists
    pub fn get(self: &HashMapI32, key: i32) -> i32 {
        if self.cap == u64_zero() {
            return 0;
        }

        let idx = self.find_slot(key);
        let state_addr = self.states_ptr + idx;
        let state = ptr_read_u8(state_addr);

        if state == state_occupied() {
            let key_addr = self.keys_ptr + idx * u64_four();
            let stored_key = ptr_read_i32(key_addr);
            if stored_key == key {
                let value_addr = self.values_ptr + idx * u64_four();
                return ptr_read_i32(value_addr);
            }
        }

        0
    }

    /// Checks if a key exists in the HashMap
    pub fn contains(self: &HashMapI32, key: i32) -> bool {
        if self.cap == u64_zero() {
            return false;
        }

        let idx = self.find_slot(key);
        let state_addr = self.states_ptr + idx;
        let state = ptr_read_u8(state_addr);

        if state == state_occupied() {
            let key_addr = self.keys_ptr + idx * u64_four();
            let stored_key = ptr_read_i32(key_addr);
            return stored_key == key;
        }

        false
    }

    /// Removes a key from the HashMap
    /// Returns the value that was removed, or 0 if key not found
    pub fn remove(self: &mut HashMapI32, key: i32) -> i32 {
        if self.cap == u64_zero() {
            return 0;
        }

        let idx = self.find_slot(key);
        let state_addr = self.states_ptr + idx;
        let state = ptr_read_u8(state_addr);

        if state == state_occupied() {
            let key_addr = self.keys_ptr + idx * u64_four();
            let stored_key = ptr_read_i32(key_addr);
            if stored_key == key {
                let value_addr = self.values_ptr + idx * u64_four();
                let value = ptr_read_i32(value_addr);

                // Mark as deleted (not empty, to preserve probe chains)
                ptr_write_u8(state_addr, state_deleted());
                self.len = self.len - u64_one();

                return value;
            }
        }

        0
    }

    /// Clears all entries (but retains capacity)
    pub fn clear(self: &mut HashMapI32) {
        let mut i = u64_zero();
        while i < self.cap {
            ptr_write_u8(self.states_ptr + i, state_empty());
            i = i + u64_one();
        }
        self.len = u64_zero();
    }

    /// Frees the memory used by the HashMap
    pub fn drop(self: &mut HashMapI32) {
        if self.keys_ptr != u64_zero() {
            free(self.keys_ptr);
            free(self.values_ptr);
            free(self.states_ptr);
            self.keys_ptr = u64_zero();
            self.values_ptr = u64_zero();
            self.states_ptr = u64_zero();
            self.len = u64_zero();
            self.cap = u64_zero();
        }
    }
}
