// Blood Standard Library - Math Utilities
//
// Integer arithmetic functions for common numeric operations.
// All functions are pure and operate on primitive types.

/// Integer exponentiation: base^exp for i32.
pub fn pow_i32(base: i32, exp: u32) -> i32 {
    let mut result: i32 = 1;
    let mut b = base;
    let mut e = exp;
    while e > 0 {
        if e % 2 == 1 {
            result = result * b;
        }
        b = b * b;
        e = e / 2;
    }
    result
}

/// Integer exponentiation: base^exp for u32.
pub fn pow_u32(base: u32, exp: u32) -> u32 {
    let mut result: u32 = 1;
    let mut b = base;
    let mut e = exp;
    while e > 0 {
        if e % 2 == 1 {
            result = result * b;
        }
        b = b * b;
        e = e / 2;
    }
    result
}

/// Greatest common divisor (Euclidean algorithm).
pub fn gcd(a: i32, b: i32) -> i32 {
    let mut x = a;
    let mut y = b;
    if x < 0 { x = 0 - x; }
    if y < 0 { y = 0 - y; }
    while y != 0 {
        let t = y;
        y = x % y;
        x = t;
    }
    x
}

/// Least common multiple.
pub fn lcm(a: i32, b: i32) -> i32 {
    if a == 0 || b == 0 {
        return 0;
    }
    let g = gcd(a, b);
    let mut abs_a = a;
    if abs_a < 0 { abs_a = 0 - abs_a; }
    let mut abs_b = b;
    if abs_b < 0 { abs_b = 0 - abs_b; }
    (abs_a / g) * abs_b
}

/// Returns true if n is a power of two.
pub fn is_power_of_two(n: u32) -> bool {
    if n == 0 {
        return false;
    }
    (n & (n - 1)) == 0
}

/// Returns the smallest power of two >= n.
pub fn next_power_of_two(n: u32) -> u32 {
    if n == 0 {
        return 1;
    }
    if is_power_of_two(n) {
        return n;
    }
    let mut v = n - 1;
    v = v | (v >> 1);
    v = v | (v >> 2);
    v = v | (v >> 4);
    v = v | (v >> 8);
    v = v | (v >> 16);
    v + 1
}

/// Integer log base 2 (floor). Returns 0 for input 0.
pub fn log2_u32(n: u32) -> u32 {
    if n == 0 {
        return 0;
    }
    let mut val = n;
    let mut log: u32 = 0;
    while val > 1 {
        val = val >> 1;
        log = log + 1;
    }
    log
}

/// Returns the sign of an integer: -1, 0, or 1.
pub fn sign(n: i32) -> i32 {
    if n > 0 {
        1
    } else {
        if n < 0 { 0 - 1 } else { 0 }
    }
}

/// Returns the smaller of two u32 values.
pub fn min_u32(a: u32, b: u32) -> u32 {
    if a < b { a } else { b }
}

/// Returns the larger of two u32 values.
pub fn max_u32(a: u32, b: u32) -> u32 {
    if a > b { a } else { b }
}

/// Returns the smaller of two usize values.
pub fn min_usize(a: usize, b: usize) -> usize {
    if a < b { a } else { b }
}

/// Returns the larger of two usize values.
pub fn max_usize(a: usize, b: usize) -> usize {
    if a > b { a } else { b }
}

/// Clamps a u32 value to the range [lo, hi].
pub fn clamp_u32(val: u32, lo: u32, hi: u32) -> u32 {
    if val < lo {
        lo
    } else {
        if val > hi { hi } else { val }
    }
}
