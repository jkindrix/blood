// Blood Standard Library - HashMap
//
// Hash map implementations using open addressing with linear probing.
// Provides O(1) average-case lookup, insertion, and deletion.
//
// This module provides monomorphic hash maps for common key-value types:
// - HashMapU64U32: Maps u64 keys to u32 values
// - HashMapU64U64: Maps u64 keys to u64 values
//
// Also provides FNV-1a hash functions for u64, byte slices, and strings.
//
// These are specialized, non-generic implementations that work within Blood's
// current language capabilities. A generic HashMap<K, V> will be added once
// closures and associated types are available (see Phase 3 of the roadmap).

// ============================================================
// Bucket types
// ============================================================

/// Bucket state for u32 values
pub enum BucketU32 {
    Empty,
    Occupied { key: u64, value: u32 },
    Deleted,
}

/// Bucket state for u64 values
pub enum BucketU64 {
    Empty,
    Occupied { key: u64, value: u64 },
    Deleted,
}

// ============================================================
// HashMapU64U32 - Maps u64 keys to u32 values
// ============================================================

/// Hash map from u64 keys to u32 values.
pub struct HashMapU64U32 {
    buckets: Vec<BucketU32>,
    len: usize,
    capacity: usize,
}

impl HashMapU64U32 {
    /// Create a new empty hash map.
    pub fn new() -> HashMapU64U32 {
        HashMapU64U32 {
            buckets: Vec::new(),
            len: 0,
            capacity: 0,
        }
    }

    /// Create a hash map with initial capacity.
    pub fn with_capacity(cap: usize) -> HashMapU64U32 {
        let actual_cap = if cap < 16 { 16 as usize } else { cap };
        let mut buckets: Vec<BucketU32> = Vec::new();
        for i in 0usize..actual_cap {
            buckets.push(BucketU32::Empty);
        }
        HashMapU64U32 {
            buckets,
            len: 0,
            capacity: actual_cap,
        }
    }

    /// Number of entries.
    pub fn len(self: &Self) -> usize {
        self.len
    }

    /// Ensure capacity, resizing if needed.
    fn ensure_capacity(self: &mut Self) {
        if self.capacity == 0 {
            self.capacity = 16;
            for i in 0usize..self.capacity {
                self.buckets.push(BucketU32::Empty);
            }
            return;
        }
        if self.len * 4 >= self.capacity * 3 {
            self.resize();
        }
    }

    /// Double capacity and rehash.
    fn resize(self: &mut Self) {
        let new_cap = self.capacity * 2;
        let mut new_buckets: Vec<BucketU32> = Vec::new();
        let mut i: usize = 0;
        while i < new_cap {
            new_buckets.push(BucketU32::Empty);
            i = i + 1;
        }

        i = 0;
        while i < self.capacity {
            match &self.buckets[i] {
                BucketU32::Occupied { key, value } => {
                    let hash = hash_u64(&key);
                    let mut idx = (hash as usize) % new_cap;
                    let mut found = false;
                    while !found {
                        match &new_buckets[idx] {
                            BucketU32::Empty => {
                                new_buckets[idx] = BucketU32::Occupied { key: key, value: value };
                                found = true;
                            }
                            _ => {
                                idx = (idx + 1) % new_cap;
                            }
                        }
                    }
                }
                _ => {}
            }
            i = i + 1;
        }
        self.buckets = new_buckets;
        self.capacity = new_cap;
    }

    /// Insert a key-value pair.
    pub fn insert(self: &mut Self, key: u64, value: u32) {
        self.ensure_capacity();
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32::Empty => {
                    self.buckets[idx] = BucketU32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32::Deleted => {
                    self.buckets[idx] = BucketU32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU32::Occupied { key, value };
                        return;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
    }

    /// Get a value by key.
    pub fn get(self: &Self, key: u64) -> Option<u32> {
        if self.capacity == 0 {
            return Option::None;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32::Empty => {
                    return Option::None;
                }
                BucketU32::Deleted => {}
                BucketU32::Occupied { key: existing_key, value } => {
                    if existing_key == key {
                        return Option::Some(value);
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        Option::None
    }

    /// Check if key exists.
    pub fn contains_key(self: &Self, key: u64) -> bool {
        match self.get(key) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Remove a key from the map. Returns true if the key was present.
    pub fn remove(self: &mut Self, key: u64) -> bool {
        if self.capacity == 0 {
            return false;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32::Empty => {
                    return false;
                }
                BucketU32::Deleted => {}
                BucketU32::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU32::Deleted;
                        self.len = self.len - 1;
                        return true;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        false
    }

    /// Check if the map is empty.
    pub fn is_empty(self: &Self) -> bool {
        self.len == 0
    }

    /// Remove all entries from the map.
    pub fn clear(self: &mut Self) {
        for i in 0usize..self.capacity {
            self.buckets[i] = BucketU32::Empty;
        }
        self.len = 0;
    }
}

// ============================================================
// HashMapU64U64 - Maps u64 keys to u64 values
// ============================================================

/// Hash map from u64 keys to u64 values.
pub struct HashMapU64U64 {
    buckets: Vec<BucketU64>,
    len: usize,
    capacity: usize,
}

impl HashMapU64U64 {
    /// Create a new empty hash map.
    pub fn new() -> HashMapU64U64 {
        HashMapU64U64 {
            buckets: Vec::new(),
            len: 0,
            capacity: 0,
        }
    }

    /// Create a hash map with initial capacity.
    pub fn with_capacity(cap: usize) -> HashMapU64U64 {
        let actual_cap = if cap < 16 { 16 as usize } else { cap };
        let mut buckets: Vec<BucketU64> = Vec::new();
        for i in 0usize..actual_cap {
            buckets.push(BucketU64::Empty);
        }
        HashMapU64U64 {
            buckets,
            len: 0,
            capacity: actual_cap,
        }
    }

    /// Number of entries.
    pub fn len(self: &Self) -> usize {
        self.len
    }

    /// Ensure capacity, resizing if needed.
    fn ensure_capacity(self: &mut Self) {
        if self.capacity == 0 {
            self.capacity = 16;
            for i in 0usize..self.capacity {
                self.buckets.push(BucketU64::Empty);
            }
            return;
        }
        if self.len * 4 >= self.capacity * 3 {
            self.resize();
        }
    }

    /// Double capacity and rehash.
    fn resize(self: &mut Self) {
        let new_cap = self.capacity * 2;
        let mut new_buckets: Vec<BucketU64> = Vec::new();
        let mut i: usize = 0;
        while i < new_cap {
            new_buckets.push(BucketU64::Empty);
            i = i + 1;
        }

        i = 0;
        while i < self.capacity {
            match &self.buckets[i] {
                BucketU64::Occupied { key, value } => {
                    let hash = hash_u64(&key);
                    let mut idx = (hash as usize) % new_cap;
                    let mut found = false;
                    while !found {
                        match &new_buckets[idx] {
                            BucketU64::Empty => {
                                new_buckets[idx] = BucketU64::Occupied { key: key, value: value };
                                found = true;
                            }
                            _ => {
                                idx = (idx + 1) % new_cap;
                            }
                        }
                    }
                }
                _ => {}
            }
            i = i + 1;
        }
        self.buckets = new_buckets;
        self.capacity = new_cap;
    }

    /// Insert a key-value pair.
    pub fn insert(self: &mut Self, key: u64, value: u64) {
        self.ensure_capacity();
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU64::Empty => {
                    self.buckets[idx] = BucketU64::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU64::Deleted => {
                    self.buckets[idx] = BucketU64::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU64::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU64::Occupied { key, value };
                        return;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
    }

    /// Get a value by key.
    pub fn get(self: &Self, key: u64) -> Option<u64> {
        if self.capacity == 0 {
            return Option::None;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU64::Empty => {
                    return Option::None;
                }
                BucketU64::Deleted => {}
                BucketU64::Occupied { key: existing_key, value } => {
                    if existing_key == key {
                        return Option::Some(value);
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        Option::None
    }

    /// Check if key exists.
    pub fn contains_key(self: &Self, key: u64) -> bool {
        match self.get(key) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Remove a key from the map. Returns true if the key was present.
    pub fn remove(self: &mut Self, key: u64) -> bool {
        if self.capacity == 0 {
            return false;
        }
        let hash = hash_u64(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU64::Empty => {
                    return false;
                }
                BucketU64::Deleted => {}
                BucketU64::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU64::Deleted;
                        self.len = self.len - 1;
                        return true;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        false
    }

    /// Check if the map is empty.
    pub fn is_empty(self: &Self) -> bool {
        self.len == 0
    }

    /// Remove all entries from the map.
    pub fn clear(self: &mut Self) {
        for i in 0usize..self.capacity {
            self.buckets[i] = BucketU64::Empty;
        }
        self.len = 0;
    }
}

// ============================================================
// Hash functions
// ============================================================

/// FNV-1a hash for u64.
pub fn hash_u64(v: &u64) -> u64 {
    let mut h: u64 = 14695981039346656037;
    let val = *v;
    for i in 0u32..8 {
        h = h ^ ((val >> (i * 8)) & 255);
        h = h * 1099511628211;
    }
    h
}

/// FNV-1a hash for a byte slice (string).
pub fn hash_bytes(bytes: &Vec<u8>) -> u64 {
    let mut h: u64 = 14695981039346656037;
    for i in 0usize..bytes.len() {
        h = h ^ (bytes[i] as u64);
        h = h * 1099511628211;
    }
    h
}

/// Hash a string by its bytes.
pub fn hash_str(s: &str) -> u64 {
    let bytes = s.as_bytes();
    let mut h: u64 = 14695981039346656037;
    for i in 0usize..bytes.len() {
        h = h ^ (bytes[i] as u64);
        h = h * 1099511628211;
    }
    h
}

/// Hash a String by its bytes.
pub fn hash_string(s: &String) -> u64 {
    hash_str(s.as_str())
}

/// FNV-1a hash for u32.
pub fn hash_u32(v: &u32) -> u64 {
    let mut h: u64 = 14695981039346656037;
    let val = *v;
    for i in 0u32..4 {
        h = h ^ (((val >> (i * 8)) & 255) as u64);
        h = h * 1099511628211;
    }
    h
}

/// Combine two u32 values into a single u64 key for hashing.
pub fn combine_u32_usize(a: u32, b: usize) -> u64 {
    ((a as u64) << 32) | ((b as u64) & 0xFFFFFFFF)
}

// ============================================================
// HashMapU32U32 - Maps u32 keys to u32 values
// ============================================================

/// Bucket state for u32 keys and u32 values.
pub enum BucketU32U32 {
    Empty,
    Occupied { key: u32, value: u32 },
    Deleted,
}

/// Hash map from u32 keys to u32 values.
pub struct HashMapU32U32 {
    buckets: Vec<BucketU32U32>,
    len: usize,
    capacity: usize,
}

impl HashMapU32U32 {
    /// Create a new empty hash map.
    pub fn new() -> HashMapU32U32 {
        HashMapU32U32 {
            buckets: Vec::new(),
            len: 0,
            capacity: 0,
        }
    }

    /// Create a hash map with initial capacity.
    pub fn with_capacity(cap: usize) -> HashMapU32U32 {
        let actual_cap = if cap < 16 { 16 as usize } else { cap };
        let mut buckets: Vec<BucketU32U32> = Vec::new();
        for i in 0usize..actual_cap {
            buckets.push(BucketU32U32::Empty);
        }
        HashMapU32U32 {
            buckets,
            len: 0,
            capacity: actual_cap,
        }
    }

    /// Number of entries.
    pub fn len(self: &Self) -> usize {
        self.len
    }

    /// Check if the map is empty.
    pub fn is_empty(self: &Self) -> bool {
        self.len == 0
    }

    /// Ensure capacity, resizing if needed.
    fn ensure_capacity(self: &mut Self) {
        if self.capacity == 0 {
            self.capacity = 16;
            for i in 0usize..self.capacity {
                self.buckets.push(BucketU32U32::Empty);
            }
            return;
        }
        if self.len * 4 >= self.capacity * 3 {
            self.resize();
        }
    }

    /// Double capacity and rehash.
    fn resize(self: &mut Self) {
        let new_cap = self.capacity * 2;
        let mut new_buckets: Vec<BucketU32U32> = Vec::new();
        let mut i: usize = 0;
        while i < new_cap {
            new_buckets.push(BucketU32U32::Empty);
            i = i + 1;
        }

        i = 0;
        while i < self.capacity {
            match &self.buckets[i] {
                BucketU32U32::Occupied { key, value } => {
                    let hash = hash_u32(&key);
                    let mut idx = (hash as usize) % new_cap;
                    let mut found = false;
                    while !found {
                        match &new_buckets[idx] {
                            BucketU32U32::Empty => {
                                new_buckets[idx] = BucketU32U32::Occupied { key: key, value: value };
                                found = true;
                            }
                            _ => {
                                idx = (idx + 1) % new_cap;
                            }
                        }
                    }
                }
                BucketU32U32::Deleted => {}
                BucketU32U32::Empty => {}
            }
            i = i + 1;
        }
        self.buckets = new_buckets;
        self.capacity = new_cap;
    }

    /// Insert a key-value pair.
    pub fn insert(self: &mut Self, key: u32, value: u32) {
        self.ensure_capacity();
        let hash = hash_u32(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32U32::Empty => {
                    self.buckets[idx] = BucketU32U32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32U32::Deleted => {
                    self.buckets[idx] = BucketU32U32::Occupied { key, value };
                    self.len = self.len + 1;
                    return;
                }
                BucketU32U32::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU32U32::Occupied { key, value };
                        return;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
    }

    /// Get a value by key.
    pub fn get(self: &Self, key: u32) -> Option<u32> {
        if self.capacity == 0 {
            return Option::None;
        }
        let hash = hash_u32(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32U32::Empty => {
                    return Option::None;
                }
                BucketU32U32::Deleted => {}
                BucketU32U32::Occupied { key: existing_key, value } => {
                    if existing_key == key {
                        return Option::Some(value);
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        Option::None
    }

    /// Check if key exists.
    pub fn contains_key(self: &Self, key: u32) -> bool {
        match self.get(key) {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    /// Remove a key from the map. Returns true if the key was present.
    pub fn remove(self: &mut Self, key: u32) -> bool {
        if self.capacity == 0 {
            return false;
        }
        let hash = hash_u32(&key);
        let mut idx = (hash as usize) % self.capacity;

        for probes in 0usize..self.capacity {
            match &self.buckets[idx] {
                BucketU32U32::Empty => {
                    return false;
                }
                BucketU32U32::Deleted => {}
                BucketU32U32::Occupied { key: existing_key, value: _ } => {
                    if existing_key == key {
                        self.buckets[idx] = BucketU32U32::Deleted;
                        self.len = self.len - 1;
                        return true;
                    }
                }
            }
            idx = (idx + 1) % self.capacity;
        }
        false
    }

    /// Remove all entries from the map.
    pub fn clear(self: &mut Self) {
        for i in 0usize..self.capacity {
            self.buckets[i] = BucketU32U32::Empty;
        }
        self.len = 0;
    }
}
