//! Runtime support for Blood programs.
//!
//! This module provides declarations and stubs for runtime functions
//! that Blood programs can call.
//!
//! ## Runtime Linking
//!
//! Compiled Blood programs must be linked with the Blood runtime library:
//!
//! - **Rust runtime** (`blood-runtime`): Full-featured runtime with fibers,
//!   channels, and effects support. Build with `cargo build --release` and
//!   link with `-lblood_runtime`.
//!
//! - **C runtime** (fallback): Minimal C runtime for simple programs without
//!   advanced features. Generated by `generate_c_runtime()`.
//!
//! ## Available Functions
//!
//! ### I/O
//! - `print_int`, `println_int` - Integer output
//! - `print_str`, `println_str` - String output
//! - `print_bool`, `println_bool` - Boolean output
//!
//! ### Memory (Generational References)
//! - `blood_alloc` - Allocate with generation tracking
//! - `blood_free` - Free allocated memory
//! - `blood_validate_generation` - Validate address/generation pair (0=valid, 1=stale)
//! - `blood_register_allocation` - Register address in slot registry
//! - `blood_unregister_allocation` - Remove address from slot registry
//! - `blood_get_generation` - Get current generation for address
//! - `blood_increment_generation` - Increment generation (invalidates refs)
//! - `blood_stale_reference_panic` - Handle stale reference errors
//!
//! ### Effects
//! - `blood_evidence_create/destroy/push/pop/get` - Evidence vectors
//! - `blood_evidence_register` - Register handler with operations
//! - `blood_evidence_set_state/get_state` - Handler state management
//! - `blood_evidence_current` - Get current evidence vector
//! - `blood_perform` - Perform effect operation
//! - `blood_handler_depth` - Get handler depth for effect
//!
//! ### Continuations
//! - `blood_fiber_create/suspend/resume` - Fiber support
//! - `blood_snapshot_create/add_entry/validate/destroy` - Generation snapshots
//!
//! ### Multiple Dispatch
//! - `blood_dispatch_register/lookup` - Method dispatch tables
//! - `blood_get_type_tag` - Runtime type information
//!
//! ### Scheduler
//! - `blood_scheduler_init/spawn/yield/run` - Work-stealing scheduler
//!
//! ### Runtime Lifecycle
//! - `blood_runtime_init` - Initialize runtime
//! - `blood_runtime_shutdown` - Cleanup runtime

/// Runtime function names.
pub mod functions {
    // === I/O Functions ===

    /// Print an integer (no newline).
    pub const PRINT_INT: &str = "print_int";

    /// Print an integer with newline.
    pub const PRINTLN_INT: &str = "println_int";

    /// Print a 64-bit integer with newline.
    pub const PRINTLN_I64: &str = "println_i64";

    /// Print a string (no newline).
    pub const PRINT_STR: &str = "print_str";

    /// Print a string with newline.
    pub const PRINTLN_STR: &str = "println_str";

    /// Print a boolean (no newline).
    pub const PRINT_BOOL: &str = "print_bool";

    /// Print a boolean with newline.
    pub const PRINTLN_BOOL: &str = "println_bool";

    /// Print a newline only.
    pub const PRINTLN: &str = "println";

    /// Print a character.
    pub const PRINT_CHAR: &str = "print_char";

    // === Assertions ===

    /// Assert that a condition is true.
    pub const ASSERT: &str = "blood_assert";

    /// Assert that two integers are equal.
    pub const ASSERT_EQ_INT: &str = "blood_assert_eq_int";

    /// Assert that two booleans are equal.
    pub const ASSERT_EQ_BOOL: &str = "blood_assert_eq_bool";

    // === Control Flow ===

    /// Unreachable code was reached.
    pub const UNREACHABLE: &str = "blood_unreachable";

    // === Memory Management ===

    /// Allocate memory with generational reference.
    pub const ALLOC: &str = "blood_alloc";

    /// Free memory.
    pub const FREE: &str = "blood_free";

    /// Allocate memory (aborts on failure).
    pub const ALLOC_OR_ABORT: &str = "blood_alloc_or_abort";

    /// Check if a generational reference is valid (legacy).
    pub const CHECK_GENERATION: &str = "blood_check_generation";

    /// Validate generation for an address (returns 0=valid, 1=stale).
    pub const VALIDATE_GENERATION: &str = "blood_validate_generation";

    /// Register an allocation in the slot registry.
    pub const REGISTER_ALLOCATION: &str = "blood_register_allocation";

    /// Unregister an allocation from the slot registry.
    pub const UNREGISTER_ALLOCATION: &str = "blood_unregister_allocation";

    /// Get the current generation for an address.
    pub const GET_GENERATION: &str = "blood_get_generation";

    /// Increment the generation for an address (invalidates references).
    pub const INCREMENT_GENERATION: &str = "blood_increment_generation";

    /// Called on stale reference access.
    pub const STALE_REFERENCE_PANIC: &str = "blood_stale_reference_panic";

    // === Effect Runtime ===

    /// Create evidence vector.
    pub const EVIDENCE_CREATE: &str = "blood_evidence_create";

    /// Destroy evidence vector.
    pub const EVIDENCE_DESTROY: &str = "blood_evidence_destroy";

    /// Push handler onto evidence vector.
    pub const EVIDENCE_PUSH: &str = "blood_evidence_push";

    /// Pop handler from evidence vector.
    pub const EVIDENCE_POP: &str = "blood_evidence_pop";

    /// Get handler from evidence vector.
    pub const EVIDENCE_GET: &str = "blood_evidence_get";

    /// Push handler with state onto evidence vector.
    pub const EVIDENCE_PUSH_WITH_STATE: &str = "blood_evidence_push_with_state";

    /// Set the current evidence vector.
    pub const EVIDENCE_SET_CURRENT: &str = "blood_evidence_set_current";

    /// Register handler with operations for an effect.
    pub const EVIDENCE_REGISTER: &str = "blood_evidence_register";

    /// Set state for current handler.
    pub const EVIDENCE_SET_STATE: &str = "blood_evidence_set_state";

    /// Get state for handler at index.
    pub const EVIDENCE_GET_STATE: &str = "blood_evidence_get_state";

    /// Get current evidence vector.
    pub const EVIDENCE_CURRENT: &str = "blood_evidence_current";

    /// Perform an effect operation.
    pub const PERFORM: &str = "blood_perform";

    /// Get handler depth for an effect.
    pub const HANDLER_DEPTH: &str = "blood_handler_depth";

    // === Fiber/Continuation Support ===

    /// Create a new fiber.
    pub const FIBER_CREATE: &str = "blood_fiber_create";

    /// Suspend current fiber.
    pub const FIBER_SUSPEND: &str = "blood_fiber_suspend";

    /// Resume a suspended fiber.
    pub const FIBER_RESUME: &str = "blood_fiber_resume";

    // === Generation Snapshots ===

    /// Create a generation snapshot for continuation capture.
    pub const SNAPSHOT_CREATE: &str = "blood_snapshot_create";

    /// Add an entry to a generation snapshot.
    pub const SNAPSHOT_ADD_ENTRY: &str = "blood_snapshot_add_entry";

    /// Validate all entries in a snapshot against current generations.
    pub const SNAPSHOT_VALIDATE: &str = "blood_snapshot_validate";

    /// Get the number of entries in a snapshot.
    pub const SNAPSHOT_LEN: &str = "blood_snapshot_len";

    /// Destroy a generation snapshot.
    pub const SNAPSHOT_DESTROY: &str = "blood_snapshot_destroy";

    // === Runtime Lifecycle ===

    /// Initialize runtime.
    pub const RUNTIME_INIT: &str = "blood_runtime_init";

    /// Shutdown runtime.
    pub const RUNTIME_SHUTDOWN: &str = "blood_runtime_shutdown";

    /// Panic handler.
    pub const PANIC: &str = "blood_panic";

    // === Multiple Dispatch ===

    /// Register a method implementation for a type.
    pub const DISPATCH_REGISTER: &str = "blood_dispatch_register";

    /// Look up a method implementation for a type.
    pub const DISPATCH_LOOKUP: &str = "blood_dispatch_lookup";

    /// Get the runtime type tag from an object.
    pub const GET_TYPE_TAG: &str = "blood_get_type_tag";

    // === Work-Stealing Scheduler ===

    /// Initialize the scheduler.
    pub const SCHEDULER_INIT: &str = "blood_scheduler_init";

    /// Spawn a task with argument.
    pub const SCHEDULER_SPAWN: &str = "blood_scheduler_spawn";

    /// Spawn a task without argument.
    pub const SCHEDULER_SPAWN_SIMPLE: &str = "blood_scheduler_spawn_simple";

    /// Yield the current task.
    pub const SCHEDULER_YIELD: &str = "blood_scheduler_yield";

    /// Run the scheduler.
    pub const SCHEDULER_RUN: &str = "blood_scheduler_run";

    /// Run the scheduler in background.
    pub const SCHEDULER_RUN_BACKGROUND: &str = "blood_scheduler_run_background";

    /// Shutdown the scheduler.
    pub const SCHEDULER_SHUTDOWN: &str = "blood_scheduler_shutdown";

    /// Wait for all tasks to complete.
    pub const SCHEDULER_WAIT: &str = "blood_scheduler_wait";

    /// Get count of active fibers.
    pub const SCHEDULER_ACTIVE_FIBERS: &str = "blood_scheduler_active_fibers";

    /// Get count of runnable fibers.
    pub const SCHEDULER_RUNNABLE_FIBERS: &str = "blood_scheduler_runnable_fibers";

    /// Check if scheduler is running.
    pub const SCHEDULER_IS_RUNNING: &str = "blood_scheduler_is_running";
}

/// Generate a minimal C runtime source.
///
/// This can be compiled with `cc -c runtime.c -o runtime.o` and linked
/// with Blood programs.
///
/// For full runtime features (fibers, channels, effects), use the Rust
/// `blood-runtime` crate instead.
pub fn generate_c_runtime() -> String {
    r#"// Blood Runtime Library - Minimal C Implementation
// Compile with: cc -c runtime.c -o runtime.o
//
// For full runtime features, use the Rust blood-runtime crate:
//   cargo build --release -p blood-runtime
//   Link with: -lblood_runtime

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>

// ============================================================================
// Constants
// ============================================================================

#define GENERATION_PERSISTENT UINT32_MAX
#define SLOT_REGISTRY_SIZE 65536
#define MAX_EVIDENCE_DEPTH 64
#define MAX_HANDLERS_PER_EFFECT 16
#define MAX_SNAPSHOT_ENTRIES 256

// ============================================================================
// BloodStr - Fat Pointer String Type
// ============================================================================

// Blood's str type is a fat pointer: {ptr, len}
// This struct must match the LLVM type {i8*, i64}
typedef struct {
    char* ptr;
    int64_t len;
} BloodStr;

// ============================================================================
// Generation Tracking - Slot Registry
// ============================================================================

typedef struct {
    uint64_t address;
    uint32_t generation;
    uint32_t size;
    uint8_t in_use;
} SlotEntry;

static SlotEntry slot_registry[SLOT_REGISTRY_SIZE];
static uint32_t next_generation = 1;

static size_t slot_hash(uint64_t addr) {
    // Simple hash for address to slot index
    return (size_t)((addr >> 3) ^ (addr >> 17)) % SLOT_REGISTRY_SIZE;
}

static SlotEntry* find_slot(uint64_t addr) {
    size_t idx = slot_hash(addr);
    size_t start = idx;
    do {
        if (slot_registry[idx].in_use && slot_registry[idx].address == addr) {
            return &slot_registry[idx];
        }
        if (!slot_registry[idx].in_use) {
            return NULL; // Not found
        }
        idx = (idx + 1) % SLOT_REGISTRY_SIZE;
    } while (idx != start);
    return NULL;
}

static SlotEntry* find_or_create_slot(uint64_t addr) {
    size_t idx = slot_hash(addr);
    size_t start = idx;
    SlotEntry* first_empty = NULL;
    do {
        if (slot_registry[idx].in_use && slot_registry[idx].address == addr) {
            return &slot_registry[idx];
        }
        if (!slot_registry[idx].in_use && !first_empty) {
            first_empty = &slot_registry[idx];
        }
        idx = (idx + 1) % SLOT_REGISTRY_SIZE;
    } while (idx != start);
    return first_empty;
}

// ============================================================================
// I/O Functions
// ============================================================================

void print_int(int32_t n) {
    printf("%d", n);
    fflush(stdout);
}

void println_int(int32_t n) {
    printf("%d\n", n);
}

void println_i64(int64_t n) {
    printf("%ld\n", n);
}

void print_str(BloodStr s) {
    if (s.ptr && s.len > 0) {
        fwrite(s.ptr, 1, (size_t)s.len, stdout);
    }
    fflush(stdout);
}

void println_str(BloodStr s) {
    if (s.ptr && s.len > 0) {
        fwrite(s.ptr, 1, (size_t)s.len, stdout);
    }
    printf("\n");
}

void print_bool(int32_t b) {
    printf("%s", b ? "true" : "false");
    fflush(stdout);
}

void println_bool(int32_t b) {
    printf("%s\n", b ? "true" : "false");
}

void println(void) {
    printf("\n");
}

void print_char(int32_t c) {
    printf("%c", (char)c);
    fflush(stdout);
}

void println_char(int32_t c) {
    printf("%c\n", (char)c);
}

// ============================================================================
// String Operations
// ============================================================================

int64_t str_len(BloodStr s) {
    return s.len;
}

int32_t str_eq(BloodStr a, BloodStr b) {
    if (a.len != b.len) return 0;
    if (a.len == 0) return 1;
    if (!a.ptr || !b.ptr) return a.ptr == b.ptr;
    return memcmp(a.ptr, b.ptr, (size_t)a.len) == 0 ? 1 : 0;
}

BloodStr blood_str_concat(BloodStr a, BloodStr b) {
    BloodStr result;
    result.len = a.len + b.len;
    if (result.len == 0) {
        result.ptr = NULL;
        return result;
    }
    result.ptr = (char*)malloc((size_t)result.len);
    if (!result.ptr) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: String allocation failed\n");
        abort();
    }
    if (a.ptr && a.len > 0) {
        memcpy(result.ptr, a.ptr, (size_t)a.len);
    }
    if (b.ptr && b.len > 0) {
        memcpy(result.ptr + a.len, b.ptr, (size_t)b.len);
    }
    return result;
}

BloodStr string_substring(BloodStr s, int64_t start, int64_t end) {
    BloodStr result;
    // Clamp bounds to valid range
    if (start < 0) start = 0;
    if (end > s.len) end = s.len;
    if (start >= end || start >= s.len) {
        result.ptr = NULL;
        result.len = 0;
        return result;
    }
    result.len = end - start;
    result.ptr = (char*)malloc((size_t)result.len);
    if (!result.ptr) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: String allocation failed\n");
        abort();
    }
    if (s.ptr) {
        memcpy(result.ptr, s.ptr + start, (size_t)result.len);
    }
    return result;
}

BloodStr int_to_string(int32_t n) {
    BloodStr result;
    // Max int32 is ~10 digits + sign + null
    char* buf = (char*)malloc(16);
    if (!buf) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: String allocation failed\n");
        abort();
    }
    result.len = (int64_t)sprintf(buf, "%d", n);
    result.ptr = buf;
    return result;
}

BloodStr bool_to_string(int32_t b) {
    BloodStr result;
    if (b) {
        result.ptr = (char*)malloc(5);
        if (!result.ptr) abort();
        memcpy(result.ptr, "true", 4);
        result.len = 4;
    } else {
        result.ptr = (char*)malloc(6);
        if (!result.ptr) abort();
        memcpy(result.ptr, "false", 5);
        result.len = 5;
    }
    return result;
}

// ============================================================================
// Char Methods
// ============================================================================

// char_is_whitespace(char: i32) -> bool
// Checks if the Unicode code point is whitespace.
// Supports ASCII space, tab, newline, carriage return, form feed, and vertical tab.
int32_t char_is_whitespace(int32_t c) {
    // ASCII whitespace characters
    if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\x0C' || c == '\x0B') {
        return 1;
    }
    // Unicode whitespace (common cases)
    // U+00A0 No-Break Space, U+2000-U+200A, U+2028, U+2029, U+202F, U+205F, U+3000
    if (c == 0x00A0 || c == 0x1680 || (c >= 0x2000 && c <= 0x200A) ||
        c == 0x2028 || c == 0x2029 || c == 0x202F || c == 0x205F || c == 0x3000) {
        return 1;
    }
    return 0;
}

// char_is_alphabetic(char: i32) -> bool
// Checks if the Unicode code point is alphabetic (letters).
int32_t char_is_alphabetic(int32_t c) {
    // ASCII letters
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
        return 1;
    }
    // Extended Latin (common accented characters)
    if ((c >= 0x00C0 && c <= 0x00FF) && c != 0x00D7 && c != 0x00F7) {
        return 1;
    }
    // Other Unicode letter ranges (simplified - covers common cases)
    // Full Unicode alphabetic check would require ICU or similar
    if (c >= 0x0100 && c <= 0x017F) return 1;  // Latin Extended-A
    if (c >= 0x0180 && c <= 0x024F) return 1;  // Latin Extended-B
    if (c >= 0x0370 && c <= 0x03FF) return 1;  // Greek
    if (c >= 0x0400 && c <= 0x04FF) return 1;  // Cyrillic
    if (c >= 0x3040 && c <= 0x309F) return 1;  // Hiragana
    if (c >= 0x30A0 && c <= 0x30FF) return 1;  // Katakana
    if (c >= 0x4E00 && c <= 0x9FFF) return 1;  // CJK Unified Ideographs
    return 0;
}

// char_is_alphanumeric(char: i32) -> bool
// Checks if the Unicode code point is alphanumeric.
int32_t char_is_alphanumeric(int32_t c) {
    if (char_is_alphabetic(c)) return 1;
    if (c >= '0' && c <= '9') return 1;
    return 0;
}

// char_is_ascii_digit(char: i32) -> bool
// Checks if the character is an ASCII digit 0-9.
int32_t char_is_ascii_digit(int32_t c) {
    return (c >= '0' && c <= '9') ? 1 : 0;
}

// char_is_ascii_hexdigit(char: i32) -> bool
// Checks if the character is an ASCII hexadecimal digit (0-9, a-f, A-F).
int32_t char_is_ascii_hexdigit(int32_t c) {
    if (c >= '0' && c <= '9') return 1;
    if (c >= 'a' && c <= 'f') return 1;
    if (c >= 'A' && c <= 'F') return 1;
    return 0;
}

// char_is_ascii_uppercase(char: i32) -> bool
// Checks if the character is an ASCII uppercase letter A-Z.
int32_t char_is_ascii_uppercase(int32_t c) {
    return (c >= 'A' && c <= 'Z') ? 1 : 0;
}

// char_is_ascii_lowercase(char: i32) -> bool
// Checks if the character is an ASCII lowercase letter a-z.
int32_t char_is_ascii_lowercase(int32_t c) {
    return (c >= 'a' && c <= 'z') ? 1 : 0;
}

// char_to_string_owned(char: i32) -> BloodStr
// Converts a Unicode code point to a UTF-8 encoded string.
BloodStr char_to_string_owned(int32_t c) {
    BloodStr result;
    // Determine UTF-8 byte count and allocate
    int len;
    if (c < 0x80) {
        len = 1;
    } else if (c < 0x800) {
        len = 2;
    } else if (c < 0x10000) {
        len = 3;
    } else if (c <= 0x10FFFF) {
        len = 4;
    } else {
        // Invalid Unicode code point - return empty string
        result.ptr = NULL;
        result.len = 0;
        return result;
    }

    result.ptr = (char*)malloc((size_t)len);
    if (!result.ptr) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: String allocation failed\n");
        abort();
    }
    result.len = (int64_t)len;

    // Encode UTF-8
    if (c < 0x80) {
        result.ptr[0] = (char)c;
    } else if (c < 0x800) {
        result.ptr[0] = (char)(0xC0 | (c >> 6));
        result.ptr[1] = (char)(0x80 | (c & 0x3F));
    } else if (c < 0x10000) {
        result.ptr[0] = (char)(0xE0 | (c >> 12));
        result.ptr[1] = (char)(0x80 | ((c >> 6) & 0x3F));
        result.ptr[2] = (char)(0x80 | (c & 0x3F));
    } else {
        result.ptr[0] = (char)(0xF0 | (c >> 18));
        result.ptr[1] = (char)(0x80 | ((c >> 12) & 0x3F));
        result.ptr[2] = (char)(0x80 | ((c >> 6) & 0x3F));
        result.ptr[3] = (char)(0x80 | (c & 0x3F));
    }

    return result;
}

// char_len_utf8(char: i32) -> i64
// Returns the number of bytes required to encode this code point in UTF-8.
int64_t char_len_utf8(int32_t c) {
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c < 0x10000) return 3;
    if (c <= 0x10FFFF) return 4;
    return 0; // Invalid code point
}

// ============================================================================
// Range Methods
// ============================================================================

// range_contains(start: i64, end: i64, item: i64) -> bool
// Checks if item is in [start, end) - exclusive end.
int32_t range_contains(int64_t start, int64_t end, int64_t item) {
    return (item >= start && item < end) ? 1 : 0;
}

// range_inclusive_contains(start: i64, end: i64, item: i64) -> bool
// Checks if item is in [start, end] - inclusive end.
int32_t range_inclusive_contains(int64_t start, int64_t end, int64_t item) {
    return (item >= start && item <= end) ? 1 : 0;
}

// ============================================================================
// Assertions
// ============================================================================

void blood_assert(int32_t condition) {
    if (!condition) {
        fprintf(stderr, "BLOOD ASSERTION FAILED\n");
        abort();
    }
}

void blood_assert_eq_int(int32_t a, int32_t b) {
    if (a != b) {
        fprintf(stderr, "BLOOD ASSERTION FAILED: %d != %d\n", a, b);
        abort();
    }
}

void blood_assert_eq_bool(int32_t a, int32_t b) {
    if (a != b) {
        fprintf(stderr, "BLOOD ASSERTION FAILED: %s != %s\n",
                a ? "true" : "false", b ? "true" : "false");
        abort();
    }
}

void blood_unreachable(void) {
    fprintf(stderr, "BLOOD RUNTIME ERROR: Unreachable code was reached!\n");
    abort();
}

// ============================================================================
// Memory Management with Generation Tracking
// ============================================================================

int blood_alloc(size_t size, uint64_t* out_addr, uint64_t* out_gen_meta) {
    if (!out_addr || !out_gen_meta) return -1;
    void* ptr = malloc(size);
    if (!ptr) return -3;

    uint64_t addr = (uint64_t)ptr;
    uint32_t gen = next_generation++;

    // Register in slot registry
    SlotEntry* slot = find_or_create_slot(addr);
    if (slot) {
        slot->address = addr;
        slot->generation = gen;
        slot->size = (uint32_t)size;
        slot->in_use = 1;
    }

    *out_addr = addr;
    *out_gen_meta = ((uint64_t)gen << 32) | 2; // gen in high bits, metadata=REGION in low
    return 0;
}

void blood_free(uint64_t addr, size_t size) {
    (void)size;
    if (!addr) return;

    // Remove from registry and increment generation (invalidates refs)
    SlotEntry* slot = find_slot(addr);
    if (slot) {
        slot->generation++; // Increment so outstanding refs become stale
        slot->in_use = 0;
    }

    free((void*)addr);
}

uint64_t blood_alloc_or_abort(size_t size) {
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: Memory allocation failed (size=%zu)\n", size);
        abort();
    }

    uint64_t addr = (uint64_t)ptr;
    uint32_t gen = next_generation++;

    // Register in slot registry
    SlotEntry* slot = find_or_create_slot(addr);
    if (slot) {
        slot->address = addr;
        slot->generation = gen;
        slot->size = (uint32_t)size;
        slot->in_use = 1;
    }

    return addr;
}

int32_t blood_register_allocation(uint64_t addr, int64_t size) {
    if (!addr) return 0;

    uint32_t gen = next_generation++;
    SlotEntry* slot = find_or_create_slot(addr);
    if (slot) {
        slot->address = addr;
        slot->generation = gen;
        slot->size = (uint32_t)size;
        slot->in_use = 1;
    }
    return (int32_t)gen;
}

void blood_unregister_allocation(uint64_t addr) {
    if (!addr) return;
    SlotEntry* slot = find_slot(addr);
    if (slot) {
        slot->generation++; // Invalidate outstanding references
        slot->in_use = 0;
    }
}

int blood_check_generation(uint32_t expected, uint32_t actual) {
    if (expected == GENERATION_PERSISTENT) return 1; // PERSISTENT always valid
    return expected == actual ? 1 : 0;
}

int32_t blood_validate_generation(uint64_t addr, int32_t expected_gen) {
    // Returns 0 if valid, 1 if stale
    if ((uint32_t)expected_gen == GENERATION_PERSISTENT) return 0; // Always valid
    if (!addr) return 1; // Null is stale

    SlotEntry* slot = find_slot(addr);
    if (!slot) {
        // Not in registry - assume valid (untracked stack allocation)
        return 0;
    }

    if (slot->generation == (uint32_t)expected_gen) {
        return 0; // Valid
    }
    return 1; // Stale
}

int32_t blood_get_generation(uint64_t addr) {
    if (!addr) return 0;
    SlotEntry* slot = find_slot(addr);
    if (slot && slot->in_use) {
        return (int32_t)slot->generation;
    }
    return 1; // Default generation for untracked memory
}

void blood_increment_generation(void* addr) {
    if (!addr) return;
    SlotEntry* slot = find_slot((uint64_t)addr);
    if (slot && slot->in_use) {
        slot->generation++;
    }
}

// ============================================================================
// Effect Runtime - Evidence Vectors
// ============================================================================

typedef struct {
    void* ops[MAX_HANDLERS_PER_EFFECT];  // Function pointers for operations
    uint64_t op_count;
    void* state;                          // Handler state
} EffectHandler;

typedef struct {
    EffectHandler handlers[MAX_EVIDENCE_DEPTH];
    uint64_t depth;
    uint64_t effect_ids[MAX_EVIDENCE_DEPTH];
} EvidenceVector;

static EvidenceVector* current_evidence = NULL;

void* blood_evidence_create(void) {
    EvidenceVector* ev = (EvidenceVector*)calloc(1, sizeof(EvidenceVector));
    return ev;
}

void blood_evidence_destroy(void* ev) {
    free(ev);
}

void blood_evidence_push(void* ev, uint64_t handler) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (vec && vec->depth < MAX_EVIDENCE_DEPTH) {
        vec->handlers[vec->depth].ops[0] = (void*)handler;
        vec->handlers[vec->depth].op_count = 1;
        vec->depth++;
    }
}

uint64_t blood_evidence_pop(void* ev) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (vec && vec->depth > 0) {
        vec->depth--;
        return (uint64_t)vec->handlers[vec->depth].ops[0];
    }
    return 0;
}

uint64_t blood_evidence_get(void* ev, size_t index) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (vec && index < vec->depth) {
        return (uint64_t)vec->handlers[index].ops[0];
    }
    return 0;
}

void blood_evidence_push_with_state(void* ev, uint64_t effect_id, void* state) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (!vec || vec->depth >= MAX_EVIDENCE_DEPTH) return;

    size_t idx = vec->depth;
    vec->effect_ids[idx] = effect_id;
    vec->handlers[idx].state = state;
    vec->handlers[idx].op_count = 0; // Ops registered separately
    vec->depth++;
}

void blood_evidence_set_current(void* ev) {
    current_evidence = (EvidenceVector*)ev;
}

void blood_evidence_register(void* ev, uint64_t effect_id, void** ops, uint64_t op_count) {
    EvidenceVector* vec;
    if (ev) {
        vec = (EvidenceVector*)ev;
    } else {
        // Use current_evidence, creating it lazily if needed
        if (!current_evidence) {
            current_evidence = (EvidenceVector*)blood_evidence_create();
        }
        vec = current_evidence;
    }
    if (!vec || vec->depth >= MAX_EVIDENCE_DEPTH) return;

    size_t idx = vec->depth;
    vec->effect_ids[idx] = effect_id;
    vec->handlers[idx].op_count = op_count;
    for (uint64_t i = 0; i < op_count && i < MAX_HANDLERS_PER_EFFECT; i++) {
        vec->handlers[idx].ops[i] = ops[i];
    }
    vec->depth++;
}

void blood_evidence_set_state(void* ev, void* state) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (vec && vec->depth > 0) {
        vec->handlers[vec->depth - 1].state = state;
    }
}

void* blood_evidence_get_state(void* ev, uint64_t index) {
    EvidenceVector* vec = (EvidenceVector*)ev;
    if (vec && index < vec->depth) {
        return vec->handlers[index].state;
    }
    return NULL;
}

void* blood_evidence_current(void) {
    return current_evidence;
}

int64_t blood_handler_depth(uint64_t effect_id) {
    if (!current_evidence) return -1;

    // Search from top to bottom for the effect
    for (int64_t i = (int64_t)current_evidence->depth - 1; i >= 0; i--) {
        if (current_evidence->effect_ids[i] == effect_id) {
            return i;
        }
    }
    return -1; // Not found
}

int64_t blood_perform(uint64_t effect_id, int32_t op_index, int64_t* args, int64_t arg_count) {
    if (!current_evidence) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: perform called with no evidence vector\n");
        abort();
    }

    // Find handler for this effect
    int64_t handler_idx = blood_handler_depth(effect_id);
    if (handler_idx < 0) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: No handler for effect %lu\n",
                (unsigned long)effect_id);
        abort();
    }

    EffectHandler* handler = &current_evidence->handlers[handler_idx];
    if ((uint64_t)op_index >= handler->op_count) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: Invalid operation index %d for effect %lu\n",
                op_index, (unsigned long)effect_id);
        abort();
    }

    // Get the operation function pointer
    void* op_fn = handler->ops[op_index];
    if (!op_fn) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: Null operation at index %d\n", op_index);
        abort();
    }

    // Call the operation - simplified dispatch based on arg count
    // In a full implementation, this would use proper continuation-passing style
    typedef int64_t (*op_fn_0)(void*);
    typedef int64_t (*op_fn_1)(void*, int64_t);
    typedef int64_t (*op_fn_2)(void*, int64_t, int64_t);
    typedef int64_t (*op_fn_3)(void*, int64_t, int64_t, int64_t);

    void* state = handler->state;

    switch (arg_count) {
        case 0: return ((op_fn_0)op_fn)(state);
        case 1: return ((op_fn_1)op_fn)(state, args[0]);
        case 2: return ((op_fn_2)op_fn)(state, args[0], args[1]);
        case 3: return ((op_fn_3)op_fn)(state, args[0], args[1], args[2]);
        default:
            fprintf(stderr, "BLOOD RUNTIME ERROR: Too many arguments (%ld) for perform\n",
                    (long)arg_count);
            abort();
    }
}

// ============================================================================
// Fiber Support (Minimal - no real continuations in C runtime)
// ============================================================================

static uint64_t next_fiber_id = 1;

uint64_t blood_fiber_create(void) {
    return next_fiber_id++;
}

uint64_t blood_fiber_suspend(void) {
    // In minimal runtime, suspend is not supported
    fprintf(stderr, "BLOOD RUNTIME WARNING: fiber suspend not supported in minimal runtime\n");
    return 0;
}

void blood_fiber_resume(uint64_t fiber, uint64_t value) {
    (void)fiber; (void)value;
    fprintf(stderr, "BLOOD RUNTIME WARNING: fiber resume not supported in minimal runtime\n");
}

// ============================================================================
// Generation Snapshots
// ============================================================================

typedef struct {
    uint64_t addresses[MAX_SNAPSHOT_ENTRIES];
    int32_t generations[MAX_SNAPSHOT_ENTRIES];
    uint64_t count;
} GenerationSnapshot;

static uint64_t next_snapshot_id = 1;
static GenerationSnapshot* snapshots[256] = {NULL};

uint64_t blood_snapshot_create(void) {
    GenerationSnapshot* snap = (GenerationSnapshot*)calloc(1, sizeof(GenerationSnapshot));
    if (!snap) return 0;

    uint64_t id = next_snapshot_id++;
    size_t idx = id % 256;
    if (snapshots[idx]) {
        free(snapshots[idx]);
    }
    snapshots[idx] = snap;
    return id;
}

void blood_snapshot_add_entry(uint64_t snapshot_id, uint64_t address, int32_t generation) {
    size_t idx = snapshot_id % 256;
    GenerationSnapshot* snap = snapshots[idx];
    if (!snap || snap->count >= MAX_SNAPSHOT_ENTRIES) return;

    snap->addresses[snap->count] = address;
    snap->generations[snap->count] = generation;
    snap->count++;
}

int64_t blood_snapshot_validate(uint64_t snapshot_id) {
    size_t idx = snapshot_id % 256;
    GenerationSnapshot* snap = snapshots[idx];
    if (!snap) return -1; // Invalid snapshot

    for (uint64_t i = 0; i < snap->count; i++) {
        int32_t result = blood_validate_generation(snap->addresses[i], snap->generations[i]);
        if (result != 0) {
            return (int64_t)(i + 1); // Return 1-indexed position of first stale ref
        }
    }
    return 0; // All valid
}

int64_t blood_snapshot_len(uint64_t snapshot_id) {
    size_t idx = snapshot_id % 256;
    GenerationSnapshot* snap = snapshots[idx];
    if (!snap) return 0;
    return (int64_t)snap->count;
}

void blood_snapshot_destroy(uint64_t snapshot_id) {
    size_t idx = snapshot_id % 256;
    if (snapshots[idx]) {
        free(snapshots[idx]);
        snapshots[idx] = NULL;
    }
}

// ============================================================================
// Multiple Dispatch Runtime
// ============================================================================

typedef struct {
    uint64_t method_slot;
    uint64_t type_tag;
    void* impl_ptr;
} DispatchEntry;

#define DISPATCH_TABLE_SIZE 1024
static DispatchEntry dispatch_table[DISPATCH_TABLE_SIZE];
static size_t dispatch_count = 0;

void blood_dispatch_register(uint64_t method_slot, uint64_t type_tag, void* impl_ptr) {
    if (dispatch_count >= DISPATCH_TABLE_SIZE) {
        fprintf(stderr, "BLOOD RUNTIME ERROR: Dispatch table full\n");
        return;
    }
    dispatch_table[dispatch_count].method_slot = method_slot;
    dispatch_table[dispatch_count].type_tag = type_tag;
    dispatch_table[dispatch_count].impl_ptr = impl_ptr;
    dispatch_count++;
}

void* blood_dispatch_lookup(uint64_t method_slot, uint64_t type_tag) {
    for (size_t i = 0; i < dispatch_count; i++) {
        if (dispatch_table[i].method_slot == method_slot &&
            dispatch_table[i].type_tag == type_tag) {
            return dispatch_table[i].impl_ptr;
        }
    }
    return NULL; // Not found
}

uint64_t blood_get_type_tag(void* obj) {
    if (!obj) return 0;
    // In a real implementation, objects would have a header with type info
    // For minimal runtime, return 0 (unknown type)
    return 0;
}

// ============================================================================
// Work-Stealing Scheduler (Stubs - single-threaded in minimal runtime)
// ============================================================================

int32_t blood_scheduler_init(int64_t num_workers) {
    (void)num_workers;
    return 0; // Success
}

uint64_t blood_scheduler_spawn(void* task_fn, void* arg) {
    // In minimal runtime, just call the task directly
    if (task_fn) {
        typedef void (*task_fn_t)(void*);
        ((task_fn_t)task_fn)(arg);
    }
    return next_fiber_id++;
}

uint64_t blood_scheduler_spawn_simple(void* task_fn) {
    return blood_scheduler_spawn(task_fn, NULL);
}

void blood_scheduler_yield(void) {
    // No-op in single-threaded runtime
}

void blood_scheduler_run(void) {
    // No-op in single-threaded runtime - tasks run immediately
}

void blood_scheduler_run_background(void) {
    // No-op in single-threaded runtime
}

void blood_scheduler_shutdown(void) {
    // No-op in minimal runtime
}

void blood_scheduler_wait(void) {
    // No-op in single-threaded runtime
}

int64_t blood_scheduler_active_fibers(void) {
    return 0; // No fibers in minimal runtime
}

int64_t blood_scheduler_runnable_fibers(void) {
    return 0; // No fibers in minimal runtime
}

int32_t blood_scheduler_is_running(void) {
    return 0; // Not running in minimal runtime
}

// ============================================================================
// Error Handling
// ============================================================================

void blood_stale_reference_panic(uint32_t expected, uint32_t actual) {
    fprintf(stderr, "BLOOD RUNTIME ERROR: Stale reference detected!\n");
    fprintf(stderr, "Expected generation: %u, Actual: %u\n", expected, actual);
    fprintf(stderr, "This indicates use-after-free. Aborting.\n");
    abort();
}

void blood_panic(BloodStr msg) {
    fprintf(stderr, "BLOOD RUNTIME PANIC: ");
    if (msg.ptr && msg.len > 0) {
        fwrite(msg.ptr, 1, (size_t)msg.len, stderr);
    } else {
        fprintf(stderr, "unknown error");
    }
    fprintf(stderr, "\n");
    abort();
}

// Also provide legacy panic that takes a C string pointer
void panic(BloodStr msg) {
    blood_panic(msg);
}

// ============================================================================
// File I/O Functions
// ============================================================================

// File open: __builtin_file_open(path: &str, flags: i32, mode: u32) -> i64
// Returns fd on success, -1 on error
int64_t __builtin_file_open(BloodStr path, int32_t flags, uint32_t mode) {
    // Null-terminate the path
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int fd = open(path_cstr, flags, mode);
    free(path_cstr);

    return (int64_t)fd;
}

// File read: __builtin_file_read(fd: i64, buf_ptr: u64, buf_len: u64) -> i64
// Returns bytes read, or -1 on error
int64_t __builtin_file_read(int64_t fd, uint64_t buf_ptr, uint64_t buf_len) {
    ssize_t n = read((int)fd, (void*)buf_ptr, (size_t)buf_len);
    return (int64_t)n;
}

// File write: __builtin_file_write(fd: i64, buf_ptr: u64, buf_len: u64) -> i64
// Returns bytes written, or -1 on error
int64_t __builtin_file_write(int64_t fd, uint64_t buf_ptr, uint64_t buf_len) {
    ssize_t n = write((int)fd, (void*)buf_ptr, (size_t)buf_len);
    return (int64_t)n;
}

// File close: __builtin_file_close(fd: i64) -> i32
// Returns 0 on success, -1 on error
int32_t __builtin_file_close(int64_t fd) {
    return close((int)fd);
}

// File flush: __builtin_file_flush(fd: i64) -> i32
// Returns 0 on success, -1 on error
int32_t __builtin_file_flush(int64_t fd) {
    return fsync((int)fd);
}

// File seek: __builtin_file_seek(fd: i64, offset: i64, whence: i32) -> u64
// Returns new position, or (u64)-1 on error
uint64_t __builtin_file_seek(int64_t fd, int64_t offset, int32_t whence) {
    off_t pos = lseek((int)fd, (off_t)offset, whence);
    return (uint64_t)pos;
}

// File sync all: __builtin_file_sync_all(fd: i64) -> i32
int32_t __builtin_file_sync_all(int64_t fd) {
    return fsync((int)fd);
}

// File sync data: __builtin_file_sync_data(fd: i64) -> i32
int32_t __builtin_file_sync_data(int64_t fd) {
#ifdef __linux__
    return fdatasync((int)fd);
#else
    return fsync((int)fd);
#endif
}

// File set length: __builtin_file_set_len(fd: i64, len: u64) -> i32
int32_t __builtin_file_set_len(int64_t fd, uint64_t len) {
    return ftruncate((int)fd, (off_t)len);
}

// Remove file: __builtin_remove_file(path: &str) -> i32
int32_t __builtin_remove_file(BloodStr path) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int result = unlink(path_cstr);
    free(path_cstr);
    return result;
}

// Rename: __builtin_rename(from: &str, to: &str) -> i32
int32_t __builtin_rename(BloodStr from, BloodStr to) {
    char* from_cstr = (char*)malloc((size_t)from.len + 1);
    char* to_cstr = (char*)malloc((size_t)to.len + 1);
    if (!from_cstr || !to_cstr) {
        free(from_cstr);
        free(to_cstr);
        return -1;
    }

    if (from.ptr && from.len > 0) memcpy(from_cstr, from.ptr, (size_t)from.len);
    from_cstr[from.len] = '\0';
    if (to.ptr && to.len > 0) memcpy(to_cstr, to.ptr, (size_t)to.len);
    to_cstr[to.len] = '\0';

    int result = rename(from_cstr, to_cstr);
    free(from_cstr);
    free(to_cstr);
    return result;
}

// Create directory: __builtin_create_dir(path: &str, mode: u32) -> i32
int32_t __builtin_create_dir(BloodStr path, uint32_t mode) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int result = mkdir(path_cstr, (mode_t)mode);
    free(path_cstr);
    return result;
}

// Create directory (recursive): __builtin_create_dir_all(path: &str, mode: u32) -> i32
int32_t __builtin_create_dir_all(BloodStr path, uint32_t mode) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    // Create parent directories as needed
    char* p = path_cstr;
    while (*p) {
        p++;
        while (*p && *p != '/') p++;
        char c = *p;
        *p = '\0';
        if (strlen(path_cstr) > 0) {
            mkdir(path_cstr, (mode_t)mode);  // Ignore errors for existing dirs
        }
        *p = c;
    }

    int result = mkdir(path_cstr, (mode_t)mode);
    // Return success if directory already exists
    if (result == -1 && errno == EEXIST) result = 0;
    free(path_cstr);
    return result;
}

// Remove directory: __builtin_remove_dir(path: &str) -> i32
int32_t __builtin_remove_dir(BloodStr path) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int result = rmdir(path_cstr);
    free(path_cstr);
    return result;
}

// Remove directory (recursive) - simplified version
int32_t __builtin_remove_dir_all(BloodStr path) {
    // For safety, this simplified version just calls rmdir
    // A full implementation would recursively remove contents
    return __builtin_remove_dir(path);
}

// Read directory: __builtin_read_dir(path: &str) -> i64
// Returns DIR* handle as i64, or -1 on error
int64_t __builtin_read_dir(BloodStr path) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    DIR* dir = opendir(path_cstr);
    free(path_cstr);

    return dir ? (int64_t)(uintptr_t)dir : -1;
}

// Close directory: __builtin_close_dir(handle: i64) -> i32
int32_t __builtin_close_dir(int64_t handle) {
    if (handle <= 0) return -1;
    return closedir((DIR*)(uintptr_t)handle);
}

// Get current directory: __builtin_current_dir() -> String
BloodStr __builtin_current_dir(void) {
    BloodStr result;
    char buf[4096];
    if (getcwd(buf, sizeof(buf))) {
        size_t len = strlen(buf);
        result.ptr = (char*)malloc(len);
        if (result.ptr) {
            memcpy(result.ptr, buf, len);
            result.len = (int64_t)len;
        } else {
            result.len = 0;
        }
    } else {
        result.ptr = NULL;
        result.len = 0;
    }
    return result;
}

// Set current directory: __builtin_set_current_dir(path: &str) -> i32
int32_t __builtin_set_current_dir(BloodStr path) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int result = chdir(path_cstr);
    free(path_cstr);
    return result;
}

// Hard link: __builtin_hard_link(original: &str, link: &str) -> i32
int32_t __builtin_hard_link(BloodStr original, BloodStr linkpath) {
    char* orig_cstr = (char*)malloc((size_t)original.len + 1);
    char* link_cstr = (char*)malloc((size_t)linkpath.len + 1);
    if (!orig_cstr || !link_cstr) {
        free(orig_cstr);
        free(link_cstr);
        return -1;
    }

    if (original.ptr && original.len > 0) memcpy(orig_cstr, original.ptr, (size_t)original.len);
    orig_cstr[original.len] = '\0';
    if (linkpath.ptr && linkpath.len > 0) memcpy(link_cstr, linkpath.ptr, (size_t)linkpath.len);
    link_cstr[linkpath.len] = '\0';

    int result = link(orig_cstr, link_cstr);
    free(orig_cstr);
    free(link_cstr);
    return result;
}

// Symlink: __builtin_symlink(original: &str, link: &str) -> i32
int32_t __builtin_symlink(BloodStr original, BloodStr linkpath) {
    char* orig_cstr = (char*)malloc((size_t)original.len + 1);
    char* link_cstr = (char*)malloc((size_t)linkpath.len + 1);
    if (!orig_cstr || !link_cstr) {
        free(orig_cstr);
        free(link_cstr);
        return -1;
    }

    if (original.ptr && original.len > 0) memcpy(orig_cstr, original.ptr, (size_t)original.len);
    orig_cstr[original.len] = '\0';
    if (linkpath.ptr && linkpath.len > 0) memcpy(link_cstr, linkpath.ptr, (size_t)linkpath.len);
    link_cstr[linkpath.len] = '\0';

    int result = symlink(orig_cstr, link_cstr);
    free(orig_cstr);
    free(link_cstr);
    return result;
}

// Read symlink: __builtin_read_link(path: &str) -> String
BloodStr __builtin_read_link(BloodStr path) {
    BloodStr result;
    result.ptr = NULL;
    result.len = 0;

    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return result;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    char buf[4096];
    ssize_t len = readlink(path_cstr, buf, sizeof(buf) - 1);
    free(path_cstr);

    if (len > 0) {
        result.ptr = (char*)malloc((size_t)len);
        if (result.ptr) {
            memcpy(result.ptr, buf, (size_t)len);
            result.len = (int64_t)len;
        }
    }
    return result;
}

// Canonicalize path: __builtin_canonicalize(path: &str) -> String
BloodStr __builtin_canonicalize(BloodStr path) {
    BloodStr result;
    result.ptr = NULL;
    result.len = 0;

    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return result;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    char* resolved = realpath(path_cstr, NULL);
    free(path_cstr);

    if (resolved) {
        size_t len = strlen(resolved);
        result.ptr = resolved;  // realpath allocates with malloc
        result.len = (int64_t)len;
    }
    return result;
}

// Set permissions: __builtin_set_permissions(path: &str, mode: u32) -> i32
int32_t __builtin_set_permissions(BloodStr path, uint32_t mode) {
    char* path_cstr = (char*)malloc((size_t)path.len + 1);
    if (!path_cstr) return -1;
    if (path.ptr && path.len > 0) {
        memcpy(path_cstr, path.ptr, (size_t)path.len);
    }
    path_cstr[path.len] = '\0';

    int result = chmod(path_cstr, (mode_t)mode);
    free(path_cstr);
    return result;
}

// ============================================================================
// Runtime Lifecycle
// ============================================================================

int blood_runtime_init(void) {
    // Initialize slot registry
    memset(slot_registry, 0, sizeof(slot_registry));
    next_generation = 1;

    // Create default evidence vector if not already created
    // (may have been created lazily by blood_evidence_register during global init)
    if (!current_evidence) {
        current_evidence = (EvidenceVector*)blood_evidence_create();
    }

    return 0;
}

void blood_runtime_shutdown(void) {
    if (current_evidence) {
        blood_evidence_destroy(current_evidence);
        current_evidence = NULL;
    }

    // Clean up snapshots
    for (size_t i = 0; i < 256; i++) {
        if (snapshots[i]) {
            free(snapshots[i]);
            snapshots[i] = NULL;
        }
    }
}
"#.to_string()
}
